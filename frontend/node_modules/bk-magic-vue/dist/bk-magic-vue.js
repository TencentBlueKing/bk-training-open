(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('path')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'path'], factory) :
  (global = global || self, factory(global.bkMagicVue = {}, global.Vue, global.path));
}(this, function (exports, Vue, path) { 'use strict';

  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
  path = path && path.hasOwnProperty('default') ? path['default'] : path;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var _global = createCommonjsModule(function (module) {
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    : Function('return this')();
  if (typeof __g == 'number') __g = global;
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.12' };
  if (typeof __e == 'number') __e = core;
  });
  var _core_1 = _core.version;

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) {  }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      : IS_BIND && own ? _ctx(out, _global)
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  var _export = $export;

  var toString$1 = {}.toString;
  var _cof = function (it) {
    return toString$1.call(it).slice(8, -1);
  };

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var _library = true;

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode:  'pure' ,
    copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var shared = _shared('keys');
  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');
  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var f$1 = {}.propertyIsEnumerable;
  var _objectPie = {
  	f: f$1
  };

  var isEnum = _objectPie.f;
  var _objectToArray = function (isEntries) {
    return function (it) {
      var O = _toIobject(it);
      var keys = _objectKeys(O);
      var length = keys.length;
      var i = 0;
      var result = [];
      var key;
      while (length > i) {
        key = keys[i++];
        if (!_descriptors || isEnum.call(O, key)) {
          result.push(isEntries ? [key, O[key]] : O[key]);
        }
      }
      return result;
    };
  };

  var $values = _objectToArray(false);
  _export(_export.S, 'Object', {
    values: function values(it) {
      return $values(it);
    }
  });

  var values = _core.Object.values;

  var values$1 = values;

  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

  var $Object = _core.Object;
  var defineProperty = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };

  var defineProperty$1 = defineProperty;

  var hasInitZIndex = false;
  var zIndex;
  (function () {
    if (!window['__bk_zIndex_manager']) {
      var zIndexManager = {
        nextZIndex: function nextZIndex() {
          var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
          return zIndex === 'default' ? zIndexManager.zIndex++ : zIndex;
        },
        nextTickIndex: function nextTickIndex() {
          var tick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
          if (zIndex === 'default') {
            zIndexManager.zIndex += tick;
            return zIndexManager.zIndex;
          }
          return zIndex;
        }
      };
      defineProperty$1(zIndexManager, 'zIndex', {
        configurable: true,
        get: function get() {
          if (!hasInitZIndex) {
            zIndex = zIndex || (Vue.prototype.$BK_EL || {}).zIndex || 2000;
            hasInitZIndex = true;
          }
          return zIndex;
        },
        set: function set(value) {
          zIndex = value;
        }
      });
      window['__bk_zIndex_manager'] = zIndexManager;
    }
  })();
  var zIndexManager = window['__bk_zIndex_manager'];

  function throttle (delay, noTrailing, callback, debounceMode) {
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel() {
      clearExistingTimeout();
      cancelled = true;
    }
    if (typeof noTrailing !== 'boolean') {
      debounceMode = callback;
      callback = noTrailing;
      noTrailing = undefined;
    }
    function wrapper() {
      var self = this;
      var elapsed = Date.now() - lastExec;
      var args = arguments;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self, args);
      }
      function clear() {
        timeoutID = undefined;
      }
      if (debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === undefined && elapsed > delay) {
        exec();
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce (delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
  }

  var script = {
    name: 'bk-back-top',
    props: {
      bottom: {
        type: Number,
        default: 40
      },
      right: {
        type: Number,
        default: 40
      },
      target: {
        type: String,
        default: ''
      },
      visibilityHeight: {
        type: Number,
        default: 200
      }
    },
    data: function data() {
      return {
        visible: false,
        zIndex: 0,
        container: document,
        el: document.documentElement
      };
    },
    computed: {
      positionStyle: function positionStyle() {
        return "right: ".concat(this.right, "px;\n                bottom: ").concat(this.bottom, "px;\n                z-index: ").concat(this.zIndex);
      }
    },
    watch: {
      visible: function visible(val) {
        if (val) {
          this.zIndex = zIndexManager.nextTickIndex(2);
        }
      }
    },
    mounted: function mounted() {
      this._lazyScrollHandler = throttle(30, this.scrollHandler);
      if (this.target) {
        this.el = document.querySelector(this.target);
        if (!this.el) {
          throw new Error('target does not exist');
        }
        this.container = this.el;
      }
      this.container.addEventListener('scroll', this._lazyScrollHandler);
    },
    methods: {
      clickHandler: function clickHandler() {
        this.$emit('click');
      },
      scrollTop: function scrollTop() {
        this.el.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      },
      scrollHandler: function scrollHandler() {
        this.visible = this.el.scrollTop >= this.visibilityHeight;
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    var options = typeof script === 'function' ? script.options : script;
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    if (scopeId) {
      options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      hook = function hook(context) {
        context = context ||
        this.$vnode && this.$vnode.ssrContext ||
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }
    if (hook) {
      if (options.functional) {
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script;
  }
  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "bk-fade-in-linear"
      }
    }, [_vm.visible ? _c('div', {
      staticClass: "bk-back-to-top",
      style: _vm.positionStyle,
      on: {
        "click": _vm.scrollTop
      }
    }, [_vm._t("default", [_c('i', {
      staticClass: "bk-icon icon-angle-up-line"
    })])], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
  };

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys = _core.Object.keys;

  var keys$1 = keys;

  function setInstaller (component, afterInstall) {
    component.install = function (Vue) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = component.props || {};
      keys$1(options).forEach(function (key) {
        if (props.hasOwnProperty(key)) {
          if (typeof props[key] === 'function' || props[key] instanceof Array) {
            props[key] = {
              type: props[key],
              default: options[key]
            };
          } else {
            props[key].default = options[key];
          }
        }
      });
      component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
      Vue.component(component.name, component);
      typeof afterInstall === 'function' && afterInstall(Vue, options);
    };
  }

  setInstaller(__vue_component__);

  var on = function () {
    if (document.addEventListener) {
      return function (element, event, handler) {
        if (element && event && handler) {
          element.addEventListener(event, handler, true);
        }
      };
    } else {
      return function (element, event, handler) {
        if (element && event && handler) {
          element.attachEvent('on' + event, handler);
        }
      };
    }
  }();
  var off = function () {
    if (document.removeEventListener) {
      return function (element, event, handler) {
        if (element && event) {
          element.removeEventListener(event, handler, true);
        }
      };
    } else {
      return function (element, event, handler) {
        if (element && event) {
          element.detachEvent('on' + event, handler);
        }
      };
    }
  }();
  var script$1 = {
    name: 'bk-affix',
    props: {
      offsetTop: {
        type: Number,
        default: 0
      },
      offsetBottom: {
        type: Number
      },
      target: {
        type: String,
        default: ''
      },
      zIndex: {
        type: Number,
        default: 1000
      }
    },
    data: function data() {
      return {
        affix: false,
        styles: {}
      };
    },
    computed: {
      offsetType: function offsetType() {
        var type = 'top';
        if (this.offsetBottom >= 0) {
          type = 'bottom';
        }
        return type;
      }
    },
    mounted: function mounted() {
      var _this = this;
      this.targetEl = this.target ? document.querySelector(this.target) : window;
      this.$refs.point.style.zIndex = this.zIndex;
      on(this.targetEl, 'scroll', this.listenScroll);
      on(this.targetEl, 'resize', this.listenScroll);
      this.$nextTick(function () {
        _this.handleScroll();
      });
    },
    beforeDestroy: function beforeDestroy() {
      off(this.targetEl, 'scroll', this.listenScroll);
      off(this.targetEl, 'resize', this.listenScroll);
      off(window, 'scroll', this.setTargetLoop);
    },
    methods: {
      setTargetLoop: function setTargetLoop() {
        if (this.offsetType === 'top') {
          this.styles = {
            top: "".concat(this.targetEl.getBoundingClientRect().top + this.offsetTop, "px")
          };
        } else {
          this.styles = {
            bottom: "".concat(window.innerHeight - this.targetEl.getBoundingClientRect().bottom + this.offsetBottom, "px")
          };
        }
      },
      listenScroll: function listenScroll() {
        this.throttle(this.handleScroll, 100);
      },
      throttle: function throttle(method, delay) {
        var previous = 0;
        var timer = null;
        var now = new Date();
        var self = this;
        var interval = delay - (now - previous);
        var args = arguments;
        if (interval <= 0) {
          method.apply.apply(method, [self].concat(_toConsumableArray(args)));
          previous = new Date();
        } else if (!timer) {
          timer = setTimeout(function () {
            clearTimeout(timer);
            timer = null;
            method.apply.apply(method, [self].concat(_toConsumableArray(args)));
            previous = new Date();
          }, interval);
        }
      },
      getOffset: function getOffset(element) {
        var rect = element.getBoundingClientRect();
        var rect2 = this.targetEl === window ? {
          top: 0,
          left: 0
        } : this.targetEl.getBoundingClientRect();
        var clientTop = this.targetEl.clientTop || 0;
        var clientLeft = this.targetEl.clientLeft || 0;
        return {
          top: rect.top - rect2.top - clientTop,
          left: rect.left - rect2.left - clientLeft
        };
      },
      handleScroll: function handleScroll() {
        var rect = this.targetEl === window ? {
          top: 0,
          left: 0,
          bottom: window.innerHeight
        } : this.targetEl.getBoundingClientRect();
        var elOffset = this.getOffset(this.$refs.root);
        var windowHeight = this.targetEl === window ? this.targetEl.innerHeight : this.targetEl.clientHeight;
        var elHeight = this.$refs.point.offsetHeight;
        if (elOffset.top < this.offsetTop && this.offsetType === 'top' && !this.affix) {
          this.affix = true;
          this.styles = {
            position: 'fixed',
            top: "".concat(rect.top + this.offsetTop, "px"),
            left: "".concat(rect.left + elOffset.left, "px"),
            width: "".concat(this.$el.offsetWidth, "px")
          };
          if (this.targetEl !== window) {
            on(window, 'scroll', this.setTargetLoop);
          }
          this.$emit('change', true);
        } else if (elOffset.top > this.offsetTop && this.offsetType === 'top' && this.affix) {
          this.affix = false;
          this.styles = null;
          this.$emit('change', false);
        }
        if (elOffset.top + this.offsetBottom + elHeight > windowHeight && this.offsetType === 'bottom' && !this.affix) {
          this.affix = true;
          this.styles = {
            bottom: "".concat(window.innerHeight - rect.bottom + this.offsetBottom, "px"),
            left: "".concat(rect.left + elOffset.left, "px"),
            width: "".concat(this.$el.offsetWidth, "px")
          };
          if (this.targetEl !== window) {
            on(window, 'scroll', this.setTargetLoop);
          }
          this.$emit('change', true);
        } else if (elOffset.top + this.offsetBottom + elHeight < windowHeight && this.offsetType === 'bottom' && this.affix) {
          this.affix = false;
          this.styles = null;
          this.$emit('change', false);
        }
      }
    }
  };

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "root"
    }, [_c('div', {
      ref: "point",
      class: {
        'bk-affix': _vm.affix
      },
      style: _vm.styles
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$1 = undefined;
  /* scoped */

  var __vue_scope_id__$1 = undefined;
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1);

  var script$2 = {
    name: 'bk-fixed-navbar',
    props: {
      navItems: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      position: {
        type: String,
        default: 'middle'
      }
    },
    data: function data() {
      return {
        localZIndex: zIndexManager.nextTickIndex(2)
      };
    },
    computed: {
      navConfig: function navConfig() {
        var config = this.navItems.map(function (item) {
          return _extends({
            tooltip: {
              disabled: true
            },
            action: function action() {}
          }, item);
        });
        return config;
      }
    }
  };

  /* script */
  var __vue_script__$2 = script$2;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-fixed-navbar-wrapper",
      class: [_vm.extCls, _vm.position],
      style: {
        zIndex: _vm.localZIndex
      }
    }, _vm._l(_vm.navConfig, function (item, index) {
      return _c('div', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips",
          value: item.tooltip,
          expression: "item.tooltip"
        }],
        key: index,
        staticClass: "fixed-navbar-item",
        on: {
          "click": item.action
        }
      }, [_c('i', {
        class: ['bk-icon', item.icon]
      }), _c('span', {
        staticClass: "text"
      }, [_vm._v(_vm._s(item.text))])]);
    }), 0);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$2);

  function isVNode(node) {
    return node && _typeof(node) === 'object' && node.hasOwnProperty('componentOptions');
  }
  function addEvent(elem, type, handler) {
    if (!elem) {
      return;
    }
    if (elem.addEventListener) {
      elem.addEventListener(type, handler, false);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, handler);
    } else {
      elem['on' + type] = handler;
    }
  }
  function removeEvent(elem, type, handler) {
    if (!elem) {
      return;
    }
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handler, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, handler);
    } else {
      elem['on' + type] = null;
    }
  }
  var cachedScrollBarSize;
  function getScrollBarWidth(fromCache) {
    if (fromCache && cachedScrollBarSize !== undefined) {
      return cachedScrollBarSize;
    }
    var inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    var outer = document.createElement('div');
    var outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.top = 0;
    outerStyle.left = 0;
    outerStyle.pointerEvents = 'none';
    outerStyle.visibility = 'hidden';
    outerStyle.width = '200px';
    outerStyle.height = '100px';
    outerStyle.overflowY = 'scroll';
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cachedScrollBarSize = widthContained - widthScroll;
    return cachedScrollBarSize;
  }
  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function findChildComponents(context, componentName) {
    return context.$children.reduce(function (components, child) {
      if (child.$options.name === componentName) {
        components.push(child);
      }
      var foundChilds = findChildComponents(child, componentName);
      return components.concat(foundChilds);
    }, []);
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var trim = function trim(string) {
    return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
  };
  var camelCase = function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  };
  function hasClass(el, cls) {
    if (!el || !cls) return false;
    if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
    if (el.classList) {
      return el.classList.contains(cls);
    } else {
      return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
    }
  }
  function addClass(el, cls) {
    if (!el) return;
    var curClass = el.className;
    var classes = (cls || '').split(' ');
    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.add(clsName);
      } else if (!hasClass(el, clsName)) {
        curClass += ' ' + clsName;
      }
    }
    if (!el.classList) {
      el.className = curClass;
    }
  }
  function removeClass(el, cls) {
    if (!el || !cls) return;
    var classes = cls.split(' ');
    var curClass = ' ' + el.className + ' ';
    for (var i = 0, j = classes.length; i < j; i++) {
      var clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.remove(clsName);
      } else if (hasClass(el, clsName)) {
        curClass = curClass.replace(' ' + clsName + ' ', ' ');
      }
    }
    if (!el.classList) {
      el.className = trim(curClass);
    }
  }
  var getStyle = Number(document.documentMode) < 9 ? function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);
    if (styleName === 'float') {
      styleName = 'styleFloat';
    }
    try {
      switch (styleName) {
        case 'opacity':
          try {
            return element.filters.item('alpha').opacity / 100;
          } catch (e) {
            return 1.0;
          }
        default:
          return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
      }
    } catch (e) {
      return element.style[styleName];
    }
  } : function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    try {
      var computed = document.defaultView.getComputedStyle(element, '');
      return element.style[styleName] || computed ? computed[styleName] : null;
    } catch (e) {
      return element.style[styleName];
    }
  };
  function scrollTop(el) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var to = arguments.length > 2 ? arguments[2] : undefined;
    var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 500;
    var endCallback = arguments.length > 4 ? arguments[4] : undefined;
    var difference = Math.abs(from - to);
    var step = Math.ceil(difference / duration * 50);
    function scroll(start, end, step) {
      if (start === end) {
        endCallback && endCallback();
        return;
      }
      var d = start + step > end ? end : start + step;
      if (start > end) {
        d = start - step < end ? end : start - step;
      }
      if (el === window) {
        window.scrollTo(d, d);
      } else {
        el.scrollTop = d;
      }
      window.requestAnimationFrame(function () {
        return scroll(d, end, step);
      });
    }
    scroll(from, to, step);
  }
  var isInContainer = function isInContainer(el, container) {
    if (!el || !container) return false;
    var elRect = el.getBoundingClientRect();
    var containerRect;
    if ([window, document, document.documentElement, null, undefined].includes(container)) {
      containerRect = {
        top: 0,
        right: window.innerWidth,
        bottom: window.innerHeight,
        left: 0
      };
    } else {
      containerRect = container.getBoundingClientRect();
    }
    return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
  };

  var transition = {
    beforeEnter: function beforeEnter(el) {
      addClass(el, 'collapse-transition');
      if (!el.dataset) {
        el.dataset = {};
      }
      el.dataset.oldPaddingTop = el.style.paddingTop;
      el.dataset.oldPaddingBottom = el.style.paddingBottom;
      el.style.height = '0';
      el.style.paddingTop = 0;
      el.style.paddingBottom = 0;
    },
    enter: function enter(el) {
      el.dataset.oldOverflow = el.style.overflow;
      if (el.scrollHeight !== 0) {
        el.style.height = el.scrollHeight + 'px';
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      } else {
        el.style.height = '';
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }
      el.style.overflow = 'hidden';
    },
    afterEnter: function afterEnter(el) {
      removeClass(el, 'collapse-transition');
      el.style.height = '';
      el.style.overflow = el.dataset.oldOverflow;
    },
    beforeLeave: function beforeLeave(el) {
      if (!el.dataset) el.dataset = {};
      el.dataset.oldPaddingTop = el.style.paddingTop;
      el.dataset.oldPaddingBottom = el.style.paddingBottom;
      el.dataset.oldOverflow = el.style.overflow;
      el.style.height = el.scrollHeight + 'px';
      el.style.overflow = 'hidden';
    },
    leave: function leave(el) {
      if (el.scrollHeight !== 0) {
        addClass(el, 'collapse-transition');
        el.style.height = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
      }
    },
    afterLeave: function afterLeave(el) {
      removeClass(el, 'collapse-transition');
      el.style.height = '';
      el.style.overflow = el.dataset.oldOverflow;
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    }
  };
  var CollapseTransition = {
    name: 'CollapseTransition',
    functional: true,
    render: function render(h, _ref) {
      var children = _ref.children;
      var data = {
        on: transition
      };
      return h('transition', data, children);
    }
  };

  var script$3 = {
    name: 'bk-transition',
    components: {
      CollapseTransition: CollapseTransition
    },
    props: {
      name: {
        type: String,
        default: ''
      },
      durationTime: {
        type: String,
        default: '.3s'
      },
      durationType: {
        type: String,
        default: 'linear'
      }
    },
    computed: {
      transitionName: function transitionName() {
        return this.isCollapse ? '' : this.name;
      },
      isCollapse: function isCollapse() {
        return this.name === 'collapse';
      }
    },
    mounted: function mounted() {
      var slot = this.getSlot();
      slot.elm.style.transitionDuration = this.durationTime;
      slot.elm.style.transitionTimingFunction = this.durationType;
    },
    methods: {
      getSlot: function getSlot() {
        return this.$slots.default[0];
      }
    }
  };

  /* script */
  var __vue_script__$3 = script$3;
  /* template */

  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      staticClass: "bk-transition",
      attrs: {
        "name": _vm.transitionName
      }
    }, [_vm.name === 'collapse' ? _c('CollapseTransition', [_vm._t("default")], 2) : _vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$3 = [];
  /* style */

  var __vue_inject_styles__$3 = undefined;
  /* scoped */

  var __vue_scope_id__$3 = undefined;
  /* module identifier */

  var __vue_module_identifier__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$3 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$3 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$3,
    staticRenderFns: __vue_staticRenderFns__$3
  }, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$3);

  var script$4 = {
    name: 'bk-alert',
    props: {
      type: {
        type: String,
        default: 'info'
      },
      title: {
        type: String,
        default: ''
      },
      closable: {
        type: Boolean,
        default: false
      },
      closeText: {
        type: String
      },
      showIcon: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        visible: true
      };
    },
    computed: {
      typeClass: function typeClass() {
        return "bk-alert-".concat(this.type);
      },
      closeClasses: function closeClasses() {
        var classes = {};
        if (this.closeText) {
          classes['close-text'] = true;
        } else {
          classes['bk-icon'] = true;
          classes['icon-close'] = true;
        }
        return classes;
      }
    },
    methods: {
      beforeLeave: function beforeLeave(el) {
        var _el$getBoundingClient = el.getBoundingClientRect(),
            height = _el$getBoundingClient.height;
        el.style.height = "".concat(height, "px");
      },
      leave: function leave(el) {
        setTimeout(function () {
          el.style.height = 0;
        });
      },
      afterLeave: function afterLeave(el) {
        el.style.height = '';
      },
      handleClose: function handleClose() {
        this.visible = false;
        this.$emit('close');
      }
    }
  };

  /* script */
  var __vue_script__$4 = script$4;
  /* template */

  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "bk-alert-leave"
      },
      on: {
        "before-leave": _vm.beforeLeave,
        "leave": _vm.leave,
        "after-leave": _vm.afterLeave
      }
    }, [_vm.visible ? _c('div', {
      staticClass: "bk-alert",
      class: _vm.typeClass
    }, [_c('div', {
      staticClass: "bk-alert-wraper"
    }, [_vm.showIcon ? _c('i', {
      staticClass: "bk-icon icon-info"
    }) : _vm._e(), _c('div', {
      staticClass: "bk-alert-content"
    }, [_c('div', {
      staticClass: "bk-alert-title"
    }, [_vm._t("title", [_vm._v("\n                        " + _vm._s(_vm.title) + "\n                    ")])], 2), _c('div', {
      staticClass: "bk-alert-description"
    })]), _vm.closable ? _c('span', {
      staticClass: "bk-alert-close",
      class: _vm.closeClasses,
      on: {
        "click": _vm.handleClose
      }
    }, [_vm._v(_vm._s(_vm.closeText))]) : _vm._e()])]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$4 = [];
  /* style */

  var __vue_inject_styles__$4 = undefined;
  /* scoped */

  var __vue_scope_id__$4 = undefined;
  /* module identifier */

  var __vue_module_identifier__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$4 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$4 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$4,
    staticRenderFns: __vue_staticRenderFns__$4
  }, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$4);

  _export(_export.S, 'Number', {
    isNaN: function isNaN(number) {
      return number != number;
    }
  });

  var isNan = _core.Number.isNaN;

  var isNan$1 = isNan;

  var script$5 = {
    name: 'bk-animate-number',
    props: {
      value: {
        type: Number,
        required: true
      },
      digits: {
        type: Number,
        default: 0
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        tweeningValue: 0,
        rafId: ''
      };
    },
    computed: {
      formatValue: function formatValue() {
        return Number(this.tweeningValue).toFixed(this.digits);
      }
    },
    watch: {
      value: function value(newValue, oldValue) {
        this.tween(oldValue, newValue);
      }
    },
    mounted: function mounted() {
      this.tween(0, this.value);
    },
    beforeDestroy: function beforeDestroy() {
      cancelAnimationFrame(this.rafId);
    },
    methods: {
      tween: function tween(startValue, endValue) {
        var _this = this;
        if (isNan$1(+endValue)) return 0;
        var dis = Math.abs(endValue - startValue);
        var isPositive = endValue - startValue > 0 ? 1 : -1;
        var ticDis = Math.ceil(dis / 30 * Math.pow(10, this.digits)) / Math.pow(10, this.digits);
        var ticTimes = Math.ceil(dis / ticDis);
        var gapTime = 25 / ticTimes;
        var tickGap = 1;
        var animate = function animate() {
          if (tickGap < gapTime) {
            _this.rafId = requestAnimationFrame(animate);
            tickGap++;
            return;
          }
          _this.tweeningValue += ticDis * isPositive;
          var isUnDone = isPositive === 1 ? _this.tweeningValue < endValue : _this.tweeningValue > endValue;
          if (isUnDone) {
            _this.rafId = requestAnimationFrame(animate);
            tickGap = 1;
          } else {
            _this.tweeningValue = endValue;
          }
        };
        animate();
      }
    }
  };

  /* script */
  var __vue_script__$5 = script$5;
  /* template */

  var __vue_render__$5 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('span', {
      class: _vm.extCls
    }, [_vm._v(_vm._s(_vm.formatValue))]);
  };

  var __vue_staticRenderFns__$5 = [];
  /* style */

  var __vue_inject_styles__$5 = undefined;
  /* scoped */

  var __vue_scope_id__$5 = undefined;
  /* module identifier */

  var __vue_module_identifier__$5 = undefined;
  /* functional template */

  var __vue_is_functional_template__$5 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$5 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$5,
    staticRenderFns: __vue_staticRenderFns__$5
  }, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$5);

  var script$6 = {
    name: 'bk-badge',
    props: {
      theme: {
        type: String,
        default: '',
        validator: function validator(value) {
          return ['', 'primary', 'info', 'warning', 'danger', 'success'].indexOf(value) > -1 || value.indexOf('#') === 0;
        }
      },
      val: {
        type: [Number, String],
        default: 1
      },
      valLength: {
        type: [Number, String],
        default: 3
      },
      icon: {
        type: String,
        default: ''
      },
      max: {
        type: Number,
        default: -1
      },
      dot: {
        type: Boolean,
        default: false
      },
      visible: {
        type: Boolean,
        default: true
      },
      position: {
        type: String,
        default: 'top-right'
      },
      radius: {
        type: [String, Number],
        default: undefined
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    computed: {
      text: function text() {
        var _this = this;
        var _type = _typeof(this.val);
        var _max = this.max;
        var _value = this.val;
        var _icon = this.icon;
        var _isNumber = _type === 'number' || /^\d+$/.test(this.val);
        if (_icon) {
          return _icon;
        }
        if (_isNumber && _max > -1 && Number(_value) > _max) {
          return _max + '+';
        } else {
          _value += '';
          var output = [];
          var count = 0;
          _value.split('').forEach(function (char) {
            if (count < Number(_this.valLength)) {
              count += /[\u4e00-\u9fa5]/.test(char) ? 2 : 1;
              output.push(char);
            }
          });
          return output.join('');
        }
      },
      hexTheme: function hexTheme() {
        return /^#[0-9a-fA-F]{3,6}$/.test(this.theme);
      },
      badgeStyle: function badgeStyle() {
        var isRadius = this.radius !== undefined && /^\d+(%|px|em|rem|vh|vw)?$/.test(this.radius);
        var _radius = isRadius && /^\d+$/.test(this.radius) && "".concat(this.radius, "px") || this.radius;
        var style = this.icon && {
          color: this.theme || '',
          borderColor: 'transparent',
          backgroundColor: '#fff'
        } || {
          color: this.hexTheme ? '#fff' : '',
          backgroundColor: this.hexTheme ? this.theme : '',
          borderColor: this.hexTheme ? this.theme : '',
          borderWidth: this.dot ? '1px' : '2px'
        };
        isRadius && _extends(style, {
          borderRadius: _radius
        });
        return style;
      },
      badgeClass: function badgeClass() {
        return [this.theme && !this.hexTheme ? 'bk-' + this.theme : '', this.$slots.default ? this.position : '', {
          pinned: this.$slots.default,
          dot: this.dot,
          'is-icon': !!this.icon
        }];
      }
    },
    methods: {
      handleHover: function handleHover() {
        this.$emit('hover');
      },
      handleLeave: function handleLeave() {
        this.$emit('leave');
      }
    }
  };

  /* script */
  var __vue_script__$6 = script$6;
  /* template */

  var __vue_render__$6 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-badge-wrapper",
      class: _vm.extCls,
      style: {
        'vertical-align': _vm.$slots.default ? 'middle' : '',
        'cursor': _vm.icon ? 'pointer' : ''
      }
    }, [_vm._t("default"), _c('transition', {
      attrs: {
        "name": "fade-center"
      }
    }, [_c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      staticClass: "bk-badge",
      class: _vm.badgeClass,
      style: _vm.badgeStyle,
      on: {
        "mouseenter": _vm.handleHover,
        "mouseleave": _vm.handleLeave
      }
    }, [_vm.icon && !_vm.dot ? _c('i', {
      staticClass: "bk-icon",
      class: 'icon-' + _vm.icon
    }) : _vm._e(), !_vm.icon && !_vm.dot ? _c('span', [_vm._v(_vm._s(_vm.text))]) : _vm._e()])])], 2);
  };

  var __vue_staticRenderFns__$6 = [];
  /* style */

  var __vue_inject_styles__$6 = undefined;
  /* scoped */

  var __vue_scope_id__$6 = undefined;
  /* module identifier */

  var __vue_module_identifier__$6 = undefined;
  /* functional template */

  var __vue_is_functional_template__$6 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$6 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$6,
    staticRenderFns: __vue_staticRenderFns__$6
  }, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$6);

  var script$7 = {
    name: 'bk-button',
    props: {
      theme: {
        type: String,
        default: 'default',
        validator: function validator(value) {
          if (['default', 'primary', 'warning', 'success', 'danger'].indexOf(value) < 0) {
            console.error("theme property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      hoverTheme: {
        type: String,
        default: '',
        validator: function validator(value) {
          if (['', 'primary', 'warning', 'success', 'danger'].indexOf(value) < 0) {
            console.error("hoverTheme property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      size: {
        type: String,
        default: 'normal',
        validator: function validator(value) {
          if (['small', 'normal', 'large'].indexOf(value) < 0) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      title: {
        type: String,
        default: ''
      },
      icon: String,
      iconRight: String,
      disabled: Boolean,
      loading: Boolean,
      outline: Boolean,
      text: Boolean,
      nativeType: {
        type: String,
        default: 'button'
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        showSlot: true
      };
    },
    computed: {
      iconType: function iconType() {
        var icon = this.icon || '';
        if (icon) {
          if (icon.indexOf('icon') === 0) {
            icon = icon.replace(/^(icon-)/, '');
          }
        }
        return icon;
      },
      iconRightType: function iconRightType() {
        var iconRight = this.iconRight || '';
        if (iconRight) {
          if (iconRight.indexOf('icon') === 0) {
            iconRight = iconRight.replace(/^(icon-)/, '');
          }
        }
        return iconRight;
      },
      themeType: function themeType() {
        if (this.text) {
          if (this.theme === 'default') {
            return 'primary';
          }
        }
        return this.theme;
      },
      buttonCls: function buttonCls() {
        return ["bk-".concat(this.themeType), "bk-button-".concat(this.size), this.hoverTheme ? "bk-button-hover bk-".concat(this.hoverTheme) : this.text ? 'bk-button-text' : 'bk-button', this.disabled ? 'is-disabled' : '', this.loading ? 'is-loading' : '', this.outline ? 'is-outline' : '', !this.showSlot ? 'no-slot' : ''];
      }
    },
    mounted: function mounted() {
      this.showSlot = this.$slots.default !== undefined;
    },
    methods: {
      handleClick: function handleClick(e) {
        if (!this.disabled && !this.loading) {
          this.$emit('click', e);
          this.$el.blur();
        }
      }
    }
  };

  /* script */
  var __vue_script__$7 = script$7;
  /* template */

  var __vue_render__$7 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('button', _vm._b({
      class: [_vm.buttonCls, _vm.extCls],
      attrs: {
        "title": _vm.title,
        "disabled": _vm.disabled,
        "type": _vm.nativeType
      },
      on: {
        "click": _vm.handleClick
      }
    }, 'button', _vm.$attrs, false), [_vm.loading ? _c('div', {
      staticClass: "bk-button-loading"
    }, [_c('div', {
      staticClass: "bounce1"
    }), _c('div', {
      staticClass: "bounce2"
    }), _c('div', {
      staticClass: "bounce3"
    }), _c('div', {
      staticClass: "bounce4"
    })]) : _vm._e(), _c('div', {
      class: _vm.loading ? 'bk-loading-wrapper' : ''
    }, [_vm.iconType ? _c('i', {
      staticClass: "bk-icon left-icon",
      class: ['icon-' + _vm.iconType, _vm.iconType === 'loading' ? 'bk-button-icon-loading' : '']
    }, [_vm.iconType === 'loading' ? [_c('span', {
      staticClass: "loading"
    })] : _vm._e()], 2) : _vm._e(), _c('span', [_vm._t("default")], 2), _vm.iconRightType ? _c('i', {
      staticClass: "bk-icon right-icon",
      class: ['icon-' + _vm.iconRightType, _vm.iconRightType === 'loading' ? 'bk-button-icon-loading' : '']
    }, [_vm.iconRightType === 'loading' ? [_c('span', {
      staticClass: "loading"
    })] : _vm._e()], 2) : _vm._e()])]);
  };

  var __vue_staticRenderFns__$7 = [];
  /* style */

  var __vue_inject_styles__$7 = undefined;
  /* scoped */

  var __vue_scope_id__$7 = undefined;
  /* module identifier */

  var __vue_module_identifier__$7 = undefined;
  /* functional template */

  var __vue_is_functional_template__$7 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$7 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$7,
    staticRenderFns: __vue_staticRenderFns__$7
  }, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$7);

  var runtime_1 = createCommonjsModule(function (module) {
  var runtime = (function (exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise =
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn)
        ? iter
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }
            next.value = undefined$1;
            next.done = true;
            return next;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !! caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
     module.exports 
  ));
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  });

  var regenerator = runtime_1;

  var emitter = {
    methods: {
      dispatch: function dispatch(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!name || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, [eventName].concat(params));
        }
      }
    }
  };

  var checkboxSeed = 0;
  var groupSeed = 0;
  function getCheckboxName() {
    return "bk-checkbox_".concat(checkboxSeed++);
  }
  function getGroupName() {
    return "bk-checkbox-group_".concat(groupSeed++);
  }

  var script$8 = {
    name: 'bk-checkbox',
    mixins: [emitter],
    props: {
      value: {
        type: [String, Number, Boolean],
        default: undefined
      },
      checked: {
        type: Boolean,
        default: undefined
      },
      trueValue: {
        type: [String, Number, Boolean],
        default: true
      },
      falseValue: {
        type: [String, Number, Boolean],
        default: false
      },
      label: {
        type: [String, Number]
      },
      name: {
        type: String,
        default: function _default() {
          return getCheckboxName();
        }
      },
      disabled: Boolean,
      indeterminate: Boolean,
      extCls: {
        type: String,
        default: ''
      },
      beforeChange: Function
    },
    data: function data() {
      return {
        parent: null,
        localValue: undefined
      };
    },
    computed: {
      selected: function selected() {
        return this.localValue === this.localTrueValue;
      },
      parentValue: function parentValue() {
        return this.parent ? this.parent.localValue : null;
      },
      localTrueValue: function localTrueValue() {
        var localValue;
        if (this.parent) {
          if (this.label === undefined && this.value === undefined) {
            localValue = this.trueValue;
          } else if (this.value !== undefined) {
            localValue = this.value;
          } else {
            localValue = this.label;
          }
        } else {
          if (this.label === undefined) {
            localValue = this.trueValue;
          } else {
            localValue = this.label;
          }
        }
        return localValue;
      }
    },
    watch: {
      value: function value(val) {
        this.setLocalValue(val);
      },
      checked: function checked() {
        this.setLocalValue();
      },
      parentValue: function parentValue() {
        this.setLocalValue();
      }
    },
    created: function created() {
      this.dispatch('bk-checkbox-group', 'checkbox-item-add', this);
      this.init();
    },
    methods: {
      getValue: function getValue() {
        if (this.selected) {
          return {
            isChecked: true,
            value: this.localTrueValue
          };
        } else {
          return {
            isChecked: false,
            value: this.falseValue
          };
        }
      },
      init: function init() {
        var parent = this.$parent;
        while (parent && !parent.isCheckboxGroup && !parent.$options.name !== 'bk-checkbox-group') {
          parent = parent.$parent;
        }
        this.parent = parent;
        this.setLocalValue();
      },
      setLocalValue: function setLocalValue(val) {
        if (val !== undefined) {
          this.localValue = val;
          return;
        }
        if (this.parent) {
          var trueValue = this.localTrueValue;
          var isSelected = this.parent.localValue.includes(trueValue);
          this.localValue = isSelected ? trueValue : this.falseValue;
        } else {
          if (this.checked !== undefined) {
            this.localValue = this.checked ? this.localTrueValue : this.falseValue;
          } else if (this.value === undefined) {
            this.localValue = this.falseValue;
          } else {
            this.localValue = this.value;
          }
        }
      },
      handleClick: function handleClick() {
        var _this = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var shouldChange, oldValue, newValue, groupValue;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!_this.disabled) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 2:
                  if (!(typeof _this.beforeChange === 'function')) {
                    _context.next = 8;
                    break;
                  }
                  _context.next = 5;
                  return _this.beforeChange();
                case 5:
                  shouldChange = _context.sent;
                  if (!(shouldChange === false)) {
                    _context.next = 8;
                    break;
                  }
                  return _context.abrupt("return");
                case 8:
                  oldValue = _this.localValue;
                  if (_this.indeterminate) {
                    newValue = _this.localTrueValue;
                  } else {
                    newValue = oldValue === _this.localTrueValue ? _this.falseValue : _this.localTrueValue;
                  }
                  _this.localValue = newValue;
                  _this.$emit('input', newValue, _this.localTrueValue);
                  _this.$emit('change', newValue, oldValue, _this.localTrueValue);
                  _this.dispatch('bk-form-item', 'form-change');
                  if (_this.parent) {
                    groupValue = _this.localTrueValue === undefined ? newValue : _this.localTrueValue;
                    _this.parent.handleChange(_this.selected, groupValue);
                  }
                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    }
  };

  /* script */
  var __vue_script__$8 = script$8;
  /* template */

  var __vue_render__$8 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('label', {
      staticClass: "bk-form-checkbox",
      class: [{
        'is-disabled': _vm.disabled,
        'is-indeterminate': _vm.indeterminate,
        'is-checked': _vm.selected
      }, _vm.extCls],
      on: {
        "click": _vm.handleClick,
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.handleClick($event);
        }
      }
    }, [_c('span', {
      staticClass: "bk-checkbox",
      attrs: {
        "tabindex": _vm.disabled ? false : 0
      }
    }), _c('input', {
      attrs: {
        "type": "hidden",
        "name": _vm.name
      },
      domProps: {
        "value": _vm.label === undefined ? _vm.localValue : _vm.label
      }
    }), _vm.$slots.default ? _c('span', {
      staticClass: "bk-checkbox-text"
    }, [_vm._t("default")], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__$8 = [];
  /* style */

  var __vue_inject_styles__$8 = undefined;
  /* scoped */

  var __vue_scope_id__$8 = undefined;
  /* module identifier */

  var __vue_module_identifier__$8 = undefined;
  /* functional template */

  var __vue_is_functional_template__$8 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$8 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$8,
    staticRenderFns: __vue_staticRenderFns__$8
  }, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$8);

  var script$9 = {
    name: 'bk-checkbox-group',
    props: {
      value: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      name: {
        type: [String, Number],
        default: function _default() {
          return getGroupName();
        }
      }
    },
    data: function data() {
      return {
        checkboxItems: [],
        isCheckboxGroup: true,
        localValue: _toConsumableArray(this.value)
      };
    },
    watch: {
      value: function value(_value) {
        this.localValue = _toConsumableArray(_value);
      }
    },
    created: function created() {
      var _this = this;
      this.$on('checkbox-item-add', function (item) {
        if (item) {
          _this.checkboxItems.push(item);
        }
        return false;
      });
    },
    methods: {
      handleChange: function handleChange(checked, value) {
        var oldValue = _toConsumableArray(this.localValue);
        var localValue = [];
        this.checkboxItems.forEach(function (checkbox) {
          var params = checkbox.getValue();
          if (params.isChecked) {
            localValue.push(params.value);
          }
        });
        this.localValue = localValue;
        this.$emit('input', this.localValue);
        this.$emit('change', this.localValue, oldValue);
      }
    }
  };

  /* script */
  var __vue_script__$9 = script$9;
  /* template */

  var __vue_render__$9 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-form-control",
      attrs: {
        "name": _vm.name
      }
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$9 = [];
  /* style */

  var __vue_inject_styles__$9 = undefined;
  /* scoped */

  var __vue_scope_id__$9 = undefined;
  /* module identifier */

  var __vue_module_identifier__$9 = undefined;
  /* functional template */

  var __vue_is_functional_template__$9 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$9 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$9,
    staticRenderFns: __vue_staticRenderFns__$9
  }, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$9);

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  _export(_export.S, 'Array', { isArray: _isArray });

  var isArray = _core.Array.isArray;

  var isArray$1 = isArray;

  var script$a = {
    name: 'bk-collapse',
    provide: function provide() {
      return {
        'collapse': this
      };
    },
    props: {
      accordion: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Array, String]
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        currentActive: []
      };
    },
    watch: {
      value: {
        handler: function handler(value) {
          if (isArray$1(value)) {
            this.currentActive = value.map(function (item) {
              return "".concat(item);
            });
          } else if (typeof value !== 'undefined') {
            this.currentActive = ["".concat(value)];
          } else {
            this.currentActive = [];
          }
        },
        immediate: true
      }
    },
    created: function created() {
      var _this = this;
      this.itemList = [];
      this.$on('inject', function (item) {
        _this.itemList.push(item);
      });
      this.$on('item-toggle', this.itemToggle);
    },
    methods: {
      itemToggle: function itemToggle(item) {
        if (this.accordion) {
          this.currentActive = this.currentActive.length && this.currentActive[0] === item.name ? [] : [item.name];
        } else {
          var index = this.currentActive.indexOf(item.name);
          if (index > -1) {
            this.currentActive.splice(index, 1);
          } else {
            this.currentActive.push(item.name);
          }
        }
        this.$emit('input', this.currentActive);
        this.$emit('item-click', this.currentActive);
      }
    }
  };

  /* script */
  var __vue_script__$a = script$a;
  /* template */

  var __vue_render__$a = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-collapse",
      class: _vm.extCls
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$a = [];
  /* style */

  var __vue_inject_styles__$a = undefined;
  /* scoped */

  var __vue_scope_id__$a = undefined;
  /* module identifier */

  var __vue_module_identifier__$a = undefined;
  /* functional template */

  var __vue_is_functional_template__$a = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$a = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$a,
    staticRenderFns: __vue_staticRenderFns__$a
  }, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$a);

  var script$b = {
    name: 'bk-collapse-item',
    inject: ['collapse'],
    props: {
      customTriggerArea: {
        type: Boolean,
        default: false
      },
      name: {
        type: String
      },
      hideArrow: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      },
      contentHiddenType: {
        type: String,
        default: 'none'
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        index: 0,
        isRender: false,
        isShow: false
      };
    },
    computed: {
      calcRender: function calcRender() {
        return this.contentHiddenType === 'hidden' || this.isRender;
      },
      isActive: function isActive() {
        return this.collapse.currentActive.includes(this.name);
      }
    },
    watch: {
      isActive: {
        handler: function handler(isActive) {
          var _this = this;
          if (!isActive) {
            return;
          }
          if (!this.isRender) {
            this.isRender = true;
            this.$nextTick(function () {
              _this.isShow = true;
            });
          }
        },
        immediate: true
      }
    },
    created: function created() {
      this.collapse.$emit('inject', this);
    },
    methods: {
      toggle: function toggle() {
        if (this.disabled) return;
        this.collapse.$emit('item-toggle', this);
      },
      beforeEnter: function beforeEnter(el) {
        this.$emit('before-enter');
        addClass(el, 'collapse-transition');
        if (!el.dataset) {
          el.dataset = {};
        }
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.style.height = '0';
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
      },
      enter: function enter(el) {
        el.dataset.oldOverflow = el.style.overflow;
        if (el.scrollHeight !== 0) {
          el.style.height = el.scrollHeight + 'px';
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        } else {
          el.style.height = '';
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
        el.style.overflow = 'hidden';
      },
      afterEnter: function afterEnter(el) {
        removeClass(el, 'collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
      },
      beforeLeave: function beforeLeave(el) {
        if (!el.dataset) el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.dataset.oldOverflow = el.style.overflow;
        el.style.height = el.scrollHeight + 'px';
        el.style.overflow = 'hidden';
      },
      leave: function leave(el) {
        if (el.scrollHeight !== 0) {
          addClass(el, 'collapse-transition');
          el.style.height = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        }
      },
      afterLeave: function afterLeave(el) {
        this.$emit('after-leave');
        removeClass(el, 'collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }
    }
  };

  /* script */
  var __vue_script__$b = script$b;
  /* template */

  var __vue_render__$b = function __vue_render__() {
    var _obj;

    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-collapse-item",
      class: (_obj = {
        'bk-collapse-item-active': _vm.isActive,
        'is-disabled': _vm.disabled
      }, _obj[_vm.extCls] = true, _obj)
    }, [_vm.customTriggerArea ? _c('div', {
      staticClass: "bk-collapse-item-header custom-trigger-layout"
    }, [_c('div', {
      staticClass: "trigger-area bk-collapse-item-hover cursor-pointer",
      on: {
        "click": _vm.toggle
      }
    }, [_vm._t("default")], 2), _c('div', {
      staticClass: "no-trigger-area"
    }, [_vm._t("no-trigger")], 2), _c('span', {
      staticClass: "custom-trigger-angle",
      class: {
        'collapse-expand': _vm.isActive
      },
      on: {
        "click": _vm.toggle
      }
    }, [!_vm.hideArrow ? _c('i', {
      staticClass: "bk-icon icon-angle-right"
    }) : _vm._e()])]) : _c('div', {
      staticClass: "bk-collapse-item-header bk-collapse-item-hover cursor-pointer",
      on: {
        "click": _vm.toggle
      }
    }, [_c('span', {
      staticClass: "fr",
      class: {
        'collapse-expand': _vm.isActive
      }
    }, [!_vm.hideArrow ? _c('i', {
      staticClass: "bk-icon icon-angle-right"
    }) : _vm._e()]), _vm._t("icon"), _vm._t("default")], 2), _vm.calcRender ? [_c('transition', {
      attrs: {
        "name": "collapse"
      },
      on: {
        "before-enter": _vm.beforeEnter,
        "enter": _vm.enter,
        "after-enter": _vm.afterEnter,
        "before-leave": _vm.beforeLeave,
        "leave": _vm.leave,
        "after-leave": _vm.afterLeave
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isActive && _vm.isShow,
        expression: "isActive && isShow"
      }],
      staticClass: "bk-collapse-item-content"
    }, [_c('div', {
      staticClass: "bk-collapse-item-detail"
    }, [_vm._t("content")], 2)])])] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$b = [];
  /* style */

  var __vue_inject_styles__$b = undefined;
  /* scoped */

  var __vue_scope_id__$b = undefined;
  /* module identifier */

  var __vue_module_identifier__$b = undefined;
  /* functional template */

  var __vue_is_functional_template__$b = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$b = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$b,
    staticRenderFns: __vue_staticRenderFns__$b
  }, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$b);

  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser && window.Promise;
  var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent(getParentNode(element));
  }
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent(commonAncestorContainer);
    }
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var defineProperty$2 = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect(offsets) {
    return _extends$1({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect(element) {
    var rect = {};
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }
  function getFixedPositionOffsetParent(element) {
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends$1({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? '-' + variation : '');
  }
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
    var popperRect = getOuterSizes(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
    return popperOffsets;
  }
  function find(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex(arr, prop, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
    data = runModifiers(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  function destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners(reference, state) {
    getWindow(reference).removeEventListener('resize', state.updateBound);
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  function applyStyle(data) {
    setStyles(data.instance.popper, data.styles);
    setAttributes(data.instance.popper, data.attributes);
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement);
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });
    return options;
  }
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
    var prefixedProperty = getSupportedPropertyName('transform');
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }
    var attributes = {
      'x-placement': data.placement
    };
    data.attributes = _extends$1({}, attributes, data.attributes);
    data.styles = _extends$1({}, styles, data.styles);
    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }
  function arrow(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var validPlacements = placements.slice(3);
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  function flip(data, options) {
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? '-' + variation : '');
        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function (op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var basePlacement = placement.split('-')[0];
    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style;
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty$2({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty$2({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$1({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: defineProperty$2({}, side, reference[side]),
        end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
    return data;
  }
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  var modifiers = {
    shift: {
      order: 100,
      enabled: true,
      fn: shift
    },
    offset: {
      order: 200,
      enabled: true,
      fn: offset,
      offset: 0
    },
    preventOverflow: {
      order: 300,
      enabled: true,
      fn: preventOverflow,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: {
      order: 400,
      enabled: true,
      fn: keepTogether
    },
    arrow: {
      order: 500,
      enabled: true,
      fn: arrow,
      element: '[x-arrow]'
    },
    flip: {
      order: 600,
      enabled: true,
      fn: flip,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: false,
      flipVariationsByContent: false
    },
    inner: {
      order: 700,
      enabled: false,
      fn: inner
    },
    hide: {
      order: 800,
      enabled: true,
      fn: hide
    },
    computeStyle: {
      order: 850,
      enabled: true,
      fn: computeStyle,
      gpuAcceleration: true,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: true,
      fn: applyStyle,
      onLoad: applyStyleOnLoad,
      gpuAcceleration: undefined
    }
  };
  var Defaults = {
    placement: 'bottom',
    positionFixed: false,
    eventsEnabled: true,
    removeOnDestroy: false,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: modifiers
  };
  var Popper = function () {
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce$1(this.update.bind(this));
      this.options = _extends$1({}, Popper.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends$1({
          name: name
        }, _this.options.modifiers[name]);
      })
      .sort(function (a, b) {
        return a.order - b.order;
      });
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
    }]);
    return Popper;
  }();
  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  var transferIndex = 0;
  function transferIncrease() {
    transferIndex = zIndexManager.nextZIndex();
  }

  var script$c = {
    name: 'DatePickerDropdown',
    props: {
      placement: {
        type: String,
        default: 'bottom-start'
      },
      className: {
        type: String
      },
      extPopoverCls: {
        type: String
      },
      transfer: {
        type: Boolean
      }
    },
    data: function data() {
      return {
        popper: null,
        popperStatus: false,
        tIndex: this.handleGetIndex()
      };
    },
    computed: {
      styles: function styles() {
        var style = {};
        if (this.transfer) {
          style['z-index'] = 1060 + this.tIndex;
        }
        return style;
      }
    },
    created: function created() {
      this.$on('on-update-popper', this.update);
      this.$on('on-destroy-popper', this.destroy);
    },
    beforeDestroy: function beforeDestroy() {
      if (this.popper) {
        this.popper.destroy();
      }
    },
    methods: {
      update: function update() {
        var _this = this;
        if (this.popper) {
          this.$nextTick(function () {
            _this.popper.update();
            _this.popperStatus = true;
          });
        } else {
          this.$nextTick(function () {
            _this.popper = new Popper(_this.$parent.$refs.reference, _this.$el, {
              placement: _this.placement,
              modifiers: {
                computeStyle: {
                  gpuAcceleration: false
                },
                preventOverflow: {
                  boundariesElement: 'window'
                }
              },
              onCreate: function onCreate() {
                _this.resetTransformOrigin();
                _this.$nextTick(_this.popper.update());
              },
              onUpdate: function onUpdate() {
                _this.resetTransformOrigin();
              }
            });
          });
        }
        this.tIndex = this.handleGetIndex();
      },
      destroy: function destroy() {
        var _this2 = this;
        if (this.popper) {
          setTimeout(function () {
            if (_this2.popper && !_this2.popperStatus) {
              _this2.popper.destroy();
              _this2.popper = null;
            }
            _this2.popperStatus = false;
          }, 300);
        }
      },
      resetTransformOrigin: function resetTransformOrigin() {
        if (!this.popper) {
          return;
        }
        var xPlacement = this.popper.popper.getAttribute('x-placement');
        var placementStart = xPlacement.split('-')[0];
        var placementEnd = xPlacement.split('-')[1];
        var leftOrRight = xPlacement === 'left' || xPlacement === 'right';
        if (!leftOrRight) {
          this.popper.popper.style.transformOrigin = placementStart === 'bottom' || placementStart !== 'top' && placementEnd === 'start' ? 'center top' : 'center bottom';
        }
      },
      handleGetIndex: function handleGetIndex() {
        transferIncrease();
        return transferIndex;
      }
    }
  };

  /* script */
  var __vue_script__$c = script$c;
  /* template */

  var __vue_render__$c = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-date-picker-dropdown",
      class: [_vm.className, _vm.extPopoverCls],
      style: _vm.styles
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$c = [];
  /* style */

  var __vue_inject_styles__$c = undefined;
  /* scoped */

  var __vue_scope_id__$c = undefined;
  /* module identifier */

  var __vue_module_identifier__$c = undefined;
  /* functional template */

  var __vue_is_functional_template__$c = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$c = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$c,
    staticRenderFns: __vue_staticRenderFns__$c
  }, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

  var tinycolor = createCommonjsModule(function (module) {
  (function(Math) {
  var trimLeft = /^\s+/,
      trimRight = /\s+$/,
      tinyCounter = 0,
      mathRound = Math.round,
      mathMin = Math.min,
      mathMax = Math.max,
      mathRandom = Math.random;
  function tinycolor (color, opts) {
      color = (color) ? color : '';
      opts = opts || { };
      if (color instanceof tinycolor) {
         return color;
      }
      if (!(this instanceof tinycolor)) {
          return new tinycolor(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color,
      this._r = rgb.r,
      this._g = rgb.g,
      this._b = rgb.b,
      this._a = rgb.a,
      this._roundA = mathRound(100*this._a) / 100,
      this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) { this._r = mathRound(this._r); }
      if (this._g < 1) { this._g = mathRound(this._g); }
      if (this._b < 1) { this._b = mathRound(this._b); }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
  }
  tinycolor.prototype = {
      isDark: function() {
          return this.getBrightness() < 128;
      },
      isLight: function() {
          return !this.isDark();
      },
      isValid: function() {
          return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
          return this._format;
      },
      getAlpha: function() {
          return this._a;
      },
      getBrightness: function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
      },
      getLuminance: function() {
          var rgb = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R, G, B;
          RsRGB = rgb.r/255;
          GsRGB = rgb.g/255;
          BsRGB = rgb.b/255;
          if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
          if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
          if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
          return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
      },
      setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100*this._a) / 100;
          return this;
      },
      toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
          return (this._a == 1) ?
            "hsv("  + h + ", " + s + "%, " + v + "%)" :
            "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
      },
      toHsl: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
          return (this._a == 1) ?
            "hsl("  + h + ", " + s + "%, " + l + "%)" :
            "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
      },
      toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
          return '#' + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
          return '#' + this.toHex8(allow4Char);
      },
      toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
          return (this._a == 1) ?
            "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
            "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
          return (this._a == 1) ?
            "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
            "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
          if (this._a === 0) {
              return "transparent";
          }
          if (this._a < 1) {
              return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
          var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
      },
      toString: function(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          if (needsAlphaFormat) {
              if (format === "name" && this._a === 0) {
                  return this.toName();
              }
              return this.toRgbString();
          }
          if (format === "rgb") {
              formattedString = this.toRgbString();
          }
          if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
          }
          if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
          }
          if (format === "hex3") {
              formattedString = this.toHexString(true);
          }
          if (format === "hex4") {
              formattedString = this.toHex8String(true);
          }
          if (format === "hex8") {
              formattedString = this.toHex8String();
          }
          if (format === "name") {
              formattedString = this.toName();
          }
          if (format === "hsl") {
              formattedString = this.toHslString();
          }
          if (format === "hsv") {
              formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
      },
      clone: function() {
          return tinycolor(this.toString());
      },
      _applyModification: function(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          this._r = color._r;
          this._g = color._g;
          this._b = color._b;
          this.setAlpha(color._a);
          return this;
      },
      lighten: function() {
          return this._applyModification(lighten, arguments);
      },
      brighten: function() {
          return this._applyModification(brighten, arguments);
      },
      darken: function() {
          return this._applyModification(darken, arguments);
      },
      desaturate: function() {
          return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
          return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
          return this._applyModification(greyscale, arguments);
      },
      spin: function() {
          return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
          return this._applyCombination(analogous, arguments);
      },
      complement: function() {
          return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
          return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
          return this._applyCombination(tetrad, arguments);
      }
  };
  tinycolor.fromRatio = function(color, opts) {
      if (typeof color == "object") {
          var newColor = {};
          for (var i in color) {
              if (color.hasOwnProperty(i)) {
                  if (i === "a") {
                      newColor[i] = color[i];
                  }
                  else {
                      newColor[i] = convertToPercentage(color[i]);
                  }
              }
          }
          color = newColor;
      }
      return tinycolor(color, opts);
  };
  function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color == "string") {
          color = stringInputToObject(color);
      }
      if (typeof color == "object") {
          if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
          }
          else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
          }
          else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
          }
          if (color.hasOwnProperty("a")) {
              a = color.a;
          }
      }
      a = boundAlpha(a);
      return {
          ok: ok,
          format: color.format || format,
          r: mathMin(255, mathMax(rgb.r, 0)),
          g: mathMin(255, mathMax(rgb.g, 0)),
          b: mathMin(255, mathMax(rgb.b, 0)),
          a: a
      };
  }
  function rgbToRgb(r, g, b){
      return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
      };
  }
  function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, l = (max + min) / 2;
      if(max == min) {
          h = s = 0;
      }
      else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }
      return { h: h, s: s, l: l };
  }
  function hslToRgb(h, s, l) {
      var r, g, b;
      h = bound01(h, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      function hue2rgb(p, q, t) {
          if(t < 0) t += 1;
          if(t > 1) t -= 1;
          if(t < 1/6) return p + (q - p) * 6 * t;
          if(t < 1/2) return q;
          if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
      }
      if(s === 0) {
          r = g = b = l;
      }
      else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
  }
  function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, v = max;
      var d = max - min;
      s = max === 0 ? 0 : d / max;
      if(max == min) {
          h = 0;
      }
      else {
          switch(max) {
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }
      return { h: h, s: s, v: v };
  }
   function hsvToRgb(h, s, v) {
      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i = Math.floor(h),
          f = h - i,
          p = v * (1 - s),
          q = v * (1 - f * s),
          t = v * (1 - (1 - f) * s),
          mod = i % 6,
          r = [v, q, p, p, t, v][mod],
          g = [t, v, v, q, p, p][mod],
          b = [p, p, t, v, v, q][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
  }
  function rgbToHex(r, g, b, allow3Char) {
      var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
  }
  function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16)),
          pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
          return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
  }
  function rgbaToArgbHex(r, g, b, a) {
      var hex = [
          pad2(convertDecimalToHex(a)),
          pad2(mathRound(r).toString(16)),
          pad2(mathRound(g).toString(16)),
          pad2(mathRound(b).toString(16))
      ];
      return hex.join("");
  }
  tinycolor.equals = function (color1, color2) {
      if (!color1 || !color2) { return false; }
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
  };
  tinycolor.random = function() {
      return tinycolor.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
      });
  };
  function desaturate(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
  }
  function saturate(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
  }
  function greyscale(color) {
      return tinycolor(color).desaturate(100);
  }
  function lighten (color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
  }
  function brighten(color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var rgb = tinycolor(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
      return tinycolor(rgb);
  }
  function darken (color, amount) {
      amount = (amount === 0) ? 0 : (amount || 10);
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
  }
  function spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
  }
  function complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
  }
  function triad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
          tinycolor(color),
          tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
      ];
  }
  function tetrad(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
          tinycolor(color),
          tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
          tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
      ];
  }
  function splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [
          tinycolor(color),
          tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
          tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
      ];
  }
  function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];
      for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(tinycolor(hsl));
      }
      return ret;
  }
  function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h = hsv.h, s = hsv.s, v = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
          ret.push(tinycolor({ h: h, s: s, v: v}));
          v = (v + modification) % 1;
      }
      return ret;
  }
  tinycolor.mix = function(color1, color2, amount) {
      amount = (amount === 0) ? 0 : (amount || 50);
      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();
      var p = amount / 100;
      var rgba = {
          r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
          g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
          b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
          a: ((rgb2.a - rgb1.a) * p) + rgb1.a
      };
      return tinycolor(rgba);
  };
  tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
  };
  tinycolor.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
              out = readability >= 4.5;
              break;
          case "AAlarge":
              out = readability >= 3;
              break;
          case "AAAsmall":
              out = readability >= 7;
              break;
      }
      return out;
  };
  tinycolor.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size ;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors ;
      level = args.level;
      size = args.size;
      for (var i= 0; i < colorList.length ; i++) {
          readability = tinycolor.readability(baseColor, colorList[i]);
          if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
          }
      }
      if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
          return bestColor;
      }
      else {
          args.includeFallbackColors=false;
          return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
      }
  };
  var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
  };
  var hexNames = tinycolor.hexNames = flip(names);
  function flip(o) {
      var flipped = { };
      for (var i in o) {
          if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
          }
      }
      return flipped;
  }
  function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
          a = 1;
      }
      return a;
  }
  function bound01(n, max) {
      if (isOnePointZero(n)) { n = "100%"; }
      var processPercent = isPercentage(n);
      n = mathMin(max, mathMax(0, parseFloat(n)));
      if (processPercent) {
          n = parseInt(n * max, 10) / 100;
      }
      if ((Math.abs(n - max) < 0.000001)) {
          return 1;
      }
      return (n % max) / parseFloat(max);
  }
  function clamp01(val) {
      return mathMin(1, mathMax(0, val));
  }
  function parseIntFromHex(val) {
      return parseInt(val, 16);
  }
  function isOnePointZero(n) {
      return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
  }
  function isPercentage(n) {
      return typeof n === "string" && n.indexOf('%') != -1;
  }
  function pad2(c) {
      return c.length == 1 ? '0' + c : '' + c;
  }
  function convertToPercentage(n) {
      if (n <= 1) {
          n = (n * 100) + "%";
      }
      return n;
  }
  function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
  }
  function convertHexToDecimal(h) {
      return (parseIntFromHex(h) / 255);
  }
  var matchers = (function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
  })();
  function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
  }
  function stringInputToObject(color) {
      color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
      var named = false;
      if (names[color]) {
          color = names[color];
          named = true;
      }
      else if (color == 'transparent') {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match;
      if ((match = matchers.rgb.exec(color))) {
          return { r: match[1], g: match[2], b: match[3] };
      }
      if ((match = matchers.rgba.exec(color))) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      if ((match = matchers.hsl.exec(color))) {
          return { h: match[1], s: match[2], l: match[3] };
      }
      if ((match = matchers.hsla.exec(color))) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      if ((match = matchers.hsv.exec(color))) {
          return { h: match[1], s: match[2], v: match[3] };
      }
      if ((match = matchers.hsva.exec(color))) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      if ((match = matchers.hex8.exec(color))) {
          return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
          };
      }
      if ((match = matchers.hex6.exec(color))) {
          return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
          };
      }
      if ((match = matchers.hex4.exec(color))) {
          return {
              r: parseIntFromHex(match[1] + '' + match[1]),
              g: parseIntFromHex(match[2] + '' + match[2]),
              b: parseIntFromHex(match[3] + '' + match[3]),
              a: convertHexToDecimal(match[4] + '' + match[4]),
              format: named ? "name" : "hex8"
          };
      }
      if ((match = matchers.hex3.exec(color))) {
          return {
              r: parseIntFromHex(match[1] + '' + match[1]),
              g: parseIntFromHex(match[2] + '' + match[2]),
              b: parseIntFromHex(match[3] + '' + match[3]),
              format: named ? "name" : "hex"
          };
      }
      return false;
  }
  function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || {"level":"AA", "size":"small"};
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
          level = "AA";
      }
      if (size !== "small" && size !== "large") {
          size = "small";
      }
      return {"level":level, "size":size};
  }
  if ( module.exports) {
      module.exports = tinycolor;
  }
  else {
      window.tinycolor = tinycolor;
  }
  })(Math);
  });

  function formatColor(colorParam) {
    if (colorParam === '') {
      colorParam = '#FFFFFF';
    }
    var tinyColor = tinycolor(colorParam);
    var hsl = tinyColor.toHsl();
    var hsv = tinyColor.toHsv();
    if (hsl.s === 0) {
      hsl.h = hsv.h = colorParam.h || 0;
    }
    if (hsv.v < 0.0164) {
      hsv.h = colorParam.h || 0;
      hsv.s = colorParam.s || 0;
    }
    if (hsl.l < 0.01) {
      hsl.h = colorParam.h || 0;
      hsl.s = colorParam.s || 0;
    }
    return {
      hsl: hsl,
      hsv: hsv,
      hex: tinyColor.toHexString().toUpperCase(),
      rgba: tinyColor.toRgb()
    };
  }
  function clamp(value, min, max) {
    if (value < min) {
      return min;
    }
    if (value > max) {
      return max;
    }
    return value;
  }
  function getTouches(e, prop) {
    return e.touches ? e.touches[0][prop] : 0;
  }
  function toRGBAString(rgba) {
    var r = rgba.r,
        g = rgba.g,
        b = rgba.b,
        a = rgba.a;
    return "rgba(".concat([r, g, b, a].join(','), ")");
  }

  var script$d = {
    props: {
      colorObj: {
        type: Object,
        required: true
      }
    },
    computed: {
      backgroundStyle: function backgroundStyle() {
        return {
          background: "hsl(".concat(this.colorObj.hsv.h, ", 100%, 50%)")
        };
      },
      pointerStyle: function pointerStyle() {
        return {
          top: "".concat((1 - this.colorObj.hsv.v) * 100, "%"),
          left: "".concat(this.colorObj.hsv.s * 100, "%")
        };
      }
    },
    methods: {
      handleMouseDown: function handleMouseDown(e) {
        this.$el.focus();
        this.handlePointChange(e);
        window.addEventListener('mousemove', this.handlePointChange, {
          passive: true
        });
        window.addEventListener('mouseup', this.handleMouseUp);
      },
      handleMouseUp: function handleMouseUp() {
        window.removeEventListener('mousemove', this.handlePointChange);
        window.removeEventListener('mouseup', this.handleMouseUp);
      },
      handleArrowKeydown: function handleArrowKeydown(e) {
        var _this$$refs$container = this.$refs.container,
            clientWidth = _this$$refs$container.clientWidth,
            clientHeight = _this$$refs$container.clientHeight;
        var left = this.colorObj.hsv.s * clientWidth;
        var top = (1 - this.colorObj.hsv.v) * clientHeight;
        var step = 10;
        switch (e.code) {
          case 'ArrowLeft':
            e.preventDefault();
            left = clamp(left - step, 0, clientWidth);
            break;
          case 'ArrowRight':
            e.preventDefault();
            left = clamp(left + step, 0, clientWidth);
            break;
          case 'ArrowUp':
            e.preventDefault();
            top = clamp(top - step, 0, clientHeight);
            break;
          case 'ArrowDown':
            e.preventDefault();
            top = clamp(top + step, 0, clientHeight);
            break;
          default:
            return;
        }
        this.handlePointChange(null, left, top);
      },
      handlePointChange: function handlePointChange(e, appointedLeft, appointedTop) {
        var _this$$refs$container2 = this.$refs.container,
            clientWidth = _this$$refs$container2.clientWidth,
            clientHeight = _this$$refs$container2.clientHeight;
        var left = appointedLeft !== undefined ? appointedLeft : this.getLeft(e);
        var top = appointedTop !== undefined ? appointedTop : this.getTop(e);
        var saturation = left / clientWidth;
        var bright = 1 - top / clientHeight;
        this.changeColor(this.colorObj.hsv.h, saturation, bright, this.colorObj.hsv.a);
      },
      getLeft: function getLeft(e) {
        var container = this.$refs.container;
        var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
        var pageX = e.pageX || getTouches(e, 'PageX');
        return clamp(pageX - xOffset, 0, container.clientWidth);
      },
      getTop: function getTop(e) {
        var container = this.$refs.container;
        var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
        var pageY = e.pageY || getTouches(e, 'PageY');
        return clamp(pageY - yOffset, 0, container.clientHeight);
      },
      changeColor: function changeColor(h, s, v, a) {
        this.$emit('change', {
          h: h,
          s: s,
          v: v,
          a: a
        });
      }
    }
  };

  /* script */
  var __vue_script__$d = script$d;
  /* template */

  var __vue_render__$d = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "container",
      staticClass: "bk-color-picker-saturation",
      style: _vm.backgroundStyle,
      attrs: {
        "tabindex": "0"
      },
      on: {
        "keydown": _vm.handleArrowKeydown,
        "mousedown": function mousedown($event) {
          $event.stopPropagation();
          return _vm.handleMouseDown($event);
        }
      }
    }, [_c('div', {
      staticClass: "bk-color-picker-saturation-white"
    }), _c('div', {
      staticClass: "bk-color-picker-saturation-black"
    }), _c('div', {
      staticClass: "bk-color-picker-pointer",
      style: _vm.pointerStyle
    }, [_c('div', {
      staticClass: "bk-color-picker-circle"
    })])]);
  };

  var __vue_staticRenderFns__$d = [];
  /* style */

  var __vue_inject_styles__$d = undefined;
  /* scoped */

  var __vue_scope_id__$d = undefined;
  /* module identifier */

  var __vue_module_identifier__$d = undefined;
  /* functional template */

  var __vue_is_functional_template__$d = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$d = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$d,
    staticRenderFns: __vue_staticRenderFns__$d
  }, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

  var script$e = {
    props: {
      colorObj: {
        type: Object,
        required: true
      }
    },
    computed: {
      pointerStyle: function pointerStyle() {
        return {
          left: "".concat(this.colorObj.hsv.h / 360 * 100, "%")
        };
      }
    },
    methods: {
      handleArrowKeydown: function handleArrowKeydown(e) {
        var clientWidth = this.$refs.container.clientWidth;
        var left = this.colorObj.hsv.h / 360 * clientWidth;
        var step = 2;
        var hugeStep = 10;
        switch (e.code) {
          case 'ArrowLeft':
            e.preventDefault();
            left = clamp(left - step, 0, clientWidth);
            break;
          case 'ArrowRight':
            e.preventDefault();
            left = clamp(left + step, 0, clientWidth);
            break;
          case 'ArrowUp':
            e.preventDefault();
            left = clamp(left - hugeStep, 0, clientWidth);
            break;
          case 'ArrowDown':
            e.preventDefault();
            left = clamp(left + hugeStep, 0, clientWidth);
            break;
          default:
            return;
        }
        this.handlePointChange(null, left);
      },
      handleMouseDown: function handleMouseDown(e) {
        this.$el.focus();
        this.handlePointChange(e);
        window.addEventListener('mousemove', this.handlePointChange, {
          passive: true
        });
        window.addEventListener('mouseup', this.handleMouseUp);
      },
      handleMouseUp: function handleMouseUp() {
        window.removeEventListener('mousemove', this.handlePointChange);
        window.removeEventListener('mouseup', this.handleMouseUp);
      },
      handlePointChange: function handlePointChange(e, appointedLeft) {
        var clientWidth = this.$refs.container.clientWidth;
        var left = appointedLeft !== undefined ? appointedLeft : this.getLeft(e);
        this.changeColor(left / clientWidth);
      },
      getLeft: function getLeft(e) {
        var container = this.$refs.container;
        var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
        var pageX = e.pageX || getTouches(e, 'PageX');
        return clamp(pageX - xOffset, 0, container.clientWidth);
      },
      changeColor: function changeColor(ratio) {
        var _this$colorObj$hsl = this.colorObj.hsl,
            h = _this$colorObj$hsl.h,
            s = _this$colorObj$hsl.s,
            l = _this$colorObj$hsl.l,
            a = _this$colorObj$hsl.a;
        var newHue = ratio * 360;
        if (h !== newHue) {
          this.$emit('change', {
            h: newHue,
            s: s,
            l: l,
            a: a
          });
        }
      }
    }
  };

  /* script */
  var __vue_script__$e = script$e;
  /* template */

  var __vue_render__$e = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "container",
      staticClass: "bk-color-picker-hue",
      attrs: {
        "tabindex": "0"
      },
      on: {
        "keydown": _vm.handleArrowKeydown,
        "mousedown": function mousedown($event) {
          $event.stopPropagation();
          return _vm.handleMouseDown($event);
        }
      }
    }, [_c('div', {
      staticClass: "bk-color-picker-hue-pointer",
      style: _vm.pointerStyle
    }, [_c('div', {
      staticClass: "bk-color-picker-hue-rectangle"
    })])]);
  };

  var __vue_staticRenderFns__$e = [];
  /* style */

  var __vue_inject_styles__$e = undefined;
  /* scoped */

  var __vue_scope_id__$e = undefined;
  /* module identifier */

  var __vue_module_identifier__$e = undefined;
  /* functional template */

  var __vue_is_functional_template__$e = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$e = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$e,
    staticRenderFns: __vue_staticRenderFns__$e
  }, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

  var script$f = {
    props: {
      info: {
        type: Object,
        required: true
      }
    },
    methods: {
      handleTab: function handleTab(e) {
        if (this.info.key === 'a') {
          this.$emit('tab', e);
        }
      },
      handleInput: function handleInput(e) {
        var key = this.info.key;
        var value = e.target.value;
        this.$emit('input', key, value);
      }
    }
  };

  /* script */
  var __vue_script__$f = script$f;
  /* template */

  var __vue_render__$f = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-color-picker-input-part"
    }, [_c('input', {
      class: ['bk-color-picker-input-value', _vm.info.error && 'error'],
      attrs: {
        "type": _vm.info.name === 'HEX' ? 'text' : 'number'
      },
      domProps: {
        "value": _vm.info.value
      },
      on: {
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
            return null;
          }

          return _vm.handleTab($event);
        },
        "input": _vm.handleInput
      }
    }), _c('span', {
      staticClass: "bk-color-picker-input-text"
    }, [_vm._v(_vm._s(_vm.info.name))])]);
  };

  var __vue_staticRenderFns__$f = [];
  /* style */

  var __vue_inject_styles__$f = undefined;
  /* scoped */

  var __vue_scope_id__$f = undefined;
  /* module identifier */

  var __vue_module_identifier__$f = undefined;
  /* functional template */

  var __vue_is_functional_template__$f = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$f = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$f,
    staticRenderFns: __vue_staticRenderFns__$f
  }, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

  var script$g = {
    components: {
      InputContainer: __vue_component__$f
    },
    props: {
      colorObj: {
        type: Object,
        required: true
      }
    },
    data: function data() {
      return {
        hex: {
          key: 'hex',
          name: 'HEX',
          value: this.colorObj.hex,
          error: false
        },
        r: {
          key: 'r',
          name: 'R',
          value: this.colorObj.rgba.r.toString(),
          error: false
        },
        g: {
          key: 'g',
          name: 'G',
          value: this.colorObj.rgba.g.toString(),
          error: false
        },
        b: {
          key: 'b',
          name: 'B',
          value: this.colorObj.rgba.b.toString(),
          error: false
        },
        a: {
          key: 'a',
          name: 'Alpha',
          value: this.colorObj.rgba.a.toString(),
          error: false
        }
      };
    },
    watch: {
      colorObj: function colorObj(val) {
        if (tinycolor(val.hex).toString() !== tinycolor(this.hex.value).toString()) {
          this.hex.value = val.hex;
        }
        this.r.value = val.rgba.r.toString();
        this.g.value = val.rgba.g.toString();
        this.b.value = val.rgba.b.toString();
        this.a.value = val.rgba.a.toString();
        this.validate();
      }
    },
    methods: {
      handleAlphaTab: function handleAlphaTab(e) {
        this.$emit('tab', e);
      },
      handleInput: function handleInput(key, value) {
        this[key].value = value;
        if (this.validate()) {
          var colorStr = key === 'hex' ? this.hex.value : "rgba(".concat(this.r.value, ", ").concat(this.g.value, ", ").concat(this.b.value, ", ").concat(this.a.value, ")");
          this.$emit('change', colorStr);
        }
      },
      validate: function validate() {
        var result = true;
        var hex = this.hex,
            r = this.r,
            g = this.g,
            b = this.b,
            a = this.a;
        if (hex.value.startsWith('#') && (hex.value.length === 4 || hex.value.length === 7) && !hex.value.slice(1).match(/[^0-9a-fA-F]/)) {
          hex.error = false;
        } else {
          hex.error = true;
          result = false;
        }
        if (a.value !== '' && a.value >= 0 && a.value <= 1) {
          a.error = false;
        } else {
          a.error = true;
          result = false;
        }
        for (var _i = 0, _arr = [r, g, b]; _i < _arr.length; _i++) {
          var colorInfo = _arr[_i];
          var value = colorInfo.value;
          if (value !== '' && value >= 0 && value <= 255) {
            colorInfo.error = false;
          } else {
            colorInfo.error = true;
            result = false;
          }
        }
        return result;
      }
    }
  };

  /* script */
  var __vue_script__$g = script$g;
  /* template */

  var __vue_render__$g = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-color-picker-input"
    }, [_c('div', {
      staticClass: "bk-color-picker-input-hex"
    }, [_c('InputContainer', {
      attrs: {
        "info": _vm.hex
      },
      on: {
        "input": _vm.handleInput
      }
    })], 1), _c('div', {
      staticClass: "bk-color-picker-input-rgba"
    }, [_c('InputContainer', {
      attrs: {
        "info": _vm.r
      },
      on: {
        "input": _vm.handleInput
      }
    }), _c('InputContainer', {
      attrs: {
        "info": _vm.g
      },
      on: {
        "input": _vm.handleInput
      }
    }), _c('InputContainer', {
      attrs: {
        "info": _vm.b
      },
      on: {
        "input": _vm.handleInput
      }
    }), _c('InputContainer', {
      attrs: {
        "info": _vm.a
      },
      on: {
        "input": _vm.handleInput,
        "tab": _vm.handleAlphaTab
      }
    })], 1)]);
  };

  var __vue_staticRenderFns__$g = [];
  /* style */

  var __vue_inject_styles__$g = undefined;
  /* scoped */

  var __vue_scope_id__$g = undefined;
  /* module identifier */

  var __vue_module_identifier__$g = undefined;
  /* functional template */

  var __vue_is_functional_template__$g = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$g = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$g,
    staticRenderFns: __vue_staticRenderFns__$g
  }, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, undefined, undefined, undefined);

  var script$h = {
    props: {
      colorObj: {
        type: Object,
        required: true
      },
      recommend: {
        type: [Boolean, Array],
        default: true
      }
    },
    data: function data() {
      return {
        isFocused: false,
        selectedIndex: -1,
        selectedColor: null
      };
    },
    computed: {
      colors: function colors() {
        return this.getColorsFromRecommend(this.recommend);
      }
    },
    watch: {
      colorObj: function colorObj() {
        this.selectedIndex = -1;
        this.selectedColor = null;
      }
    },
    methods: {
      handleKeydown: function handleKeydown(e) {
        if (e.code === 'Tab') {
          this.$emit('tab', e);
        } else {
          var index = 0;
          var rowNum = 10;
          var max = this.colors.length - 1;
          switch (e.code) {
            case 'ArrowLeft':
              e.preventDefault();
              index = clamp(this.selectedIndex - 1, 0, max);
              break;
            case 'ArrowRight':
              e.preventDefault();
              index = clamp(this.selectedIndex + 1, 0, max);
              break;
            case 'ArrowUp':
              e.preventDefault();
              index = clamp(this.selectedIndex - rowNum, 0, max);
              break;
            case 'ArrowDown':
              e.preventDefault();
              index = clamp(this.selectedIndex + rowNum, 0, max);
              break;
            default:
              return;
          }
          this.selectColor(index);
        }
      },
      selectColor: function selectColor(index) {
        var _this = this;
        var color = this.colors[index];
        this.$emit('change', color);
        this.$nextTick(function () {
          _this.selectedIndex = index;
          _this.selectedColor = color;
        });
      },
      getColorsFromRecommend: function getColorsFromRecommend(recommend) {
        if (recommend === true) {
          return ['', '#ff4500', '#ff8c00', '#ffd700', '#90ee90', '#ddffff', '#00ced1', '#3a84ff', '#a933f5', '#db7093', '#000000', '#494949', '#9B9B9B', '#ffffff'];
        } else if (isArray$1(recommend)) {
          return recommend.map(function (color) {
            return tinycolor(color).isValid() ? color : '';
          });
        }
      }
    }
  };

  /* script */
  var __vue_script__$h = script$h;
  /* template */

  var __vue_render__$h = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-color-picker-recommend",
      attrs: {
        "tabindex": "0"
      },
      on: {
        "focus": function focus($event) {
          _vm.isFocused = true;
        },
        "blur": function blur($event) {
          _vm.isFocused = false;
        },
        "keydown": _vm.handleKeydown
      }
    }, _vm._l(_vm.colors, function (color, index) {
      return _c('div', {
        key: color + index,
        class: {
          'bk-color-picker-recommend-color': true,
          'bk-color-picker-recommend-selected-color': _vm.isFocused && _vm.selectedIndex === index,
          'bk-color-picker-empty': color === ''
        },
        style: {
          background: color || '#fff'
        },
        on: {
          "click": function click($event) {
            _vm.selectColor(index);
          }
        }
      }, [_c('div', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: _vm.selectedIndex === index,
          expression: "selectedIndex === index"
        }],
        staticClass: "bk-color-picker-pointer"
      }, [_c('div', {
        staticClass: "bk-color-picker-circle"
      })])]);
    }), 0);
  };

  var __vue_staticRenderFns__$h = [];
  /* style */

  var __vue_inject_styles__$h = undefined;
  /* scoped */

  var __vue_scope_id__$h = undefined;
  /* module identifier */

  var __vue_module_identifier__$h = undefined;
  /* functional template */

  var __vue_is_functional_template__$h = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$h = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$h,
    staticRenderFns: __vue_staticRenderFns__$h
  }, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

  var nodeList = [];
  var clickctx = '$clickoutsideCtx';
  var beginClick;
  document.addEventListener('mousedown', function (event) {
    return beginClick = event;
  });
  document.addEventListener('mouseup', function (event) {
    nodeList.forEach(function (node) {
      node[clickctx].clickoutsideHandler(event, beginClick);
    });
  });
  var bkClickoutside = {
    bind: function bind(el, binding, vnode) {
      var id = nodeList.push(el) - 1;
      var clickoutsideHandler = function clickoutsideHandler() {
        var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!vnode.context
        || !mouseup.target || !mousedown.target || el.contains(mouseup.target)
        || el.contains(mousedown.target)
        || el === mouseup.target
        || vnode.context.popup
        && (vnode.context.popup.contains(mouseup.target)
        || vnode.context.popup.contains(mousedown.target)
        )) {
          return;
        }
        if (binding.expression
        && el[clickctx].callbackName
        && vnode.context[el[clickctx].callbackName]
        ) {
          vnode.context[el[clickctx].callbackName](mouseup, mousedown, el);
        } else {
          el[clickctx].bindingFn && el[clickctx].bindingFn(mouseup, mousedown, el);
        }
      };
      el[clickctx] = {
        id: id,
        clickoutsideHandler: clickoutsideHandler,
        callbackName: binding.expression,
        callbackFn: binding.value
      };
    },
    update: function update(el, binding) {
      el[clickctx].callbackName = binding.expression;
      el[clickctx].callbackFn = binding.value;
    },
    unbind: function unbind(el) {
      for (var i = 0, len = nodeList.length; i < len; i++) {
        if (nodeList[i][clickctx].id === el[clickctx].id) {
          nodeList.splice(i, 1);
          break;
        }
      }
    }
  };
  bkClickoutside.install = function (Vue) {
    Vue.directive('bkClickoutside', bkClickoutside);
  };

  function getTarget(node) {
    if (node === void 0) {
      node = document.body;
    }
    if (node === true) {
      return document.body;
    }
    return node instanceof window.Node ? node : document.querySelector(node);
  }
  var transferDom = {
    inserted: function inserted(el, _ref, vnode) {
      var value = _ref.value;
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      el.className = el.className ? el.className + ' v-transfer-dom' : 'v-transfer-dom';
      var parentNode = el.parentNode;
      if (!parentNode) {
        return;
      }
      var home = document.createComment('');
      var hasMovedOut = false;
      if (value !== false) {
        parentNode.replaceChild(home, el);
        getTarget(value).appendChild(el);
        hasMovedOut = true;
      }
      if (!el.__transferDomData) {
        el.__transferDomData = {
          parentNode: parentNode,
          home: home,
          target: getTarget(value),
          hasMovedOut: hasMovedOut
        };
      }
    },
    componentUpdated: function componentUpdated(el, _ref2) {
      var value = _ref2.value;
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      var ref$1 = el.__transferDomData;
      if (!ref$1) {
        return;
      }
      var parentNode = ref$1.parentNode;
      var home = ref$1.home;
      var hasMovedOut = ref$1.hasMovedOut;
      if (!hasMovedOut && value) {
        parentNode.replaceChild(home, el);
        getTarget(value).appendChild(el);
        el.__transferDomData = _extends({}, el.__transferDomData, {
          hasMovedOut: true,
          target: getTarget(value)
        });
      } else if (hasMovedOut && value === false) {
        parentNode.replaceChild(el, home);
        el.__transferDomData = _extends({}, el.__transferDomData, {
          hasMovedOut: false,
          target: getTarget(value)
        });
      } else if (value) {
        getTarget(value).appendChild(el);
      }
    },
    unbind: function unbind(el) {
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      el.className = el.className.replace('v-transfer-dom', '');
      var ref$1 = el.__transferDomData;
      if (!ref$1) {
        return;
      }
      if (el.__transferDomData.hasMovedOut === true) {
        el.__transferDomData.parentNode && el.__transferDomData.parentNode.appendChild(el);
      }
      el.__transferDomData = null;
    }
  };
  transferDom.install = function (Vue) {
    Vue.directive('bk-transfer-dom', transferDom);
  };

  var whiteColorObj = formatColor('#FFFFFF');
  var script$i = {
    name: 'bk-color-picker',
    components: {
      DatePickerDropdown: __vue_component__$c,
      SaturationPanel: __vue_component__$d,
      HueSlider: __vue_component__$e,
      ColorInput: __vue_component__$g,
      RecommendColors: __vue_component__$h
    },
    directives: {
      clickoutside: bkClickoutside,
      transferDom: transferDom
    },
    model: {
      event: 'change'
    },
    props: {
      value: {
        type: String,
        default: ''
      },
      disabled: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      transfer: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        default: '',
        validator: function validator(val) {
          return ['', 'large', 'small'].includes(val);
        }
      },
      showValue: {
        type: Boolean,
        default: true
      },
      recommend: {
        type: [Boolean, Array],
        default: true
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        showDropdown: false,
        colorStr: '',
        colorObj: whiteColorObj
      };
    },
    computed: {
      isRenderRecommend: function isRenderRecommend() {
        return Boolean(this.recommend === true || isArray$1(this.recommend) && this.recommend.length);
      }
    },
    watch: {
      value: function value() {
        this.changeColorFromProps();
      }
    },
    created: function created() {
      this.changeColorFromProps({
        isCreated: true
      });
    },
    methods: {
      handleTriggerKeydown: function handleTriggerKeydown(e) {
        if (e.code === 'Enter' || e.code === 'NumpadEnter') {
          this.toggleDropdown();
        } else if (e.code === 'Escape') {
          this.closeDropdown();
        }
      },
      handleDropdownKeydown: function handleDropdownKeydown(e) {
        if (this.transfer) {
          this.handleTriggerKeydown(e);
        }
      },
      toggleDropdown: function toggleDropdown() {
        if (this.disabled || this.readonly) {
          return;
        }
        this.showDropdown ? this.closeDropdown() : this.openDropdown();
      },
      handleTabInput: function handleTabInput(e) {
        if (!this.isRenderRecommend) {
          e.preventDefault();
          this.$refs.saturationPanel.$el.focus();
        }
      },
      handleTabRecommend: function handleTabRecommend(e) {
        e.preventDefault();
        this.$refs.saturationPanel.$el.focus();
      },
      openDropdown: function openDropdown() {
        var _this = this;
        this.showDropdown = true;
        this.$refs.drop.update();
        setTimeout(function () {
          var hexInput = _this.$refs.drop.$el.querySelector('.bk-color-picker-input-hex .bk-color-picker-input-value');
          hexInput.select();
        }, 100);
      },
      closeDropdown: function closeDropdown() {
        var _this2 = this;
        if (this.showDropdown) {
          this.$nextTick(function () {
            return _this2.$el.focus();
          });
          this.showDropdown = false;
          this.$refs.drop.destroy();
          this.changeColorFromProps();
        }
      },
      changeColorFromProps: function changeColorFromProps() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$isCreated = _ref.isCreated,
            isCreated = _ref$isCreated === void 0 ? false : _ref$isCreated;
        if (this.value === '') {
          if (this.colorStr !== '') {
            this.colorStr = '';
            this.colorObj = whiteColorObj;
          }
          return;
        }
        var colorObj = formatColor(this.value);
        var colorStr = colorObj.rgba.a === 1 ? colorObj.hex : toRGBAString(colorObj.rgba);
        if (colorStr !== this.colorStr) {
          var isValid = tinycolor(this.value).isValid();
          if (isCreated) {
            if (!isValid) {
              this.colorObj = whiteColorObj;
              this.$emit('change', '');
            } else {
              this.colorStr = colorStr.toLowerCase() === this.value.toLowerCase() ? this.value
              : colorStr;
              this.colorObj = colorObj;
            }
          } else {
            if (!isValid) {
              this.colorStr = '';
              this.colorObj = whiteColorObj;
            } else if (colorStr.toLowerCase() !== this.colorStr.toLowerCase()) {
              this.colorObj = colorObj;
              this.colorStr = colorStr;
            }
          }
        }
      },
      handleColorChange: function handleColorChange(val) {
        if (val === '') {
          this.colorStr = '';
          this.colorObj = whiteColorObj;
          this.$emit('change', '');
          return;
        }
        var colorObj = formatColor(val);
        var colorStr = colorObj.rgba.a === 1 ? colorObj.hex : toRGBAString(colorObj.rgba);
        this.colorObj = colorObj;
        this.colorStr = colorStr;
        this.$emit('change', colorStr);
      }
    }
  };

  /* script */
  var __vue_script__$i = script$i;
  /* template */

  var __vue_render__$i = function __vue_render__() {
    var _obj;

    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.closeDropdown,
        expression: "closeDropdown"
      }],
      ref: "reference",
      class: ['bk-color-picker', _vm.extCls, (_obj = {}, _obj["bk-color-picker-" + _vm.size] = _vm.size, _obj['bk-color-picker-show-dropdown'] = _vm.showDropdown, _obj['bk-color-picker-show-value'] = _vm.showValue, _obj['bk-color-picker-disabled'] = _vm.disabled || _vm.readonly, _obj)],
      attrs: {
        "tabindex": "0"
      },
      on: {
        "keydown": _vm.handleTriggerKeydown,
        "click": _vm.toggleDropdown
      }
    }, [_c('div', {
      staticClass: "bk-color-picker-color"
    }, [_c('span', {
      class: ['bk-color-picker-color-square', !_vm.colorStr && 'bk-color-picker-empty'],
      style: {
        background: _vm.colorStr || '#FFF'
      }
    })]), _vm.showValue ? _c('div', {
      staticClass: "bk-color-picker-text"
    }, [_c('span', [_vm._v(_vm._s(_vm.colorStr))])]) : _vm._e(), _vm._m(0), _c('transition', {
      attrs: {
        "name": "transition-drop"
      }
    }, [_c('DatePickerDropdown', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showDropdown,
        expression: "showDropdown"
      }, {
        name: "transfer-dom",
        rawName: "v-transfer-dom"
      }],
      ref: "drop",
      staticStyle: {
        "padding": "0",
        "cursor": "default"
      },
      attrs: {
        "transfer": _vm.transfer,
        "data-transfer": _vm.transfer
      }
    }, [_c('div', {
      staticClass: "bk-color-picker-dropdown",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
        },
        "mousedown": function mousedown($event) {
          $event.stopPropagation();
        },
        "keydown": _vm.handleDropdownKeydown
      }
    }, [_c('SaturationPanel', {
      ref: "saturationPanel",
      attrs: {
        "color-obj": _vm.colorObj
      },
      on: {
        "change": _vm.handleColorChange
      }
    }), _c('HueSlider', {
      attrs: {
        "color-obj": _vm.colorObj
      },
      on: {
        "change": _vm.handleColorChange
      }
    }), _c('ColorInput', {
      attrs: {
        "color-obj": _vm.colorObj
      },
      on: {
        "tab": _vm.handleTabInput,
        "change": _vm.handleColorChange
      }
    }), _vm.isRenderRecommend ? _c('div', {
      staticClass: "bk-color-picker-recommend-container"
    }, [_c('RecommendColors', {
      attrs: {
        "color-obj": _vm.colorObj,
        "recommend": _vm.recommend
      },
      on: {
        "tab": _vm.handleTabRecommend,
        "change": _vm.handleColorChange
      }
    })], 1) : _vm._e()], 1)])], 1)], 1);
  };

  var __vue_staticRenderFns__$i = [function () {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-color-picker-icon"
    }, [_c('span', {
      staticClass: "bk-icon icon-angle-down"
    })]);
  }];
  /* style */

  var __vue_inject_styles__$i = undefined;
  /* scoped */

  var __vue_scope_id__$i = undefined;
  /* module identifier */

  var __vue_module_identifier__$i = undefined;
  /* functional template */

  var __vue_is_functional_template__$i = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$i = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$i,
    staticRenderFns: __vue_staticRenderFns__$i
  }, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$i);

  var isCustomComponent = function isCustomComponent(node) {
    return node.tag && node.componentOptions;
  };
  var bkComposeFormItem = {
    name: 'bk-compose-form-item',
    props: {
      headBackgroundColor: {
        type: String,
        default: '#FAFBFD'
      },
      tailBackgroundColor: String
    },
    render: function render(h) {
      var childrenArr = this.$slots.default;
      if (childrenArr.length > 1) {
        var childrenLength = childrenArr.length;
        var startIndex = 0;
        var headChildren = null;
        while (startIndex < childrenLength) {
          if (isCustomComponent(childrenArr[startIndex])) {
            headChildren = childrenArr[startIndex];
            break;
          }
          startIndex++;
        }
        var tailIndex = childrenLength - 1;
        var tailChildren = null;
        while (tailIndex >= 0 && tailIndex > startIndex) {
          if (isCustomComponent(childrenArr[tailIndex])) {
            tailChildren = childrenArr[tailIndex];
            break;
          }
          tailIndex--;
        }
        if (headChildren && tailChildren) {
          var headChildStaticClass = 'bk-compose-form-item-head';
          if (headChildren.data.staticClass) {
            headChildStaticClass += " ".concat(headChildren.data.staticClass);
          }
          if (this.headBackgroundColor) {
            headChildren.data.style = _extends(headChildren.data.style || {}, {
              'background-color': this.headBackgroundColor
            });
          }
          headChildren.data.staticClass = headChildStaticClass;
          var tailChildStaticClass = 'bk-compose-form-item-tail';
          if (tailChildren.data.staticClass) {
            tailChildStaticClass += " ".concat(tailChildren.data.staticClass);
          }
          if (this.tailBackgroundColor) {
            tailChildren.data.style = _extends(tailChildren.data.style || {}, {
              'background-color': this.tailBackgroundColor
            });
          }
          tailChildren.data.staticClass = tailChildStaticClass;
        }
      }
      return h('div', {
        staticClass: 'bk-compose-form-item'
      }, childrenArr);
    }
  };

  setInstaller(bkComposeFormItem);

  var $JSON = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
  var stringify = function stringify(it) {
    return $JSON.stringify.apply($JSON, arguments);
  };

  var stringify$1 = stringify;

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');
  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim$1) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };
  var trim$1 = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
  var _stringTrim = exporter;

  var $parseInt = _global.parseInt;
  var $trim = _stringTrim.trim;
  var hex = /^[-+]?0[xX]/;
  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
  } : $parseInt;

  _export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

  var _parseInt$1 = _core.parseInt;

  var _parseInt$2 = _parseInt$1;

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function noop() {};
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }
  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }
  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  var formatFlags = {
    D: function D(dateObj) {
      return dateObj.getDay();
    },
    DD: function DD(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function Do(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function d(dateObj) {
      return dateObj.getDate();
    },
    dd: function dd(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function ddd(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function dddd(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function M(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function MM(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function MMM(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function MMMM(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function yy(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function yyyy(dateObj) {
      return dateObj.getFullYear();
    },
    h: function h(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function hh(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function H(dateObj) {
      return dateObj.getHours();
    },
    HH: function HH(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function m(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function mm(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function s(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function ss(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function S(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function SS(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function SSS(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function a(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function A(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function ZZ(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date();
      var cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi);
      var minutes;
      if (parts) {
        minutes = +(parts[1] * 60) + _parseInt$2(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }
    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    return mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }
    format = fecha.masks[format] || format;
    if (dateStr.length > 1000) {
      return false;
    }
    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }
      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });
    if (!isValid) {
      return false;
    }
    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  var initTime = function initTime() {
    var date = new Date();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    return date;
  };
  var mergeDateHMS = function mergeDateHMS(date, h, m, s) {
    var newDate = new Date(date.getTime());
    newDate.setHours(h);
    newDate.setMinutes(m);
    newDate.setSeconds(s);
    return newDate;
  };
  var getDayCountOfMonth = function getDayCountOfMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  };
  var toDate = function toDate(date) {
    var _date = new Date(date);
    if (isNaN(_date.getTime()) && typeof date === 'string') {
      _date = date.split('-').map(Number);
      _date[1] += 1;
      _date = _construct(Date, _toConsumableArray(_date));
    }
    if (isNaN(_date.getTime())) {
      return null;
    }
    return _date;
  };
  var formatDate = function formatDate(date, format) {
    date = toDate(date);
    if (!date) {
      return '';
    }
    return fecha.format(date, format || 'yyyy-MM-dd');
  };
  var parseDate = function parseDate(string, format) {
    return fecha.parse(string, format || 'yyyy-MM-dd');
  };
  var DEFAULT_FORMATS = {
    date: 'yyyy-MM-dd',
    month: 'yyyy-MM',
    year: 'yyyy',
    datetime: 'yyyy-MM-dd HH:mm:ss',
    time: 'HH:mm:ss',
    timerange: 'HH:mm:ss',
    daterange: 'yyyy-MM-dd',
    datetimerange: 'yyyy-MM-dd HH:mm:ss'
  };
  var DATE_FORMATTER = function DATE_FORMATTER(value, format) {
    return formatDate(value, format);
  };
  var DATE_PARSER = function DATE_PARSER(text, format) {
    return parseDate(text, format);
  };
  var RANGE_SEPARATOR = ' - ';
  var RANGE_FORMATTER = function RANGE_FORMATTER(value, format) {
    if (isArray$1(value) && value.length === 2) {
      var start = value[0];
      var end = value[1];
      if (start && end) {
        return formatDate(start, format) + RANGE_SEPARATOR + formatDate(end, format);
      }
    } else if (!isArray$1(value) && value instanceof Date) {
      return formatDate(value, format);
    }
    return '';
  };
  var RANGE_PARSER = function RANGE_PARSER(text, format) {
    var array = isArray$1(text) ? text : text.split(RANGE_SEPARATOR);
    if (array.length === 2) {
      var range1 = array[0];
      var range2 = array[1];
      return [range1 instanceof Date ? range1 : parseDate(range1, format), range2 instanceof Date ? range2 : parseDate(range2, format)];
    }
    return [];
  };
  var TYPE_VALUE_RESOLVER_MAP = {
    default: {
      formatter: function formatter(value) {
        if (!value) {
          return '';
        }
        return '' + value;
      },
      parser: function parser(text) {
        if (text === undefined || text === '') {
          return null;
        }
        return text;
      }
    },
    date: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    datetime: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    daterange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    datetimerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    timerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    time: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    month: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    year: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    multiple: {
      formatter: function formatter(value, format) {
        return value.filter(Boolean).map(function (date) {
          return formatDate(date, format);
        }).join(',');
      },
      parser: function parser(value, format) {
        var values = typeof value === 'string' ? value.split(',') : value;
        return values.map(function (value) {
          if (value instanceof Date) {
            return value;
          }
          if (typeof value === 'string') {
            value = value.trim();
          } else if (typeof value !== 'number' && !value) {
            value = '';
          }
          return parseDate(value, format);
        });
      }
    },
    number: {
      formatter: function formatter(value) {
        if (!value) {
          return '';
        }
        return '' + value;
      },
      parser: function parser(text) {
        var result = Number(text);
        if (!isNaN(text)) {
          return result;
        }
        return null;
      }
    }
  };
  var formatDateLabels = function () {
    var formats = {
      yyyy: function yyyy(date) {
        return date.getFullYear();
      },
      m: function m(date) {
        return date.getMonth() + 1;
      },
      mm: function mm(date) {
        return ('0' + (date.getMonth() + 1)).slice(-2);
      },
      mmm: function mmm(date, locale) {
        var monthName = date.toLocaleDateString(locale, {
          month: 'long'
        });
        return monthName.slice(0, 3);
      },
      Mmm: function Mmm(date, locale) {
        var monthName = date.toLocaleDateString(locale, {
          month: 'long'
        });
        return (monthName[0].toUpperCase() + monthName.slice(1).toLowerCase()).slice(0, 3);
      },
      mmmm: function mmmm(date, locale) {
        return date.toLocaleDateString(locale, {
          month: 'long'
        });
      },
      Mmmm: function Mmmm(date, locale) {
        var monthName = date.toLocaleDateString(locale, {
          month: 'long'
        });
        return monthName[0].toUpperCase() + monthName.slice(1).toLowerCase();
      }
    };
    var formatRegex = new RegExp(['yyyy', 'Mmmm', 'mmmm', 'Mmm', 'mmm', 'mm', 'm'].join('|'), 'g');
    return function (locale, format, date) {
      var componetsRegex = /(\[[^\]]+\])([^\[\]]+)(\[[^\]]+\])/;
      var components = format.match(componetsRegex).slice(1);
      var separator = components[1];
      var labels = [components[0], components[2]].map(function (component) {
        var label = component.replace(/\[[^\]]+\]/, function (str) {
          return str.slice(1, -1).replace(formatRegex, function (match) {
            return formats[match](date, locale);
          });
        });
        return {
          label: label,
          type: component.indexOf('yy') !== -1 ? 'year' : 'month'
        };
      });
      return {
        separator: separator,
        labels: labels
      };
    };
  }();
  var clearHours = function clearHours(time) {
    var cloneDate = new Date(time);
    cloneDate.setHours(0, 0, 0, 0);
    return cloneDate.getTime();
  };
  var isInRange = function isInRange(time, a, b) {
    if (!a || !b) {
      return false;
    }
    var _sort = [a, b].sort(),
        _sort2 = _slicedToArray(_sort, 2),
        start = _sort2[0],
        end = _sort2[1];
    return time >= start && time <= end;
  };
  var siblingMonth = function siblingMonth(src, diff) {
    var temp = new Date(src);
    var newMonth = temp.getMonth() + diff;
    var newMonthDayCount = getDayCountOfMonth(temp.getFullYear(), newMonth);
    if (newMonthDayCount < temp.getDate()) {
      temp.setDate(newMonthDayCount);
    }
    temp.setMonth(newMonth);
    return temp;
  };

  var isEmptyArray = function isEmptyArray(val) {
    return val.reduce(function (isEmpty, str) {
      return isEmpty && !str || typeof str === 'string' && str.trim() === '';
    }, true);
  };
  var keyValueMapper = {
    40: 'up',
    39: 'right',
    38: 'down',
    37: 'left'
  };
  var mapPossibleValues = function mapPossibleValues(key, horizontal, vertical) {
    if (key === 'left') {
      return horizontal * -1;
    }
    if (key === 'right') {
      return horizontal * 1;
    }
    if (key === 'up') {
      return vertical * 1;
    }
    if (key === 'down') {
      return vertical * -1;
    }
  };
  var extractTime = function extractTime(date) {
    if (!date) {
      return [0, 0, 0];
    }
    return [date.getHours(), date.getMinutes(), date.getSeconds()];
  };
  var script$j = {
    components: {
      DatePickerDropdown: __vue_component__$c
    },
    directives: {
      clickoutside: bkClickoutside,
      transferDom: transferDom
    },
    mixins: [emitter],
    props: {
      extCls: {
        type: String,
        default: ''
      },
      extPopoverCls: {
        type: String,
        default: ''
      },
      format: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      editable: {
        type: Boolean,
        default: true
      },
      clearable: {
        type: Boolean,
        default: true
      },
      open: {
        type: Boolean,
        default: null
      },
      multiple: {
        type: Boolean,
        default: false
      },
      timePickerOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      splitPanels: {
        type: Boolean,
        default: true
      },
      startDate: {
        type: Date
      },
      placeholder: {
        type: String,
        default: ''
      },
      placement: {
        type: String,
        default: 'bottom-start',
        validator: function validator(value) {
          var validList = ['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end'];
          if (validList.indexOf(value) < 0) {
            console.error("placement property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      transfer: {
        type: Boolean,
        default: false
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcuts: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcutClose: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Date, String, Array]
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      fontSize: {
        type: String,
        default: 'normal'
      },
      upToNow: {
        type: Boolean,
        default: false
      },
      useShortcutText: {
        type: Boolean,
        default: false
      },
      shortcutSelectedIndex: {
        type: Number,
        default: -1
      },
      headerSlotCls: {
        type: String,
        default: ''
      },
      footerSlotCls: {
        type: String,
        default: ''
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      },
      behavior: {
        type: String,
        default: 'normal',
        validate: function validate(v) {
          return ['simplicity', 'normal'].indexOf(v) > -1;
        }
      }
    },
    data: function data() {
      var isRange = this.type.includes('range');
      var emptyArray = isRange ? [null, null] : [null];
      var initialValue = isEmptyArray((isRange ? this.value : [this.value]) || []) ? emptyArray : this.parseDate(this.value);
      var shortcut = null;
      if (this.shortcutSelectedIndex !== -1) {
        shortcut = this.shortcuts[this.shortcutSelectedIndex] || null;
        if (shortcut) {
          initialValue = shortcut.value();
        }
      }
      var focusedTime = initialValue.map(extractTime);
      return {
        showClose: false,
        visible: false,
        internalValue: initialValue,
        disableClickOutSide: false,
        disableCloseUnderTransfer: false,
        selectionMode: this.onSelectionModeChange(this.type),
        forceInputRerender: 1,
        isFocused: false,
        focusedDate: initialValue[0] || this.startDate || new Date(),
        focusedTime: {
          column: 0,
          picker: 0,
          time: focusedTime,
          active: false
        },
        internalFocus: false,
        timeEnterMode: true,
        shortcut: shortcut
      };
    },
    computed: {
      publicVModelValue: function publicVModelValue() {
        if (this.multiple) {
          return this.internalValue.slice();
        }
        var isRange = this.type.includes('range');
        var val = this.internalValue.map(function (date) {
          return date instanceof Date ? new Date(date) : date || '';
        });
        if (this.type.match(/^time/)) {
          val = val.map(this.formatDate);
        }
        return isRange || this.multiple ? val : val[0];
      },
      publicStringValue: function publicStringValue() {
        var formatDate = this.formatDate,
            publicVModelValue = this.publicVModelValue,
            type = this.type;
        if (type.match(/^time/)) {
          return publicVModelValue;
        }
        if (this.multiple) {
          return formatDate(publicVModelValue);
        }
        return isArray$1(publicVModelValue) ? publicVModelValue.map(formatDate) : formatDate(publicVModelValue);
      },
      opened: function opened() {
        return this.open === null ? this.visible : this.open;
      },
      transition: function transition() {
        var bottomPlaced = this.placement.match(/^bottom/);
        return bottomPlaced ? 'slide-up' : 'slide-down';
      },
      visualValue: function visualValue() {
        return this.formatDate(this.internalValue);
      },
      displayValue: function displayValue() {
        if (this.shortcut && this.shortcut.text && this.useShortcutText) {
          return this.shortcut.text;
        }
        return this.visualValue;
      },
      isConfirm: function isConfirm() {
        return !!this.$slots.trigger || this.type === 'datetime' || this.type === 'datetimerange' || this.multiple;
      },
      fontSizeCls: function fontSizeCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-font';
        } else if (this.fontSize === 'large') {
          cls = 'large-font';
        }
        return cls;
      },
      longWidthCls: function longWidthCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-width';
        } else if (this.fontSize === 'large') {
          cls = 'large-width';
        }
        return cls;
      },
      localReadonly: function localReadonly() {
        if (this.shortcut && this.shortcut.text && this.useShortcutText) {
          return true;
        }
        return !this.editable || this.readonly;
      },
      hasFooter: function hasFooter() {
        return !!this.$slots.footer || !!this.$scopedSlots.footer;
      },
      hasHeader: function hasHeader() {
        return !!this.$slots.header || !!this.$scopedSlots.header;
      },
      allowCrossDayProp: function allowCrossDayProp() {
        return this.panel === 'RangeTimePickerPanel' ? this.allowCrossDay : false;
      }
    },
    watch: {
      visible: function visible(state) {
        if (state === false) {
          this.$refs.drop.destroy();
        }
        this.$refs.drop.update();
        if (!state) {
          this.dispatch('bk-form-item', 'form-blur');
        }
        this.$emit('open-change', state);
      },
      value: function value(val) {
        this.internalValue = this.parseDate(val);
      },
      open: function open(val) {
        this.visible = val === true;
      },
      type: function type(_type) {
        this.onSelectionModeChange(_type);
      },
      publicVModelValue: function publicVModelValue(now, before) {
        var newValue = stringify$1(now);
        var oldValue = stringify$1(before);
        var shouldEmitInput = newValue !== oldValue || _typeof(now) !== _typeof(before);
        if (shouldEmitInput) {
          this.$emit('input', now);
        }
      }
    },
    mounted: function mounted() {
      var _this = this;
      if (this.type.indexOf('date') > -1) {
        this.timeEnterMode = true;
      } else {
        this.timeEnterMode = this.enterMode;
      }
      var initialValue = this.value;
      var parsedValue = this.publicVModelValue;
      if (_typeof(initialValue) !== _typeof(parsedValue) || stringify$1(initialValue) !== stringify$1(parsedValue)) {
        this.$emit('input', this.publicVModelValue);
      }
      if (this.open !== null) {
        this.visible = this.open;
      }
      this.$on('focus-input', function () {
        return _this.focus();
      });
    },
    methods: {
      handleIconClick: function handleIconClick() {
        this.$refs.input.focus();
        this.$refs.input.click();
      },
      onSelectionModeChange: function onSelectionModeChange(type) {
        if (type.match(/^date/)) {
          type = 'date';
        }
        this.selectionMode = ['year', 'month', 'date', 'time'].indexOf(type) > -1 && type;
        return this.selectionMode;
      },
      handleTransferClick: function handleTransferClick() {
        if (this.transfer) {
          this.disableCloseUnderTransfer = true;
        }
      },
      handleClose: function handleClose(e) {
        if (this.disableCloseUnderTransfer) {
          this.disableCloseUnderTransfer = false;
          return false;
        }
        if (e && e.type === 'mousedown' && this.visible) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (this.visible) {
          var pickerPanel = this.$refs.pickerPanel && this.$refs.pickerPanel.$el;
          if (e && pickerPanel && pickerPanel.contains(e.target)) {
            return;
          }
          this.visible = false;
          e && e.preventDefault();
          e && e.stopPropagation();
          return;
        }
        this.isFocused = false;
        this.disableClickOutSide = false;
      },
      handleFocus: function handleFocus(e) {
        if (this.readonly) {
          return;
        }
        this.isFocused = true;
        if (e && e.type === 'focus') {
          return;
        }
        if (!this.disabled) {
          this.visible = true;
        }
      },
      handleBlur: function handleBlur(e) {
        if (this.internalFocus) {
          this.internalFocus = false;
          return;
        }
        if (this.visible) {
          e.preventDefault();
          return;
        }
        this.isFocused = false;
        this.onSelectionModeChange(this.type);
        this.internalValue = this.internalValue.slice();
        this.reset();
        this.$refs.pickerPanel.onToggleVisibility(false);
      },
      handleKeydown: function handleKeydown(e) {
        var keyCode = e.keyCode;
        if (keyCode === 9) {
          if (this.visible) {
            e.stopPropagation();
            e.preventDefault();
            if (this.isConfirm) {
              var selector = '.bk-picker-confirm > *';
              var tabbable = this.$refs.drop.$el.querySelectorAll(selector);
              this.internalFocus = true;
              var element = _toConsumableArray(tabbable)[e.shiftKey ? 'pop' : 'shift']();
              element.focus();
            } else {
              this.handleClose();
            }
          } else {
            this.focused = false;
          }
        }
        var arrows = [37, 38, 39, 40];
        if (!this.visible && arrows.includes(keyCode)) {
          this.visible = true;
          return;
        }
        if (keyCode === 27) {
          if (this.visible) {
            e.stopPropagation();
            this.handleClose();
          }
        }
        if (keyCode === 13 && this.timeEnterMode) {
          var _timePickers = findChildComponents(this, 'TimeSpinner');
          if (_timePickers.length > 0) {
            var columnsPerPicker = _timePickers[0].showSeconds ? 3 : 2;
            var pickerIndex = Math.floor(this.focusedTime.column / columnsPerPicker);
            var value = this.focusedTime.time[pickerIndex];
            _timePickers[pickerIndex].chooseValue(value);
            return;
          }
        }
        if (!arrows.includes(keyCode)) {
          return;
        }
        if (this.focusedTime.active) {
          e.preventDefault();
        }
        var timePickers = findChildComponents(this, 'TimeSpinner');
        if (timePickers.length > 0) {
          this.navigateTimePanel(keyValueMapper[keyCode]);
        }
      },
      reset: function reset() {
        this.$refs.pickerPanel.reset && this.$refs.pickerPanel.reset();
      },
      navigateTimePanel: function navigateTimePanel(direction) {
        var _this2 = this;
        this.focusedTime.active = true;
        var horizontal = direction.match(/left|right/);
        var vertical = direction.match(/up|down/);
        var timePickers = findChildComponents(this, 'TimeSpinner');
        var maxNrOfColumns = (timePickers[0].showSeconds ? 3 : 2) * timePickers.length;
        var column = function (currentColumn) {
          var incremented = currentColumn + (horizontal ? direction === 'left' ? -1 : 1 : 0);
          return (incremented + maxNrOfColumns) % maxNrOfColumns;
        }(this.focusedTime.column);
        var columnsPerPicker = maxNrOfColumns / timePickers.length;
        var pickerIndex = Math.floor(column / columnsPerPicker);
        var col = column % columnsPerPicker;
        if (horizontal) {
          var time = this.internalValue.map(extractTime);
          this.focusedTime = _objectSpread({}, this.focusedTime, {
            column: column,
            time: time
          });
          timePickers.forEach(function (instance, i) {
            if (i === pickerIndex) {
              instance.updateFocusedTime(col, time[pickerIndex]);
            } else {
              instance.updateFocusedTime(-1, instance.focusedTime);
            }
          });
        }
        if (vertical) {
          var increment = direction === 'up' ? 1 : -1;
          var timeParts = ['hours', 'minutes', 'seconds'];
          var pickerPossibleValues = timePickers[pickerIndex]["".concat(timeParts[col], "List")];
          var nextIndex = pickerPossibleValues.findIndex(function (_ref) {
            var text = _ref.text;
            return _this2.focusedTime.time[pickerIndex][col] === text;
          }) + increment;
          if (nextIndex === -1) {
            return;
          }
          var nextValue = pickerPossibleValues[nextIndex % pickerPossibleValues.length].text;
          var times = this.focusedTime.time.map(function (time, i) {
            if (i !== pickerIndex) {
              return time;
            }
            time[col] = nextValue;
            return time;
          });
          this.focusedTime = _objectSpread({}, this.focusedTime, {
            time: times
          });
          timePickers.forEach(function (instance, i) {
            if (i === pickerIndex) {
              instance.updateFocusedTime(col, times[i]);
              if (!_this2.timeEnterMode) {
                instance.chooseValue(_this2.focusedTime.time[pickerIndex]);
              }
            } else {
              instance.updateFocusedTime(-1, instance.focusedTime);
            }
          });
        }
      },
      navigateDatePanel: function navigateDatePanel(direction) {
        var timePickers = findChildComponents(this, 'TimeSpinner');
        if (timePickers.length > 0) {
          this.navigateTimePanel(direction);
          return;
        }
        var initialDate = this.focusedDate || this.internalValue && this.internalValue[0] || new Date();
        var focusedDate = new Date(initialDate);
        if (this.type.match(/^date/)) {
          var lastOfMonth = getDayCountOfMonth(initialDate.getFullYear(), initialDate.getMonth());
          var startDay = initialDate.getDate();
          var nextDay = focusedDate.getDate() + mapPossibleValues(direction, 1, 7);
          if (nextDay < 1) {
            if (direction.match(/left|right/)) {
              focusedDate.setMonth(focusedDate.getMonth() + 1);
              focusedDate.setDate(nextDay);
            } else {
              focusedDate.setDate(startDay + Math.floor((lastOfMonth - startDay) / 7) * 7);
            }
          } else if (nextDay > lastOfMonth) {
            if (direction.match(/left|right/)) {
              focusedDate.setMonth(focusedDate.getMonth() - 1);
              focusedDate.setDate(nextDay);
            } else {
              focusedDate.setDate(startDay % 7);
            }
          } else {
            focusedDate.setDate(nextDay);
          }
        }
        if (this.type.match(/^month/)) {
          focusedDate.setMonth(focusedDate.getMonth() + mapPossibleValues(direction, 1, 3));
        }
        if (this.type.match(/^year/)) {
          focusedDate.setFullYear(focusedDate.getFullYear() + mapPossibleValues(direction, 1, 3));
        }
        this.focusedDate = focusedDate;
      },
      handleInputChange: function handleInputChange(e) {
        var isArrayValue = this.type.includes('range') || this.multiple;
        var oldValue = this.visualValue;
        var newValue = e.target.value;
        var newDate = this.parseDate(newValue);
        var disabledDateFn = this.options && typeof this.options.disabledDate === 'function' && this.options.disabledDate;
        var valueToTest = isArrayValue ? newDate : newDate[0];
        var isDisabled = disabledDateFn && disabledDateFn(valueToTest);
        var isValidDate = newDate.reduce(function (valid, date) {
          return valid && date instanceof Date;
        }, true);
        if (newValue !== oldValue && !isDisabled && isValidDate) {
          this.emitChange(this.type);
          this.internalValue = newDate;
        } else {
          this.forceInputRerender++;
        }
      },
      handleInputMouseenter: function handleInputMouseenter() {
        if (this.readonly || this.disabled) {
          return;
        }
        if (this.visualValue) {
          this.showClose = true;
        }
      },
      handleInputMouseleave: function handleInputMouseleave(e) {
        if (e.toElement && e.toElement.classList.contains('clear-action')) {
          return;
        }
        this.showClose = false;
      },
      handleClear: function handleClear(e) {
        var _this3 = this;
        this.visible = false;
        this.internalValue = this.internalValue.map(function () {
          return null;
        });
        this.$emit('clear');
        this.emitChange(this.type);
        this.reset();
        this.showClose = false;
        this.shortcut = null;
        setTimeout(function () {
          return _this3.onSelectionModeChange(_this3.type);
        }, 500);
      },
      emitChange: function emitChange(type) {
        var _this4 = this;
        this.$nextTick(function () {
          _this4.$emit('change', _this4.publicStringValue, type);
          _this4.dispatch('bk-form-item', 'form-change');
          if (_this4.type.indexOf('time') < 0) {
            _this4.$refs.input && _this4.$refs.input.blur();
          }
        });
      },
      parseDate: function parseDate(val) {
        var isRange = this.type.includes('range');
        var type = this.type;
        var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
        var format = this.format || DEFAULT_FORMATS[type];
        var multipleParser = TYPE_VALUE_RESOLVER_MAP['multiple'].parser;
        if (val && type === 'time' && !(val instanceof Date)) {
          val = parser(val, format);
        } else if (this.multiple && val) {
          val = multipleParser(val, format);
        } else if (isRange) {
          if (!val) {
            val = [null, null];
          } else {
            if (typeof val === 'string') {
              val = parser(val, format);
            } else if (type === 'timerange') {
              val = parser(val, format).map(function (v) {
                return v || '';
              });
            } else {
              var _val = val,
                  _val2 = _slicedToArray(_val, 2),
                  start = _val2[0],
                  end = _val2[1];
              if (start instanceof Date && end instanceof Date) {
                val = val.map(function (date) {
                  return new Date(date);
                });
              } else if (typeof start === 'string' && typeof end === 'string') {
                val = parser(val.join(RANGE_SEPARATOR), format);
              } else if (!start || !end) {
                val = [null, null];
              }
            }
          }
        } else if (typeof val === 'string' && type.indexOf('time') !== 0) {
          val = parser(val, format) || null;
        }
        return isRange || this.multiple ? val || [] : [val];
      },
      formatDate: function formatDate(value) {
        var format = DEFAULT_FORMATS[this.type];
        if (this.multiple) {
          var formatter = TYPE_VALUE_RESOLVER_MAP.multiple.formatter;
          return formatter(value, this.format || format);
        } else {
          var _ref2 = TYPE_VALUE_RESOLVER_MAP[this.type] || TYPE_VALUE_RESOLVER_MAP['default'],
              _formatter = _ref2.formatter;
          return _formatter(value, this.format || format);
        }
      },
      onPick: function onPick(dates) {
        var _this5 = this;
        var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var type = arguments.length > 2 ? arguments[2] : undefined;
        var shortcut = arguments.length > 3 ? arguments[3] : undefined;
        if (this.multiple) {
          var pickedTimeStamp = dates.getTime();
          var indexOfPickedDate = this.internalValue.findIndex(function (date) {
            return date && date.getTime() === pickedTimeStamp;
          });
          var allDates = [].concat(_toConsumableArray(this.internalValue), [dates]).filter(Boolean);
          var timeStamps = allDates.map(function (date) {
            return date.getTime();
          }).filter(function (ts, i, arr) {
            return arr.indexOf(ts) === i && i !== indexOfPickedDate;
          });
          this.internalValue = timeStamps.map(function (ts) {
            return new Date(ts);
          });
        } else {
          dates = this.parseDate(dates);
          this.internalValue = isArray$1(dates) ? dates : [dates];
        }
        if (this.internalValue[0]) {
          this.focusedDate = this.internalValue[0];
        }
        this.focusedTime = _objectSpread({}, this.focusedTime, {
          time: this.internalValue.map(extractTime)
        });
        if (!this.isConfirm) {
          this.onSelectionModeChange(this.type);
          this.visible = visible;
        }
        if (type === 'upToNow' && this.type === 'daterange') {
          this.onPickSuccess();
        }
        this.shortcut = shortcut;
        this.emitChange(type);
        var shortcutIndex = this.shortcuts.findIndex(function (item) {
          return item === _this5.shortcut;
        });
        this.$emit('shortcut-change', this.shortcut, shortcutIndex);
      },
      onPickSuccess: function onPickSuccess() {
        var _this6 = this;
        this.visible = false;
        this.$nextTick(function () {
          _this6.$emit('pick-success');
        });
        this.$refs.input && this.$refs.input.blur();
        this.reset();
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      }
    }
  };

  /* script */
  var __vue_script__$j = script$j;
  /* template */

  var __vue_render__$j = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleClose,
        expression: "handleClose"
      }],
      staticClass: "bk-date-picker",
      class: [_vm.type === 'datetimerange' ? 'long' : '', _vm.longWidthCls, _vm.extCls]
    }, [_c('div', {
      ref: "reference",
      staticClass: "bk-date-picker-rel"
    }, [_vm._t("trigger", [_c('span', {
      staticClass: "icon-wrapper",
      class: _vm.disabled ? 'disabled' : '',
      on: {
        "click": _vm.handleIconClick,
        "mouseenter": _vm.handleInputMouseenter,
        "mouseleave": _vm.handleInputMouseleave
      }
    }, [_vm.type === 'time' || _vm.type === 'timerange' ? _c('svg', {
      staticClass: "picker-icon",
      attrs: {
        "x": "0px",
        "y": "0px",
        "viewBox": "0 0 1024 1024"
      }
    }, [_c('g', {
      attrs: {
        "id": "time"
      }
    }, [_c('path', {
      attrs: {
        "fill": "#c4c6cc",
        "d": "M512,128c51.9,0,102.2,10.1,149.5,30.2c45.7,19.3,86.8,47,122.1,82.3s63,76.4,82.3,122.1\n                            c20,47.3,30.2,97.6,30.2,149.5S886,614.3,865.9,661.6c-19.3,45.7-47,86.8-82.3,122.1s-76.4,63-122.1,82.3\n                            c-47.3,20-97.6,30.2-149.5,30.2S409.8,886.1,362.5,866c-45.7-19.3-86.8-47-122.1-82.3s-63-76.4-82.3-122.1\n                            c-20-47.3-30.2-97.6-30.2-149.5s10.1-102.2,30.2-149.5c19.3-45.7,47-86.8,82.3-122.1s76.4-63,122.1-82.3\n                            C409.8,138.1,460.1,128,512,128 M512,64C264.6,64,64,264.6,64,512s200.6,448,448,448s448-200.6,448-448S759.4,64,512,64L512,64z"
      }
    }), _c('polygon', {
      attrs: {
        "fill": "#c4c6cc",
        "points": "512,512 512,256 448,256 448,512 448,576 512,576 768,576 768,512"
      }
    })])]) : _c('svg', {
      staticClass: "picker-icon",
      attrs: {
        "x": "0px",
        "y": "0px",
        "viewBox": "0 0 1024 1024"
      }
    }, [_c('g', {
      attrs: {
        "id": "date"
      }
    }, [_c('path', {
      attrs: {
        "fill": "#c4c6cc",
        "d": "M896,128h-96v64h64v112H160V192h64v-64h-96c-17.7,0-32,14.3-32,32v736c0,17.7,14.3,32,32,32h768\n                            c17.7,0,32-14.3,32-32V160C928,142.3,913.7,128,896,128z M160,864V368h704v496H160z"
      }
    }), _c('rect', {
      attrs: {
        "x": "416",
        "y": "128",
        "fill": "#c4c6cc",
        "width": "192",
        "height": "64"
      }
    }), _c('rect', {
      attrs: {
        "x": "288",
        "y": "96",
        "fill": "#c4c6cc",
        "width": "64",
        "height": "128"
      }
    }), _c('rect', {
      attrs: {
        "x": "672",
        "y": "96",
        "fill": "#c4c6cc",
        "width": "64",
        "height": "128"
      }
    }), _c('polygon', {
      attrs: {
        "fill": "#c4c6cc",
        "points": "403.7,514.4 557.1,514.4 557.1,515.3 420.1,765.5 483.5,765.5 620.3,504.3 620.3,466.5 403.7,466.5"
      }
    })])])]), _c('input', {
      key: _vm.forceInputRerender,
      ref: "input",
      staticClass: "bk-date-picker-editor",
      class: [_vm.readonly ? 'readonly' : '', _vm.fontSizeCls, {
        'only-bottom-border': _vm.behavior === 'simplicity'
      }],
      attrs: {
        "type": "text",
        "readonly": _vm.localReadonly,
        "disabled": _vm.disabled,
        "placeholder": _vm.placeholder
      },
      domProps: {
        "value": _vm.displayValue
      },
      on: {
        "focus": _vm.handleFocus,
        "blur": _vm.handleBlur,
        "click": _vm.handleFocus,
        "change": _vm.handleInputChange,
        "keydown": _vm.handleKeydown,
        "mouseenter": _vm.handleInputMouseenter,
        "mouseleave": _vm.handleInputMouseleave
      }
    }), _vm.clearable && _vm.showClose ? _c('i', {
      staticClass: "bk-icon icon-close-circle-shape clear-action",
      on: {
        "click": _vm.handleClear
      }
    }) : _vm._e()])], 2), _c('transition', {
      attrs: {
        "name": "transition-drop"
      }
    }, [_c('DatePickerDropdown', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.opened,
        expression: "opened"
      }, {
        name: "transfer-dom",
        rawName: "v-transfer-dom"
      }],
      ref: "drop",
      class: _vm.transfer ? 'bk-date-picker-transfer' : '',
      attrs: {
        "placement": _vm.placement,
        "ext-popover-cls": _vm.extPopoverCls,
        "data-transfer": _vm.transfer,
        "transfer": _vm.transfer
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.handleTransferClick($event);
        }
      }
    }, [_vm.hasHeader ? [_c('div', {
      staticClass: "bk-date-picker-top-wrapper",
      class: _vm.headerSlotCls
    }, [_vm._t("header")], 2)] : _vm._e(), _c(_vm.panel, _vm._b({
      ref: "pickerPanel",
      tag: "component",
      attrs: {
        "clearable": _vm.clearable,
        "visible": _vm.visible,
        "show-time": _vm.type === 'datetime' || _vm.type === 'datetimerange',
        "confirm": _vm.isConfirm,
        "selection-mode": _vm.selectionMode,
        "steps": _vm.steps,
        "format": _vm.format,
        "value": _vm.internalValue,
        "start-date": _vm.startDate,
        "split-panels": _vm.splitPanels,
        "shortcuts": _vm.shortcuts,
        "picker-type": _vm.type,
        "multiple": _vm.multiple,
        "focused-date": _vm.focusedDate,
        "width": _vm.type === 'time' || _vm.type === 'timerange' ? _vm.width : 261,
        "time-picker-options": _vm.timePickerOptions,
        "shortcut-close": _vm.shortcutClose,
        "up-to-now": _vm.upToNow,
        "allow-cross-day": _vm.allowCrossDayProp
      },
      on: {
        "pick": _vm.onPick,
        "pick-clear": _vm.handleClear,
        "pick-success": _vm.onPickSuccess,
        "pick-click": function pickClick($event) {
          _vm.disableClickOutSide = true;
        },
        "selection-mode-change": _vm.onSelectionModeChange
      }
    }, 'component', _vm.ownPickerProps, false), [_vm.$slots.shortcuts || _vm.$scopedSlots.shortcuts ? _c('div', {
      attrs: {
        "slot": "shortcuts"
      },
      slot: "shortcuts"
    }, [_vm._t("shortcuts")], 2) : _vm._e()]), _vm.hasFooter ? [_c('div', {
      staticClass: "bk-date-picker-footer-wrapper",
      class: _vm.footerSlotCls
    }, [_vm._t("footer")], 2)] : _vm._e()], 2)], 1)], 1);
  };

  var __vue_staticRenderFns__$j = [];
  /* style */

  var __vue_inject_styles__$j = undefined;
  /* scoped */

  var __vue_scope_id__$j = undefined;
  /* module identifier */

  var __vue_module_identifier__$j = undefined;
  /* functional template */

  var __vue_is_functional_template__$j = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$j = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$j,
    staticRenderFns: __vue_staticRenderFns__$j
  }, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

  var oneDay = 1000 * 60 * 60 * 24;
  function daysInMonth(year, month) {
      return new Date(year, month + 1, 0).getDate();
  }
  function getYear(year, month, weekNr){
  	if (month === 0 && weekNr > 50) return year - 1;
  	else if(month === 11 && weekNr < 10) return year + 1;
  	else return year;
  }
  function getDateInfo(y, m, d, iso) {
  	if (m > 11){
  		m = 0;
  		y++;
  	}
      var currentDay = new Date(y, m, d);
      if (iso) currentDay.setDate(currentDay.getDate() + 4 - (currentDay.getDay() || 7));
      var year = iso ? currentDay.getFullYear() : y;
      var firstOfJanuary = new Date(year, 0, 1);
      var numberOfDays = 1 + Math.round((currentDay - firstOfJanuary) / oneDay);
      if (!iso) numberOfDays += firstOfJanuary.getDay();
  	var w = Math.ceil(numberOfDays / 7);
      if (!iso) {
  		var initialDay = new Date(y, m, d);
          var beginOfNextYear = new Date(y + 1, 0, 1);
          var startDayOfNextYear = beginOfNextYear.getDay();
          if (initialDay.getTime() >= beginOfNextYear.getTime() - (oneDay * startDayOfNextYear)) w = 1;
      }
  	return w;
  }
  function getMonthCalender(year, month, iteratorFns){
  	var lang = this.lang || 'en';
  	var onlyDays = this.onlyDays;
  	var weekStart = typeof this.weekStart === 'undefined' ? 1 : this.weekStart;
  	var iso = weekStart === 1;
  	var cells = [];
  	var monthStartDate = new Date(year, month, 1);
  	var dayOfWeek = monthStartDate.getDay() || (iso ? 7 : 0);
  	var currentDay = weekStart - dayOfWeek;
  	var weekNr = getDateInfo(year, month, 1, iso);
  	var maxDays = daysInMonth(year, month);
  	var lastMonthMaxDays = daysInMonth(year, month - 1);
  	var currentMonth, day, dayBefore;
  	var currentYear = getYear(year, month, weekNr);
  	var returnObject = {
  		month: month,
  		year: year,
  		daysInMonth: maxDays
  	};
  	for (var i = 0; i < 7; i++){
  		dayBefore = currentDay;
  		for (var j = 0; j < 8; j++){
  			if (i > 0 && j > 0) currentDay++;
  			if (currentDay > maxDays || currentDay < 1){
  				day = currentDay > maxDays ? currentDay - maxDays : lastMonthMaxDays + currentDay;
  				currentMonth = currentDay > maxDays ? month + 1 : month - 1;
  			} else {
  				day = currentDay;
  				currentMonth = month;
  			}
  			var type = (function(){
  				if (j === 0) return 'weekLabel';
  				else if (i === 0) return 'dayLabel';
  				else if (currentDay < 1) return 'prevMonth';
  				else if (currentDay > maxDays) return 'nextMonth';
  				else return 'monthDay';
  			})();
  			var isDay = dayBefore !== currentDay && i > 0;
  			var dayData = {
  				desc: isDay ? day : weekNr,
  				week: weekNr,
  				type: type,
  				format: iso ? 'ISO 8601' : 'US',
  				date: isDay ? new Date(Date.UTC(year, currentMonth, day)) : false,
  				year: currentYear,
  				index: cells.length
  			};
  			if (iteratorFns){
  				if (typeof iteratorFns === "function") dayData = iteratorFns.call(returnObject, dayData, lang);
  				else iteratorFns.forEach(function(fn){
  					dayData = fn.call(returnObject, dayData, lang);
  				});
  			}
  			if (onlyDays && isDay) cells.push(dayData);
  			else if (!onlyDays) cells.push(dayData);
  		}
  		if (i > 0) weekNr = getDateInfo(year, currentMonth, day + 1, iso);
  		currentYear = getYear(year, month, weekNr);
  	}
  	returnObject.cells = cells;
  	return returnObject;
  }
  var jsCalendar = function (config){
  	return getMonthCalender.bind(config);
  };

  var labels = {
  	weekPlaceholder: '',
  	columnNames: {
  		en: {
  			0: 'w',
  			1: 'monday',
  			2: 'tuesday',
  			3: 'wednesday',
  			4: 'thursday',
  			5: 'friday',
  			6: 'saturday',
  			7: 'sunday'
  		},
  		sv: {
  			0: 'v',
  			1: 'måndag',
  			2: 'tisdag',
  			3: 'onsdag',
  			4: 'torsdag',
  			5: 'fredag',
  			6: 'lördag',
  			7: 'söndag'
  		},
  		pt: {
  			0: 's',
  			1: 'segunda',
  			2: 'terça',
  			3: 'quarta',
  			4: 'quinta',
  			5: 'sexta',
  			6: 'sábado',
  			7: 'domingo'
  		}
  	},
  	monthNames: {
  		en: [
  			"January",
  			"February",
  			"March",
  			"April",
  			"May",
  			"June",
  			"July",
  			"August",
  			"September",
  			"October",
  			"November",
  			"December"
  		],
  		sv: [
  			"januari",
  			"februari",
  			"mars",
  			"april",
  			"maj",
  			"juni",
  			"juli",
  			"augusti",
  			"september",
  			"oktober",
  			"november",
  			"december"
  		],
  		pt: [
  			"Janeiro",
  			"Fevereiro",
  			"Março",
  			"Abril",
  			"Maio",
  			"Junho",
  			"Julho",
  			"Agosto",
  			"Setembro",
  			"Outubro",
  			"Novembro",
  			"Dezembro"
  		]
  	},
  	classes: {
  		dayLabel: 'day-of-week',
  		weekLabel: 'week-number',
  		prevMonth: 'inactive',
  		nextMonth: 'inactive',
  		monthDay: 'day-in-month'
  	}
  };

  function isIterable(variable){
  	if (variable == null) return false;
  	if (variable.constructor === Array) return true;
  	if (variable.constructor === Object) return true;
  	return false;
  }
  function merge(_new, _old){
      for (var prop in _new){
          if (!_old[prop]) _old[prop] = _new[prop];
          else if (isIterable(_new[prop])) merge(_new[prop], _old[prop]);
      }
  }
  function addLabels(dayObject, lang){
  	var cssClass = [labels.classes[dayObject.type]];
  	if (dayObject.class) dayObject.class = (typeof dayObject.class == 'string' ? [dayObject.class] : dayObject.class).concat(cssClass);
  	else dayObject.class = cssClass;
  	if (dayObject.type.indexOf('Label') > 0){
  		if (dayObject.index == 0 && labels.weekPlaceholder) dayObject.desc = labels.weekPlaceholder;
  		else if (dayObject.index < 8) dayObject.desc = labels.columnNames[lang][dayObject.index];
  		else if (dayObject.index % 8 == 0) dayObject.desc = dayObject.week;
  	}
  	if (dayObject.date) dayObject.monthName = labels.monthNames[lang][dayObject.date.getMonth()];
  	if (!this.monthName) this.monthName = labels.monthNames[lang][this.month];
  	if (!this.labels) this.labels = {
  		monthNames: labels.monthNames[lang],
  		columnNames: labels.columnNames[lang],
  		classes: labels.classes
  	};
  	return dayObject;
  }
  addLabels.setLabels = function(newOptions){
  	merge(newOptions, labels);
  };
  var addLabels_1 = addLabels;

  var jsCalendar$1 = {
  	Generator: jsCalendar,
  	addLabels: addLabels_1
  };

  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;
  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$1)) return O[IE_PROTO$1];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  _objectSap('getPrototypeOf', function () {
    return function getPrototypeOf(it) {
      return _objectGpo(_toObject(it));
    };
  });

  var getPrototypeOf = _core.Object.getPrototypeOf;

  var getPrototypeOf$1 = getPrototypeOf;

  var enUS = {
    bk: {
      lang: 'en-US',
      datePicker: {
        selectDate: 'Select Date',
        selectTime: 'Select Time',
        clear: 'Clear',
        ok: 'OK',
        weekdays: {
          sun: 'Sun',
          mon: 'Mon',
          tue: 'Tue',
          wed: 'Wed',
          thu: 'Thu',
          fri: 'Fri',
          sat: 'Sat'
        },
        hour: 'Hour',
        min: 'Minute',
        sec: 'Second',
        toNow: 'Now'
      },
      dialog: {
        ok: 'OK',
        cancel: 'CANCEL'
      },
      exception: {
        403: 'Forbidden',
        404: 'Not Found',
        500: 'Internal Server Error',
        building: 'Building',
        empty: 'No Data',
        searchEmpty: 'Search Is Empty',
        login: 'Please log in to Blueking'
      },
      form: {
        validPath: 'Please configure a valid path'
      },
      input: {
        input: 'Please input'
      },
      imageViewer: {
        loadFailed: 'Picture failed to load.',
        quitTips: 'ESC Can Exit fullscreen'
      },
      notify: {
        showMore: 'Show more'
      },
      select: {
        selectAll: 'Select All',
        pleaseselect: 'Please select',
        searchPlaceholder: 'Input keyword to search',
        dataEmpty: 'No options',
        searchEmpty: 'No matched data'
      },
      sideslider: {
        title: 'Title'
      },
      tagInput: {
        placeholder: 'Please input and press ENTER to finish'
      },
      transfer: {
        left: 'Left',
        total: ' (Total {total})',
        addAll: 'Add All',
        emptyContent: 'No Data',
        right: 'Right',
        removeAll: 'Remove All',
        emptySelected: 'No Selected',
        searchPlaceholder: 'Input keyword to search'
      },
      tree: {
        emptyText: 'No Data'
      },
      steps: {
        step1: 'Step1',
        step2: 'Step2',
        step3: 'Step3'
      },
      uploadFile: {
        drag: 'Try dragging an file here or',
        click: 'click to upload',
        uploadDone: 'Upload finished',
        uploading: 'uploading',
        reupload: 'reupload',
        replace: 'replace',
        uploadFailed: 'upload failed',
        fileExceedMsg: '{fileName} cannot exceed {size} MB',
        invalidFileName: 'FileName is not valid',
        invalidImageFormat: 'Only upload JPG | PNG | JPEG',
        imageExceedMsg: 'Image Size cannot exceed {imgSize} MB',
        uploadLabel: 'Upload Files'
      },
      navigation: {
        headerTitle: 'Program name'
      },
      searchSelect: {
        placeholder: 'Please enter',
        emptyText: 'Included key worth filtering query must have a value',
        condition: 'Or',
        remoteEmptyText: 'Query no data',
        remoteLoadingText: 'Loading...',
        tips: 'multiple keywords separate by |',
        ok: 'OK',
        cancel: 'Cancel'
      },
      table: {
        emptyText: 'No Data',
        sumText: 'Summary',
        setting: {
          title: 'Table Settings',
          fields: {
            title: 'Displaying Fields Setting',
            subtitle: '（{max} fiels most）',
            selectAll: 'All'
          },
          lineHeight: {
            title: 'Table Line Height',
            small: 'small',
            medium: 'medium',
            large: 'large'
          },
          options: {
            ok: 'OK',
            cancel: 'Cancel'
          }
        },
        confirm: 'Confirm',
        reset: 'Reset',
        all: 'All',
        filter: {
          placeholder: 'Please input keyword',
          empty: 'No matched data'
        }
      },
      bigTree: {
        emptyText: 'No Data'
      },
      message: {
        copy: 'copy',
        copied: 'copied'
      }
    }
  };

  var zhCN = {
    bk: {
      lang: 'zh-CN',
      datePicker: {
        selectDate: '选择日期',
        selectTime: '选择时间',
        clear: '清除',
        ok: '确定',
        weekdays: {
          sun: '日',
          mon: '一',
          tue: '二',
          wed: '三',
          thu: '四',
          fri: '五',
          sat: '六'
        },
        hour: '时',
        min: '分',
        sec: '秒',
        toNow: '至今'
      },
      dialog: {
        ok: '确定',
        cancel: '取消'
      },
      exception: {
        403: '无业务权限',
        404: '页面不存在',
        500: '服务维护中',
        building: '功能建设中',
        empty: '没有数据',
        searchEmpty: '搜索为空',
        login: '请登入蓝鲸'
      },
      form: {
        validPath: '请配置合法的路径'
      },
      input: {
        input: '请输入'
      },
      imageViewer: {
        loadFailed: '抱歉，图片加载失败',
        quitTips: 'ESC 可以退出全屏'
      },
      notify: {
        showMore: '查看更多'
      },
      select: {
        selectAll: '全选',
        pleaseselect: '请选择',
        searchPlaceholder: '输入关键字搜索',
        dataEmpty: '暂无选项',
        searchEmpty: '无匹配数据'
      },
      sideslider: {
        title: '标题'
      },
      tagInput: {
        placeholder: '请输入并按Enter结束'
      },
      transfer: {
        left: '左侧列表',
        total: '（共{total}条）',
        addAll: '全部添加',
        emptyContent: '无数据',
        right: '右侧列表',
        removeAll: '清空',
        emptySelected: '未选择任何项',
        searchPlaceholder: '请输入搜索关键字'
      },
      tree: {
        emptyText: '暂无数据'
      },
      steps: {
        step1: '步骤1',
        step2: '步骤2',
        step3: '步骤3'
      },
      uploadFile: {
        drag: '将文件拖到此处或',
        click: '点击上传',
        uploadDone: '上传完毕',
        uploading: '正在上传',
        reupload: '重新上传',
        replace: '点击替换',
        uploadFailed: '上传失败',
        fileExceedMsg: '{fileName} 文件不能超过 {size} MB',
        invalidFileName: '文件名不合法',
        invalidImageFormat: '只允许上传JPG|PNG|JPEG格式的图片',
        imageExceedMsg: '图片大小不能超过 {imgSize} MB',
        uploadLabel: '上传文件'
      },
      navigation: {
        headerTitle: '栏目名称'
      },
      searchSelect: {
        placeholder: '请输入',
        emptyText: '包含键值得过滤查询必须有一个值',
        condition: '或',
        remoteEmptyText: '查询无数据',
        remoteLoadingText: '正在加载中...',
        tips: '多个关键字用竖线 “|” 分隔',
        ok: '确认',
        cancel: '取消'
      },
      table: {
        emptyText: '暂无数据',
        sumText: '总计',
        setting: {
          title: '表格设置',
          fields: {
            title: '字段显示设置',
            subtitle: '（最多{max}项）',
            selectAll: '全选'
          },
          lineHeight: {
            title: '表格行高',
            small: '小',
            medium: '中',
            large: '大'
          },
          options: {
            ok: '确认',
            cancel: '取消'
          }
        },
        confirm: '确定',
        reset: '重置',
        all: '全部',
        filter: {
          placeholder: '请输入关键字',
          empty: '无匹配项'
        }
      },
      bigTree: {
        emptyText: '暂无搜索结果'
      },
      message: {
        copy: '复制',
        copied: '已复制'
      }
    }
  };

  var lang = {
    enUS: enUS,
    zhCN: zhCN
  };

  var _redefine = _hide;

  var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');
  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id,
      w: {}
    } });
  };
  var fastKey = function (it, create) {
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      if (!isExtensible(it)) return 'F';
      if (!create) return 'E';
      setMeta(it);
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!_has(it, META)) {
      if (!isExtensible(it)) return true;
      if (!create) return false;
      setMeta(it);
    } return it[META].w;
  };
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  });
  var _meta_1 = _meta.KEY;
  var _meta_2 = _meta.NEED;
  var _meta_3 = _meta.fastKey;
  var _meta_4 = _meta.getWeak;
  var _meta_5 = _meta.onFreeze;

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');
  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';
  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };
  $exports.store = store;
  });

  var def = _objectDp.f;
  var TAG = _wks('toStringTag');
  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var f$2 = _wks;
  var _wksExt = {
  	f: f$2
  };

  var defineProperty$3 = _objectDp.f;
  var _wksDefine = function (name) {
    var $Symbol = _core.Symbol || (_core.Symbol =  {} );
    if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$3($Symbol, name, { value: _wksExt.f(name) });
  };

  var f$3 = Object.getOwnPropertySymbols;
  var _objectGops = {
  	f: f$3
  };

  var _enumKeys = function (it) {
    var result = _objectKeys(it);
    var getSymbols = _objectGops.f;
    if (getSymbols) {
      var symbols = getSymbols(it);
      var isEnum = _objectPie.f;
      var i = 0;
      var key;
      while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
    } return result;
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var Empty = function () {  };
  var PROTOTYPE$1 = 'prototype';
  var createDict = function () {
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };
  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      result[IE_PROTO$2] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var hiddenKeys = _enumBugKeys.concat('length', 'prototype');
  var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return _objectKeysInternal(O, hiddenKeys);
  };
  var _objectGopn = {
  	f: f$4
  };

  var gOPN = _objectGopn.f;
  var toString$2 = {}.toString;
  var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
    ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function (it) {
    try {
      return gOPN(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  var f$5 = function getOwnPropertyNames(it) {
    return windowNames && toString$2.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
  };
  var _objectGopnExt = {
  	f: f$5
  };

  var gOPD = Object.getOwnPropertyDescriptor;
  var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
    O = _toIobject(O);
    P = _toPrimitive(P, true);
    if (_ie8DomDefine) try {
      return gOPD(O, P);
    } catch (e) {  }
    if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
  };
  var _objectGopd = {
  	f: f$6
  };

  var META = _meta.KEY;
  var gOPD$1 = _objectGopd.f;
  var dP$1 = _objectDp.f;
  var gOPN$1 = _objectGopnExt.f;
  var $Symbol = _global.Symbol;
  var $JSON$1 = _global.JSON;
  var _stringify = $JSON$1 && $JSON$1.stringify;
  var PROTOTYPE$2 = 'prototype';
  var HIDDEN = _wks('_hidden');
  var TO_PRIMITIVE = _wks('toPrimitive');
  var isEnum$1 = {}.propertyIsEnumerable;
  var SymbolRegistry = _shared('symbol-registry');
  var AllSymbols = _shared('symbols');
  var OPSymbols = _shared('op-symbols');
  var ObjectProto$1 = Object[PROTOTYPE$2];
  var USE_NATIVE = typeof $Symbol == 'function' && !!_objectGops.f;
  var QObject = _global.QObject;
  var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;
  var setSymbolDesc = _descriptors && _fails(function () {
    return _objectCreate(dP$1({}, 'a', {
      get: function () { return dP$1(this, 'a', { value: 7 }).a; }
    })).a != 7;
  }) ? function (it, key, D) {
    var protoDesc = gOPD$1(ObjectProto$1, key);
    if (protoDesc) delete ObjectProto$1[key];
    dP$1(it, key, D);
    if (protoDesc && it !== ObjectProto$1) dP$1(ObjectProto$1, key, protoDesc);
  } : dP$1;
  var wrap = function (tag) {
    var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
    sym._k = tag;
    return sym;
  };
  var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
    return typeof it == 'symbol';
  } : function (it) {
    return it instanceof $Symbol;
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);
    _anObject(it);
    key = _toPrimitive(key, true);
    _anObject(D);
    if (_has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
        D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
      } return setSymbolDesc(it, key, D);
    } return dP$1(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    _anObject(it);
    var keys = _enumKeys(P = _toIobject(P));
    var i = 0;
    var l = keys.length;
    var key;
    while (l > i) $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum$1.call(this, key = _toPrimitive(key, true));
    if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
    return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    it = _toIobject(it);
    key = _toPrimitive(key, true);
    if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
    var D = gOPD$1(it, key);
    if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = gOPN$1(_toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
    } return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var IS_OP = it === ObjectProto$1;
    var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
    var result = [];
    var i = 0;
    var key;
    while (names.length > i) {
      if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);
    } return result;
  };
  if (!USE_NATIVE) {
    $Symbol = function Symbol() {
      if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
      var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
      var $set = function (value) {
        if (this === ObjectProto$1) $set.call(OPSymbols, value);
        if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, _propertyDesc(1, value));
      };
      if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });
      return wrap(tag);
    };
    _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
      return this._k;
    });
    _objectGopd.f = $getOwnPropertyDescriptor;
    _objectDp.f = $defineProperty;
    _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
    _objectPie.f = $propertyIsEnumerable;
    _objectGops.f = $getOwnPropertySymbols;
    if (_descriptors && !_library) {
      _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
    _wksExt.f = function (name) {
      return wrap(_wks(name));
    };
  }
  _export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });
  for (var es6Symbols = (
    'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
  ).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);
  for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);
  _export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
    'for': function (key) {
      return _has(SymbolRegistry, key += '')
        ? SymbolRegistry[key]
        : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(sym) {
      if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
      for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
    },
    useSetter: function () { setter = true; },
    useSimple: function () { setter = false; }
  });
  _export(_export.S + _export.F * !USE_NATIVE, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  var FAILS_ON_PRIMITIVES = _fails(function () { _objectGops.f(1); });
  _export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
      return _objectGops.f(_toObject(it));
    }
  });
  $JSON$1 && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
  })), 'JSON', {
    stringify: function stringify(it) {
      var args = [it];
      var i = 1;
      var replacer, $replacer;
      while (arguments.length > i) args.push(arguments[i++]);
      $replacer = replacer = args[1];
      if (!_isObject(replacer) && it === undefined || isSymbol(it)) return;
      if (!_isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return _stringify.apply($JSON$1, args);
    }
  });
  $Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
  _setToStringTag($Symbol, 'Symbol');
  _setToStringTag(Math, 'Math', true);
  _setToStringTag(_global.JSON, 'JSON', true);

  var getOwnPropertySymbols = _core.Object.getOwnPropertySymbols;

  var getOwnPropertySymbols$1 = getOwnPropertySymbols;

  var _for = _core.Symbol['for'];

  var _for$1 = _for;

  _wksDefine('asyncIterator');

  _wksDefine('observable');

  var symbol = _core.Symbol;

  var symbol$1 = symbol;

  var canUseSymbol = typeof symbol$1 === 'function' && _for$1;
  var REACT_ELEMENT_TYPE = canUseSymbol ? _for$1('react.element') : 0xeac7;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function isNonNullObject(value) {
    return !!value && _typeof(value) === 'object';
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
  }
  function defaultIsMergeableObject (value) {
    return isNonNullObject(value) && !isSpecial(value);
  }

  function emptyTarget(val) {
    return isArray$1(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return !!options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function (element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return getOwnPropertySymbols$1 ? getOwnPropertySymbols$1(target).filter(function (symbol) {
      return target.propertyIsEnumerable(symbol);
    }) : [];
  }
  function getKeys(target) {
    return keys$1(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key)
    && !(Object.hasOwnProperty.call(target, key)
    && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function (key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function (key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = isArray$1(source);
    var targetIsArray = isArray$1(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!isArray$1(array)) {
      throw new Error('first argument should be an array');
    }
    return array.reduce(function (prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };

  var curLang = lang.zhCN;
  var merged = false;
  var i18nHandler = function i18nHandler() {
    var i18n = getPrototypeOf$1(this || Vue).$t;
    if (typeof i18n === 'function' && !!Vue.locale) {
      if (!merged) {
        merged = true;
        Vue.locale(Vue.config.lang, deepmerge(curLang, Vue.locale(Vue.config.lang) || {}, {
          clone: true
        }));
      }
      return i18n.apply(this, arguments);
    }
  };
  var escape = function escape(str) {
    return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  };
  var _t = function t(path, data) {
    var value = i18nHandler.apply(this, arguments);
    if (value !== null && typeof value !== 'undefined') {
      return value;
    }
    var arr = path.split('.');
    var current = curLang;
    var len = arr.length;
    for (var i = 0; i < len; i++) {
      value = current[arr[i]];
      if (i === len - 1) {
        if (data && typeof value === 'string') {
          return value.replace(/\{(?=\w+)/g, '').replace(/(\w+)\}/g, '$1').replace(new RegExp(keys$1(data).map(escape).join('|'), 'g'), function ($0) {
            return data[$0];
          });
        }
        return value;
      }
      if (!value) {
        return '';
      }
      current = value;
    }
    return '';
  };
  var use = function use(l) {
    if (l) {
      curLang = deepmerge(curLang, l);
    }
  };
  var i18n = function i18n(fn) {
    i18nHandler = fn || i18nHandler;
  };
  var getCurLang = function getCurLang() {
    return curLang;
  };
  var mixin = {
    methods: {
      t: function t() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _t.apply(this, args);
      }
    }
  };
  Vue.prototype.bkLocale = {
    use: use,
    t: _t,
    i18n: i18n,
    getCurLang: getCurLang,
    lang: lang,
    mixin: mixin
  };
  var locale = {
    use: use,
    t: _t,
    i18n: i18n,
    getCurLang: getCurLang,
    lang: lang,
    mixin: mixin
  };

  var mixin$1 = {
    name: 'PanelTable',
    props: {
      tableDate: {
        type: Date,
        required: true
      },
      disabledDate: {
        type: Function
      },
      selectionMode: {
        type: String,
        required: true
      },
      value: {
        type: Array,
        required: true
      },
      rangeState: {
        type: Object,
        default: function _default() {
          return {
            from: null,
            to: null,
            selecting: false
          };
        }
      },
      focusedDate: {
        type: Date,
        required: true
      }
    },
    computed: {
      dates: function dates() {
        var selectionMode = this.selectionMode,
            value = this.value,
            rangeState = this.rangeState;
        var rangeSelecting = selectionMode === 'range' && rangeState.selecting;
        return rangeSelecting ? [rangeState.from] : value;
      }
    },
    methods: {
      handleClick: function handleClick(cell) {
        if (cell.disabled || cell.type === 'weekLabel') {
          return;
        }
        var newDate = new Date(clearHours(cell.date));
        this.$emit('pick', newDate);
        this.$emit('pick-click');
      },
      handleMouseMove: function handleMouseMove(cell) {
        if (!this.rangeState.selecting) {
          return;
        }
        if (cell.disabled) {
          return;
        }
        var newDate = cell.date;
        this.$emit('change-range', newDate);
      }
    }
  };

  var script$k = {
    mixins: [mixin$1, locale.mixin],
    data: function data() {
      return {};
    },
    computed: {
      calendar: function calendar() {
        return new jsCalendar$1.Generator({
          onlyDays: true,
          weekStart: 0
        });
      },
      headerDays: function headerDays() {
        var translatedDays = [this.t('bk.datePicker.weekdays.sun'), this.t('bk.datePicker.weekdays.mon'), this.t('bk.datePicker.weekdays.tue'), this.t('bk.datePicker.weekdays.wed'), this.t('bk.datePicker.weekdays.thu'), this.t('bk.datePicker.weekdays.fri'), this.t('bk.datePicker.weekdays.sat')];
        return translatedDays.splice(0, 7 - 0).concat(translatedDays.splice(0, 0));
      },
      cells: function cells() {
        var tableYear = this.tableDate.getFullYear();
        var tableMonth = this.tableDate.getMonth();
        var today = clearHours(new Date());
        var selectedDays = this.dates.filter(Boolean).map(clearHours);
        var _this$dates$map = this.dates.map(clearHours),
            _this$dates$map2 = _slicedToArray(_this$dates$map, 2),
            minDay = _this$dates$map2[0],
            maxDay = _this$dates$map2[1];
        var rangeStart = this.rangeState.from && clearHours(this.rangeState.from);
        var rangeEnd = this.rangeState.to && clearHours(this.rangeState.to);
        var isRange = this.selectionMode === 'range';
        var disabledTestFn = typeof this.disabledDate === 'function' && this.disabledDate;
        return this.calendar(tableYear, tableMonth, function (cell) {
          if (cell.date instanceof Date) {
            cell.date.setTime(cell.date.getTime() + cell.date.getTimezoneOffset() * 60000);
          }
          var time = cell.date && clearHours(cell.date);
          var dateIsInCurrentMonth = cell.date && tableMonth === cell.date.getMonth();
          return _objectSpread({}, cell, {
            type: time === today ? 'today' : cell.type,
            selected: dateIsInCurrentMonth && selectedDays.includes(time),
            disabled: cell.date && disabledTestFn && disabledTestFn(new Date(time)),
            range: dateIsInCurrentMonth && isRange && isInRange(time, rangeStart, rangeEnd),
            start: dateIsInCurrentMonth && isRange && time === minDay,
            end: dateIsInCurrentMonth && isRange && time === maxDay
          });
        }).cells.slice(0);
      }
    },
    methods: {
      getCellCls: function getCellCls(cell) {
        var _ref;
        return ['bk-date-picker-cells-cell', (_ref = {}, _defineProperty(_ref, "bk-date-picker-cells-cell-selected", cell.selected || cell.start || cell.end), _defineProperty(_ref, "bk-date-picker-cells-cell-disabled", cell.disabled), _defineProperty(_ref, "bk-date-picker-cells-cell-today", cell.type === 'today'), _defineProperty(_ref, "bk-date-picker-cells-cell-prev-month", cell.type === 'prevMonth'), _defineProperty(_ref, "bk-date-picker-cells-cell-next-month", cell.type === 'nextMonth'), _defineProperty(_ref, "bk-date-picker-cells-cell-week-label", cell.type === 'weekLabel'), _defineProperty(_ref, "bk-date-picker-cells-cell-range", cell.range && !cell.start && !cell.end), _ref)];
      }
    }
  };

  /* script */
  var __vue_script__$k = script$k;
  /* template */

  var __vue_render__$k = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-date-picker-cells"
    }, [_c('div', {
      staticClass: "bk-date-picker-cells-header"
    }, _vm._l(_vm.headerDays, function (day) {
      return _c('span', {
        key: day
      }, [_vm._v(_vm._s(day))]);
    }), 0), _vm._l(_vm.cells, function (cell, i) {
      return _c('span', {
        key: String(cell.date) + i,
        class: _vm.getCellCls(cell),
        on: {
          "click": function click($event) {
            _vm.handleClick(cell, $event);
          },
          "mouseenter": function mouseenter($event) {
            _vm.handleMouseMove(cell);
          }
        }
      }, [_c('em', [_vm._v(_vm._s(cell.desc))])]);
    })], 2);
  };

  var __vue_staticRenderFns__$k = [];
  /* style */

  var __vue_inject_styles__$k = undefined;
  /* scoped */

  var __vue_scope_id__$k = undefined;
  /* module identifier */

  var __vue_module_identifier__$k = undefined;
  /* functional template */

  var __vue_is_functional_template__$k = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$k = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$k,
    staticRenderFns: __vue_staticRenderFns__$k
  }, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

  var script$l = {
    mixins: [mixin$1],
    computed: {
      startYear: function startYear() {
        return Math.floor(this.tableDate.getFullYear() / 10) * 10;
      },
      cells: function cells() {
        var cells = [];
        var cellTmpl = {
          text: '',
          selected: false,
          disabled: false
        };
        var selectedDays = this.dates.filter(Boolean).map(function (date) {
          return clearHours(new Date(date.getFullYear(), 0, 1));
        });
        var focusedDate = clearHours(new Date(this.focusedDate.getFullYear(), 0, 1));
        for (var i = 0; i < 10; i++) {
          var cell = JSON.parse(stringify$1(cellTmpl));
          cell.date = new Date(this.startYear + i, 0, 1);
          cell.disabled = typeof this.disabledDate === 'function' && this.disabledDate(cell.date) && this.selectionMode === 'year';
          var day = clearHours(cell.date);
          cell.selected = selectedDays.includes(day);
          cell.focused = day === focusedDate;
          cells.push(cell);
        }
        return cells;
      }
    },
    methods: {
      getCellCls: function getCellCls(cell) {
        return ['bk-date-picker-cells-cell', {
          'bk-date-picker-cells-cell-selected': cell.selected,
          'bk-date-picker-cells-cell-disabled': cell.disabled,
          'bk-date-picker-cells-cell-range': cell.range && !cell.start && !cell.end
        }];
      }
    }
  };

  /* script */
  var __vue_script__$l = script$l;
  /* template */

  var __vue_render__$l = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-date-picker-cells bk-date-picker-cells-year"
    }, _vm._l(_vm.cells, function (cell, index) {
      return _c('span', {
        key: index,
        class: _vm.getCellCls(cell),
        on: {
          "click": function click($event) {
            _vm.handleClick(cell);
          },
          "mouseenter": function mouseenter($event) {
            _vm.handleMouseMove(cell);
          }
        }
      }, [_c('em', [_vm._v(_vm._s(cell.date.getFullYear()))])]);
    }), 0);
  };

  var __vue_staticRenderFns__$l = [];
  /* style */

  var __vue_inject_styles__$l = undefined;
  /* scoped */

  var __vue_scope_id__$l = undefined;
  /* module identifier */

  var __vue_module_identifier__$l = undefined;
  /* functional template */

  var __vue_is_functional_template__$l = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$l = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$l,
    staticRenderFns: __vue_staticRenderFns__$l
  }, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

  var script$m = {
    mixins: [mixin$1],
    computed: {
      cells: function cells() {
        var cells = [];
        var cellTmpl = {
          text: '',
          selected: false,
          disabled: false
        };
        var tableYear = this.tableDate.getFullYear();
        var selectedDays = this.dates.filter(Boolean).map(function (date) {
          return clearHours(new Date(date.getFullYear(), date.getMonth(), 1));
        });
        var focusedDate = clearHours(new Date(this.focusedDate.getFullYear(), this.focusedDate.getMonth(), 1));
        for (var i = 0; i < 12; i++) {
          var cell = JSON.parse(stringify$1(cellTmpl));
          cell.date = new Date(tableYear, i, 1);
          cell.text = this.tCell(i + 1);
          var day = clearHours(cell.date);
          cell.disabled = typeof this.disabledDate === 'function' && this.disabledDate(cell.date) && this.selectionMode === 'month';
          cell.selected = selectedDays.includes(day);
          cell.focused = day === focusedDate;
          cells.push(cell);
        }
        return cells;
      }
    },
    methods: {
      getCellCls: function getCellCls(cell) {
        var _ref;
        return ["bk-date-picker-cells-cell", (_ref = {}, _defineProperty(_ref, "bk-date-picker-cells-cell-selected", cell.selected), _defineProperty(_ref, "bk-date-picker-cells-cell-disabled", cell.disabled), _defineProperty(_ref, "bk-date-picker-cells-cell-range", cell.range && !cell.start && !cell.end), _ref)];
      },
      tCell: function tCell(nr) {
        return String(nr).length > 1 ? nr : "0".concat(nr);
      }
    }
  };

  /* script */
  var __vue_script__$m = script$m;
  /* template */

  var __vue_render__$m = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-date-picker-cells bk-date-picker-cells-month"
    }, _vm._l(_vm.cells, function (cell, index) {
      return _c('span', {
        key: index,
        class: _vm.getCellCls(cell),
        on: {
          "click": function click($event) {
            _vm.handleClick(cell);
          },
          "mouseenter": function mouseenter($event) {
            _vm.handleMouseMove(cell);
          }
        }
      }, [_c('em', [_vm._v(_vm._s(cell.text))])]);
    }), 0);
  };

  var __vue_staticRenderFns__$m = [];
  /* style */

  var __vue_inject_styles__$m = undefined;
  /* scoped */

  var __vue_scope_id__$m = undefined;
  /* module identifier */

  var __vue_module_identifier__$m = undefined;
  /* functional template */

  var __vue_is_functional_template__$m = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$m = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$m,
    staticRenderFns: __vue_staticRenderFns__$m
  }, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

  var script$n = {
    mixins: [emitter, locale.mixin],
    props: {
      showTime: {
        type: Boolean,
        default: false
      },
      isTime: {
        type: Boolean,
        default: false
      },
      timeDisabled: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      labels: function labels() {
        return {
          time: this.isTime ? this.t('bk.datePicker.selectDate') : this.t('bk.datePicker.selectTime'),
          clear: this.t('bk.datePicker.clear'),
          ok: this.t('bk.datePicker.ok')
        };
      }
    },
    methods: {
      handleClear: function handleClear() {
        this.$emit('pick-clear');
      },
      handleSuccess: function handleSuccess() {
        this.$emit('pick-success');
      },
      handleToggleTime: function handleToggleTime() {
        if (this.timeDisabled) {
          return;
        }
        this.$emit('pick-toggle-time');
        this.dispatch('bk-date-picker', 'focus-input');
      },
      handleTab: function handleTab(e) {
        var tabbables = _toConsumableArray(this.$el.children);
        var expectedFocus = tabbables[e.shiftKey ? 'shift' : 'pop']();
        if (document.activeElement === expectedFocus) {
          e.preventDefault();
          e.stopPropagation();
          this.dispatch('bk-date-picker', 'focus-input');
        }
      }
    }
  };

  /* script */
  var __vue_script__$n = script$n;
  /* template */

  var __vue_render__$n = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-confirm",
      on: {
        "!keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
            return null;
          }

          return _vm.handleTab($event);
        }
      }
    }, [_vm.showTime ? _c('a', {
      staticClass: "bk-picker-confirm-time",
      attrs: {
        "href": "javascript: void(0);",
        "disabled": _vm.timeDisabled
      },
      on: {
        "click": _vm.handleToggleTime
      }
    }, [_vm._v(_vm._s(_vm.labels.time))]) : _vm._e(), _vm.clearable ? _c('a', {
      attrs: {
        "href": "javascript: void(0);"
      },
      on: {
        "click": _vm.handleClear,
        "keydown": _vm.handleClear
      }
    }, [_vm._v(_vm._s(_vm.labels.clear))]) : _vm._e(), _c('a', {
      staticClass: "confirm",
      attrs: {
        "href": "javascript: void(0);"
      },
      on: {
        "click": _vm.handleSuccess,
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          return _vm.handleSuccess($event);
        }
      }
    }, [_vm._v(_vm._s(_vm.labels.ok))])]);
  };

  var __vue_staticRenderFns__$n = [];
  /* style */

  var __vue_inject_styles__$n = undefined;
  /* scoped */

  var __vue_scope_id__$n = undefined;
  /* module identifier */

  var __vue_module_identifier__$n = undefined;
  /* functional template */

  var __vue_is_functional_template__$n = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$n = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$n,
    staticRenderFns: __vue_staticRenderFns__$n
  }, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

  var $parseFloat = _global.parseFloat;
  var $trim$1 = _stringTrim.trim;
  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim$1(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  _export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

  var _parseFloat$1 = _core.parseFloat;

  var _parseFloat$2 = _parseFloat$1;

  function addClass$1(node, className) {
    var classNames = className.split(' ');
    if (node.nodeType === 1) {
      if (!node.className && classNames.length === 1) {
        node.className = className;
      } else {
        var setClass = ' ' + node.className + ' ';
        classNames.forEach(function (cl) {
          if (setClass.indexOf(' ' + cl + ' ') < 0) {
            setClass += cl + ' ';
          }
        });
        var rtrim = /^\s+|\s+$/;
        node.className = setClass.replace(rtrim, '');
      }
    }
  }
  function removeClass$1(node, className) {
    var classNames = className.split(' ');
    if (node.nodeType === 1) {
      var setClass = ' ' + node.className + ' ';
      classNames.forEach(function (cl) {
        setClass = setClass.replace(' ' + cl + ' ', ' ');
      });
      var rtrim = /^\s+|\s+$/;
      node.className = setClass.replace(rtrim, '');
    }
  }
  var requestAnimationFrame$2 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$2 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function uuid() {
    var id = '';
    var randomNum = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    for (var i = 0; i < 7; i++) {
      id += randomNum;
    }
    return id;
  }
  function formatPercentage(val) {
    return "".concat(Number((val * 100).toFixed(3)), "%");
  }
  function getTag(value) {
    if (value === null) {
      return '[object Null]';
    }
    return toString.call(value);
  }
  function isNumber(value) {
    return typeof value === 'number' || getTag(value) === '[object Number]';
  }
  function isString(value) {
    var type = _typeof(value);
    return type === 'string' || type === 'object' && value !== null && getTag(value) === '[object String]';
  }
  function isArray$2(value) {
    return isArray$1(value);
  }
  function isEmpty(value) {
    return value === undefined || value === null || isString(value) && value === '' || isArray$2(value) && value.length === 0;
  }
  function isHtmlElement(node) {
    return node && node.nodeType === Node.ELEMENT_NODE;
  }
  function debounce$2(cb) {
    var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
    for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      params[_key2 - 2] = arguments[_key2];
    }
    var timer = null;
    return function (e) {
      clearTimeout(timer);
      timer = setTimeout(function () {
        cb.apply(void 0, [e].concat(params));
      }, interval);
    };
  }
  var copyText = function copyText(text) {
    var textarea = document.createElement('textarea');
    document.body.appendChild(textarea);
    textarea.value = text;
    textarea.select();
    if (document.execCommand('copy')) {
      document.execCommand('copy');
    } else {
      console.warn('unsupported this function, please use Google Chrome.');
    }
    document.body.removeChild(textarea);
  };
  function checkOverflow(el) {
    if (!el) return false;
    var createDom = function createDom(el, css) {
      var dom = document.createElement('div');
      var width = _parseFloat$2(css['width']) ? Math.ceil(_parseFloat$2(css['width'])) + 'px' : css['width'];
      dom.style.cssText = "\n        width: ".concat(width, ";\n        line-height: ").concat(css['line-height'], ";\n        font-size: ").concat(css['font-size'], ";\n        word-break: ").concat(css['word-break'], ";\n        padding: ").concat(css['padding'], ";\n    ");
      dom.textContent = el.textContent;
      return dom;
    };
    var isOverflow = false;
    try {
      var css = window.getComputedStyle(el, null);
      var lineClamp = css.webkitLineClamp;
      if (lineClamp !== 'none') {
        var targetHeight = _parseFloat$2(css.height);
        var dom = createDom(el, css);
        document.body.appendChild(dom);
        var domHeight = window.getComputedStyle(dom, null)['height'];
        document.body.removeChild(dom);
        isOverflow = targetHeight < _parseFloat$2(domHeight);
      } else {
        isOverflow = el.clientWidth < el.scrollWidth || el.clientHeight < el.scrollHeight;
      }
    } catch (e) {
      console.warn('There is an error when check element overflow state: ', e);
    }
    return isOverflow;
  }

  var timeMixins = {
    props: {
      disabledHours: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      disabledMinutes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      disabledSeconds: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      hideDisabledOptions: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 261
      },
      enterMode: {
        type: Boolean,
        default: true
      }
    },
    methods: {
      firstUpperCase: function firstUpperCase(str) {
        return str.toString()[0].toUpperCase() + str.toString().slice(1);
      }
    }
  };

  var timeParts = ['hours', 'minutes', 'seconds'];
  var script$o = {
    name: 'TimeSpinner',
    mixins: [timeMixins, locale.mixin],
    props: {
      hours: {
        type: [Number, String],
        default: NaN
      },
      minutes: {
        type: [Number, String],
        default: NaN
      },
      seconds: {
        type: [Number, String],
        default: NaN
      },
      showSeconds: {
        type: Boolean,
        default: true
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      var _this = this;
      return {
        spinerSteps: [1, 1, 1].map(function (one, i) {
          return Math.abs(_this.steps[i]) || one;
        }),
        compiled: false,
        focusedColumn: -1,
        focusedTime: [0, 0, 0]
      };
    },
    computed: {
      hoursList: function hoursList() {
        var hours = [];
        var step = this.spinerSteps[0];
        var focusedHour = this.focusedColumn === 0 && this.focusedTime[0];
        var hourTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 24; i += step) {
          var hour = JSON.parse(stringify$1(hourTmpl));
          hour.text = i;
          hour.focused = i === focusedHour;
          if (this.disabledHours.length && this.disabledHours.indexOf(i) > -1) {
            hour.disabled = true;
            if (this.hideDisabledOptions) {
              hour.hide = true;
            }
          }
          if (this.hours === i) {
            hour.selected = true;
          }
          hours.push(hour);
        }
        return hours;
      },
      minutesList: function minutesList() {
        var minutes = [];
        var step = this.spinerSteps[1];
        var focusedMinute = this.focusedColumn === 1 && this.focusedTime[1];
        var minuteTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 60; i += step) {
          var minute = JSON.parse(stringify$1(minuteTmpl));
          minute.text = i;
          minute.focused = i === focusedMinute;
          if (this.disabledMinutes.length && this.disabledMinutes.indexOf(i) > -1) {
            minute.disabled = true;
            if (this.hideDisabledOptions) {
              minute.hide = true;
            }
          }
          if (this.minutes === i) {
            minute.selected = true;
          }
          minutes.push(minute);
        }
        return minutes;
      },
      secondsList: function secondsList() {
        var seconds = [];
        var step = this.spinerSteps[2];
        var focusedMinute = this.focusedColumn === 2 && this.focusedTime[2];
        var secondTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 60; i += step) {
          var second = JSON.parse(stringify$1(secondTmpl));
          second.text = i;
          second.focused = i === focusedMinute;
          if (this.disabledSeconds.length && this.disabledSeconds.indexOf(i) > -1) {
            second.disabled = true;
            if (this.hideDisabledOptions) {
              second.hide = true;
            }
          }
          if (this.seconds === i) {
            second.selected = true;
          }
          seconds.push(second);
        }
        return seconds;
      },
      styles: function styles() {
        return {
          width: this.showSeconds ? '33.33%' : '50%'
        };
      }
    },
    watch: {
      hours: function hours(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('hours', this.hoursList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      minutes: function minutes(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('minutes', this.minutesList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      seconds: function seconds(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('seconds', this.secondsList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      focusedTime: function focusedTime(updated, old) {
        var _this2 = this;
        timeParts.forEach(function (part, i) {
          if (updated[i] === old[i] || typeof updated[i] === 'undefined') {
            return;
          }
          var valueIndex = _this2["".concat(part, "List")].findIndex(function (obj) {
            return obj.text === updated[i];
          });
          _this2.scroll(part, valueIndex);
        });
      }
    },
    mounted: function mounted() {
      var _this3 = this;
      this.$nextTick(function () {
        _this3.compiled = true;
        _this3.bindWheelEvent();
      });
    },
    methods: {
      getCellCls: function getCellCls(cell) {
        var _ref;
        return ['bk-time-picker-cells-cell', (_ref = {}, _defineProperty(_ref, "bk-time-picker-cells-cell-selected", cell.selected), _defineProperty(_ref, "bk-time-picker-cells-cell-focused", cell.focused), _defineProperty(_ref, "bk-time-picker-cells-cell-disabled", cell.disabled), _ref)];
      },
      chooseValue: function chooseValue(values) {
        var _this4 = this;
        var changes = timeParts.reduce(function (obj, part, i) {
          var value = values[i];
          if (_this4[part] === value) {
            return obj;
          }
          return _objectSpread({}, obj, _defineProperty({}, part, value));
        }, {});
        if (keys$1(changes).length > 0) {
          this.emitChange(changes);
        }
      },
      bindWheelEvent: function bindWheelEvent() {
        var _this5 = this;
        var bindFunction = function bindFunction(type) {
          _this5.$refs[type].addEventListener('wheel', debounce$2(_this5.handleWheel, 32, type), {
            passive: true
          });
        };
        bindFunction('hours');
        bindFunction('minutes');
        bindFunction('seconds');
      },
      typeItemHeight: function typeItemHeight(type) {
        return this.$refs[type].querySelector('li').offsetHeight;
      },
      scrollBarHeight: function scrollBarHeight(type) {
        return this.$refs[type].offsetHeight;
      },
      handleWheel: function handleWheel(e, type) {
        var _this6 = this;
        var value = Math.min(Math.round((this.$refs[type].scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === 'hours' ? 23 : 59);
        var list = this["".concat(type, "List")];
        var item = list.find(function (data) {
          return data.text === value;
        });
        if (item.disabled) {
          return false;
        }
        this.$nextTick(function () {
          _this6.emitChange(_defineProperty({}, type, value));
        });
      },
      handleClick: function handleClick(type, cell) {
        if (cell.disabled) {
          return;
        }
        var data = _defineProperty({}, type, cell.text);
        this.emitChange(data);
      },
      emitChange: function emitChange(changes) {
        this.$emit('change', changes);
        this.$emit('pick-click');
      },
      scroll: function scroll(type, index) {
        var from = this.$refs[type].scrollTop;
        var to = 32 * this.getScrollIndex(type, index);
        scrollTop(this.$refs[type], from, to, 500);
      },
      getScrollIndex: function getScrollIndex(type, index) {
        var t = this.firstUpperCase(type);
        var disabled = this["disabled".concat(t)];
        if (disabled.length && this.hideDisabledOptions) {
          var _count = 0;
          disabled.forEach(function (item) {
            return item <= index ? _count++ : '';
          });
          index -= _count;
        }
        return index;
      },
      updateScroll: function updateScroll() {
        var _this7 = this;
        this.$nextTick(function () {
          timeParts.forEach(function (type) {
            _this7.$refs[type].scrollTop = 32 * _this7["".concat(type, "List")].findIndex(function (obj) {
              return obj.text === _this7[type];
            });
          });
        });
      },
      padTime: function padTime(text) {
        return text < 10 ? '0' + text : text;
      },
      updateFocusedTime: function updateFocusedTime(col, time) {
        this.focusedColumn = col;
        this.focusedTime = time.slice();
      }
    }
  };

  /* script */
  var __vue_script__$o = script$o;
  /* template */

  var __vue_render__$o = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-time-picker-cells",
      class: _vm.showSeconds ? 'bk-time-picker-cells-with-seconds' : ''
    }, [_c('div', {
      staticClass: "bk-time-picker-cells-title-wrapper"
    }, [_c('div', {
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 0 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.hour')))]), _c('div', {
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 1 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.min')))]), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showSeconds,
        expression: "showSeconds"
      }],
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 2 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.sec')))])]), _c('div', {
      ref: "hours",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.hoursList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('hours', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)]), _c('div', {
      ref: "minutes",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.minutesList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('minutes', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)]), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showSeconds,
        expression: "showSeconds"
      }],
      ref: "seconds",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.secondsList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('seconds', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)])]);
  };

  var __vue_staticRenderFns__$o = [];
  /* style */

  var __vue_inject_styles__$o = undefined;
  /* scoped */

  var __vue_scope_id__$o = undefined;
  /* module identifier */

  var __vue_module_identifier__$o = undefined;
  /* functional template */

  var __vue_is_functional_template__$o = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$o = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$o,
    staticRenderFns: __vue_staticRenderFns__$o
  }, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

  var panelMixins = {
    props: {
      confirm: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      capitalize: function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      },
      iconBtnCls: function iconBtnCls(direction) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        return ['bk-picker-panel-icon-btn', "bk-date-picker-".concat(direction, "-btn"), "bk-date-picker-".concat(direction, "-btn-arrow").concat(type)];
      },
      handleShortcutClick: function handleShortcutClick(shortcut) {
        if (shortcut.value) {
          this.$emit('pick', shortcut.value(), false, undefined, shortcut);
        }
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
        if (this.shortcutClose) {
          this.handlePickSuccess();
        }
      },
      handlePickClear: function handlePickClear() {
        this.resetView();
        this.$emit('pick-clear');
      },
      handlePickSuccess: function handlePickSuccess() {
        this.resetView();
        this.$emit('pick-success');
      },
      handlePickClick: function handlePickClick() {
        this.$emit('pick-click');
      },
      resetView: function resetView() {
        var _this = this;
        setTimeout(function () {
          _this.currentView = _this.selectionMode;
        }, 500);
      },
      handleClear: function handleClear() {
        this.dates = this.dates.map(function () {
          return null;
        });
        this.rangeState = {};
        this.$emit('pick', this.dates);
        this.handleConfirm();
      },
      handleConfirm: function handleConfirm(visible, type) {
        this.$emit('pick', this.dates, visible, type || this.type);
      },
      onToggleVisibility: function onToggleVisibility(open) {
        var _this$$refs = this.$refs,
            timeSpinner = _this$$refs.timeSpinner,
            timeSpinnerEnd = _this$$refs.timeSpinnerEnd;
        if (open && timeSpinner) {
          timeSpinner.updateScroll();
        }
        if (open && timeSpinnerEnd) {
          timeSpinnerEnd.updateScroll();
        }
      }
    }
  };

  var script$p = {
    name: 'TimePickerPanel',
    components: {
      TimeSpinner: __vue_component__$o
    },
    mixins: [timeMixins, panelMixins],
    props: {
      disabledDate: {
        type: Function,
        default: function _default() {
          return false;
        }
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      format: {
        type: String,
        default: 'HH:mm:ss'
      },
      value: {
        type: Array,
        required: true
      }
    },
    data: function data() {
      return {
        date: this.value[0] || initTime(),
        showDate: false
      };
    },
    computed: {
      showSeconds: function showSeconds() {
        return !(this.format || '').match(/mm$/);
      },
      visibleDate: function visibleDate() {
        return fecha.format(this.$parent.panelDate, this.$parent.format);
      },
      timeSlots: function timeSlots() {
        var _this = this;
        if (!this.value[0]) {
          return [];
        }
        return ['getHours', 'getMinutes', 'getSeconds'].map(function (slot) {
          return _this.date[slot]();
        });
      },
      disabledHMS: function disabledHMS() {
        var _this2 = this;
        var disabledTypes = ['disabledHours', 'disabledMinutes', 'disabledSeconds'];
        if (this.disabledDate === function () {
          return  !_this2.value[0];
        }) {
          var disabled = disabledTypes.reduce(function (obj, type) {
            obj[type] = _this2[type];
            return obj;
          }, {});
          return disabled;
        } else {
          var slots = [24, 60, 60];
          var _disabled = ['Hours', 'Minutes', 'Seconds'].map(function (type) {
            return _this2["disabled".concat(type)];
          });
          var disabledHMS = _disabled.map(function (preDisabled, j) {
            var slot = slots[j];
            var toDisable = preDisabled;
            var _loop = function _loop(i) {
              var hms = _this2.timeSlots.map(function (slot, x) {
                return x === j ? i : slot;
              });
              var testDateTime = mergeDateHMS.apply(void 0, [_this2.date].concat(_toConsumableArray(hms)));
              if (_this2.disabledDate(testDateTime, true)) {
                toDisable.push(i);
              }
            };
            for (var i = 0; i < slot; i += _this2.steps[j] || 1) {
              _loop(i);
            }
            return toDisable.filter(function (el, i, arr) {
              return arr.indexOf(el) === i;
            });
          });
          return disabledTypes.reduce(function (obj, type, i) {
            obj[type] = disabledHMS[i];
            return obj;
          }, {});
        }
      }
    },
    watch: {
      value: function value(dates) {
        var newVal = dates[0] || initTime();
        newVal = new Date(newVal);
        this.date = newVal;
      }
    },
    mounted: function mounted() {
      if (this.$parent && this.$parent.$options.name === 'DatePanel') {
        this.showDate = true;
      }
    },
    methods: {
      handleChange: function handleChange(date) {
        var _this3 = this;
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var newDate = new Date(this.date);
        keys$1(date).forEach(function (type) {
          return newDate["set".concat(_this3.capitalize(type))](date[type]);
        });
        if (emit) {
          this.$emit('pick', newDate, 'time');
        }
      }
    }
  };

  /* script */
  var __vue_script__$p = script$p;
  /* template */

  var __vue_render__$p = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper",
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-body",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [_vm._v(_vm._s(_vm.visibleDate))]) : _vm._e(), _c('div', {
      staticClass: "bk-picker-panel-content"
    }, [_c('time-spinner', {
      ref: "timeSpinner",
      attrs: {
        "show-seconds": _vm.showSeconds,
        "steps": _vm.steps,
        "hours": _vm.timeSlots[0],
        "minutes": _vm.timeSlots[1],
        "seconds": _vm.timeSlots[2],
        "disabled-hours": _vm.disabledHMS.disabledHours,
        "disabled-minutes": _vm.disabledHMS.disabledMinutes,
        "disabled-seconds": _vm.disabledHMS.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1)])]);
  };

  var __vue_staticRenderFns__$p = [];
  /* style */

  var __vue_inject_styles__$p = undefined;
  /* scoped */

  var __vue_scope_id__$p = undefined;
  /* module identifier */

  var __vue_module_identifier__$p = undefined;
  /* functional template */

  var __vue_is_functional_template__$p = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$p = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$p,
    staticRenderFns: __vue_staticRenderFns__$p
  }, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

  var script$q = {
    props: {
      datePanelLabel: Object,
      currentView: String
    },
    data: function data() {
      return {
        cls: 'bk-date-picker-header-label'
      };
    },
    computed: {
      showLabelFirst: function showLabelFirst() {
        return this.datePanelLabel.labels[0].type === 'year' || this.currentView === 'date';
      },
      showLabelSecond: function showLabelSecond() {
        return this.datePanelLabel.labels[1].type === 'year' || this.currentView === 'date';
      }
    }
  };

  /* script */
  var __vue_script__$q = script$q;
  /* template */

  var __vue_render__$q = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('span', [_vm.datePanelLabel ? [_c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showLabelFirst,
        expression: "showLabelFirst"
      }],
      class: _vm.cls,
      on: {
        "click": _vm.datePanelLabel.labels[0].handler
      }
    }, [_vm._v(_vm._s(_vm.datePanelLabel.labels[0].label))]), _vm.currentView === 'date' ? [_vm._v(_vm._s(_vm.datePanelLabel.separator))] : _vm._e(), _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showLabelSecond,
        expression: "showLabelSecond"
      }],
      class: _vm.cls,
      on: {
        "click": _vm.datePanelLabel.labels[1].handler
      }
    }, [_vm._v(_vm._s(_vm.datePanelLabel.labels[1].label))])] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$q = [];
  /* style */

  var __vue_inject_styles__$q = undefined;
  /* scoped */

  var __vue_scope_id__$q = undefined;
  /* module identifier */

  var __vue_module_identifier__$q = undefined;
  /* functional template */

  var __vue_is_functional_template__$q = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$q = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$q,
    staticRenderFns: __vue_staticRenderFns__$q
  }, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

  var datePanelMixin = {
    props: {
      showTime: {
        type: Boolean,
        default: false
      },
      format: {
        type: String,
        default: 'yyyy-MM-dd'
      },
      selectionMode: {
        type: String,
        default: 'date',
        validator: function validator(value) {
          if (['year', 'month', 'date', 'time'].indexOf(value) < 0) {
            console.error("selectionMode property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      disabledDate: {
        type: Function,
        default: function _default() {
          return false;
        }
      },
      value: {
        type: Array,
        default: function _default() {
          return [initTime(), initTime()];
        }
      },
      timePickerOptions: {
        default: function _default() {
          return {};
        },
        type: Object
      },
      startDate: {
        type: Date
      },
      pickerType: {
        type: String,
        require: true
      },
      focusedDate: {
        type: Date,
        required: true
      },
      upToNow: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      isTime: function isTime() {
        return this.currentView === 'time';
      }
    },
    methods: {
      handleToggleTime: function handleToggleTime() {
        this.currentView = this.currentView === 'time' ? 'date' : 'time';
      }
    }
  };

  var script$r = {
    name: 'DatePanel',
    components: {
      DateTable: __vue_component__$k,
      YearTable: __vue_component__$l,
      MonthTable: __vue_component__$m,
      TimePicker: __vue_component__$p,
      DatePanelLabel: __vue_component__$q,
      Confirm: __vue_component__$n
    },
    mixins: [panelMixins, datePanelMixin],
    props: {
      clearable: {
        type: Boolean,
        default: true
      },
      multiple: {
        type: Boolean,
        default: false
      },
      shortcuts: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcutClose: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      var selectionMode = this.selectionMode,
          value = this.value;
      var dates = value.slice().sort();
      return {
        currentView: selectionMode || 'date',
        pickerTable: this.getTableType(selectionMode),
        dates: dates,
        panelDate: this.startDate || dates[0] || new Date()
      };
    },
    computed: {
      panelPickerHandlers: function panelPickerHandlers() {
        return this.pickerTable === "".concat(this.currentView, "-table") ? this.handlePick : this.handlePreSelection;
      },
      datePanelLabel: function datePanelLabel() {
        var _this = this;
        var locale = 'zh-CN';
        var datePanelLabelStr = '[yyyy]-[mm]';
        var date = this.panelDate;
        var _formatDateLabels = formatDateLabels(locale, datePanelLabelStr, date),
            labels = _formatDateLabels.labels,
            separator = _formatDateLabels.separator;
        var handler = function handler(type) {
          return function () {
            _this.pickerTable = _this.getTableType(type);
          };
        };
        return {
          separator: separator,
          labels: labels.map(function (obj) {
            obj.handler = handler(obj.type);
            return obj;
          })
        };
      },
      timeDisabled: function timeDisabled() {
        return !this.dates[0];
      }
    },
    watch: {
      value: function value(newVal) {
        this.dates = newVal;
        var panelDate = this.multiple ? this.dates[this.dates.length - 1] : this.startDate || this.dates[0];
        this.panelDate = panelDate || new Date();
      },
      currentView: function currentView(_currentView) {
        var _this2 = this;
        this.$emit('selection-mode-change', _currentView);
        if (this.currentView === 'time') {
          this.$nextTick(function () {
            var spinner = _this2.$refs.timePicker.$refs.timeSpinner;
            spinner.updateScroll();
          });
        }
      },
      selectionMode: function selectionMode(type) {
        this.currentView = type;
        this.pickerTable = this.getTableType(type);
      },
      focusedDate: function focusedDate(date) {
        var isDifferentYear = date.getFullYear() !== this.panelDate.getFullYear();
        var isDifferentMonth = isDifferentYear || date.getMonth() !== this.panelDate.getMonth();
        if (isDifferentYear || isDifferentMonth) {
          if (!this.multiple) {
            this.panelDate = date;
          }
        }
      }
    },
    methods: {
      reset: function reset() {
        this.currentView = this.selectionMode;
        this.pickerTable = this.getTableType(this.currentView);
      },
      changeYear: function changeYear(dir) {
        if (this.selectionMode === 'year' || this.pickerTable === 'year-table') {
          this.panelDate = new Date(this.panelDate.getFullYear() + dir * 10, 0, 1);
        } else {
          this.panelDate = siblingMonth(this.panelDate, dir * 12);
        }
      },
      getTableType: function getTableType(currentView) {
        return currentView.match(/^time/) ? 'time-picker' : "".concat(currentView, "-table");
      },
      changeMonth: function changeMonth(dir) {
        this.panelDate = siblingMonth(this.panelDate, dir);
      },
      handlePreSelection: function handlePreSelection(value) {
        this.panelDate = value;
        if (this.pickerTable === 'year-table') {
          this.pickerTable = 'month-table';
        } else {
          this.pickerTable = this.getTableType(this.currentView);
        }
      },
      handlePick: function handlePick(value, type) {
        var selectionMode = this.selectionMode,
            panelDate = this.panelDate;
        if (selectionMode === 'year') {
          value = new Date(value.getFullYear(), 0, 1);
        } else if (selectionMode === 'month') {
          value = new Date(panelDate.getFullYear(), value.getMonth(), 1);
        } else {
          value = new Date(value);
        }
        this.dates = [value];
        this.$emit('pick', value, false, type || selectionMode);
      }
    }
  };

  /* script */
  var __vue_script__$r = script$r;
  /* template */

  var __vue_render__$r = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper",
      class: _vm.shortcuts.length ? 'bk-picker-panel-with-sidebar' : '',
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_vm.shortcuts.length ? _c('div', {
      staticClass: "bk-picker-panel-sidebar"
    }, _vm._l(_vm.shortcuts, function (shortcut, index) {
      return _c('div', {
        key: index,
        staticClass: "bk-picker-panel-shortcut",
        on: {
          "click": function click($event) {
            _vm.handleShortcutClick(shortcut);
          }
        }
      }, [_vm._v("\n            " + _vm._s(shortcut.text) + "\n        ")]);
    }), 0) : _vm._e(), _c('div', {
      staticClass: "bk-picker-panel-body",
      staticStyle: {
        "width": "261px"
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView !== 'time',
        expression: "currentView !== 'time'"
      }],
      staticClass: "bk-date-picker-header"
    }, [_c('span', {
      class: _vm.iconBtnCls('prev', '-double'),
      on: {
        "click": function click($event) {
          _vm.changeYear(-1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-left"
    })]), _vm.pickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('prev'),
      on: {
        "click": function click($event) {
          _vm.changeMonth(-1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-left"
    })]) : _vm._e(), _c('date-panel-label', {
      attrs: {
        "date-panel-label": _vm.datePanelLabel,
        "current-view": _vm.pickerTable.split('-').shift()
      }
    }), _c('span', {
      class: _vm.iconBtnCls('next', '-double'),
      on: {
        "click": function click($event) {
          _vm.changeYear(+1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-right"
    })]), _vm.pickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('next'),
      on: {
        "click": function click($event) {
          _vm.changeMonth(+1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-right"
    })]) : _vm._e()], 1), _c('div', {
      staticClass: "bk-picker-panel-content"
    }, [_vm.currentView !== 'time' ? _c(_vm.pickerTable, {
      ref: "pickerTable",
      tag: "component",
      attrs: {
        "table-date": _vm.panelDate,
        "value": _vm.dates,
        "selection-mode": _vm.selectionMode,
        "disabled-date": _vm.disabledDate,
        "focused-date": _vm.focusedDate
      },
      on: {
        "pick": _vm.panelPickerHandlers,
        "pick-click": _vm.handlePickClick
      }
    }) : _vm._e()], 1), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isTime,
        expression: "isTime"
      }],
      staticClass: "bk-picker-panel-content"
    }, [_vm.currentView === 'time' ? _c('time-picker', _vm._b({
      ref: "timePicker",
      attrs: {
        "value": _vm.dates,
        "format": _vm.format,
        "time-disabled": _vm.timeDisabled,
        "disabled-date": _vm.disabledDate,
        "focused-date": _vm.focusedDate
      },
      on: {
        "pick": _vm.handlePick,
        "pick-click": _vm.handlePickClick,
        "pick-clear": _vm.handlePickClear,
        "pick-success": _vm.handlePickSuccess,
        "pick-toggle-time": _vm.handleToggleTime
      }
    }, 'time-picker', _vm.timePickerOptions, false)) : _vm._e()], 1), _vm.confirm ? _c('Confirm', {
      attrs: {
        "clearable": _vm.clearable,
        "show-time": _vm.showTime,
        "is-time": _vm.isTime
      },
      on: {
        "pick-toggle-time": _vm.handleToggleTime,
        "pick-clear": _vm.handlePickClear,
        "pick-success": _vm.handlePickSuccess
      }
    }) : _vm._e()], 1)]);
  };

  var __vue_staticRenderFns__$r = [];
  /* style */

  var __vue_inject_styles__$r = undefined;
  /* scoped */

  var __vue_scope_id__$r = undefined;
  /* module identifier */

  var __vue_module_identifier__$r = undefined;
  /* functional template */

  var __vue_is_functional_template__$r = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$r = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$r,
    staticRenderFns: __vue_staticRenderFns__$r
  }, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

  var script$s = {
    name: 'RangeTimePickerPanel',
    components: {
      TimeSpinner: __vue_component__$o
    },
    mixins: [timeMixins, panelMixins],
    props: {
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      format: {
        type: String,
        default: 'HH:mm:ss'
      },
      value: {
        type: Array,
        required: true
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      var _this$value$slice = this.value.slice(),
          _this$value$slice2 = _slicedToArray(_this$value$slice, 2),
          dateStart = _this$value$slice2[0],
          dateEnd = _this$value$slice2[1];
      return {
        showDate: false,
        dateStart: dateStart || initTime(),
        dateEnd: dateEnd || initTime()
      };
    },
    computed: {
      showSeconds: function showSeconds() {
        return !(this.format || '').match(/mm$/);
      },
      leftDatePanelLabel: function leftDatePanelLabel() {
        return fecha.format(this.$parent.dates[0], this.$parent.format);
      },
      rightDatePanelLabel: function rightDatePanelLabel() {
        return fecha.format(this.$parent.dates[1], this.$parent.format);
      }
    },
    watch: {
      value: function value(dates) {
        var _dates$slice = dates.slice(),
            _dates$slice2 = _slicedToArray(_dates$slice, 2),
            dateStart = _dates$slice2[0],
            dateEnd = _dates$slice2[1];
        this.dateStart = dateStart || initTime();
        this.dateEnd = dateEnd || initTime();
      }
    },
    mounted: function mounted() {
      if (this.$parent && this.$parent.$options.name === 'DateRangePanel') {
        this.showDate = true;
      }
    },
    methods: {
      handleChange: function handleChange(idx, start, end) {
        var _this = this;
        var emit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var dateStart = new Date(this.dateStart);
        var dateEnd = new Date(this.dateEnd);
        keys$1(start).forEach(function (type) {
          dateStart["set".concat(_this.capitalize(type))](start[type]);
        });
        keys$1(end).forEach(function (type) {
          dateEnd["set".concat(_this.capitalize(type))](end[type]);
        });
        if (!this.allowCrossDay && dateEnd < dateStart) {
          if (idx === 'start') {
            dateEnd = dateStart;
          }
          if (idx === 'end') {
            dateStart = dateEnd;
          }
        }
        if (emit) {
          this.$emit('pick', [dateStart, dateEnd], 'time');
        }
      },
      handleStartChange: function handleStartChange(date) {
        this.handleChange('start', date, {});
      },
      handleEndChange: function handleEndChange(date) {
        this.handleChange('end', {}, date);
      },
      updateScroll: function updateScroll() {
        this.$refs.timeSpinner.updateScroll();
        this.$refs.timeSpinnerEnd.updateScroll();
      }
    }
  };

  /* script */
  var __vue_script__$s = script$s;
  /* template */

  var __vue_render__$s = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper bk-time-picker-with-range",
      class: _vm.showSeconds ? 'bk-time-picker-with-seconds' : '',
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-body",
      style: {
        width: _vm.width * 2 + "px"
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-content bk-picker-panel-content-left",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [[_vm._v(_vm._s(_vm.leftDatePanelLabel))]], 2) : _vm._e(), _c('time-spinner', {
      ref: "timeSpinner",
      attrs: {
        "steps": _vm.steps,
        "show-seconds": _vm.showSeconds,
        "hours": _vm.value[0] && _vm.dateStart.getHours(),
        "minutes": _vm.value[0] && _vm.dateStart.getMinutes(),
        "seconds": _vm.value[0] && _vm.dateStart.getSeconds(),
        "disabled-hours": _vm.disabledHours,
        "disabled-minutes": _vm.disabledMinutes,
        "disabled-seconds": _vm.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleStartChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1), _c('div', {
      staticClass: "bk-picker-panel-content bk-picker-panel-content-right",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [[_vm._v(_vm._s(_vm.rightDatePanelLabel))]], 2) : _vm._e(), _c('time-spinner', {
      ref: "timeSpinnerEnd",
      attrs: {
        "steps": _vm.steps,
        "show-seconds": _vm.showSeconds,
        "hours": _vm.value[1] && _vm.dateEnd.getHours(),
        "minutes": _vm.value[1] && _vm.dateEnd.getMinutes(),
        "seconds": _vm.value[1] && _vm.dateEnd.getSeconds(),
        "disabled-hours": _vm.disabledHours,
        "disabled-minutes": _vm.disabledMinutes,
        "disabled-seconds": _vm.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleEndChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1)])]);
  };

  var __vue_staticRenderFns__$s = [];
  /* style */

  var __vue_inject_styles__$s = undefined;
  /* scoped */

  var __vue_scope_id__$s = undefined;
  /* module identifier */

  var __vue_module_identifier__$s = undefined;
  /* functional template */

  var __vue_is_functional_template__$s = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$s = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$s,
    staticRenderFns: __vue_staticRenderFns__$s
  }, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

  var dateSorter = function dateSorter(a, b) {
    if (!a || !b) {
      return 0;
    }
    return a.getTime() - b.getTime();
  };
  var script$t = {
    name: 'DateRangePanel',
    components: {
      DateTable: __vue_component__$k,
      YearTable: __vue_component__$l,
      MonthTable: __vue_component__$m,
      TimePicker: __vue_component__$s,
      DatePanelLabel: __vue_component__$q,
      Confirm: __vue_component__$n
    },
    mixins: [panelMixins, datePanelMixin, locale.mixin],
    props: {
      clearable: {
        type: Boolean,
        default: true
      },
      splitPanels: {
        type: Boolean,
        default: true
      },
      shortcuts: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcutClose: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      var _this$value$map = this.value.map(function (date) {
        return date || initTime();
      }),
          _this$value$map2 = _slicedToArray(_this$value$map, 2),
          minDate = _this$value$map2[0],
          maxDate = _this$value$map2[1];
      var leftPanelDate = this.startDate ? this.startDate : minDate;
      return {
        dates: this.value,
        rangeState: {
          from: this.value[0],
          to: this.value[1],
          selecting: minDate && !maxDate
        },
        currentView: this.selectionMode || 'range',
        leftPickerTable: "".concat(this.selectionMode, "-table"),
        rightPickerTable: "".concat(this.selectionMode, "-table"),
        leftPanelDate: leftPanelDate,
        rightPanelDate: new Date(leftPanelDate.getFullYear(), leftPanelDate.getMonth() + 1, 1),
        upToNowEnable: false
      };
    },
    computed: {
      leftDatePanelLabel: function leftDatePanelLabel() {
        return this.panelLabelConfig('left');
      },
      rightDatePanelLabel: function rightDatePanelLabel() {
        return this.panelLabelConfig('right');
      },
      leftDatePanelView: function leftDatePanelView() {
        return this.leftPickerTable.split('-').shift();
      },
      rightDatePanelView: function rightDatePanelView() {
        return this.rightPickerTable.split('-').shift();
      },
      timeDisabled: function timeDisabled() {
        return !(this.dates[0] && this.dates[1]);
      },
      preSelecting: function preSelecting() {
        var tableType = "".concat(this.currentView, "-table");
        return {
          left: this.leftPickerTable !== tableType,
          right: this.rightPickerTable !== tableType
        };
      },
      panelPickerHandlers: function panelPickerHandlers() {
        return {
          left: this.preSelecting.left ? this.handlePreSelection.bind(this, 'left') : this.handleRangePick,
          right: this.preSelecting.right ? this.handlePreSelection.bind(this, 'right') : this.handleRangePick
        };
      }
    },
    watch: {
      value: function value(newVal) {
        var minDate = newVal[0] ? toDate(newVal[0]) : null;
        var maxDate = newVal[1] ? toDate(newVal[1]) : null;
        this.dates = [minDate, maxDate].sort(dateSorter);
        this.rangeState = {
          from: this.dates[0],
          to: this.dates[1],
          selecting: false
        };
        this.setPanelDates(this.startDate || this.dates[0] || new Date());
      },
      currentView: function currentView(_currentView) {
        var _this = this;
        var leftMonth = this.leftPanelDate.getMonth();
        var rightMonth = this.rightPanelDate.getMonth();
        var isSameYear = this.leftPanelDate.getFullYear() === this.rightPanelDate.getFullYear();
        if (_currentView === 'date' && isSameYear && leftMonth === rightMonth) {
          this.changePanelDate('right', 'Month', 1);
        }
        if (_currentView === 'month' && isSameYear) {
          this.changePanelDate('right', 'FullYear', 1);
        }
        if (_currentView === 'year' && isSameYear) {
          this.changePanelDate('right', 'FullYear', 10);
        }
        if (this.currentView === 'time') {
          this.$nextTick(function () {
            _this.$refs.timePicker.updateScroll();
          });
        }
      },
      selectionMode: function selectionMode(type) {
        this.currentView = type || 'range';
      },
      focusedDate: function focusedDate(date) {
        this.setPanelDates(date || new Date());
      }
    },
    methods: {
      reset: function reset() {
        this.currentView = this.selectionMode;
        this.leftPickerTable = "".concat(this.currentView, "-table");
        this.rightPickerTable = "".concat(this.currentView, "-table");
      },
      setPanelDates: function setPanelDates(leftPanelDate) {
        this.leftPanelDate = leftPanelDate;
        var rightPanelDate = new Date(leftPanelDate.getFullYear(), leftPanelDate.getMonth() + 1, 1);
        var splitRightPanelDate = this.dates[1] ? this.dates[1].getTime() : this.dates[1];
        this.rightPanelDate = this.splitPanels ? new Date(Math.max(splitRightPanelDate, rightPanelDate.getTime())) : rightPanelDate;
      },
      panelLabelConfig: function panelLabelConfig(direction) {
        var _this2 = this;
        var locale = 'zh-CN';
        var datePanelLabel = '[yyyy]-[mm]';
        var handler = function handler(type) {
          var fn = type === 'month' ? _this2.showMonthPicker : _this2.showYearPicker;
          return function () {
            return fn(direction);
          };
        };
        var date = this["".concat(direction, "PanelDate")];
        var _formatDateLabels = formatDateLabels(locale, datePanelLabel, date),
            labels = _formatDateLabels.labels,
            separator = _formatDateLabels.separator;
        return {
          separator: separator,
          labels: labels.map(function (obj) {
            obj.handler = handler(obj.type);
            return obj;
          })
        };
      },
      prevYear: function prevYear(panel) {
        var increment = this.currentView === 'year' ? -10 : -1;
        this.changePanelDate(panel, 'FullYear', increment);
      },
      nextYear: function nextYear(panel) {
        var increment = this.currentView === 'year' ? 10 : 1;
        this.changePanelDate(panel, 'FullYear', increment);
      },
      prevMonth: function prevMonth(panel) {
        this.changePanelDate(panel, 'Month', -1);
      },
      nextMonth: function nextMonth(panel) {
        this.changePanelDate(panel, 'Month', 1);
      },
      changePanelDate: function changePanelDate(panel, type, increment) {
        var updateOtherPanel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var current = new Date(this["".concat(panel, "PanelDate")]);
        current["set".concat(type)](current["get".concat(type)]() + increment);
        this["".concat(panel, "PanelDate")] = current;
        if (!updateOtherPanel) {
          return;
        }
        if (this.splitPanels) {
          var otherPanel = panel === 'left' ? 'right' : 'left';
          if (panel === 'left' && this.leftPanelDate >= this.rightPanelDate) {
            this.changePanelDate(otherPanel, type, 1);
          }
          if (panel === 'right' && this.rightPanelDate <= this.leftPanelDate) {
            this.changePanelDate(otherPanel, type, -1);
          }
        } else {
          var _otherPanel = panel === 'left' ? 'right' : 'left';
          var currentDate = this["".concat(_otherPanel, "PanelDate")];
          var temp = new Date(currentDate);
          if (type === 'Month') {
            var nextMonthLastDate = new Date(temp.getFullYear(), temp.getMonth() + increment + 1, 0).getDate();
            temp.setDate(Math.min(nextMonthLastDate, temp.getDate()));
          }
          temp["set".concat(type)](temp["get".concat(type)]() + increment);
          this["".concat(_otherPanel, "PanelDate")] = temp;
        }
      },
      showYearPicker: function showYearPicker(panel) {
        this["".concat(panel, "PickerTable")] = 'year-table';
      },
      showMonthPicker: function showMonthPicker(panel) {
        this["".concat(panel, "PickerTable")] = 'month-table';
      },
      handlePreSelection: function handlePreSelection(panelPosition, value) {
        this["".concat(panelPosition, "PanelDate")] = value;
        var currentViewType = this["".concat(panelPosition, "PickerTable")];
        if (currentViewType === 'year-table') {
          this["".concat(panelPosition, "PickerTable")] = 'month-table';
        } else {
          this["".concat(panelPosition, "PickerTable")] = "".concat(this.currentView, "-table");
        }
        if (!this.splitPanels) {
          var otherPanel = panelPosition === 'left' ? 'right' : 'left';
          this["".concat(otherPanel, "PanelDate")] = value;
          var increment = otherPanel === 'left' ? -1 : 1;
          this.changePanelDate(otherPanel, 'Month', increment, false);
        }
      },
      handleRangePick: function handleRangePick(val, type) {
        if (this.rangeState.selecting || this.currentView === 'time') {
          if (this.currentView === 'time') {
            this.dates = val;
          } else {
            var _sort = [this.rangeState.from, val].sort(dateSorter),
                _sort2 = _slicedToArray(_sort, 2),
                minDate = _sort2[0],
                maxDate = _sort2[1];
            var maxDateLastMoment = type === 'upToNow'
            ? new Date()
            : new Date(new Date(new Date(maxDate.setHours(23)).setMinutes(59)).setSeconds(59));
            this.dates = [minDate, maxDateLastMoment];
            this.rangeState = {
              from: minDate,
              to: maxDateLastMoment,
              selecting: false
            };
          }
          this.handleConfirm(false, type || 'date');
        } else {
          this.upToNowEnable = new Date(val).getTime() < new Date().getTime();
          this.rangeState = {
            from: val,
            to: null,
            selecting: true
          };
        }
      },
      handleChangeRange: function handleChangeRange(val) {
        this.rangeState.to = val;
      }
    }
  };

  /* script */
  var __vue_script__$t = script$t;
  /* template */

  var __vue_render__$t = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper bk-date-picker-with-range",
      class: [_vm.shortcuts.length || _vm.$slots.shortcuts ? 'bk-picker-panel-with-sidebar' : ''],
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-body",
      class: _vm.showTime ? 'bk-picker-panel-body-time' : 'bk-picker-panel-body-date'
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.isTime,
        expression: "!isTime"
      }],
      staticClass: "bk-picker-panel-content bk-picker-panel-content-left",
      staticStyle: {
        "width": "261px"
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView !== 'time',
        expression: "currentView !== 'time'"
      }],
      staticClass: "bk-date-picker-header"
    }, [_c('span', {
      class: _vm.iconBtnCls('prev', '-double'),
      on: {
        "click": function click($event) {
          _vm.prevYear('left');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-left"
    })]), _vm.leftPickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('prev'),
      on: {
        "click": function click($event) {
          _vm.prevMonth('left');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-left"
    })]) : _vm._e(), _c('date-panel-label', {
      attrs: {
        "date-panel-label": _vm.leftDatePanelLabel,
        "current-view": _vm.leftDatePanelView
      }
    }), _vm.splitPanels || _vm.leftPickerTable !== 'date-table' ? _c('span', {
      class: _vm.iconBtnCls('next', '-double'),
      on: {
        "click": function click($event) {
          _vm.nextYear('left');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-right"
    })]) : _vm._e(), _vm.splitPanels && _vm.leftPickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('next'),
      on: {
        "click": function click($event) {
          _vm.nextMonth('left');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-right"
    })]) : _vm._e()], 1), _vm.currentView !== 'time' ? _c(_vm.leftPickerTable, {
      ref: "leftYearTable",
      tag: "component",
      attrs: {
        "selection-mode": "range",
        "table-date": _vm.leftPanelDate,
        "disabled-date": _vm.disabledDate,
        "range-state": _vm.rangeState,
        "value": _vm.preSelecting.left ? [_vm.dates[0]] : _vm.dates,
        "focused-date": _vm.focusedDate
      },
      on: {
        "change-range": _vm.handleChangeRange,
        "pick": _vm.panelPickerHandlers.left,
        "pick-click": _vm.handlePickClick
      }
    }) : _vm._e()], 1), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.isTime,
        expression: "!isTime"
      }],
      staticClass: "bk-picker-panel-content bk-picker-panel-content-right",
      staticStyle: {
        "width": "261px"
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView !== 'time',
        expression: "currentView !== 'time'"
      }],
      staticClass: "bk-date-picker-header"
    }, [_vm.splitPanels || _vm.rightPickerTable !== 'date-table' ? _c('span', {
      class: _vm.iconBtnCls('prev', '-double'),
      on: {
        "click": function click($event) {
          _vm.prevYear('right');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-left"
    })]) : _vm._e(), _vm.splitPanels && _vm.rightPickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('prev'),
      on: {
        "click": function click($event) {
          _vm.prevMonth('right');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-left"
    })]) : _vm._e(), _c('date-panel-label', {
      attrs: {
        "date-panel-label": _vm.rightDatePanelLabel,
        "current-view": _vm.rightDatePanelView
      }
    }), _vm.upToNow ? [(_vm.rangeState.selecting || _vm.currentView === 'time') && _vm.upToNowEnable ? _c('span', {
      staticClass: "up-to-now",
      attrs: {
        "href": "javascript: void(0);"
      },
      on: {
        "click": function click($event) {
          _vm.handleRangePick(new Date(), 'upToNow');
        }
      }
    }, [_vm._v("\n                        " + _vm._s(_vm.t('bk.datePicker.toNow')) + "\n                    ")]) : _c('span', {
      staticClass: "up-to-now disabled",
      attrs: {
        "href": "javascript: void(0);"
      }
    }, [_vm._v("\n                        " + _vm._s(_vm.t('bk.datePicker.toNow')) + "\n                    ")])] : _vm._e(), _c('span', {
      class: _vm.iconBtnCls('next', '-double'),
      on: {
        "click": function click($event) {
          _vm.nextYear('right');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-double-right"
    })]), _vm.rightPickerTable === 'date-table' ? _c('span', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.currentView === 'date',
        expression: "currentView === 'date'"
      }],
      class: _vm.iconBtnCls('next'),
      on: {
        "click": function click($event) {
          _vm.nextMonth('right');
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-right"
    })]) : _vm._e()], 2), _vm.currentView !== 'time' ? _c(_vm.rightPickerTable, {
      ref: "rightYearTable",
      tag: "component",
      attrs: {
        "selection-mode": "range",
        "table-date": _vm.rightPanelDate,
        "range-state": _vm.rangeState,
        "disabled-date": _vm.disabledDate,
        "value": _vm.preSelecting.right ? [_vm.dates[_vm.dates.length - 1]] : _vm.dates,
        "focused-date": _vm.focusedDate
      },
      on: {
        "change-range": _vm.handleChangeRange,
        "pick": _vm.panelPickerHandlers.right,
        "pick-click": _vm.handlePickClick
      }
    }) : _vm._e()], 1), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isTime,
        expression: "isTime"
      }],
      staticClass: "bk-picker-panel-content"
    }, [_vm.currentView === 'time' ? _c('time-picker', _vm._b({
      ref: "timePicker",
      attrs: {
        "value": _vm.dates,
        "format": _vm.format,
        "time-disabled": _vm.timeDisabled
      },
      on: {
        "pick": _vm.handleRangePick,
        "pick-click": _vm.handlePickClick,
        "pick-clear": _vm.handlePickClear,
        "pick-success": _vm.handlePickSuccess,
        "pick-toggle-time": _vm.handleToggleTime
      }
    }, 'time-picker', _vm.timePickerOptions, false)) : _vm._e()], 1), _vm.confirm ? _c('Confirm', {
      attrs: {
        "clearable": _vm.clearable,
        "show-time": _vm.showTime,
        "is-time": _vm.isTime,
        "time-disabled": _vm.timeDisabled
      },
      on: {
        "pick-toggle-time": _vm.handleToggleTime,
        "pick-clear": _vm.handlePickClear,
        "pick-success": _vm.handlePickSuccess
      }
    }) : _vm._e()], 1), _vm.shortcuts.length || _vm.$slots.shortcuts ? _c('div', {
      staticClass: "bk-picker-panel-sidebar"
    }, [_vm.$slots.shortcuts ? _vm._t("shortcuts") : _vm._l(_vm.shortcuts, function (shortcut, index) {
      return _c('div', {
        key: index,
        staticClass: "bk-picker-panel-shortcut",
        on: {
          "click": function click($event) {
            _vm.handleShortcutClick(shortcut);
          }
        }
      }, [_vm._v(_vm._s(shortcut.text))]);
    })], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__$t = [];
  /* style */

  var __vue_inject_styles__$t = undefined;
  /* scoped */

  var __vue_scope_id__$t = undefined;
  /* module identifier */

  var __vue_module_identifier__$t = undefined;
  /* functional template */

  var __vue_is_functional_template__$t = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$t = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$t,
    staticRenderFns: __vue_staticRenderFns__$t
  }, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

  var bkDatePicker = {
    name: 'bk-date-picker',
    mixins: [__vue_component__$j],
    components: {
      DatePanel: __vue_component__$r,
      DateRangePanel: __vue_component__$t
    },
    props: {
      type: {
        type: String,
        default: 'date',
        validator: function validator(value) {
          if (['year', 'month', 'date', 'daterange', 'datetime', 'datetimerange'].indexOf(value) < 0) {
            console.error("type property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      }
    },
    computed: {
      panel: function panel() {
        var isRange = this.type === 'daterange' || this.type === 'datetimerange';
        return isRange ? 'DateRangePanel' : 'DatePanel';
      },
      ownPickerProps: function ownPickerProps() {
        return this.options;
      }
    }
  };

  setInstaller(bkDatePicker);

  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var _iterators = {};

  var IteratorPrototype = {};
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });
  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys());
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';
  var returnThis = function () { return this; };
  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        _setToStringTag(IteratorPrototype, TAG, true);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    if (( FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    }
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  var $at = _stringAt(true);
  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;
  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  var TAG$1 = _wks('toStringTag');
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {  }
  };
  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      : ARG ? _cof(O)
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$2 = _wks('iterator');
  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
    Array.from(riter, function () { throw 2; });
  } catch (e) {  }
  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) {  }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
    from: function from(arrayLike ) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  var from_1 = _core.Array.from;

  var from_1$1 = from_1;

  var scrollbarMixins = {
    methods: {
      checkScrollBar: function checkScrollBar() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.documentElement.clientWidth < fullWindowWidth;
        if (this.bodyIsOverflowing) {
          this.scrollBarWidth = getScrollBarWidth() || fullWindowWidth - document.documentElement.clientWidth;
        }
      },
      checkMaskInVisible: function checkMaskInVisible() {
        var _this = this;
        var masks = document.getElementsByClassName('bk-dialog-mask') || [];
        return from_1$1(masks).every(function (m) {
          return _this.isHidden(m) || m.classList.contains('fade-leave-to');
        });
      },
      isHidden: function isHidden(el) {
        var style = window.getComputedStyle(el);
        return style.display === 'none';
      },
      setScrollBar: function setScrollBar() {
        if (this.bodyIsOverflowing && this.scrollBarWidth !== undefined) {
          document.body.style.paddingRight = "".concat(this.scrollBarWidth, "px");
        }
      },
      resetScrollBar: function resetScrollBar() {
        document.body.style.paddingRight = '';
      },
      addScrollEffect: function addScrollEffect() {
        this.checkScrollBar();
        this.setScrollBar();
        if (document.body.__oldOverflow === undefined) {
          document.body.__oldOverflow = document.body.style.overflow;
        }
        document.body.style.overflow = 'hidden';
      },
      removeScrollEffect: function removeScrollEffect() {
        if (this.checkMaskInVisible()) {
          document.body.style.overflow = document.body.__oldOverflow || '';
          this.resetScrollBar();
        }
      }
    }
  };

  (function () {
    if (!window['__bk_pop_manager']) {
      var __containerId = "bk_pop_".concat(new Date().getTime());
      var __maskId = "bk_pop_mask_".concat(new Date().getTime());
      var __defaultKey = "bk_pop_key_".concat(new Date().getTime());
      var __popInstances = [];
      var popManager = {
        containerId: __containerId,
        maskId: __maskId,
        defaultKey: __defaultKey,
        formatKey: function formatKey(key) {
          return String(key).replace(/#/g, '_');
        },
        show: function show(key, instance) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            tplAction: 'keepAll',
            zIndex: '',
            beforeHide: function beforeHide() {},
            ignoreExistMask: false,
            appendToBody: false
          };
          key = key === undefined || key === null || isNan$1(key) ? this.defaultKey : key;
          key = this.formatKey(key);
          var uid = uuid();
          var isAppendToBody = false;
          if (options.tplAction === 'onlyone') {
            this.clearByTpl(key);
          }
          if (this.shouldAppendToBody(key)) {
            isAppendToBody = true;
            this.showModalMask(options.zIndex);
            !options.appendToBody && this.container.append(instance);
          } else {
            isAppendToBody = false;
            var lastInsZindex = options.zIndex;
            this.showModalMask(lastInsZindex);
          }
          var beforeHide = options.beforeHide,
              zIndex = options.zIndex,
              ignoreExistMask = options.ignoreExistMask;
          this.instances.push({
            uid: uid,
            ins: instance,
            tplName: key,
            beforeHide: beforeHide,
            zIndex: zIndex,
            ignoreExistMask: ignoreExistMask,
            isAppendToBody: isAppendToBody
          });
          return "".concat(uid, "#").concat(key);
        },
        shouldAppendToBody: function shouldAppendToBody(tplName) {
          return this.instances.some(function (item) {
            return item.tplName === tplName;
          });
        },
        hide: function hide(popId, options) {
          options = options || {
            action: 'hideUid'
          };
          switch (options.action) {
            case 'hideAll':
              this.clearAll();
              break;
            case 'hideUid':
              this.clearByUid(popId);
              break;
            case 'hideSameTpl':
              this.clearByTpl(popId);
              break;
            default:
              this.autoClear(popId);
              break;
          }
          this.updateModalMaskIndex();
        },
        updateModalMaskIndex: function updateModalMaskIndex() {
          if (this.instances.length) {
            var lastIns = this.instances.slice(-1)[0];
            var lastInsZindex = lastIns.isAppendToBody ? lastIns.zIndex : lastIns.zIndex - 1;
            this.showModalMask(lastInsZindex);
          } else {
            this.hideModalMask();
          }
        },
        autoClear: function autoClear() {
          var uid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          if (uid.indexOf('#') > 0) {
            this.clearByUid(uid);
          } else {
            this.clearByTpl();
          }
        },
        clearByTpl: function clearByTpl(uid) {
          var _this = this;
          var keyStr = uid.split('#');
          var tplName = keyStr.slice(-1)[0];
          this.instances = this.instances.filter(function (item) {
            if (item.tplName === tplName) {
              _this.__hideInstance(item);
              return false;
            } else {
              return true;
            }
          });
        },
        clearByUid: function clearByUid(uid) {
          var keyStr = uid.split('#');
          var instanceUid = keyStr[0];
          var tplName = keyStr[1];
          var index = this.instances.findIndex(function (ins) {
            return ins.uid === instanceUid && ins.tplName === tplName;
          });
          if (index >= 0) {
            this.__hideInstance(this.instances[index]);
            this.instances.splice(index, 1);
          } else {
            console.warn('Can not find pop instance with index ' + index);
          }
        },
        clearAll: function clearAll() {
          var _this2 = this;
          this.instances.forEach(function (item) {
            return _this2.__hideInstance(item);
          });
          this.instances = [];
        },
        showModalMask: function showModalMask(zIndex) {
          this.dialogMask.setAttribute('style', "z-index:".concat(zIndex, ";"));
          document.body.style.overflow = 'hidden';
          this.dialogMask.classList.remove('hide-active');
          this.dialogMask.classList.add('show-active');
        },
        hideModalMask: function hideModalMask() {
          this.dialogMask.classList.remove('show-active');
          this.dialogMask.classList.add('hide-active');
          document.body.style.overflow = '';
        },
        __hideInstance: function __hideInstance(instance) {
          if (typeof instance.beforeHide === 'function') {
            instance.beforeHide();
            setTimeout(function () {
              if (instance.isAppendToBody) {
                instance.ins.remove();
              }
            });
          } else {
            if (instance.isAppendToBody) {
              instance.ins.remove();
            }
          }
        }
      };
      defineProperty$1(popManager, 'container', {
        get: function get() {
          var container = document.querySelector('[data-bkpop-container]');
          if (!container) {
            container = document.createElement('div');
            container.setAttribute('id', this.containerId);
            container.setAttribute('data-bkpop-container', 'true');
            document.body.append(container);
          }
          return container;
        }
      });
      defineProperty$1(popManager, 'dialogMask', {
        get: function get() {
          var mask = document.querySelector('[data-bkpop-mask]');
          if (!mask) {
            mask = document.createElement('div');
            mask.setAttribute('id', this.maskId);
            mask.setAttribute('class', 'bk-dialog-mask');
            mask.setAttribute('data-bkpop-mask', 'true');
            this.container.append(mask);
          }
          return mask;
        }
      });
      defineProperty$1(popManager, 'instances', {
        get: function get() {
          return __popInstances;
        },
        set: function set(val) {
          __popInstances = val;
        }
      });
      window['__bk_pop_manager'] = popManager;
      window['__bk_pop_manager'].__container = popManager.container;
    }
  })();
  var popManager = window['__bk_pop_manager'];

  var zIndex$1 = {
    props: {
      zIndex: {
        type: [Number, String],
        default: 'default'
      }
    },
    methods: {
      getLocalZIndex: function getLocalZIndex(zIndex) {
        return zIndexManager.nextTickIndex(2, zIndex);
      }
    }
  };

  var script$u = {
    name: 'bk-dialog',
    components: {
      bkButton: __vue_component__$7
    },
    directives: {
      transferDom: transferDom
    },
    mixins: [locale.mixin, scrollbarMixins, zIndex$1],
    props: {
      value: {
        type: Boolean,
        default: false
      },
      title: {
        type: String
      },
      okText: {
        type: String
      },
      cancelText: {
        type: String
      },
      theme: {
        type: String,
        default: 'primary',
        validator: function validator(value) {
          if (['primary', 'warning', 'success', 'danger'].indexOf(value) < 0) {
            console.error("theme property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      position: {
        type: Object
      },
      beforeClose: {
        type: Function,
        default: function _default() {
          return true;
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      width: {
        type: [Number, String],
        default: 400
      },
      showMask: {
        type: Boolean,
        default: true
      },
      maskClose: {
        type: Boolean,
        default: true
      },
      closeIcon: {
        type: Boolean,
        default: true
      },
      escClose: {
        type: Boolean,
        default: true
      },
      fullscreen: {
        type: Boolean,
        default: false
      },
      headerPosition: {
        type: String,
        default: 'center',
        validator: function validator(value) {
          if (['left', 'center'].indexOf(value) < 0) {
            console.error("headerPosition property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      showFooter: {
        type: Boolean,
        default: true
      },
      footerPosition: {
        type: String,
        default: 'right',
        validator: function validator(value) {
          if (['left', 'center', 'right'].indexOf(value) < 0) {
            console.error("footerPosition property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      draggable: {
        type: Boolean,
        default: true
      },
      scrollable: {
        type: Boolean,
        default: false
      },
      loading: {
        type: Boolean,
        default: false
      },
      confirmLoading: {
        type: Boolean,
        default: false
      },
      zIndex: {
        type: Number,
        default: 1000
      },
      confirmFn: {
        type: Function,
        default: null
      },
      onClose: {
        type: Function,
        default: function _default() {}
      },
      type: {
        type: String,
        default: '',
        validator: function validator(value) {
          if (['', 'success', 'warning', 'danger', 'loading'].indexOf(value) < 0) {
            console.error("type property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      subTitle: {
        type: String
      },
      transfer: {
        type: Boolean,
        default: true
      },
      autoClose: {
        type: Boolean,
        default: true
      },
      renderDirective: {
        type: String,
        default: 'show',
        validator: function validator(value) {
          if (['show', 'if'].indexOf(value) < 0) {
            console.error("type render-directive is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      multiInstance: {
        type: Boolean,
        default: true
      },
      ignoreExistMask: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        visible: this.value,
        maskTransitionName: 'fade',
        contentTransitionName: 'ease',
        wrapShow: false,
        showHead: true,
        buttonLoading: false,
        dragData: {
          x: null,
          y: null,
          dragX: null,
          dragY: null,
          dragging: false
        },
        dialogIndex: 0,
        popUid: '',
        uuid: uuid()
      };
    },
    computed: {
      calcIcon: function calcIcon() {
        var _icon = '';
        if (this.icon) {
          return this.icon;
        }
        switch (this.type) {
          case 'success':
            _icon = 'check-1';
            break;
          case 'error':
            _icon = 'close';
            break;
          case 'warning':
            _icon = 'exclamation';
            break;
        }
        return _icon;
      },
      wrapStyles: function wrapStyles() {
        return {
          zIndex: this.transfer ? this.dialogIndex : this.dialogIndex + 1
        };
      },
      mainStyles: function mainStyles() {
        var ret = {};
        var width = _parseInt$2(this.width, 10);
        var styleWidth = this.dragData.x !== null ? {
          top: 0
        } : {
          width: width <= 100 ? "".concat(width, "%") : "".concat(width, "px")
        };
        _extends(ret, styleWidth);
        if (this.position) {
          var left = this.position.left;
          if (left !== undefined && left !== null) {
            ret.left = "".concat(left, "px");
          }
          var top = this.position.top;
          if (top !== undefined && top !== null) {
            ret.top = "".concat(top, "px");
          }
        }
        return ret;
      },
      contentStyles: function contentStyles() {
        var ret = {};
        if (this.isDraggable) {
          if (this.dragData.x !== null) {
            var left = 0;
            if (this.position) {
              if (this.position.left !== undefined && this.position.left !== null) {
                left = this.position.left;
              }
            }
            ret.left = "".concat(this.dragData.x - left, "px");
          }
          if (this.dragData.y !== null) {
            var top = 0;
            if (this.position) {
              if (this.position.top !== undefined && this.position.top !== null) {
                top = this.position.top;
              }
            }
            ret.top = "".concat(this.dragData.y - top, "px");
          }
          var width = _parseInt$2(this.width, 10);
          var styleWidth = {
            width: width <= 100 ? "".concat(width, "%") : "".concat(width, "px")
          };
          _extends(ret, styleWidth);
        }
        return ret;
      },
      localeOkText: function localeOkText() {
        if (this.okText === undefined) {
          return this.t('bk.dialog.ok');
        }
        return this.okText;
      },
      localeCancelText: function localeCancelText() {
        if (this.cancelText === undefined) {
          return this.t('bk.dialog.cancel');
        }
        return this.cancelText;
      },
      isDraggable: function isDraggable() {
        if (!this.fullscreen) {
          return this.draggable;
        }
        return false;
      },
      isInfoBox: function isInfoBox() {
        return this.$root.name === 'bk-info-box';
      },
      shouldRender: function shouldRender() {
        return this.renderDirective === 'show';
      }
    },
    watch: {
      value: function value(val) {
        this.visible = val;
      },
      visible: function visible(val) {
        var _this = this;
        if (val === false) {
          this.buttonLoading = false;
          this.timer = setTimeout(function () {
            _this.wrapShow = false;
            if (_this.isDraggable) {
              _this.dragData = _extends({}, {
                x: null,
                y: null,
                dragX: null,
                dragY: null,
                dragging: false
              });
            }
            _this.removeScrollEffect();
          }, 300);
          this.showMask && popManager.hide(this.popUid);
        } else {
          this.addScrollEffect();
          this.$nextTick(function () {
            if (_this.timer) {
              clearTimeout(_this.timer);
            }
            _this.wrapShow = true;
            if (!_this.fullscreen) {
              setTimeout(function () {
                var contentNode = _this.$refs.content;
                var height = _parseInt$2(window.getComputedStyle(contentNode).height, 10);
                if (height >= window.innerHeight) {
                  contentNode.style.marginBottom = '50px';
                }
              }, 0);
            }
            _this.dialogIndex = _this.getLocalZIndex();
            if (_this.showMask) {
              var options = {
                tplAction: 'keepAll',
                zIndex: _this.dialogIndex,
                ignoreExistMask: _this.ignoreExistMask
              };
              _this.popUid = popManager.show("bk-dialog-".concat(_this.uuid), _this.$el, options);
            }
          });
        }
        this.$emit('value-change', val);
        typeof this.stateChangeFn === 'function' && this.stateChangeFn(val);
      },
      loading: function loading(val) {
        if (!val) {
          this.buttonLoading = false;
        }
      },
      scrollable: function scrollable(val) {
      },
      title: function title(val) {
        if (this.$slots.header === undefined) {
          this.showHead = !!val;
        }
      }
    },
    mounted: function mounted() {
      if (this.visible) {
        this.wrapShow = true;
      }
      var showHead = true;
      if (this.$slots.header === undefined && !this.title) {
        showHead = false;
      }
      this.showHead = showHead;
      if (this.escClose) {
        addEvent(document, 'keydown', this.escCloseHandler);
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.escClose) {
        removeEvent(document, 'keydown', this.escCloseHandler);
      }
      this.removeScrollEffect();
      this.visible && this.showMask && popManager.hide(this.popUid);
    },
    methods: {
      getDialogIndex: function getDialogIndex() {
        return this.getLocalZIndex();
      },
      maskClickHandler: function maskClickHandler() {
        if (this.maskClose && this.showMask && this.closeIcon) {
          this.close();
        }
      },
      wrapClickHandler: function wrapClickHandler(e) {
        var classList = e.target.classList;
        if (classList.contains('bk-dialog-wrapper')) {
          this.maskClickHandler();
        }
      },
      contentClickHandler: function contentClickHandler(e) {
        if (this.isDraggable) ;
      },
      escCloseHandler: function escCloseHandler(e) {
        if (this.visible && this.closeIcon) {
          if (e.keyCode === 27) {
            var first = null;
            if (this.isInfoBox) {
              first = this.$root;
            } else {
              var dialogs = findChildComponents(this.$root, 'bk-dialog').filter(function (item) {
                return item.$data.visible && item.$props.closeIcon;
              });
              first = dialogs.sort(function (a, b) {
                return a.$data.dialogIndex < b.$data.dialogIndex ? 1 : -1;
              })[0];
            }
            this.$nextTick(function () {
              first && first.close();
            });
          }
        }
      },
      moveStartHandler: function moveStartHandler(e) {
        if (!this.isDraggable) {
          return false;
        }
        var content = this.$refs.content;
        var rect = content.getBoundingClientRect();
        this.dragData.x = rect.x;
        this.dragData.y = rect.y;
        this.dragData.contentRect = rect;
        this.dragData.dialogRect = this.$el.getBoundingClientRect();
        var distance = {
          x: e.clientX,
          y: e.clientY
        };
        this.dragData.dragX = distance.x;
        this.dragData.dragY = distance.y;
        this.dragData.dragging = true;
        addEvent(window, 'mousemove', this.moveHandler);
        addEvent(window, 'mouseup', this.moveEndHandler);
      },
      moveHandler: function moveHandler(e) {
        var dragData = this.dragData;
        if (!dragData.dragging) {
          return false;
        }
        var distance = {
          x: e.clientX,
          y: e.clientY
        };
        var diffDistance = {
          x: distance.x - dragData.dragX,
          y: distance.y - dragData.dragY
        };
        if (dragData.x <= 0 && diffDistance.x < 0) {
          dragData.x = 0;
        } else if (dragData.x + dragData.contentRect.width >= window.innerWidth && diffDistance.x > 0) {
          dragData.x = window.innerWidth - dragData.contentRect.width;
        } else {
          dragData.x += diffDistance.x;
        }
        dragData.dragX = distance.x;
        if (dragData.y <= 0 && diffDistance.y < 0) {
          dragData.y = 0;
        } else if (dragData.y + dragData.contentRect.height >= window.innerHeight && diffDistance.y > 0) {
          dragData.y = window.innerHeight - dragData.contentRect.height;
        } else {
          dragData.y += diffDistance.y;
        }
        dragData.dragY = distance.y;
        this.dragData = _objectSpread({}, dragData);
      },
      moveEndHandler: function moveEndHandler() {
        this.dragData.dragging = false;
        removeEvent(window, 'mousemove', this.moveHandler);
        removeEvent(window, 'mouseup', this.moveEndHandler);
      },
      close: function close() {
        var _this2 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var shouldClose;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  shouldClose = true;
                  if (!(typeof _this2.beforeClose === 'function')) {
                    _context.next = 5;
                    break;
                  }
                  _context.next = 4;
                  return _this2.beforeClose();
                case 4:
                  shouldClose = _context.sent;
                case 5:
                  if (shouldClose) {
                    _this2.visible = false;
                    typeof _this2.onClose === 'function' && _this2.onClose();
                    _this2.$emit('input', false);
                    _this2.$emit('cancel');
                    typeof _this2.cancelFn === 'function' && _this2.cancelFn(_this2);
                  }
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      animationFinish: function animationFinish() {
        this.$emit('after-leave');
        typeof this.afterLeaveFn === 'function' && this.afterLeaveFn(this);
      },
      cancelHandler: function cancelHandler(e) {
        this.close();
      },
      okHandler: function okHandler(e) {
        var _this3 = this;
        if (this.loading) return false;
        this.$emit('confirm');
        this.$nextTick( _asyncToGenerator( regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!_this3.loading) {
                    _context2.next = 4;
                    break;
                  }
                  _this3.buttonLoading = true;
                  _context2.next = 24;
                  break;
                case 4:
                  if (!(typeof _this3.confirmFn === 'function')) {
                    _context2.next = 23;
                    break;
                  }
                  if (!_this3.confirmLoading) {
                    _context2.next = 20;
                    break;
                  }
                  _context2.prev = 6;
                  _this3.buttonLoading = true;
                  _context2.next = 10;
                  return _this3.confirmFn(_this3);
                case 10:
                  _context2.next = 15;
                  break;
                case 12:
                  _context2.prev = 12;
                  _context2.t0 = _context2["catch"](6);
                  console.warn(_context2.t0);
                case 15:
                  _context2.prev = 15;
                  _this3.buttonLoading = false;
                  return _context2.finish(15);
                case 18:
                  _context2.next = 21;
                  break;
                case 20:
                  _this3.confirmFn(_this3);
                case 21:
                  _context2.next = 24;
                  break;
                case 23:
                  if (_this3.autoClose) {
                    _this3.visible = false;
                    _this3.$emit('input', false);
                  }
                case 24:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[6, 12, 15, 18]]);
        })));
      }
    }
  };

  var img = new Image(); img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAA6CAYAAADhu0ooAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsSAAALEgHS3X78AAAJSUlEQVRo3s2aW6gdVxmAv3/OzsnJ7TRtopO2JkaqtU4IUrUSwQdBLGmDaMmbIIi3irYoFn0SzxzQUkGwvorE24tUhCoqXjAkVWmo1XppB9qkrUpKnbSWJuck6bns+X1Ya838s/bsc0nOyc6Czd579uyZ9a3//q8R1mFkZT4OvBs4ANwMegvIbuA6YFJgFvgz8C2FX/q/KUCR5roec5K1utC+cuoahcMgdwHvBd3iLy/NSwUQad/2foWvmvPCqIBqrcAvGzQrpzKQzwOHgS0NkODfLSQgIoP3/bCXrFmUen4VsFikeTUS0KzM94B+DeRDoL0AEU1WDGy4X9Jx02MKH+gATcz3PjB/qcCrBvX2dy/wZWDTIFAtTT9Je2wo6Iw6+03MvLqkm3jYuXUFzcr8JuC7oLc2EG7lBUQdMOa3MLnW5DtUd1bhWkBQEmQADlrS1T7IhdVIN1npiVmZHwI9Crzd309BvaNQVU/YDDUfwq/KwGluPF5DNEsQS9PKZwzYlpX5hjUFzcqpj4MeAdlqJq9eRe08tP3ZzFnCeZ1K9O0ht5Yh34Okt2VlPrEmoFk5dR/wQHOuqgFST6ANfH2MRuJdc67H/Qq/WAKyy1atJ9+alfnm5TiWtNGszD8G+g0TIjDOpcPDIs4JtX5LmklJsNELwGPAgwq/iqQU/a/zty4bni3S/OKqQbMyvxP0OyC97hVVAUk6vGziFyQBCuAYcAJ4GvQ0yGyR5vP+HjaMhFfHInVB1gtnnd3ZIs1fWzFoVk7tBfk1MGlUZCkva6V4Efge8KMizZ9aTqWixRWgB2xow7Wg7OLY93D85SLNF5cF9XHyZ8B+r4ZWihgpttI6oAI5AjxQpPn/VgM4BHjcv2Lpdqm1fS142JZ773Xc59Og+/w1quaCqh5S2+sjgD4L3F2k+V8vBzAMP8m5rMwXgc0Mqu4wSAEdB9kGnBsq0azMdwO/8xenrbIDmU/4fhT4VJFOz6wFZDy8dLcCG/0hq6pdn8P4r1Xh+McvuQtqhQ8ZglT+u3+J/00U9GHgo+sFCU66RZrPAPO0nZO10Rg4Abbb69SgWZnvBb2DVmwUHwi7YqX+BvhckU4vrBdkBHzOw3Z55dhDJ7j4WmdOVqJ3N15VtS1FtJEkFejzIPdcKUgzzuKqmK4YbnkC8PYWaFbmW4BDXlpePQUjvZA8V8Ai8BmvTld0eCf1KpCgrbgbfw7w27IyT8wK6O2gE20VpULFQ4pfABTkh0U6/c8rDWlgF4DzPv2XJlHphE1wjiyAyqGmGgnSU0Ww6loBs6APjgrSjLP+PfEZ2EC7xoBPAogzWH0MZFNTidQ1JbRsQL9fpNNfHzUlQFbmO4BrGKx3Md/xMCd7uPpyHGebFlCjPwL8ZNSAZszguhIWqgNWAdmUONBaPYMt+s/19z7oM0U6/cyo6cLwhcECtYpql336IoPNPeBmD2Oq6NAOELs6fxw1XMe4gOtbYYoKmve6VzXRA24gdAPccW3bafij/G3UVB1jjsHqxQinFtTGHvA6QkhpWWTIZ2vq50ZNtQTosJZL+Lyxh2s6h5BiV0GNOqjAmVFTdYxFYIxuxxkgFTTpgW42uW2ts83QCkTU2cPVNvo4iYY5D9SP3h439KilSVgYbZ8oGh2/ikbdsgnfrbBCiRlOkvM0aV+fJrSEz6E02zJqrMEhY9CZ846ZY2NA1cMlyRMmK/KSk9AeCVfd6c+9msY4jY1iImQrxQPVBHiJumJpCu6oTKuAN46aqmP4NouapEGCRE3OKwsJymnqzEh8pSIVSCVNllQB2aipOsakB0nEJviqQY0D8FyCcIrGRluS1Dr9owLeMWqqjrEjAGkNpQkiUedBX0uAJ6lrTRSkP6S7sMf1e6+O4ZoFuo12oW2dk3nJjO+m68UGTkPPqJJapeuFODhqQDNupFFP42UlSupVgZnEV+x/b7oIUoOpg++D9p29ysGszCdHTeib7HtceNFYghIdO1ekeRU6DMdpyjRjp1KXburi6jjwkVGDAm9hoIuvXTE0AXkJQuav+ghwMXT6pJFq5ImpgDuyMn/zqAizMt8OvInaJsWqbPxZceHTgRa7pmeA4zTeVts2i8mSFNAvrmRPch0gNwDvcoAavGycHdnXGW+arb7uQybtCzmukaTd5JVdwL1ZOTV2BSET4DZcn2iskZpE3rYF/q/w/xq0SPN/C/IH6hBDR4iRyi2GVsA7Qe7ZV+brDushDwBvoGWXsSTDJrSKuL2X2QFQAEWP4PY3VdppYXjvG3tV4IDCfVk5tWkdITeAvg/YS2eMpMM2pVJo9bdaoEU6XQI/xoUWo6p1bDWN7Fra+0Gm3d7NmkPuBD4IcuOgFNXEyoEO/XNFmrfq56790YeBAyA3UdeqTQKhdee+tuMKeD3IV7Iy/z3w8yLNz18m4AQu5XyrO+KKf5pCu/LSq2i8a1j8c8Cp+JpDtvbz64FvAhPRRWxO3HfgNhRRARdBj6M8WuyafnGVgDuAtwG34OtI//BU1Ia1MT6YkSrIPHC0a6GXeljjPcAXfCA2e6It4H60NxMyqeDQXgCeBp7H9ZxeBeZ96Tvuc9XrQK4H3Q1yLa1CIt6XrZsAJrGReuFBThRp/kIXz3KP39wO+gkLKY39hhvGK155SBN/6ZtFCccWm4lrP/L0sdeP/YLZD3JmJMjjT6X5s8NYlnygqkjz34I8ZFdRmxUOIYdGdcJxiCQfhpo385TLwB7PsAQgetVe9smlIJcF9bA/BX7gVzl6aqyVFwegsCtnzqlbHQEsAg7949bmloVPTEM93vz9y0oe85HlTggjK6duA/kk6EYGdsBj1aptKbbbCliUWjO0b87rd5y7hNoyB/ypSPP/rGT+KwYF2FdOpYp8FthNSzU1SDs4LdtB1AjIJh8WcohzC32sljN6GfRYkU6fW+ncVwXqJdsDOQjciYvDkZsfcCJWqlH5F6eadXOub8DMAuo8yBPAP1b7JPaqQQ3wDpDDuIeUh4FaaZotyM6FaElRXBpnYU8BJy712YlLBm2A8xuA9+MymRDka0mIK9pjm7Vtm0iiYlV4AZezPlGk+SuXM8/LBjXAm4Fbgf3AXoGedjopIhsccGDzoKeBkyAnhz2tOTLQCHoM1/DeA7oT2IF7ensjzq4VdM5vh5wHXgHOOEB5sUjz/lrP6f89wbRxX0nsEwAAAABJRU5ErkJggg=='; var __$_require_ui_images_default_loading_png__ = img.src;

  /* script */
  var __vue_script__$u = script$u;

  var __vue_render__$u = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "transfer-dom",
        rawName: "v-transfer-dom"
      }],
      staticStyle: {
        "position": "absolute",
        "top": "-100000px",
        "left": "-100000px"
      },
      attrs: {
        "data-transfer": _vm.transfer
      }
    }, [_c('div', {
      ref: "dialog_wrapper",
      staticClass: "bk-dialog-wrapper",
      class: [_vm.showMask ? '' : 'bk-dialog-no-mask', _vm.wrapShow ? '' : 'bk-dialog-hidden', _vm.extCls],
      style: _vm.wrapStyles,
      on: {
        "mousedown": function mousedown($event) {
          $event.stopPropagation();
          return _vm.wrapClickHandler($event);
        }
      }
    }, [_c('transition', {
      attrs: {
        "name": _vm.contentTransitionName
      },
      on: {
        "after-leave": _vm.animationFinish
      }
    }, [_vm.isInfoBox ? [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      staticClass: "bk-dialog bk-info-box",
      style: [_vm.mainStyles]
    }, [_c('div', {
      ref: "content",
      class: ['bk-dialog-content', _vm.isDraggable ? 'bk-dialog-content-drag' : '', _vm.isDraggable && _vm.dragData.dragging ? 'bk-dialog-content-dragging' : ''],
      style: [_vm.contentStyles],
      on: {
        "click": _vm.contentClickHandler
      }
    }, [_c('div', {
      staticClass: "bk-dialog-tool",
      on: {
        "mousedown": function mousedown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
            return null;
          }

          if ('button' in $event && $event.button !== 0) {
            return null;
          }

          return _vm.moveStartHandler($event);
        }
      }
    }, [_vm._t("tools")], 2), _vm.type ? [_c('div', {
      staticClass: "bk-dialog-type-body",
      class: _vm.type === 'loading' ? 'loading' : ''
    }, [_vm._t("type-body", [_vm.type === 'loading' ? [_c('img', {
      staticClass: "bk-dialog-loading",
      attrs: {
        "src": __$_require_ui_images_default_loading_png__,
        "alt": "loading"
      }
    })] : [_c('i', {
      staticClass: "bk-icon bk-dialog-mark",
      class: ['bk-dialog-' + _vm.type, 'icon-' + _vm.calcIcon]
    })]])], 2), _vm.title || _vm.$slots['type-header'] ? _c('div', {
      staticClass: "bk-dialog-type-header",
      class: [_vm.type === 'loading' ? 'loading' : '', _vm.subTitle || _vm.$slots['type-sub-header'] ? 'has-sub-header' : '']
    }, [_c('div', {
      staticClass: "header"
    }, [_vm._t("type-header", [_vm._v(_vm._s(_vm.title))])], 2)]) : _vm._e(), _vm.subTitle || _vm.$slots['type-sub-header'] ? _c('div', {
      staticClass: "bk-dialog-type-sub-header",
      class: _vm.type === 'loading' ? 'loading' : ''
    }, [_c('div', {
      staticClass: "header"
    }, [_vm._t("type-sub-header", [_vm._v(_vm._s(_vm.subTitle))])], 2)]) : _vm._e(), _vm.showFooter ? _c('div', {
      staticClass: "bk-dialog-footer"
    }, [_vm._t("footer", [_c('div', {
      staticClass: "footer-wrapper"
    }, [_c('bk-button', {
      attrs: {
        "type": "button",
        "name": "confirm",
        "loading": _vm.buttonLoading,
        "theme": _vm.theme
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.okHandler($event);
        }
      }
    }, [_vm._v("\n                                            " + _vm._s(_vm.localeOkText) + "\n                                        ")]), _c('bk-button', {
      attrs: {
        "type": "button",
        "name": "cancel",
        "disabled": _vm.buttonLoading
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.cancelHandler($event);
        }
      }
    }, [_vm._v("\n                                            " + _vm._s(_vm.localeCancelText) + "\n                                        ")])], 1)])], 2) : _vm._e()] : [_vm.showHead ? _c('div', {
      staticClass: "bk-dialog-header"
    }, [_vm._t("header", [_c('div', {
      staticClass: "bk-dialog-header-inner"
    }, [_vm._v(_vm._s(_vm.title))])])], 2) : _vm._e(), _c('div', {
      staticClass: "bk-dialog-sub-header",
      class: _vm.subTitle || _vm.$slots['sub-header'] ? 'has-sub' : ''
    }, [_vm._t("sub-header", [_c('div', {
      staticClass: "bk-dialog-header-inner"
    }, [_vm._v(_vm._s(_vm.subTitle))])])], 2), _vm.showFooter ? _c('div', {
      staticClass: "bk-dialog-footer"
    }, [_vm._t("footer", [_c('div', {
      staticClass: "footer-wrapper"
    }, [_c('bk-button', {
      attrs: {
        "type": "button",
        "name": "confirm",
        "loading": _vm.buttonLoading,
        "theme": _vm.theme
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.okHandler($event);
        }
      }
    }, [_vm._v("\n                                            " + _vm._s(_vm.localeOkText) + "\n                                        ")]), _c('bk-button', {
      attrs: {
        "type": "button",
        "name": "cancel",
        "disabled": _vm.buttonLoading
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.cancelHandler($event);
        }
      }
    }, [_vm._v("\n                                            " + _vm._s(_vm.localeCancelText) + "\n                                        ")])], 1)])], 2) : _vm._e()], _vm.closeIcon ? _c('i', {
      staticClass: "bk-dialog-close bk-icon icon-close",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.cancelHandler($event);
        }
      }
    }) : _vm._e()], 2)])] : [_vm.shouldRender || _vm.visible ? _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      class: ['bk-dialog', _vm.fullscreen ? 'bk-dialog-fullscreen' : '', _vm.fullscreen && !_vm.showHead ? 'bk-dialog-fullscreen-no-header' : '', _vm.fullscreen && !_vm.showFooter ? 'bk-dialog-fullscreen-no-footer' : ''],
      style: [_vm.mainStyles]
    }, [_c('div', {
      ref: "content",
      class: ['bk-dialog-content', _vm.showMask ? '' : 'bk-dialog-content-no-mask', _vm.isDraggable ? 'bk-dialog-content-drag' : '', _vm.isDraggable && _vm.dragData.dragging ? 'bk-dialog-content-dragging' : ''],
      style: [_vm.contentStyles],
      on: {
        "click": _vm.contentClickHandler
      }
    }, [_c('div', {
      staticClass: "bk-dialog-tool",
      on: {
        "mousedown": function mousedown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
            return null;
          }

          if ('button' in $event && $event.button !== 0) {
            return null;
          }

          return _vm.moveStartHandler($event);
        }
      }
    }, [_vm._t("tools")], 2), _vm.showHead ? _c('div', {
      class: {
        'bk-dialog-header': true,
        'header-on-left': _vm.headerPosition === 'left'
      },
      style: {
        textAlign: _vm.headerPosition
      }
    }, [_vm._t("header", [_c('div', {
      class: {
        'bk-dialog-header-inner': true,
        'header-center': _vm.headerPosition === 'center'
      }
    }, [_vm._v(_vm._s(_vm.title))])])], 2) : _vm._e(), _c('div', {
      staticClass: "bk-dialog-body"
    }, [_vm._t("default")], 2), _vm.showFooter ? _c('div', {
      staticClass: "bk-dialog-footer",
      style: {
        textAlign: _vm.footerPosition
      }
    }, [_vm._t("footer", [_c('div', {
      staticClass: "footer-wrapper"
    }, [_c('bk-button', {
      attrs: {
        "type": "button",
        "name": "confirm",
        "loading": _vm.buttonLoading,
        "theme": _vm.theme
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.okHandler($event);
        }
      }
    }, [_vm._v("\n                                        " + _vm._s(_vm.localeOkText) + "\n                                    ")]), _c('bk-button', {
      attrs: {
        "type": "button",
        "name": "cancel",
        "disabled": _vm.buttonLoading
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.cancelHandler($event);
        }
      }
    }, [_vm._v("\n                                        " + _vm._s(_vm.localeCancelText) + "\n                                    ")])], 1)])], 2) : _vm._e(), _vm.closeIcon ? _c('i', {
      staticClass: "bk-dialog-close bk-icon icon-close",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.cancelHandler($event);
        }
      }
    }) : _vm._e()])]) : _vm._e()]], 2)], 1)]);
  };

  var __vue_staticRenderFns__$u = [];
  /* style */

  var __vue_inject_styles__$u = undefined;
  /* scoped */

  var __vue_scope_id__$u = undefined;
  /* module identifier */

  var __vue_module_identifier__$u = undefined;
  /* functional template */

  var __vue_is_functional_template__$u = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$u = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$u,
    staticRenderFns: __vue_staticRenderFns__$u
  }, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$u);

  var diff = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
     factory(exports) ;
  }(commonjsGlobal, function (exports) {  function Diff() {}
    Diff.prototype = {
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === 'function') {
          callback = options;
          options = {};
        }
        this.options = options;
        var self = this;
        function done(value) {
          if (callback) {
            setTimeout(function () {
              callback(undefined, value);
            }, 0);
            return true;
          } else {
            return value;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length,
            oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = void 0;
            var addPath = bestPath[diagonalPath - 1],
                removePath = bestPath[diagonalPath + 1],
                _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = undefined;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen,
                canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = undefined;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self.pushComponent(basePath.components, undefined, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self.pushComponent(basePath.components, true, undefined);
            }
            _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function () {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added: added,
            removed: removed
          };
        } else {
          components.push({
            count: 1,
            added: added,
            removed: removed
          });
        }
      },
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length,
            oldLen = oldString.length,
            newPos = basePath.newPos,
            oldPos = newPos - diagonalPath,
            commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      castInput: function castInput(value) {
        return value;
      },
      tokenize: function tokenize(value) {
        return value.split('');
      },
      join: function join(chars) {
        return chars.join('');
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0,
          componentLen = components.length,
          newPos = 0,
          oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value = newString.slice(newPos, newPos + component.count);
            value = value.map(function (value, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value.length ? oldValue : value;
            });
            component.value = diff.join(value);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
    var characterDiff = new Diff();
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
    function generateOptions(options, defaults) {
      if (typeof options === 'function') {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new Diff();
    wordDiff.equals = function (left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function (value) {
      var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, options) {
      options = generateOptions(options, {
        ignoreWhitespace: true
      });
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, options) {
      return wordDiff.diff(oldStr, newStr, options);
    }
    var lineDiff = new Diff();
    lineDiff.tokenize = function (value) {
      var retLines = [],
          linesAndNewlines = value.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = generateOptions(callback, {
        ignoreWhitespace: true
      });
      return lineDiff.diff(oldStr, newStr, options);
    }
    var sentenceDiff = new Diff();
    sentenceDiff.tokenize = function (value) {
      return value.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
    var cssDiff = new Diff();
    cssDiff.tokenize = function (value) {
      return value.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }
      return _typeof(obj);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
        return arr2;
      }
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new Diff();
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = lineDiff.tokenize;
    jsonDiff.castInput = function (value) {
      var _this$options = this.options,
          undefinedReplacement = _this$options.undefinedReplacement,
          _this$options$stringi = _this$options.stringifyReplacer,
          stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
        return typeof v === 'undefined' ? undefinedReplacement : v;
      } : _this$options$stringi;
      return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
    };
    jsonDiff.equals = function (left, right) {
      return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ('[object Array]' === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (_typeof(obj) === 'object' && obj !== null) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [],
            _key;
        for (_key in obj) {
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
    var arrayDiff = new Diff();
    arrayDiff.tokenize = function (value) {
      return value.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function (value) {
      return value;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
    function parsePatch(uniDiff) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
          delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
          list = [],
          i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
          var data = fileHeader[2].split('\t', 2);
          var fileName = data[0].replace(/\\\\/g, '\\');
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          index[keyPrefix + 'FileName'] = fileName;
          index[keyPrefix + 'Header'] = (data[1] || '').trim();
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i,
            chunkHeaderLine = diffstr[i++],
            chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: +chunkHeader[2] || 1,
          newStart: +chunkHeader[3],
          newLines: +chunkHeader[4] || 1,
          lines: [],
          linedelimiters: []
        };
        var addCount = 0,
            removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
            break;
          }
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];
          if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || '\n');
            if (operation === '+') {
              addCount++;
            } else if (operation === '-') {
              removeCount++;
            } else if (operation === ' ') {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
    function distanceIterator (start, minLine, maxLine) {
      var wantForward = true,
          backwardExhausted = false,
          forwardExhausted = false,
          localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    }
    function applyPatch(source, uniDiff) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (typeof uniDiff === 'string') {
        uniDiff = parsePatch(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error('applyPatch only works with a single input.');
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
          delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
          hunks = uniDiff.hunks,
          compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
        return line === patchContent;
      },
          errorCount = 0,
          fuzzFactor = options.fuzzFactor || 0,
          minLine = 0,
          offset = 0,
          removeEOFNL,
          addEOFNL;
      function hunkFits(hunk, toPos) {
        for (var j = 0; j < hunk.lines.length; j++) {
          var line = hunk.lines[j],
              operation = line.length > 0 ? line[0] : ' ',
              content = line.length > 0 ? line.substr(1) : line;
          if (operation === ' ' || operation === '-') {
            if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i],
            maxLine = lines.length - hunk.oldLines,
            localOffset = 0,
            toPos = offset + hunk.oldStart - 1;
        var iterator = distanceIterator(toPos, minLine, maxLine);
        for (; localOffset !== undefined; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === undefined) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      var diffOffset = 0;
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i],
            _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        if (_toPos < 0) {
          _toPos = 0;
        }
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j],
              operation = line.length > 0 ? line[0] : ' ',
              content = line.length > 0 ? line.substr(1) : line,
              delimiter = _hunk.linedelimiters[j];
          if (operation === ' ') {
            _toPos++;
          } else if (operation === '-') {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === '+') {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === '\\') {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === '+') {
              removeEOFNL = true;
            } else if (previousOperation === '-') {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push('');
        delimiters.push('\n');
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join('');
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === 'string') {
        uniDiff = parsePatch(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function (err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function (err) {
            if (err) {
              return options.complete(err);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === 'undefined') {
        options.context = 4;
      }
      var diff = diffLines(oldStr, newStr, options);
      diff.push({
        value: '',
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function (entry) {
          return ' ' + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0,
          newRangeStart = 0,
          curRange = [],
          oldLine = 1,
          newLine = 1;
      var _loop = function _loop(i) {
        var current = diff[i],
            lines = current.lines || current.value.replace(/\n$/, '').split('\n');
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
            return (current.added ? '+' : '-') + entry;
          })));
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i < diff.length - 2) {
              var _curRange2;
              (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                if (!oldEOFNewline && noNlBeforeAdds) {
                  curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
                }
                if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                  curRange.push('\\ No newline at end of file');
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(i);
      }
      return {
        oldFileName: oldFileName,
        newFileName: newFileName,
        oldHeader: oldHeader,
        newHeader: newHeader,
        hunks: hunks
      };
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
      var ret = [];
      if (oldFileName == newFileName) {
        ret.push('Index: ' + oldFileName);
      }
      ret.push('===================================================================');
      ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
      ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join('\n') + '\n';
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return arrayStartsWith(a, b);
    }
    function arrayStartsWith(array, start) {
      if (start.length > array.length) {
        return false;
      }
      for (var i = 0; i < start.length; i++) {
        if (start[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
    function calcLineCount(hunk) {
      var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
          oldLines = _calcOldNewLineCount.oldLines,
          newLines = _calcOldNewLineCount.newLines;
      if (oldLines !== undefined) {
        hunk.oldLines = oldLines;
      } else {
        delete hunk.oldLines;
      }
      if (newLines !== undefined) {
        hunk.newLines = newLines;
      } else {
        delete hunk.newLines;
      }
    }
    function merge(mine, theirs, base) {
      mine = loadPatch(mine, base);
      theirs = loadPatch(theirs, base);
      var ret = {};
      if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
      }
      if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
          ret.oldFileName = theirs.oldFileName || mine.oldFileName;
          ret.newFileName = theirs.newFileName || mine.newFileName;
          ret.oldHeader = theirs.oldHeader || mine.oldHeader;
          ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
          ret.oldFileName = mine.oldFileName;
          ret.newFileName = mine.newFileName;
          ret.oldHeader = mine.oldHeader;
          ret.newHeader = mine.newHeader;
        } else {
          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
      }
      ret.hunks = [];
      var mineIndex = 0,
          theirsIndex = 0,
          mineOffset = 0,
          theirsOffset = 0;
      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
        var mineCurrent = mine.hunks[mineIndex] || {
          oldStart: Infinity
        },
            theirsCurrent = theirs.hunks[theirsIndex] || {
          oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
          mineIndex++;
          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
          theirsIndex++;
          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
          var mergedHunk = {
            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
            oldLines: 0,
            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
            newLines: 0,
            lines: []
          };
          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
          theirsIndex++;
          mineIndex++;
          ret.hunks.push(mergedHunk);
        }
      }
      return ret;
    }
    function loadPatch(param, base) {
      if (typeof param === 'string') {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
          return parsePatch(param)[0];
        }
        if (!base) {
          throw new Error('Must provide a base reference or pass in a patch');
        }
        return structuredPatch(undefined, undefined, base, param);
      }
      return param;
    }
    function fileNameChanged(patch) {
      return patch.newFileName && patch.newFileName !== patch.oldFileName;
    }
    function selectField(index, mine, theirs) {
      if (mine === theirs) {
        return mine;
      } else {
        index.conflict = true;
        return {
          mine: mine,
          theirs: theirs
        };
      }
    }
    function hunkBefore(test, check) {
      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
    }
    function cloneHunk(hunk, offset) {
      return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
      };
    }
    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
      var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
      },
          their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
      };
      insertLeading(hunk, mine, their);
      insertLeading(hunk, their, mine);
      while (mine.index < mine.lines.length && their.index < their.lines.length) {
        var mineCurrent = mine.lines[mine.index],
            theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
          mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
          var _hunk$lines;
          (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
        } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
          var _hunk$lines2;
          (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
        } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
          removal(hunk, mine, their);
        } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
          removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
          hunk.lines.push(mineCurrent);
          mine.index++;
          their.index++;
        } else {
          conflict(hunk, collectChange(mine), collectChange(their));
        }
      }
      insertTrailing(hunk, mine);
      insertTrailing(hunk, their);
      calcLineCount(hunk);
    }
    function mutualChange(hunk, mine, their) {
      var myChanges = collectChange(mine),
          theirChanges = collectChange(their);
      if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
          var _hunk$lines3;
          (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
          return;
        } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
          var _hunk$lines4;
          (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
          return;
        }
      } else if (arrayEqual(myChanges, theirChanges)) {
        var _hunk$lines5;
        (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
        return;
      }
      conflict(hunk, myChanges, theirChanges);
    }
    function removal(hunk, mine, their, swap) {
      var myChanges = collectChange(mine),
          theirChanges = collectContext(their, myChanges);
      if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
      } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
    }
    function conflict(hunk, mine, their) {
      hunk.conflict = true;
      hunk.lines.push({
        conflict: true,
        mine: mine,
        theirs: their
      });
    }
    function insertLeading(hunk, insert, their) {
      while (insert.offset < their.offset && insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
      }
    }
    function insertTrailing(hunk, insert) {
      while (insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
      }
    }
    function collectChange(state) {
      var ret = [],
          operation = state.lines[state.index][0];
      while (state.index < state.lines.length) {
        var line = state.lines[state.index];
        if (operation === '-' && line[0] === '+') {
          operation = '+';
        }
        if (operation === line[0]) {
          ret.push(line);
          state.index++;
        } else {
          break;
        }
      }
      return ret;
    }
    function collectContext(state, matchChanges) {
      var changes = [],
          merged = [],
          matchIndex = 0,
          contextChanges = false,
          conflicted = false;
      while (matchIndex < matchChanges.length && state.index < state.lines.length) {
        var change = state.lines[state.index],
            match = matchChanges[matchIndex];
        if (match[0] === '+') {
          break;
        }
        contextChanges = contextChanges || change[0] !== ' ';
        merged.push(match);
        matchIndex++;
        if (change[0] === '+') {
          conflicted = true;
          while (change[0] === '+') {
            changes.push(change);
            change = state.lines[++state.index];
          }
        }
        if (match.substr(1) === change.substr(1)) {
          changes.push(change);
          state.index++;
        } else {
          conflicted = true;
        }
      }
      if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
        conflicted = true;
      }
      if (conflicted) {
        return changes;
      }
      while (matchIndex < matchChanges.length) {
        merged.push(matchChanges[matchIndex++]);
      }
      return {
        merged: merged,
        changes: changes
      };
    }
    function allRemoves(changes) {
      return changes.reduce(function (prev, change) {
        return prev && change[0] === '-';
      }, true);
    }
    function skipRemoveSuperset(state, removeChanges, delta) {
      for (var i = 0; i < delta; i++) {
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== ' ' + changeContent) {
          return false;
        }
      }
      state.index += delta;
      return true;
    }
    function calcOldNewLineCount(lines) {
      var oldLines = 0;
      var newLines = 0;
      lines.forEach(function (line) {
        if (typeof line !== 'string') {
          var myCount = calcOldNewLineCount(line.mine);
          var theirCount = calcOldNewLineCount(line.theirs);
          if (oldLines !== undefined) {
            if (myCount.oldLines === theirCount.oldLines) {
              oldLines += myCount.oldLines;
            } else {
              oldLines = undefined;
            }
          }
          if (newLines !== undefined) {
            if (myCount.newLines === theirCount.newLines) {
              newLines += myCount.newLines;
            } else {
              newLines = undefined;
            }
          }
        } else {
          if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
            newLines++;
          }
          if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
            oldLines++;
          }
        }
      });
      return {
        oldLines: oldLines,
        newLines: newLines
      };
    }
    function convertChangesToDMP(changes) {
      var ret = [],
          change,
          operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push('<ins>');
        } else if (change.removed) {
          ret.push('<del>');
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push('</ins>');
        } else if (change.removed) {
          ret.push('</del>');
        }
      }
      return ret.join('');
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, '&amp;');
      n = n.replace(/</g, '&lt;');
      n = n.replace(/>/g, '&gt;');
      n = n.replace(/"/g, '&quot;');
      return n;
    }
    exports.Diff = Diff;
    exports.diffChars = diffChars;
    exports.diffWords = diffWords;
    exports.diffWordsWithSpace = diffWordsWithSpace;
    exports.diffLines = diffLines;
    exports.diffTrimmedLines = diffTrimmedLines;
    exports.diffSentences = diffSentences;
    exports.diffCss = diffCss;
    exports.diffJson = diffJson;
    exports.diffArrays = diffArrays;
    exports.structuredPatch = structuredPatch;
    exports.createTwoFilesPatch = createTwoFilesPatch;
    exports.createPatch = createPatch;
    exports.applyPatch = applyPatch;
    exports.applyPatches = applyPatches;
    exports.parsePatch = parsePatch;
    exports.merge = merge;
    exports.convertChangesToDMP = convertChangesToDMP;
    exports.convertChangesToXML = convertChangesToXML;
    exports.canonicalize = canonicalize;
    Object.defineProperty(exports, '__esModule', { value: true });
  }));
  });
  unwrapExports(diff);
  var diff_1 = diff.createPatch;

  var merge$1 = createCommonjsModule(function (module) {
  (function(isNode) {
  	var Public = function(clone) {
  		return merge(clone === true, false, arguments);
  	}, publicName = 'merge';
  	Public.recursive = function(clone) {
  		return merge(clone === true, true, arguments);
  	};
  	Public.clone = function(input) {
  		var output = input,
  			type = typeOf(input),
  			index, size;
  		if (type === 'array') {
  			output = [];
  			size = input.length;
  			for (index=0;index<size;++index)
  				output[index] = Public.clone(input[index]);
  		} else if (type === 'object') {
  			output = {};
  			for (index in input)
  				output[index] = Public.clone(input[index]);
  		}
  		return output;
  	};
  	function merge_recursive(base, extend) {
  		if (typeOf(base) !== 'object')
  			return extend;
  		for (var key in extend) {
  			if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {
  				base[key] = merge_recursive(base[key], extend[key]);
  			} else {
  				base[key] = extend[key];
  			}
  		}
  		return base;
  	}
  	function merge(clone, recursive, argv) {
  		var result = argv[0],
  			size = argv.length;
  		if (clone || typeOf(result) !== 'object')
  			result = {};
  		for (var index=0;index<size;++index) {
  			var item = argv[index],
  				type = typeOf(item);
  			if (type !== 'object') continue;
  			for (var key in item) {
  				if (key === '__proto__') continue;
  				var sitem = clone ? Public.clone(item[key]) : item[key];
  				if (recursive) {
  					result[key] = merge_recursive(result[key], sitem);
  				} else {
  					result[key] = sitem;
  				}
  			}
  		}
  		return result;
  	}
  	function typeOf(input) {
  		return ({}).toString.call(input).slice(8, -1).toLowerCase();
  	}
  	if (isNode) {
  		module.exports = Public;
  	} else {
  		window[publicName] = Public;
  	}
  })( module && 'object' === 'object' && module.exports);
  });

  var utils = createCommonjsModule(function (module) {
  (function() {
    var merge = merge$1;
    function Utils() {
    }
    Utils.prototype.escape = function(str) {
      return str.slice(0)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;')
        .replace(/\//g, '&#x2F;');
    };
    Utils.prototype.startsWith = function(str, start) {
      if (typeof start === 'object') {
        var result = false;
        start.forEach(function(s) {
          if (str.indexOf(s) === 0) {
            result = true;
          }
        });
        return result;
      }
      return str && str.indexOf(start) === 0;
    };
    Utils.prototype.valueOrEmpty = function(value) {
      return value || '';
    };
    Utils.prototype.safeConfig = function(cfg, defaultConfig) {
      return merge.recursive(true, defaultConfig, cfg);
    };
    module.exports.Utils = new Utils();
  })();
  });
  var utils_1 = utils.Utils;

  var diffParser = createCommonjsModule(function (module) {
  (function() {
    var utils$1 = utils.Utils;
    var LINE_TYPE = {
      INSERTS: 'd2h-ins',
      DELETES: 'd2h-del',
      INSERT_CHANGES: 'd2h-ins d2h-change',
      DELETE_CHANGES: 'd2h-del d2h-change',
      CONTEXT: 'd2h-cntx',
      INFO: 'd2h-info'
    };
    function DiffParser() {
    }
    DiffParser.prototype.LINE_TYPE = LINE_TYPE;
    DiffParser.prototype.generateDiffJson = function(diffInput, configuration) {
      var config = configuration || {};
      var files = [];
      var currentFile = null;
      var currentBlock = null;
      var oldLine = null;
      var oldLine2 = null;
      var newLine = null;
      var possibleOldName;
      var possibleNewName;
      var oldFileNameHeader = '--- ';
      var newFileNameHeader = '+++ ';
      var hunkHeaderPrefix = '@@';
      function saveBlock() {
        if (currentBlock) {
          currentFile.blocks.push(currentBlock);
          currentBlock = null;
        }
      }
      function saveFile() {
        if (currentFile) {
          if (!currentFile.oldName) {
            currentFile.oldName = possibleOldName;
          }
          if (!currentFile.newName) {
            currentFile.newName = possibleNewName;
          }
          if (currentFile.newName) {
            files.push(currentFile);
            currentFile = null;
          }
        }
        possibleOldName = undefined;
        possibleNewName = undefined;
      }
      function startFile() {
        saveBlock();
        saveFile();
        currentFile = {};
        currentFile.blocks = [];
        currentFile.deletedLines = 0;
        currentFile.addedLines = 0;
      }
      function startBlock(line) {
        saveBlock();
        var values;
        if ((values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line))) {
          currentFile.isCombined = false;
          oldLine = values[1];
          newLine = values[2];
        } else if ((values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line))) {
          currentFile.isCombined = true;
          oldLine = values[1];
          oldLine2 = values[2];
          newLine = values[3];
        } else {
          if (utils$1.startsWith(line, hunkHeaderPrefix)) {
            console.error('Failed to parse lines, starting in 0!');
          }
          oldLine = 0;
          newLine = 0;
          currentFile.isCombined = false;
        }
        currentBlock = {};
        currentBlock.lines = [];
        currentBlock.oldStartLine = oldLine;
        currentBlock.oldStartLine2 = oldLine2;
        currentBlock.newStartLine = newLine;
        currentBlock.header = line;
      }
      function createLine(line) {
        var currentLine = {};
        currentLine.content = line;
        var newLinePrefixes = !currentFile.isCombined ? ['+'] : ['+', ' +'];
        var delLinePrefixes = !currentFile.isCombined ? ['-'] : ['-', ' -'];
        if (utils$1.startsWith(line, newLinePrefixes)) {
          currentFile.addedLines++;
          currentLine.type = LINE_TYPE.INSERTS;
          currentLine.oldNumber = null;
          currentLine.newNumber = newLine++;
          currentBlock.lines.push(currentLine);
        } else if (utils$1.startsWith(line, delLinePrefixes)) {
          currentFile.deletedLines++;
          currentLine.type = LINE_TYPE.DELETES;
          currentLine.oldNumber = oldLine++;
          currentLine.newNumber = null;
          currentBlock.lines.push(currentLine);
        } else {
          currentLine.type = LINE_TYPE.CONTEXT;
          currentLine.oldNumber = oldLine++;
          currentLine.newNumber = newLine++;
          currentBlock.lines.push(currentLine);
        }
      }
      function existHunkHeader(line, lineIdx) {
        var idx = lineIdx;
        while (idx < diffLines.length - 3) {
          if (utils$1.startsWith(line, 'diff')) {
            return false;
          }
          if (
            utils$1.startsWith(diffLines[idx], oldFileNameHeader) &&
            utils$1.startsWith(diffLines[idx + 1], newFileNameHeader) &&
            utils$1.startsWith(diffLines[idx + 2], hunkHeaderPrefix)
          ) {
            return true;
          }
          idx++;
        }
        return false;
      }
      var diffLines =
        diffInput.replace(/\\ No newline at end of file/g, '')
          .replace(/\r\n?/g, '\n')
          .split('\n');
      var oldMode = /^old mode (\d{6})/;
      var newMode = /^new mode (\d{6})/;
      var deletedFileMode = /^deleted file mode (\d{6})/;
      var newFileMode = /^new file mode (\d{6})/;
      var copyFrom = /^copy from "?(.+)"?/;
      var copyTo = /^copy to "?(.+)"?/;
      var renameFrom = /^rename from "?(.+)"?/;
      var renameTo = /^rename to "?(.+)"?/;
      var similarityIndex = /^similarity index (\d+)%/;
      var dissimilarityIndex = /^dissimilarity index (\d+)%/;
      var index = /^index ([0-9a-z]+)\.\.([0-9a-z]+)\s*(\d{6})?/;
      var binaryFiles = /^Binary files (.*) and (.*) differ/;
      var binaryDiff = /^GIT binary patch/;
      var combinedIndex = /^index ([0-9a-z]+),([0-9a-z]+)\.\.([0-9a-z]+)/;
      var combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
      var combinedNewFile = /^new file mode (\d{6})/;
      var combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
      diffLines.forEach(function(line, lineIndex) {
        if (!line || utils$1.startsWith(line, '*')) {
          return;
        }
        var values;
        var prevLine = diffLines[lineIndex - 1];
        var nxtLine = diffLines[lineIndex + 1];
        var afterNxtLine = diffLines[lineIndex + 2];
        if (utils$1.startsWith(line, 'diff')) {
          startFile();
          var gitDiffStart = /^diff --git "?(.+)"? "?(.+)"?/;
          if ((values = gitDiffStart.exec(line))) {
            possibleOldName = _getFilename(null, values[1], config.dstPrefix);
            possibleNewName = _getFilename(null, values[2], config.srcPrefix);
          }
          currentFile.isGitDiff = true;
          return;
        }
        if (!currentFile ||
          (
            !currentFile.isGitDiff && currentFile &&
            (
              utils$1.startsWith(line, oldFileNameHeader) &&
              utils$1.startsWith(nxtLine, newFileNameHeader) && utils$1.startsWith(afterNxtLine, hunkHeaderPrefix)
            )
          )
        ) {
          startFile();
        }
        if (
          (utils$1.startsWith(line, oldFileNameHeader) &&
          utils$1.startsWith(nxtLine, newFileNameHeader)) ||
          (utils$1.startsWith(line, newFileNameHeader) &&
          utils$1.startsWith(prevLine, oldFileNameHeader))
        ) {
          if (currentFile && !currentFile.oldName &&
            utils$1.startsWith(line, '--- ') && (values = getSrcFilename(line, config))) {
            currentFile.oldName = values;
            currentFile.language = getExtension(currentFile.oldName, currentFile.language);
            return;
          }
          if (currentFile && !currentFile.newName &&
            utils$1.startsWith(line, '+++ ') && (values = getDstFilename(line, config))) {
            currentFile.newName = values;
            currentFile.language = getExtension(currentFile.newName, currentFile.language);
            return;
          }
        }
        if (
          (currentFile && utils$1.startsWith(line, hunkHeaderPrefix)) ||
          (currentFile.isGitDiff && currentFile && currentFile.oldName && currentFile.newName && !currentBlock)
        ) {
          startBlock(line);
          return;
        }
        if (currentBlock && (utils$1.startsWith(line, '+') || utils$1.startsWith(line, '-') || utils$1.startsWith(line, ' '))) {
          createLine(line);
          return;
        }
        var doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
        if ((values = oldMode.exec(line))) {
          currentFile.oldMode = values[1];
        } else if ((values = newMode.exec(line))) {
          currentFile.newMode = values[1];
        } else if ((values = deletedFileMode.exec(line))) {
          currentFile.deletedFileMode = values[1];
          currentFile.isDeleted = true;
        } else if ((values = newFileMode.exec(line))) {
          currentFile.newFileMode = values[1];
          currentFile.isNew = true;
        } else if ((values = copyFrom.exec(line))) {
          if (doesNotExistHunkHeader) {
            currentFile.oldName = values[1];
          }
          currentFile.isCopy = true;
        } else if ((values = copyTo.exec(line))) {
          if (doesNotExistHunkHeader) {
            currentFile.newName = values[1];
          }
          currentFile.isCopy = true;
        } else if ((values = renameFrom.exec(line))) {
          if (doesNotExistHunkHeader) {
            currentFile.oldName = values[1];
          }
          currentFile.isRename = true;
        } else if ((values = renameTo.exec(line))) {
          if (doesNotExistHunkHeader) {
            currentFile.newName = values[1];
          }
          currentFile.isRename = true;
        } else if ((values = binaryFiles.exec(line))) {
          currentFile.isBinary = true;
          currentFile.oldName = _getFilename(null, values[1], config.srcPrefix);
          currentFile.newName = _getFilename(null, values[2], config.dstPrefix);
          startBlock('Binary file');
        } else if ((values = binaryDiff.exec(line))) {
          currentFile.isBinary = true;
          startBlock(line);
        } else if ((values = similarityIndex.exec(line))) {
          currentFile.unchangedPercentage = values[1];
        } else if ((values = dissimilarityIndex.exec(line))) {
          currentFile.changedPercentage = values[1];
        } else if ((values = index.exec(line))) {
          currentFile.checksumBefore = values[1];
          currentFile.checksumAfter = values[2];
          values[3] && (currentFile.mode = values[3]);
        } else if ((values = combinedIndex.exec(line))) {
          currentFile.checksumBefore = [values[2], values[3]];
          currentFile.checksumAfter = values[1];
        } else if ((values = combinedMode.exec(line))) {
          currentFile.oldMode = [values[2], values[3]];
          currentFile.newMode = values[1];
        } else if ((values = combinedNewFile.exec(line))) {
          currentFile.newFileMode = values[1];
          currentFile.isNew = true;
        } else if ((values = combinedDeletedFile.exec(line))) {
          currentFile.deletedFileMode = values[1];
          currentFile.isDeleted = true;
        }
      });
      saveBlock();
      saveFile();
      return files;
    };
    function getExtension(filename, language) {
      var nameSplit = filename.split('.');
      if (nameSplit.length > 1) {
        return nameSplit[nameSplit.length - 1];
      }
      return language;
    }
    function getSrcFilename(line, cfg) {
      return _getFilename('---', line, cfg.srcPrefix);
    }
    function getDstFilename(line, cfg) {
      return _getFilename('\\+\\+\\+', line, cfg.dstPrefix);
    }
    function _getFilename(linePrefix, line, extraPrefix) {
      var prefixes = ['a/', 'b/', 'i/', 'w/', 'c/', 'o/'];
      if (extraPrefix) {
        prefixes.push(extraPrefix);
      }
      var FilenameRegExp;
      if (linePrefix) {
        FilenameRegExp = new RegExp('^' + linePrefix + ' "?(.+?)"?$');
      } else {
        FilenameRegExp = new RegExp('^"?(.+?)"?$');
      }
      var filename;
      var values = FilenameRegExp.exec(line);
      if (values && values[1]) {
        filename = values[1];
        var matchingPrefixes = prefixes.filter(function(p) {
          return filename.indexOf(p) === 0;
        });
        if (matchingPrefixes[0]) {
          filename = filename.slice(matchingPrefixes[0].length);
        }
        filename = filename.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [-+]\d{4}.*$/, '');
      }
      return filename;
    }
    module.exports.DiffParser = new DiffParser();
  })();
  });
  var diffParser_1 = diffParser.DiffParser;

  var rematch = createCommonjsModule(function (module) {
  (function() {
    var Rematch = {};
    function levenshtein(a, b) {
      if (a.length === 0) {
        return b.length;
      }
      if (b.length === 0) {
        return a.length;
      }
      var matrix = [];
      var i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      var j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1,
              Math.min(matrix[i][j - 1] + 1,
                matrix[i - 1][j] + 1));
          }
        }
      }
      return matrix[b.length][a.length];
    }
    Rematch.levenshtein = levenshtein;
    Rematch.distance = function distance(x, y) {
      x = x.trim();
      y = y.trim();
      var lev = levenshtein(x, y);
      var score = lev / (x.length + y.length);
      return score;
    };
    Rematch.rematch = function rematch(distanceFunction) {
      function findBestMatch(a, b, cache) {
        var bestMatchDist = Infinity;
        var bestMatch;
        for (var i = 0; i < a.length; ++i) {
          for (var j = 0; j < b.length; ++j) {
            var cacheKey = JSON.stringify([a[i], b[j]]);
            var md;
            if (cache.hasOwnProperty(cacheKey)) {
              md = cache[cacheKey];
            } else {
              md = distanceFunction(a[i], b[j]);
              cache[cacheKey] = md;
            }
            if (md < bestMatchDist) {
              bestMatchDist = md;
              bestMatch = {indexA: i, indexB: j, score: bestMatchDist};
            }
          }
        }
        return bestMatch;
      }
      function group(a, b, level, cache) {
        if (typeof (cache) === 'undefined') {
          cache = {};
        }
        var bm = findBestMatch(a, b, cache);
        if (!level) {
          level = 0;
        }
        if (!bm || (a.length + b.length < 3)) {
          return [[a, b]];
        }
        var a1 = a.slice(0, bm.indexA);
        var b1 = b.slice(0, bm.indexB);
        var aMatch = [a[bm.indexA]];
        var bMatch = [b[bm.indexB]];
        var tailA = bm.indexA + 1;
        var tailB = bm.indexB + 1;
        var a2 = a.slice(tailA);
        var b2 = b.slice(tailB);
        var group1 = group(a1, b1, level + 1, cache);
        var groupMatch = group(aMatch, bMatch, level + 1, cache);
        var group2 = group(a2, b2, level + 1, cache);
        var result = groupMatch;
        if (bm.indexA > 0 || bm.indexB > 0) {
          result = group1.concat(result);
        }
        if (a.length > tailA || b.length > tailB) {
          result = result.concat(group2);
        }
        return result;
      }
      return group;
    };
    module.exports.Rematch = Rematch;
  })();
  });
  var rematch_1 = rematch.Rematch;

  var printerUtils = createCommonjsModule(function (module) {
  (function() {
    var jsDiff = diff;
    var utils$1 = utils.Utils;
    var Rematch = rematch.Rematch;
    var separator = '/';
    function PrinterUtils() {
    }
    PrinterUtils.prototype.separatePrefix = function(isCombined, line) {
      var prefix;
      var lineWithoutPrefix;
      if (isCombined) {
        prefix = line.substring(0, 2);
        lineWithoutPrefix = line.substring(2);
      } else {
        prefix = line.substring(0, 1);
        lineWithoutPrefix = line.substring(1);
      }
      return {
        'prefix': prefix,
        'line': lineWithoutPrefix
      };
    };
    PrinterUtils.prototype.getHtmlId = function(file) {
      var hashCode = function(text) {
        var i, chr, len;
        var hash = 0;
        for (i = 0, len = text.length; i < len; i++) {
          chr = text.charCodeAt(i);
          hash = ((hash << 5) - hash) + chr;
          hash |= 0;
        }
        return hash;
      };
      return 'd2h-' + hashCode(this.getDiffName(file)).toString().slice(-6);
    };
    PrinterUtils.prototype.getDiffName = function(file) {
      var oldFilename = unifyPath(file.oldName);
      var newFilename = unifyPath(file.newName);
      if (oldFilename && newFilename && oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
        var prefixPaths = [];
        var suffixPaths = [];
        var oldFilenameParts = oldFilename.split(separator);
        var newFilenameParts = newFilename.split(separator);
        var oldFilenamePartsSize = oldFilenameParts.length;
        var newFilenamePartsSize = newFilenameParts.length;
        var i = 0;
        var j = oldFilenamePartsSize - 1;
        var k = newFilenamePartsSize - 1;
        while (i < j && i < k) {
          if (oldFilenameParts[i] === newFilenameParts[i]) {
            prefixPaths.push(newFilenameParts[i]);
            i += 1;
          } else {
            break;
          }
        }
        while (j > i && k > i) {
          if (oldFilenameParts[j] === newFilenameParts[k]) {
            suffixPaths.unshift(newFilenameParts[k]);
            j -= 1;
            k -= 1;
          } else {
            break;
          }
        }
        var finalPrefix = prefixPaths.join(separator);
        var finalSuffix = suffixPaths.join(separator);
        var oldRemainingPath = oldFilenameParts.slice(i, j + 1).join(separator);
        var newRemainingPath = newFilenameParts.slice(i, k + 1).join(separator);
        if (finalPrefix.length && finalSuffix.length) {
          return finalPrefix + separator + '{' + oldRemainingPath + ' → ' + newRemainingPath + '}' + separator + finalSuffix;
        } else if (finalPrefix.length) {
          return finalPrefix + separator + '{' + oldRemainingPath + ' → ' + newRemainingPath + '}';
        } else if (finalSuffix.length) {
          return '{' + oldRemainingPath + ' → ' + newRemainingPath + '}' + separator + finalSuffix;
        }
        return oldFilename + ' → ' + newFilename;
      } else if (newFilename && !isDevNullName(newFilename)) {
        return newFilename;
      } else if (oldFilename) {
        return oldFilename;
      }
      return 'unknown/file/path';
    };
    PrinterUtils.prototype.getFileTypeIcon = function(file) {
      var templateName = 'file-changed';
      if (file.isRename) {
        templateName = 'file-renamed';
      } else if (file.isCopy) {
        templateName = 'file-renamed';
      } else if (file.isNew) {
        templateName = 'file-added';
      } else if (file.isDeleted) {
        templateName = 'file-deleted';
      } else if (file.newName !== file.oldName) {
        templateName = 'file-renamed';
      }
      return templateName;
    };
    PrinterUtils.prototype.diffHighlight = function(diffLine1, diffLine2, config) {
      var linePrefix1, linePrefix2, unprefixedLine1, unprefixedLine2;
      var prefixSize = 1;
      if (config.isCombined) {
        prefixSize = 2;
      }
      linePrefix1 = diffLine1.substr(0, prefixSize);
      linePrefix2 = diffLine2.substr(0, prefixSize);
      unprefixedLine1 = diffLine1.substr(prefixSize);
      unprefixedLine2 = diffLine2.substr(prefixSize);
      if (unprefixedLine1.length > config.maxLineLengthHighlight ||
        unprefixedLine2.length > config.maxLineLengthHighlight) {
        return {
          first: {
            prefix: linePrefix1,
            line: utils$1.escape(unprefixedLine1)
          },
          second: {
            prefix: linePrefix2,
            line: utils$1.escape(unprefixedLine2)
          }
        };
      }
      var diff;
      if (config.charByChar) {
        diff = jsDiff.diffChars(unprefixedLine1, unprefixedLine2);
      } else {
        diff = jsDiff.diffWordsWithSpace(unprefixedLine1, unprefixedLine2);
      }
      var highlightedLine = '';
      var changedWords = [];
      if (!config.charByChar && config.matching === 'words') {
        var treshold = 0.25;
        if (typeof (config.matchWordsThreshold) !== 'undefined') {
          treshold = config.matchWordsThreshold;
        }
        var matcher = Rematch.rematch(function(a, b) {
          var amod = a.value;
          var bmod = b.value;
          return Rematch.distance(amod, bmod);
        });
        var removed = diff.filter(function isRemoved(element) {
          return element.removed;
        });
        var added = diff.filter(function isAdded(element) {
          return element.added;
        });
        var chunks = matcher(added, removed);
        chunks.forEach(function(chunk) {
          if (chunk[0].length === 1 && chunk[1].length === 1) {
            var dist = Rematch.distance(chunk[0][0].value, chunk[1][0].value);
            if (dist < treshold) {
              changedWords.push(chunk[0][0]);
              changedWords.push(chunk[1][0]);
            }
          }
        });
      }
      diff.forEach(function(part) {
        var addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : '';
        var elemType = part.added ? 'ins' : part.removed ? 'del' : null;
        var escapedValue = utils$1.escape(part.value);
        if (elemType !== null) {
          highlightedLine += '<' + elemType + addClass + '>' + escapedValue + '</' + elemType + '>';
        } else {
          highlightedLine += escapedValue;
        }
      });
      return {
        first: {
          prefix: linePrefix1,
          line: removeIns(highlightedLine)
        },
        second: {
          prefix: linePrefix2,
          line: removeDel(highlightedLine)
        }
      };
    };
    function unifyPath(path) {
      if (path) {
        return path.replace('\\', '/');
      }
      return path;
    }
    function isDevNullName(name) {
      return name.indexOf('dev/null') !== -1;
    }
    function removeIns(line) {
      return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, '');
    }
    function removeDel(line) {
      return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, '');
    }
    module.exports.PrinterUtils = new PrinterUtils();
  })();
  });
  var printerUtils_1 = printerUtils.PrinterUtils;

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    'default': _nodeResolve_empty
  });

  var compiler = createCommonjsModule(function (module, exports) {
  (function (Hogan) {
    var rIsWhitespace = /\S/,
        rQuot = /\"/g,
        rNewline =  /\n/g,
        rCr = /\r/g,
        rSlash = /\\/g,
        rLineSep = /\u2028/,
        rParagraphSep = /\u2029/;
    Hogan.tags = {
      '#': 1, '^': 2, '<': 3, '$': 4,
      '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
      '{': 10, '&': 11, '_t': 12
    };
    Hogan.scan = function scan(text, delimiters) {
      var len = text.length,
          IN_TEXT = 0,
          IN_TAG_TYPE = 1,
          IN_TAG = 2,
          state = IN_TEXT,
          tagType = null,
          tag = null,
          buf = '',
          tokens = [],
          seenTag = false,
          i = 0,
          lineStart = 0,
          otag = '{{',
          ctag = '}}';
      function addBuf() {
        if (buf.length > 0) {
          tokens.push({tag: '_t', text: new String(buf)});
          buf = '';
        }
      }
      function lineIsWhitespace() {
        var isAllWhitespace = true;
        for (var j = lineStart; j < tokens.length; j++) {
          isAllWhitespace =
            (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
            (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
          if (!isAllWhitespace) {
            return false;
          }
        }
        return isAllWhitespace;
      }
      function filterLine(haveSeenTag, noNewLine) {
        addBuf();
        if (haveSeenTag && lineIsWhitespace()) {
          for (var j = lineStart, next; j < tokens.length; j++) {
            if (tokens[j].text) {
              if ((next = tokens[j+1]) && next.tag == '>') {
                next.indent = tokens[j].text.toString();
              }
              tokens.splice(j, 1);
            }
          }
        } else if (!noNewLine) {
          tokens.push({tag:'\n'});
        }
        seenTag = false;
        lineStart = tokens.length;
      }
      function changeDelimiters(text, index) {
        var close = '=' + ctag,
            closeIndex = text.indexOf(close, index),
            delimiters = trim(
              text.substring(text.indexOf('=', index) + 1, closeIndex)
            ).split(' ');
        otag = delimiters[0];
        ctag = delimiters[delimiters.length - 1];
        return closeIndex + close.length - 1;
      }
      if (delimiters) {
        delimiters = delimiters.split(' ');
        otag = delimiters[0];
        ctag = delimiters[1];
      }
      for (i = 0; i < len; i++) {
        if (state == IN_TEXT) {
          if (tagChange(otag, text, i)) {
            --i;
            addBuf();
            state = IN_TAG_TYPE;
          } else {
            if (text.charAt(i) == '\n') {
              filterLine(seenTag);
            } else {
              buf += text.charAt(i);
            }
          }
        } else if (state == IN_TAG_TYPE) {
          i += otag.length - 1;
          tag = Hogan.tags[text.charAt(i + 1)];
          tagType = tag ? text.charAt(i + 1) : '_v';
          if (tagType == '=') {
            i = changeDelimiters(text, i);
            state = IN_TEXT;
          } else {
            if (tag) {
              i++;
            }
            state = IN_TAG;
          }
          seenTag = i;
        } else {
          if (tagChange(ctag, text, i)) {
            tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                         i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
            buf = '';
            i += ctag.length - 1;
            state = IN_TEXT;
            if (tagType == '{') {
              if (ctag == '}}') {
                i++;
              } else {
                cleanTripleStache(tokens[tokens.length - 1]);
              }
            }
          } else {
            buf += text.charAt(i);
          }
        }
      }
      filterLine(seenTag, true);
      return tokens;
    };
    function cleanTripleStache(token) {
      if (token.n.substr(token.n.length - 1) === '}') {
        token.n = token.n.substring(0, token.n.length - 1);
      }
    }
    function trim(s) {
      if (s.trim) {
        return s.trim();
      }
      return s.replace(/^\s*|\s*$/g, '');
    }
    function tagChange(tag, text, index) {
      if (text.charAt(index) != tag.charAt(0)) {
        return false;
      }
      for (var i = 1, l = tag.length; i < l; i++) {
        if (text.charAt(index + i) != tag.charAt(i)) {
          return false;
        }
      }
      return true;
    }
    var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};
    function buildTree(tokens, kind, stack, customTags) {
      var instructions = [],
          opener = null,
          tail = null,
          token = null;
      tail = stack[stack.length - 1];
      while (tokens.length > 0) {
        token = tokens.shift();
        if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
          throw new Error('Illegal content in < super tag.');
        }
        if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
          stack.push(token);
          token.nodes = buildTree(tokens, token.tag, stack, customTags);
        } else if (token.tag == '/') {
          if (stack.length === 0) {
            throw new Error('Closing tag without opener: /' + token.n);
          }
          opener = stack.pop();
          if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
            throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
          }
          opener.end = token.i;
          return instructions;
        } else if (token.tag == '\n') {
          token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
        }
        instructions.push(token);
      }
      if (stack.length > 0) {
        throw new Error('missing closing tag: ' + stack.pop().n);
      }
      return instructions;
    }
    function isOpener(token, tags) {
      for (var i = 0, l = tags.length; i < l; i++) {
        if (tags[i].o == token.n) {
          token.tag = '#';
          return true;
        }
      }
    }
    function isCloser(close, open, tags) {
      for (var i = 0, l = tags.length; i < l; i++) {
        if (tags[i].c == close && tags[i].o == open) {
          return true;
        }
      }
    }
    function stringifySubstitutions(obj) {
      var items = [];
      for (var key in obj) {
        items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
      }
      return "{ " + items.join(",") + " }";
    }
    function stringifyPartials(codeObj) {
      var partials = [];
      for (var key in codeObj.partials) {
        partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
      }
      return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
    }
    Hogan.stringify = function(codeObj, text, options) {
      return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
    };
    var serialNo = 0;
    Hogan.generate = function(tree, text, options) {
      serialNo = 0;
      var context = { code: '', subs: {}, partials: {} };
      Hogan.walk(tree, context);
      if (options.asString) {
        return this.stringify(context, text, options);
      }
      return this.makeTemplate(context, text, options);
    };
    Hogan.wrapMain = function(code) {
      return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
    };
    Hogan.template = Hogan.Template;
    Hogan.makeTemplate = function(codeObj, text, options) {
      var template = this.makePartials(codeObj);
      template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
      return new this.template(template, text, this, options);
    };
    Hogan.makePartials = function(codeObj) {
      var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
      for (key in template.partials) {
        template.partials[key] = this.makePartials(template.partials[key]);
      }
      for (key in codeObj.subs) {
        template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
      }
      return template;
    };
    function esc(s) {
      return s.replace(rSlash, '\\\\')
              .replace(rQuot, '\\\"')
              .replace(rNewline, '\\n')
              .replace(rCr, '\\r')
              .replace(rLineSep, '\\u2028')
              .replace(rParagraphSep, '\\u2029');
    }
    function chooseMethod(s) {
      return (~s.indexOf('.')) ? 'd' : 'f';
    }
    function createPartial(node, context) {
      var prefix = "<" + (context.prefix || "");
      var sym = prefix + node.n + serialNo++;
      context.partials[sym] = {name: node.n, partials: {}};
      context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
      return sym;
    }
    Hogan.codegen = {
      '#': function(node, context) {
        context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                        'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
                        't.rs(c,p,' + 'function(c,p,t){';
        Hogan.walk(node.nodes, context);
        context.code += '});c.pop();}';
      },
      '^': function(node, context) {
        context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
        Hogan.walk(node.nodes, context);
        context.code += '};';
      },
      '>': createPartial,
      '<': function(node, context) {
        var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
        Hogan.walk(node.nodes, ctx);
        var template = context.partials[createPartial(node, context)];
        template.subs = ctx.subs;
        template.partials = ctx.partials;
      },
      '$': function(node, context) {
        var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
        Hogan.walk(node.nodes, ctx);
        context.subs[node.n] = ctx.code;
        if (!context.inPartial) {
          context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
        }
      },
      '\n': function(node, context) {
        context.code += write('"\\n"' + (node.last ? '' : ' + i'));
      },
      '_v': function(node, context) {
        context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
      },
      '_t': function(node, context) {
        context.code += write('"' + esc(node.text) + '"');
      },
      '{': tripleStache,
      '&': tripleStache
    };
    function tripleStache(node, context) {
      context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    }
    function write(s) {
      return 't.b(' + s + ');';
    }
    Hogan.walk = function(nodelist, context) {
      var func;
      for (var i = 0, l = nodelist.length; i < l; i++) {
        func = Hogan.codegen[nodelist[i].tag];
        func && func(nodelist[i], context);
      }
      return context;
    };
    Hogan.parse = function(tokens, text, options) {
      options = options || {};
      return buildTree(tokens, '', [], options.sectionTags || []);
    };
    Hogan.cache = {};
    Hogan.cacheKey = function(text, options) {
      return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
    };
    Hogan.compile = function(text, options) {
      options = options || {};
      var key = Hogan.cacheKey(text, options);
      var template = this.cache[key];
      if (template) {
        var partials = template.partials;
        for (var name in partials) {
          delete partials[name].instance;
        }
        return template;
      }
      template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
      return this.cache[key] = template;
    };
  })( exports );
  });

  var template = createCommonjsModule(function (module, exports) {
  (function (Hogan) {
    Hogan.Template = function (codeObj, text, compiler, options) {
      codeObj = codeObj || {};
      this.r = codeObj.code || this.r;
      this.c = compiler;
      this.options = options || {};
      this.text = text || '';
      this.partials = codeObj.partials || {};
      this.subs = codeObj.subs || {};
      this.buf = '';
    };
    Hogan.Template.prototype = {
      r: function (context, partials, indent) { return ''; },
      v: hoganEscape,
      t: coerceToString,
      render: function render(context, partials, indent) {
        return this.ri([context], partials || {}, indent);
      },
      ri: function (context, partials, indent) {
        return this.r(context, partials, indent);
      },
      ep: function(symbol, partials) {
        var partial = this.partials[symbol];
        var template = partials[partial.name];
        if (partial.instance && partial.base == template) {
          return partial.instance;
        }
        if (typeof template == 'string') {
          if (!this.c) {
            throw new Error("No compiler available.");
          }
          template = this.c.compile(template, this.options);
        }
        if (!template) {
          return null;
        }
        this.partials[symbol].base = template;
        if (partial.subs) {
          if (!partials.stackText) partials.stackText = {};
          for (key in partial.subs) {
            if (!partials.stackText[key]) {
              partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
            }
          }
          template = createSpecializedPartial(template, partial.subs, partial.partials,
            this.stackSubs, this.stackPartials, partials.stackText);
        }
        this.partials[symbol].instance = template;
        return template;
      },
      rp: function(symbol, context, partials, indent) {
        var partial = this.ep(symbol, partials);
        if (!partial) {
          return '';
        }
        return partial.ri(context, partials, indent);
      },
      rs: function(context, partials, section) {
        var tail = context[context.length - 1];
        if (!isArray(tail)) {
          section(context, partials, this);
          return;
        }
        for (var i = 0; i < tail.length; i++) {
          context.push(tail[i]);
          section(context, partials, this);
          context.pop();
        }
      },
      s: function(val, ctx, partials, inverted, start, end, tags) {
        var pass;
        if (isArray(val) && val.length === 0) {
          return false;
        }
        if (typeof val == 'function') {
          val = this.ms(val, ctx, partials, inverted, start, end, tags);
        }
        pass = !!val;
        if (!inverted && pass && ctx) {
          ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
        }
        return pass;
      },
      d: function(key, ctx, partials, returnFound) {
        var found,
            names = key.split('.'),
            val = this.f(names[0], ctx, partials, returnFound),
            doModelGet = this.options.modelGet,
            cx = null;
        if (key === '.' && isArray(ctx[ctx.length - 2])) {
          val = ctx[ctx.length - 1];
        } else {
          for (var i = 1; i < names.length; i++) {
            found = findInScope(names[i], val, doModelGet);
            if (found !== undefined) {
              cx = val;
              val = found;
            } else {
              val = '';
            }
          }
        }
        if (returnFound && !val) {
          return false;
        }
        if (!returnFound && typeof val == 'function') {
          ctx.push(cx);
          val = this.mv(val, ctx, partials);
          ctx.pop();
        }
        return val;
      },
      f: function(key, ctx, partials, returnFound) {
        var val = false,
            v = null,
            found = false,
            doModelGet = this.options.modelGet;
        for (var i = ctx.length - 1; i >= 0; i--) {
          v = ctx[i];
          val = findInScope(key, v, doModelGet);
          if (val !== undefined) {
            found = true;
            break;
          }
        }
        if (!found) {
          return (returnFound) ? false : "";
        }
        if (!returnFound && typeof val == 'function') {
          val = this.mv(val, ctx, partials);
        }
        return val;
      },
      ls: function(func, cx, partials, text, tags) {
        var oldTags = this.options.delimiters;
        this.options.delimiters = tags;
        this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
        this.options.delimiters = oldTags;
        return false;
      },
      ct: function(text, cx, partials) {
        if (this.options.disableLambda) {
          throw new Error('Lambda features disabled.');
        }
        return this.c.compile(text, this.options).render(cx, partials);
      },
      b: function(s) { this.buf += s; },
      fl: function() { var r = this.buf; this.buf = ''; return r; },
      ms: function(func, ctx, partials, inverted, start, end, tags) {
        var textSource,
            cx = ctx[ctx.length - 1],
            result = func.call(cx);
        if (typeof result == 'function') {
          if (inverted) {
            return true;
          } else {
            textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
            return this.ls(result, cx, partials, textSource.substring(start, end), tags);
          }
        }
        return result;
      },
      mv: function(func, ctx, partials) {
        var cx = ctx[ctx.length - 1];
        var result = func.call(cx);
        if (typeof result == 'function') {
          return this.ct(coerceToString(result.call(cx)), cx, partials);
        }
        return result;
      },
      sub: function(name, context, partials, indent) {
        var f = this.subs[name];
        if (f) {
          this.activeSub = name;
          f(context, partials, this, indent);
          this.activeSub = false;
        }
      }
    };
    function findInScope(key, scope, doModelGet) {
      var val;
      if (scope && typeof scope == 'object') {
        if (scope[key] !== undefined) {
          val = scope[key];
        } else if (doModelGet && scope.get && typeof scope.get == 'function') {
          val = scope.get(key);
        }
      }
      return val;
    }
    function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
      function PartialTemplate() {}    PartialTemplate.prototype = instance;
      function Substitutions() {}    Substitutions.prototype = instance.subs;
      var key;
      var partial = new PartialTemplate();
      partial.subs = new Substitutions();
      partial.subsText = {};
      partial.buf = '';
      stackSubs = stackSubs || {};
      partial.stackSubs = stackSubs;
      partial.subsText = stackText;
      for (key in subs) {
        if (!stackSubs[key]) stackSubs[key] = subs[key];
      }
      for (key in stackSubs) {
        partial.subs[key] = stackSubs[key];
      }
      stackPartials = stackPartials || {};
      partial.stackPartials = stackPartials;
      for (key in partials) {
        if (!stackPartials[key]) stackPartials[key] = partials[key];
      }
      for (key in stackPartials) {
        partial.partials[key] = stackPartials[key];
      }
      return partial;
    }
    var rAmp = /&/g,
        rLt = /</g,
        rGt = />/g,
        rApos = /\'/g,
        rQuot = /\"/g,
        hChars = /[&<>\"\']/;
    function coerceToString(val) {
      return String((val === null || val === undefined) ? '' : val);
    }
    function hoganEscape(str) {
      str = coerceToString(str);
      return hChars.test(str) ?
        str
          .replace(rAmp, '&amp;')
          .replace(rLt, '&lt;')
          .replace(rGt, '&gt;')
          .replace(rApos, '&#39;')
          .replace(rQuot, '&quot;') :
        str;
    }
    var isArray = Array.isArray || function(a) {
      return Object.prototype.toString.call(a) === '[object Array]';
    };
  })( exports );
  });

  compiler.Template = template.Template;
  compiler.template = compiler.Template;
  var hogan = compiler;

  var diff2htmlTemplates = createCommonjsModule(function (module) {
  (function() {
  if (!!!commonjsGlobal.browserTemplates) commonjsGlobal.browserTemplates = {};
  var Hogan = hogan;commonjsGlobal.browserTemplates["file-summary-line"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<li class=\"d2h-file-list-line\">");t.b("\n" + i);t.b("    <span class=\"d2h-file-name-wrapper\">");t.b("\n" + i);t.b(t.rp("<fileIcon0",c,p,"      "));t.b("      <a href=\"#");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-name\">");t.b(t.v(t.f("fileName",c,p,0)));t.b("</a>");t.b("\n" + i);t.b("      <span class=\"d2h-file-stats\">");t.b("\n" + i);t.b("          <span class=\"d2h-lines-added\">");t.b(t.v(t.f("addedLines",c,p,0)));t.b("</span>");t.b("\n" + i);t.b("          <span class=\"d2h-lines-deleted\">");t.b(t.v(t.f("deletedLines",c,p,0)));t.b("</span>");t.b("\n" + i);t.b("      </span>");t.b("\n" + i);t.b("    </span>");t.b("\n" + i);t.b("</li>");return t.fl(); },partials: {"<fileIcon0":{name:"fileIcon", partials: {}, subs: {  }}}, subs: {  }});
  commonjsGlobal.browserTemplates["file-summary-wrapper"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"d2h-file-list-wrapper\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-list-header\">");t.b("\n" + i);t.b("        <span class=\"d2h-file-list-title\">Files changed (");t.b(t.v(t.f("filesNumber",c,p,0)));t.b(")</span>");t.b("\n" + i);t.b("        <a class=\"d2h-file-switch d2h-hide\">hide</a>");t.b("\n" + i);t.b("        <a class=\"d2h-file-switch d2h-show\">show</a>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <ol class=\"d2h-file-list\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("files",c,p,0)));t.b("\n" + i);t.b("    </ol>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["generic-column-line-number"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("lineClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\"></td>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b(t.t(t.f("blockHeader",c,p,0)));t.b("</div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["generic-empty-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("            File without changes");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["generic-file-path"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-file-name-wrapper\">");t.b("\n" + i);t.b(t.rp("<fileIcon0",c,p,"    "));t.b("    <span class=\"d2h-file-name\">");t.b(t.v(t.f("fileDiffName",c,p,0)));t.b("</span>");t.b("\n" + i);t.b(t.rp("<fileTag1",c,p,"    "));t.b("</span>");return t.fl(); },partials: {"<fileIcon0":{name:"fileIcon", partials: {}, subs: {  }},"<fileTag1":{name:"fileTag", partials: {}, subs: {  }}}, subs: {  }});
  commonjsGlobal.browserTemplates["generic-line"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("lineClass",c,p,0)));t.b(" ");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);t.b("      ");t.b(t.t(t.f("lineNumber",c,p,0)));t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);if(t.s(t.f("prefix",c,p,1),c,p,0,171,247,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("            <span class=\"d2h-code-line-prefix\">");t.b(t.t(t.f("prefix",c,p,0)));t.b("</span>");t.b("\n" + i);});c.pop();}if(t.s(t.f("content",c,p,1),c,p,0,279,353,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("            <span class=\"d2h-code-line-ctn\">");t.b(t.t(t.f("content",c,p,0)));t.b("</span>");t.b("\n" + i);});c.pop();}t.b("        </div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["generic-wrapper"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"d2h-wrapper\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("content",c,p,0)));t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["icon-file-added"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-added\" height=\"16\" title=\"added\" version=\"1.1\" viewBox=\"0 0 14 16\"");t.b("\n" + i);t.b("     width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["icon-file-changed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-changed\" height=\"16\" title=\"modified\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["icon-file-deleted"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-deleted\" height=\"16\" title=\"removed\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["icon-file-renamed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-moved\" height=\"16\" title=\"renamed\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["icon-file"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\">");t.b("\n" + i);t.b("    <path d=\"M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["line-by-line-file-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div id=\"");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-wrapper\" data-lang=\"");t.b(t.v(t.d("file.language",c,p,0)));t.b("\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-header\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("filePath",c,p,0)));t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <div class=\"d2h-file-diff\">");t.b("\n" + i);t.b("        <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("            <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                ");t.b(t.t(t.f("diffs",c,p,0)));t.b("\n" + i);t.b("                </tbody>");t.b("\n" + i);t.b("            </table>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["line-by-line-numbers"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"line-num1\">");t.b(t.v(t.f("oldNumber",c,p,0)));t.b("</div>");t.b("\n" + i);t.b("<div class=\"line-num2\">");t.b(t.v(t.f("newNumber",c,p,0)));t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["side-by-side-file-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div id=\"");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-wrapper\" data-lang=\"");t.b(t.v(t.d("file.language",c,p,0)));t.b("\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-header\">");t.b("\n" + i);t.b("      ");t.b(t.t(t.f("filePath",c,p,0)));t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <div class=\"d2h-files-diff\">");t.b("\n" + i);t.b("        <div class=\"d2h-file-side-diff\">");t.b("\n" + i);t.b("            <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("                <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                    <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                    ");t.b(t.t(t.d("diffs.left",c,p,0)));t.b("\n" + i);t.b("                    </tbody>");t.b("\n" + i);t.b("                </table>");t.b("\n" + i);t.b("            </div>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("        <div class=\"d2h-file-side-diff\">");t.b("\n" + i);t.b("            <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("                <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                    <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                    ");t.b(t.t(t.d("diffs.right",c,p,0)));t.b("\n" + i);t.b("                    </tbody>");t.b("\n" + i);t.b("                </table>");t.b("\n" + i);t.b("            </div>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["tag-file-added"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-added d2h-added-tag\">ADDED</span>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["tag-file-changed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-changed d2h-changed-tag\">CHANGED</span>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["tag-file-deleted"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-deleted d2h-deleted-tag\">DELETED</span>");return t.fl(); },partials: {}, subs: {  }});
  commonjsGlobal.browserTemplates["tag-file-renamed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-moved d2h-moved-tag\">RENAMED</span>");return t.fl(); },partials: {}, subs: {  }});
  module.exports = commonjsGlobal.browserTemplates;
  })();
  });

  var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

  var hoganjsUtils = createCommonjsModule(function (module) {
  (function() {
    var fs = require$$0;
    var path$1 = path;
    var hogan$1 = hogan;
    var hoganTemplates = diff2htmlTemplates;
    var extraTemplates;
    function HoganJsUtils(configuration) {
      this.config = configuration || {};
      extraTemplates = this.config.templates || {};
      var rawTemplates = this.config.rawTemplates || {};
      for (var templateName in rawTemplates) {
        if (rawTemplates.hasOwnProperty(templateName)) {
          if (!extraTemplates[templateName]) extraTemplates[templateName] = this.compile(rawTemplates[templateName]);
        }
      }
    }
    HoganJsUtils.prototype.render = function(namespace, view, params) {
      var template = this.template(namespace, view);
      if (template) {
        return template.render(params);
      }
      return null;
    };
    HoganJsUtils.prototype.template = function(namespace, view) {
      var templateKey = this._templateKey(namespace, view);
      return this._getTemplate(templateKey);
    };
    HoganJsUtils.prototype._getTemplate = function(templateKey) {
      var template;
      if (!this.config.noCache) {
        template = this._readFromCache(templateKey);
      }
      if (!template) {
        template = this._loadTemplate(templateKey);
      }
      return template;
    };
    HoganJsUtils.prototype._loadTemplate = function(templateKey) {
      var template;
      try {
        if (fs.readFileSync) {
          var templatesPath = path$1.resolve(__dirname, 'templates');
          var templatePath = path$1.join(templatesPath, templateKey);
          var templateContent = fs.readFileSync(templatePath + '.mustache', 'utf8');
          template = hogan$1.compile(templateContent);
          hoganTemplates[templateKey] = template;
        }
      } catch (e) {
        console.error('Failed to read (template: ' + templateKey + ') from fs: ' + e.message);
      }
      return template;
    };
    HoganJsUtils.prototype._readFromCache = function(templateKey) {
      return extraTemplates[templateKey] || hoganTemplates[templateKey];
    };
    HoganJsUtils.prototype._templateKey = function(namespace, view) {
      return namespace + '-' + view;
    };
    HoganJsUtils.prototype.compile = function(templateStr) {
      return hogan$1.compile(templateStr);
    };
    module.exports.HoganJsUtils = HoganJsUtils;
  })();
  });
  var hoganjsUtils_1 = hoganjsUtils.HoganJsUtils;

  var lineByLinePrinter = createCommonjsModule(function (module) {
  (function() {
    var diffParser$1 = diffParser.DiffParser;
    var printerUtils$1 = printerUtils.PrinterUtils;
    var utils$1 = utils.Utils;
    var Rematch = rematch.Rematch;
    var hoganUtils;
    var genericTemplatesPath = 'generic';
    var baseTemplatesPath = 'line-by-line';
    var iconsBaseTemplatesPath = 'icon';
    var tagsBaseTemplatesPath = 'tag';
    function LineByLinePrinter(config) {
      this.config = config;
      var HoganJsUtils = hoganjsUtils.HoganJsUtils;
      hoganUtils = new HoganJsUtils(config);
    }
    LineByLinePrinter.prototype.makeFileDiffHtml = function(file, diffs) {
      if (this.config.renderNothingWhenEmpty && file.blocks && !file.blocks.length) return '';
      var fileDiffTemplate = hoganUtils.template(baseTemplatesPath, 'file-diff');
      var filePathTemplate = hoganUtils.template(genericTemplatesPath, 'file-path');
      var fileIconTemplate = hoganUtils.template(iconsBaseTemplatesPath, 'file');
      var fileTagTemplate = hoganUtils.template(tagsBaseTemplatesPath, printerUtils$1.getFileTypeIcon(file));
      return fileDiffTemplate.render({
        file: file,
        fileHtmlId: printerUtils$1.getHtmlId(file),
        diffs: diffs,
        filePath: filePathTemplate.render({
          fileDiffName: printerUtils$1.getDiffName(file)
        }, {
          fileIcon: fileIconTemplate,
          fileTag: fileTagTemplate
        })
      });
    };
    LineByLinePrinter.prototype.makeLineByLineHtmlWrapper = function(content) {
      return hoganUtils.render(genericTemplatesPath, 'wrapper', {'content': content});
    };
    LineByLinePrinter.prototype.generateLineByLineJsonHtml = function(diffFiles) {
      var that = this;
      var htmlDiffs = diffFiles.map(function(file) {
        var diffs;
        if (file.blocks.length) {
          diffs = that._generateFileHtml(file);
        } else {
          diffs = that._generateEmptyDiff();
        }
        return that.makeFileDiffHtml(file, diffs);
      });
      return this.makeLineByLineHtmlWrapper(htmlDiffs.join('\n'));
    };
    var matcher = Rematch.rematch(function(a, b) {
      var amod = a.content.substr(1);
      var bmod = b.content.substr(1);
      return Rematch.distance(amod, bmod);
    });
    LineByLinePrinter.prototype.makeColumnLineNumberHtml = function(block) {
      return hoganUtils.render(genericTemplatesPath, 'column-line-number', {
        diffParser: diffParser$1,
        blockHeader: utils$1.escape(block.header),
        lineClass: 'd2h-code-linenumber',
        contentClass: 'd2h-code-line'
      });
    };
    LineByLinePrinter.prototype._generateFileHtml = function(file) {
      var that = this;
      return file.blocks.map(function(block) {
        var lines = that.makeColumnLineNumberHtml(block);
        var oldLines = [];
        var newLines = [];
        function processChangeBlock() {
          var matches;
          var insertType;
          var deleteType;
          var comparisons = oldLines.length * newLines.length;
          var maxComparisons = that.config.matchingMaxComparisons || 2500;
          var doMatching = comparisons < maxComparisons && (that.config.matching === 'lines' ||
            that.config.matching === 'words');
          if (doMatching) {
            matches = matcher(oldLines, newLines);
            insertType = diffParser$1.LINE_TYPE.INSERT_CHANGES;
            deleteType = diffParser$1.LINE_TYPE.DELETE_CHANGES;
          } else {
            matches = [[oldLines, newLines]];
            insertType = diffParser$1.LINE_TYPE.INSERTS;
            deleteType = diffParser$1.LINE_TYPE.DELETES;
          }
          matches.forEach(function(match) {
            oldLines = match[0];
            newLines = match[1];
            var processedOldLines = [];
            var processedNewLines = [];
            var common = Math.min(oldLines.length, newLines.length);
            var oldLine, newLine;
            for (var j = 0; j < common; j++) {
              oldLine = oldLines[j];
              newLine = newLines[j];
              that.config.isCombined = file.isCombined;
              var diff = printerUtils$1.diffHighlight(oldLine.content, newLine.content, that.config);
              processedOldLines +=
                that.makeLineHtml(file.isCombined, deleteType, oldLine.oldNumber, oldLine.newNumber,
                  diff.first.line, diff.first.prefix);
              processedNewLines +=
                that.makeLineHtml(file.isCombined, insertType, newLine.oldNumber, newLine.newNumber,
                  diff.second.line, diff.second.prefix);
            }
            lines += processedOldLines + processedNewLines;
            lines += that._processLines(file.isCombined, oldLines.slice(common), newLines.slice(common));
          });
          oldLines = [];
          newLines = [];
        }
        for (var i = 0; i < block.lines.length; i++) {
          var line = block.lines[i];
          var escapedLine = utils$1.escape(line.content);
          if (line.type !== diffParser$1.LINE_TYPE.INSERTS &&
            (newLines.length > 0 || (line.type !== diffParser$1.LINE_TYPE.DELETES && oldLines.length > 0))) {
            processChangeBlock();
          }
          if (line.type === diffParser$1.LINE_TYPE.CONTEXT) {
            lines += that.makeLineHtml(file.isCombined, line.type, line.oldNumber, line.newNumber, escapedLine);
          } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && !oldLines.length) {
            lines += that.makeLineHtml(file.isCombined, line.type, line.oldNumber, line.newNumber, escapedLine);
          } else if (line.type === diffParser$1.LINE_TYPE.DELETES) {
            oldLines.push(line);
          } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && Boolean(oldLines.length)) {
            newLines.push(line);
          } else {
            console.error('Unknown state in html line-by-line generator');
            processChangeBlock();
          }
        }
        processChangeBlock();
        return lines;
      }).join('\n');
    };
    LineByLinePrinter.prototype._processLines = function(isCombined, oldLines, newLines) {
      var lines = '';
      for (var i = 0; i < oldLines.length; i++) {
        var oldLine = oldLines[i];
        var oldEscapedLine = utils$1.escape(oldLine.content);
        lines += this.makeLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldLine.newNumber, oldEscapedLine);
      }
      for (var j = 0; j < newLines.length; j++) {
        var newLine = newLines[j];
        var newEscapedLine = utils$1.escape(newLine.content);
        lines += this.makeLineHtml(isCombined, newLine.type, newLine.oldNumber, newLine.newNumber, newEscapedLine);
      }
      return lines;
    };
    LineByLinePrinter.prototype.makeLineHtml = function(isCombined, type, oldNumber, newNumber, content, possiblePrefix) {
      var lineNumberTemplate = hoganUtils.render(baseTemplatesPath, 'numbers', {
        oldNumber: utils$1.valueOrEmpty(oldNumber),
        newNumber: utils$1.valueOrEmpty(newNumber)
      });
      var lineWithoutPrefix = content;
      var prefix = possiblePrefix;
      if (!prefix) {
        var lineWithPrefix = printerUtils$1.separatePrefix(isCombined, content);
        prefix = lineWithPrefix.prefix;
        lineWithoutPrefix = lineWithPrefix.line;
      }
      return hoganUtils.render(genericTemplatesPath, 'line',
        {
          type: type,
          lineClass: 'd2h-code-linenumber',
          contentClass: 'd2h-code-line',
          prefix: prefix,
          content: lineWithoutPrefix,
          lineNumber: lineNumberTemplate
        });
    };
    LineByLinePrinter.prototype._generateEmptyDiff = function() {
      return hoganUtils.render(genericTemplatesPath, 'empty-diff', {
        contentClass: 'd2h-code-line',
        diffParser: diffParser$1
      });
    };
    module.exports.LineByLinePrinter = LineByLinePrinter;
  })();
  });
  var lineByLinePrinter_1 = lineByLinePrinter.LineByLinePrinter;

  var sideBySidePrinter = createCommonjsModule(function (module) {
  (function() {
    var diffParser$1 = diffParser.DiffParser;
    var printerUtils$1 = printerUtils.PrinterUtils;
    var utils$1 = utils.Utils;
    var Rematch = rematch.Rematch;
    var hoganUtils;
    var genericTemplatesPath = 'generic';
    var baseTemplatesPath = 'side-by-side';
    var iconsBaseTemplatesPath = 'icon';
    var tagsBaseTemplatesPath = 'tag';
    var matcher = Rematch.rematch(function(a, b) {
      var amod = a.content.substr(1);
      var bmod = b.content.substr(1);
      return Rematch.distance(amod, bmod);
    });
    function SideBySidePrinter(config) {
      this.config = config;
      var HoganJsUtils = hoganjsUtils.HoganJsUtils;
      hoganUtils = new HoganJsUtils(config);
    }
    SideBySidePrinter.prototype.makeDiffHtml = function(file, diffs) {
      var fileDiffTemplate = hoganUtils.template(baseTemplatesPath, 'file-diff');
      var filePathTemplate = hoganUtils.template(genericTemplatesPath, 'file-path');
      var fileIconTemplate = hoganUtils.template(iconsBaseTemplatesPath, 'file');
      var fileTagTemplate = hoganUtils.template(tagsBaseTemplatesPath, printerUtils$1.getFileTypeIcon(file));
      return fileDiffTemplate.render({
        file: file,
        fileHtmlId: printerUtils$1.getHtmlId(file),
        diffs: diffs,
        filePath: filePathTemplate.render({
          fileDiffName: printerUtils$1.getDiffName(file)
        }, {
          fileIcon: fileIconTemplate,
          fileTag: fileTagTemplate
        })
      });
    };
    SideBySidePrinter.prototype.generateSideBySideJsonHtml = function(diffFiles) {
      var that = this;
      var content = diffFiles.map(function(file) {
        var diffs;
        if (file.blocks.length) {
          diffs = that.generateSideBySideFileHtml(file);
        } else {
          diffs = that.generateEmptyDiff();
        }
        return that.makeDiffHtml(file, diffs);
      }).join('\n');
      return hoganUtils.render(genericTemplatesPath, 'wrapper', {'content': content});
    };
    SideBySidePrinter.prototype.makeSideHtml = function(blockHeader) {
      return hoganUtils.render(genericTemplatesPath, 'column-line-number', {
        diffParser: diffParser$1,
        blockHeader: utils$1.escape(blockHeader),
        lineClass: 'd2h-code-side-linenumber',
        contentClass: 'd2h-code-side-line'
      });
    };
    SideBySidePrinter.prototype.generateSideBySideFileHtml = function(file) {
      var that = this;
      var fileHtml = {};
      fileHtml.left = '';
      fileHtml.right = '';
      file.blocks.forEach(function(block) {
        fileHtml.left += that.makeSideHtml(block.header);
        fileHtml.right += that.makeSideHtml('');
        var oldLines = [];
        var newLines = [];
        function processChangeBlock() {
          var matches;
          var insertType;
          var deleteType;
          var comparisons = oldLines.length * newLines.length;
          var maxComparisons = that.config.matchingMaxComparisons || 2500;
          var doMatching = comparisons < maxComparisons && (that.config.matching === 'lines' ||
            that.config.matching === 'words');
          if (doMatching) {
            matches = matcher(oldLines, newLines);
            insertType = diffParser$1.LINE_TYPE.INSERT_CHANGES;
            deleteType = diffParser$1.LINE_TYPE.DELETE_CHANGES;
          } else {
            matches = [[oldLines, newLines]];
            insertType = diffParser$1.LINE_TYPE.INSERTS;
            deleteType = diffParser$1.LINE_TYPE.DELETES;
          }
          matches.forEach(function(match) {
            oldLines = match[0];
            newLines = match[1];
            var common = Math.min(oldLines.length, newLines.length);
            var max = Math.max(oldLines.length, newLines.length);
            for (var j = 0; j < common; j++) {
              var oldLine = oldLines[j];
              var newLine = newLines[j];
              that.config.isCombined = file.isCombined;
              var diff = printerUtils$1.diffHighlight(oldLine.content, newLine.content, that.config);
              fileHtml.left +=
                that.generateSingleLineHtml(file.isCombined, deleteType, oldLine.oldNumber,
                  diff.first.line, diff.first.prefix);
              fileHtml.right +=
                that.generateSingleLineHtml(file.isCombined, insertType, newLine.newNumber,
                  diff.second.line, diff.second.prefix);
            }
            if (max > common) {
              var oldSlice = oldLines.slice(common);
              var newSlice = newLines.slice(common);
              var tmpHtml = that.processLines(file.isCombined, oldSlice, newSlice);
              fileHtml.left += tmpHtml.left;
              fileHtml.right += tmpHtml.right;
            }
          });
          oldLines = [];
          newLines = [];
        }
        for (var i = 0; i < block.lines.length; i++) {
          var line = block.lines[i];
          var prefix = line.content[0];
          var escapedLine = utils$1.escape(line.content.substr(1));
          if (line.type !== diffParser$1.LINE_TYPE.INSERTS &&
            (newLines.length > 0 || (line.type !== diffParser$1.LINE_TYPE.DELETES && oldLines.length > 0))) {
            processChangeBlock();
          }
          if (line.type === diffParser$1.LINE_TYPE.CONTEXT) {
            fileHtml.left += that.generateSingleLineHtml(file.isCombined, line.type, line.oldNumber, escapedLine, prefix);
            fileHtml.right += that.generateSingleLineHtml(file.isCombined, line.type, line.newNumber, escapedLine, prefix);
          } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && !oldLines.length) {
            fileHtml.left += that.generateSingleLineHtml(file.isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
            fileHtml.right += that.generateSingleLineHtml(file.isCombined, line.type, line.newNumber, escapedLine, prefix);
          } else if (line.type === diffParser$1.LINE_TYPE.DELETES) {
            oldLines.push(line);
          } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && Boolean(oldLines.length)) {
            newLines.push(line);
          } else {
            console.error('unknown state in html side-by-side generator');
            processChangeBlock();
          }
        }
        processChangeBlock();
      });
      return fileHtml;
    };
    SideBySidePrinter.prototype.processLines = function(isCombined, oldLines, newLines) {
      var that = this;
      var fileHtml = {};
      fileHtml.left = '';
      fileHtml.right = '';
      var maxLinesNumber = Math.max(oldLines.length, newLines.length);
      for (var i = 0; i < maxLinesNumber; i++) {
        var oldLine = oldLines[i];
        var newLine = newLines[i];
        var oldContent;
        var newContent;
        var oldPrefix;
        var newPrefix;
        if (oldLine) {
          oldContent = utils$1.escape(oldLine.content.substr(1));
          oldPrefix = oldLine.content[0];
        }
        if (newLine) {
          newContent = utils$1.escape(newLine.content.substr(1));
          newPrefix = newLine.content[0];
        }
        if (oldLine && newLine) {
          fileHtml.left += that.generateSingleLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldContent, oldPrefix);
          fileHtml.right += that.generateSingleLineHtml(isCombined, newLine.type, newLine.newNumber, newContent, newPrefix);
        } else if (oldLine) {
          fileHtml.left += that.generateSingleLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldContent, oldPrefix);
          fileHtml.right += that.generateSingleLineHtml(isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
        } else if (newLine) {
          fileHtml.left += that.generateSingleLineHtml(isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
          fileHtml.right += that.generateSingleLineHtml(isCombined, newLine.type, newLine.newNumber, newContent, newPrefix);
        } else {
          console.error('How did it get here?');
        }
      }
      return fileHtml;
    };
    SideBySidePrinter.prototype.generateSingleLineHtml = function(isCombined, type, number, content, possiblePrefix) {
      var lineWithoutPrefix = content;
      var prefix = possiblePrefix;
      var lineClass = 'd2h-code-side-linenumber';
      var contentClass = 'd2h-code-side-line';
      if (!number && !content) {
        lineClass += ' d2h-code-side-emptyplaceholder';
        contentClass += ' d2h-code-side-emptyplaceholder';
        type += ' d2h-emptyplaceholder';
      }
      if (!prefix) {
        var lineWithPrefix = printerUtils$1.separatePrefix(isCombined, content);
        prefix = lineWithPrefix.prefix;
        lineWithoutPrefix = lineWithPrefix.line;
      }
      return hoganUtils.render(genericTemplatesPath, 'line',
        {
          type: type,
          lineClass: lineClass,
          contentClass: contentClass,
          prefix: prefix,
          content: lineWithoutPrefix,
          lineNumber: number
        });
    };
    SideBySidePrinter.prototype.generateEmptyDiff = function() {
      var fileHtml = {};
      fileHtml.right = '';
      fileHtml.left = hoganUtils.render(genericTemplatesPath, 'empty-diff', {
        contentClass: 'd2h-code-side-line',
        diffParser: diffParser$1
      });
      return fileHtml;
    };
    module.exports.SideBySidePrinter = SideBySidePrinter;
  })();
  });
  var sideBySidePrinter_1 = sideBySidePrinter.SideBySidePrinter;

  var fileListPrinter = createCommonjsModule(function (module) {
  (function() {
    var printerUtils$1 = printerUtils.PrinterUtils;
    var hoganUtils;
    var baseTemplatesPath = 'file-summary';
    var iconsBaseTemplatesPath = 'icon';
    function FileListPrinter(config) {
      this.config = config;
      var HoganJsUtils = hoganjsUtils.HoganJsUtils;
      hoganUtils = new HoganJsUtils(config);
    }
    FileListPrinter.prototype.generateFileList = function(diffFiles) {
      var lineTemplate = hoganUtils.template(baseTemplatesPath, 'line');
      var files = diffFiles.map(function(file) {
        var fileTypeName = printerUtils$1.getFileTypeIcon(file);
        var iconTemplate = hoganUtils.template(iconsBaseTemplatesPath, fileTypeName);
        return lineTemplate.render({
          fileHtmlId: printerUtils$1.getHtmlId(file),
          fileName: printerUtils$1.getDiffName(file),
          deletedLines: '-' + file.deletedLines,
          addedLines: '+' + file.addedLines
        }, {
          fileIcon: iconTemplate
        });
      }).join('\n');
      return hoganUtils.render(baseTemplatesPath, 'wrapper', {
        filesNumber: diffFiles.length,
        files: files
      });
    };
    module.exports.FileListPrinter = FileListPrinter;
  })();
  });
  var fileListPrinter_1 = fileListPrinter.FileListPrinter;

  var htmlPrinter = createCommonjsModule(function (module) {
  (function() {
    var LineByLinePrinter = lineByLinePrinter.LineByLinePrinter;
    var SideBySidePrinter = sideBySidePrinter.SideBySidePrinter;
    var FileListPrinter = fileListPrinter.FileListPrinter;
    function HtmlPrinter() {
    }
    HtmlPrinter.prototype.generateLineByLineJsonHtml = function(diffFiles, config) {
      var lineByLinePrinter = new LineByLinePrinter(config);
      return lineByLinePrinter.generateLineByLineJsonHtml(diffFiles);
    };
    HtmlPrinter.prototype.generateSideBySideJsonHtml = function(diffFiles, config) {
      var sideBySidePrinter = new SideBySidePrinter(config);
      return sideBySidePrinter.generateSideBySideJsonHtml(diffFiles);
    };
    HtmlPrinter.prototype.generateFileListSummary = function(diffJson, config) {
      var fileListPrinter = new FileListPrinter(config);
      return fileListPrinter.generateFileList(diffJson);
    };
    module.exports.HtmlPrinter = new HtmlPrinter();
  })();
  });
  var htmlPrinter_1 = htmlPrinter.HtmlPrinter;

  var diff2html = createCommonjsModule(function (module) {
  (function() {
    var diffParser$1 = diffParser.DiffParser;
    var htmlPrinter$1 = htmlPrinter.HtmlPrinter;
    var utils$1 = utils.Utils;
    function Diff2Html() {
    }
    var defaultConfig = {
      wordByWord: true,
      outputFormat: 'line-by-line',
      matching: 'none',
      matchWordsThreshold: 0.25,
      matchingMaxComparisons: 2500,
      maxLineLengthHighlight: 10000,
      renderNothingWhenEmpty: false
    };
    Diff2Html.prototype.getJsonFromDiff = function(diffInput, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      return diffParser$1.generateDiffJson(diffInput, cfg);
    };
    Diff2Html.prototype.getPrettyHtml = function(diffInput, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      var diffJson = diffInput;
      if (!cfg.inputFormat || cfg.inputFormat === 'diff') {
        diffJson = diffParser$1.generateDiffJson(diffInput, cfg);
      }
      var fileList = '';
      if (cfg.showFiles === true) {
        fileList = htmlPrinter$1.generateFileListSummary(diffJson, cfg);
      }
      var diffOutput = '';
      if (cfg.outputFormat === 'side-by-side') {
        diffOutput = htmlPrinter$1.generateSideBySideJsonHtml(diffJson, cfg);
      } else {
        diffOutput = htmlPrinter$1.generateLineByLineJsonHtml(diffJson, cfg);
      }
      return fileList + diffOutput;
    };
    Diff2Html.prototype.getPrettyHtmlFromDiff = function(diffInput, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      cfg.inputFormat = 'diff';
      cfg.outputFormat = 'line-by-line';
      return this.getPrettyHtml(diffInput, cfg);
    };
    Diff2Html.prototype.getPrettyHtmlFromJson = function(diffJson, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      cfg.inputFormat = 'json';
      cfg.outputFormat = 'line-by-line';
      return this.getPrettyHtml(diffJson, cfg);
    };
    Diff2Html.prototype.getPrettySideBySideHtmlFromDiff = function(diffInput, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      cfg.inputFormat = 'diff';
      cfg.outputFormat = 'side-by-side';
      return this.getPrettyHtml(diffInput, cfg);
    };
    Diff2Html.prototype.getPrettySideBySideHtmlFromJson = function(diffJson, config) {
      var cfg = utils$1.safeConfig(config, defaultConfig);
      cfg.inputFormat = 'json';
      cfg.outputFormat = 'side-by-side';
      return this.getPrettyHtml(diffJson, cfg);
    };
    var diffObject = new Diff2Html();
    module.exports.Diff2Html = diffObject;
    commonjsGlobal.Diff2Html = diffObject;
  })();
  });
  var diff2html_1 = diff2html.Diff2Html;

  function deepFreeze(obj) {
      if (obj instanceof Map) {
          obj.clear = obj.delete = obj.set = function () {
              throw new Error('map is read-only');
          };
      } else if (obj instanceof Set) {
          obj.add = obj.clear = obj.delete = function () {
              throw new Error('set is read-only');
          };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach(function (name) {
          var prop = obj[name];
          if (typeof prop == 'object' && !Object.isFrozen(prop)) {
              deepFreeze(prop);
          }
      });
      return obj;
  }
  var deepFreezeEs6 = deepFreeze;
  var _default = deepFreeze;
  deepFreezeEs6.default = _default;
  class Response {
    constructor(mode) {
      if (mode.data === undefined) mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(value) {
    return value
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }
  function inherit(original, ...objects) {
    const result = Object.create(null);
    for (const key in original) {
      result[key] = original[key];
    }
    objects.forEach(function(obj) {
      for (const key in obj) {
        result[key] = obj[key];
      }
    });
    return  (result);
  }
  const SPAN_CLOSE = '</span>';
  const emitsWrappingTags = (node) => {
    return !!node.kind;
  };
  class HTMLRenderer {
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    openNode(node) {
      if (!emitsWrappingTags(node)) return;
      let className = node.kind;
      if (!node.sublanguage) {
        className = `${this.classPrefix}${className}`;
      }
      this.span(className);
    }
    closeNode(node) {
      if (!emitsWrappingTags(node)) return;
      this.buffer += SPAN_CLOSE;
    }
    value() {
      return this.buffer;
    }
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = { children: [] };
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() { return this.rootNode; }
    add(node) {
      this.top.children.push(node);
    }
    openNode(kind) {
      const node = { kind, children: [] };
      this.add(node);
      this.stack.push(node);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return undefined;
    }
    closeAllNodes() {
      while (this.closeNode());
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    static _walk(builder, node) {
      if (typeof node === "string") {
        builder.addText(node);
      } else if (node.children) {
        builder.openNode(node);
        node.children.forEach((child) => this._walk(builder, child));
        builder.closeNode(node);
      }
      return builder;
    }
    static _collapse(node) {
      if (typeof node === "string") return;
      if (!node.children) return;
      if (node.children.every(el => typeof el === "string")) {
        node.children = [node.children.join("")];
      } else {
        node.children.forEach((child) => {
          TokenTree._collapse(child);
        });
      }
    }
  }
  class TokenTreeEmitter extends TokenTree {
    constructor(options) {
      super();
      this.options = options;
    }
    addKeyword(text, kind) {
      if (text === "") { return; }
      this.openNode(kind);
      this.addText(text);
      this.closeNode();
    }
    addText(text) {
      if (text === "") { return; }
      this.add(text);
    }
    addSublanguage(emitter, name) {
      const node = emitter.root;
      node.kind = name;
      node.sublanguage = true;
      this.add(node);
    }
    toHTML() {
      const renderer = new HTMLRenderer(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  }
  function escape$1(value) {
    return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
  }
  function source(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function concat(...args) {
    const joined = args.map((x) => source(x)).join("");
    return joined;
  }
  function either(...args) {
    const joined = '(' + args.map((x) => source(x)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re) {
    return (new RegExp(re.toString() + '|')).exec('').length - 1;
  }
  function startsWith(re, lexeme) {
    const match = re && re.exec(lexeme);
    return match && match.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function join(regexps, separator = "|") {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset = numCaptures;
      let re = source(regex);
      let out = '';
      while (re.length > 0) {
        const match = BACKREF_RE.exec(re);
        if (!match) {
          out += re;
          break;
        }
        out += re.substring(0, match.index);
        re = re.substring(match.index + match[0].length);
        if (match[0][0] === '\\' && match[1]) {
          out += '\\' + String(Number(match[1]) + offset);
        } else {
          out += match[0];
          if (match[0] === '(') {
            numCaptures++;
          }
        }
      }
      return out;
    }).map(re => `(${re})`).join(separator);
  }
  const MATCH_NOTHING_RE = /\b\B/;
  const IDENT_RE = '[a-zA-Z]\\w*';
  const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
  const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
  const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)';
  const BINARY_NUMBER_RE = '\\b(0b[01]+)';
  const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
  const SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat(
        beginShebang,
        /.*\b/,
        opts.binary,
        /\b.*/);
    }
    return inherit({
      className: 'meta',
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      "on:begin": (m, resp) => {
        if (m.index !== 0) resp.ignoreMatch();
      }
    }, opts);
  };
  const BACKSLASH_ESCAPE = {
    begin: '\\\\[\\s\\S]', relevance: 0
  };
  const APOS_STRING_MODE = {
    className: 'string',
    begin: '\'',
    end: '\'',
    illegal: '\\n',
    contains: [BACKSLASH_ESCAPE]
  };
  const QUOTE_STRING_MODE = {
    className: 'string',
    begin: '"',
    end: '"',
    illegal: '\\n',
    contains: [BACKSLASH_ESCAPE]
  };
  const PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  const COMMENT = function(begin, end, modeOptions = {}) {
    const mode = inherit(
      {
        className: 'comment',
        begin,
        end,
        contains: []
      },
      modeOptions
    );
    mode.contains.push(PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: 'doctag',
      begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
      relevance: 0
    });
    return mode;
  };
  const C_LINE_COMMENT_MODE = COMMENT('//', '$');
  const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
  const HASH_COMMENT_MODE = COMMENT('#', '$');
  const NUMBER_MODE = {
    className: 'number',
    begin: NUMBER_RE,
    relevance: 0
  };
  const C_NUMBER_MODE = {
    className: 'number',
    begin: C_NUMBER_RE,
    relevance: 0
  };
  const BINARY_NUMBER_MODE = {
    className: 'number',
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  const CSS_NUMBER_MODE = {
    className: 'number',
    begin: NUMBER_RE + '(' +
      '%|em|ex|ch|rem' +
      '|vw|vh|vmin|vmax' +
      '|cm|mm|in|pt|pc|px' +
      '|deg|grad|rad|turn' +
      '|s|ms' +
      '|Hz|kHz' +
      '|dpi|dpcm|dppx' +
      ')?',
    relevance: 0
  };
  const REGEXP_MODE = {
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      className: 'regexp',
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  const TITLE_MODE = {
    className: 'title',
    begin: IDENT_RE,
    relevance: 0
  };
  const UNDERSCORE_TITLE_MODE = {
    className: 'title',
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const METHOD_GUARD = {
    begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(mode,
      {
        'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
        'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
      });
  };
  var MODES = Object.freeze({
      __proto__: null,
      MATCH_NOTHING_RE: MATCH_NOTHING_RE,
      IDENT_RE: IDENT_RE,
      UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
      NUMBER_RE: NUMBER_RE,
      C_NUMBER_RE: C_NUMBER_RE,
      BINARY_NUMBER_RE: BINARY_NUMBER_RE,
      RE_STARTERS_RE: RE_STARTERS_RE,
      SHEBANG: SHEBANG,
      BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
      APOS_STRING_MODE: APOS_STRING_MODE,
      QUOTE_STRING_MODE: QUOTE_STRING_MODE,
      PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
      COMMENT: COMMENT,
      C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
      HASH_COMMENT_MODE: HASH_COMMENT_MODE,
      NUMBER_MODE: NUMBER_MODE,
      C_NUMBER_MODE: C_NUMBER_MODE,
      BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
      CSS_NUMBER_MODE: CSS_NUMBER_MODE,
      REGEXP_MODE: REGEXP_MODE,
      TITLE_MODE: TITLE_MODE,
      UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
      METHOD_GUARD: METHOD_GUARD,
      END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
  });
  function skipIfhasPrecedingDot(match, response) {
    const before = match.input[match.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent) return;
    if (!mode.beginKeywords) return;
    mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
    mode.__beforeBegin = skipIfhasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === undefined) mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal)) return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match) return;
    if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === undefined) mode.relevance = 1;
  }
  const COMMON_KEYWORDS = [
    'of',
    'and',
    'for',
    'in',
    'not',
    'or',
    'if',
    'then',
    'parent',
    'list',
    'value'
  ];
  const DEFAULT_KEYWORD_CLASSNAME = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
    const compiledKeywords = {};
    if (typeof rawKeywords === 'string') {
      compileList(className, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(className, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(className) {
        Object.assign(
          compiledKeywords,
          compileKeywords(rawKeywords[className], caseInsensitive, className)
        );
      });
    }
    return compiledKeywords;
    function compileList(className, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map(x => x.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split('|');
        compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  function compileLanguage(language, { plugins }) {
    function langRe(value, global) {
      return new RegExp(
        source(value),
        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
      );
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      addRule(re, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re]);
        this.matchAt += countMatchGroups(re) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map(el => el[1]);
        this.matcherRe = langRe(join(terminators), true);
        this.lastIndex = 0;
      }
      exec(s) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match = this.matcherRe.exec(s);
        if (!match) { return null; }
        const i = match.findIndex((el, i) => i > 0 && el !== undefined);
        const matchData = this.matchIndexes[i];
        match.splice(0, i);
        return Object.assign(match, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      getMatcher(index) {
        if (this.multiRegexes[index]) return this.multiRegexes[index];
        const matcher = new MultiRegex();
        this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
        matcher.compile();
        this.multiRegexes[index] = matcher;
        return matcher;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      addRule(re, opts) {
        this.rules.push([re, opts]);
        if (opts.type === "begin") this.count++;
      }
      exec(s) {
        const m = this.getMatcher(this.regexIndex);
        m.lastIndex = this.lastIndex;
        let result = m.exec(s);
        if (this.resumingScanAtSamePosition()) {
          if (result && result.index === this.lastIndex) ; else {
            const m2 = this.getMatcher(0);
            m2.lastIndex = this.lastIndex + 1;
            result = m2.exec(s);
          }
        }
        if (result) {
          this.regexIndex += result.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result;
      }
    }
    function buildModeRegex(mode) {
      const mm = new ResumableMultiRegex();
      mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));
      if (mode.terminatorEnd) {
        mm.addRule(mode.terminatorEnd, { type: "end" });
      }
      if (mode.illegal) {
        mm.addRule(mode.illegal, { type: "illegal" });
      }
      return mm;
    }
    function compileMode(mode, parent) {
      const cmode =  (mode);
      if (mode.isCompiled) return cmode;
      [
        compileMatch
      ].forEach(ext => ext(mode, parent));
      language.compilerExtensions.forEach(ext => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        compileIllegal,
        compileRelevance
      ].forEach(ext => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object") {
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      if (mode.lexemes && keywordPattern) {
        throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
      }
      keywordPattern = keywordPattern || mode.lexemes || /\w+/;
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin) mode.begin = /\B|\b/;
        cmode.beginRe = langRe(mode.begin);
        if (mode.endSameAsBegin) mode.end = mode.begin;
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) cmode.endRe = langRe(mode.end);
        cmode.terminatorEnd = source(mode.end) || '';
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
        }
      }
      if (mode.illegal) cmode.illegalRe = langRe( (mode.illegal));
      if (!mode.contains) mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c) {
        return expandOrCloneMode(c === 'self' ? mode : c);
      }));
      mode.contains.forEach(function(c) { compileMode( (c), cmode); });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions) language.compilerExtensions = [];
    if (language.contains && language.contains.includes('self')) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit(language.classNameAliases || {});
    return compileMode( (language));
  }
  function dependencyOnParent(mode) {
    if (!mode) return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit(mode, { variants: null }, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
    }
    if (Object.isFrozen(mode)) {
      return inherit(mode);
    }
    return mode;
  }
  var version = "10.7.3";
  function hasValueOrEmptyAttribute(value) {
    return Boolean(value || value === "");
  }
  function BuildVuePlugin(hljs) {
    const Component = {
      props: ["language", "code", "autodetect"],
      data: function() {
        return {
          detectedLanguage: "",
          unknownLanguage: false
        };
      },
      computed: {
        className() {
          if (this.unknownLanguage) return "";
          return "hljs " + this.detectedLanguage;
        },
        highlighted() {
          if (!this.autoDetect && !hljs.getLanguage(this.language)) {
            console.warn(`The language "${this.language}" you specified could not be found.`);
            this.unknownLanguage = true;
            return escapeHTML(this.code);
          }
          let result = {};
          if (this.autoDetect) {
            result = hljs.highlightAuto(this.code);
            this.detectedLanguage = result.language;
          } else {
            result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
            this.detectedLanguage = this.language;
          }
          return result.value;
        },
        autoDetect() {
          return !this.language || hasValueOrEmptyAttribute(this.autodetect);
        },
        ignoreIllegals() {
          return true;
        }
      },
      render(createElement) {
        return createElement("pre", {}, [
          createElement("code", {
            class: this.className,
            domProps: { innerHTML: this.highlighted }
          })
        ]);
      }
    };
    const VuePlugin = {
      install(Vue) {
        Vue.component('highlightjs', Component);
      }
    };
    return { Component, VuePlugin };
  }
  const mergeHTMLPlugin = {
    "after:highlightElement": ({ el, result, text }) => {
      const originalStream = nodeStream(el);
      if (!originalStream.length) return;
      const resultNode = document.createElement('div');
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
  };
  function tag(node) {
    return node.nodeName.toLowerCase();
  }
  function nodeStream(node) {
    const result = [];
    (function _nodeStream(node, offset) {
      for (let child = node.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) {
          offset += child.nodeValue.length;
        } else if (child.nodeType === 1) {
          result.push({
            event: 'start',
            offset: offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: 'stop',
              offset: offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node, 0);
    return result;
  }
  function mergeStreams(original, highlighted, value) {
    let processed = 0;
    let result = '';
    const nodeStack = [];
    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return (original[0].offset < highlighted[0].offset) ? original : highlighted;
      }
      return highlighted[0].event === 'start' ? original : highlighted;
    }
    function open(node) {
      function attributeString(attr) {
        return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
      }
      result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
    }
    function close(node) {
      result += '</' + tag(node) + '>';
    }
    function render(event) {
      (event.event === 'start' ? open : close)(event.node);
    }
    while (original.length || highlighted.length) {
      let stream = selectStream();
      result += escapeHTML(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === 'start') {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escapeHTML(value.substr(processed));
  }
  const seenDeprecations = {};
  const error = (message) => {
    console.error(message);
  };
  const warn = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  const deprecated = (version, message) => {
    if (seenDeprecations[`${version}/${message}`]) return;
    console.log(`Deprecated as of ${version}. ${message}`);
    seenDeprecations[`${version}/${message}`] = true;
  };
  const escape$1$1 = escapeHTML;
  const inherit$1 = inherit;
  const NO_MATCH = Symbol("nomatch");
  const HLJS = function(hljs) {
    const languages = Object.create(null);
    const aliases = Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };
    let options = {
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: 'hljs-',
      tabReplace: null,
      useBR: false,
      languages: null,
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + ' ';
      classes += block.parentNode ? block.parentNode.className : '';
      const match = options.languageDetectRe.exec(classes);
      if (match) {
        const language = getLanguage(match[1]);
        if (!language) {
          warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
          warn("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match[1] : 'no-highlight';
      }
      return classes
        .split(/\s+/)
        .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrlanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
        continuation = undefined;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrlanguageName;
        code = optionsOrCode;
      }
      const context = {
        code,
        language: languageName
      };
      fire("before:highlight", context);
      const result = context.result
        ? context.result
        : _highlight(context.language, context.code, ignoreIllegals, continuation);
      result.code = context.code;
      fire("after:highlight", result);
      return result;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      function keywordData(mode, match) {
        const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
        return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top.keywordPatternRe.lastIndex = 0;
        let match = top.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match) {
          buf += modeBuffer.substring(lastIndex, match.index);
          const data = keywordData(top, match);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match[0], cssClass);
            }
          } else {
            buf += match[0];
          }
          lastIndex = top.keywordPatternRe.lastIndex;
          match = top.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "") return;
        let result = null;
        if (typeof top.subLanguage === 'string') {
          if (!languages[top.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
          continuations[top.subLanguage] =  (result.top);
        } else {
          result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
        }
        if (top.relevance > 0) {
          relevance += result.relevance;
        }
        emitter.addSublanguage(result.emitter, result.language);
      }
      function processBuffer() {
        if (top.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = '';
      }
      function startNewMode(mode) {
        if (mode.className) {
          emitter.openNode(language.classNameAliases[mode.className] || mode.className);
        }
        top = Object.create(mode, { parent: { value: top } });
        return top;
      }
      function endOfMode(mode, match, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match, resp);
            if (resp.isMatchIgnored) matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match) {
        const lexeme = match[0];
        const newMode = match.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb of beforeCallbacks) {
          if (!cb) continue;
          cb(match, resp);
          if (resp.isMatchIgnored) return doIgnore(lexeme);
        }
        if (newMode && newMode.endSameAsBegin) {
          newMode.endRe = escape$1(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match) {
        const lexeme = match[0];
        const matchPlusRemainder = codeToHighlight.substr(match.index);
        const endMode = endOfMode(top, match, matchPlusRemainder);
        if (!endMode) { return NO_MATCH; }
        const origin = top;
        if (origin.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin.returnEnd || origin.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top.className) {
            emitter.closeNode();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== endMode.parent);
        if (endMode.starts) {
          if (endMode.endSameAsBegin) {
            endMode.starts.endRe = endMode.endRe;
          }
          startNewMode(endMode.starts);
        }
        return origin.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top; current !== language; current = current.parent) {
          if (current.className) {
            list.unshift(current.className);
          }
        }
        list.forEach(item => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match) {
        const lexeme = match && match[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
          if (!SAFE_MODE) {
            const err = new Error('0 width match regex');
            err.languageName = languageName;
            err.badRule = lastMatch.rule;
            throw err;
          }
          return 1;
        }
        lastMatch = match;
        if (match.type === "begin") {
          return doBeginMatch(match);
        } else if (match.type === "illegal" && !ignoreIllegals) {
          const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
          err.mode = top;
          throw err;
        } else if (match.type === "end") {
          const processed = doEndMatch(match);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 100000 && iterations > match.index * 3) {
          const err = new Error('potential infinite loop, way more iterations than matches');
          throw err;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md = compileLanguage(language, { plugins });
      let result = '';
      let top = continuation || md;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = '';
      let relevance = 0;
      let index = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top.matcher.considerAll();
        for (;;) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match = top.matcher.exec(codeToHighlight);
          if (!match) break;
          const beforeMatch = codeToHighlight.substring(index, match.index);
          const processedCount = processLexeme(beforeMatch, match);
          index = match.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index));
        emitter.closeAllNodes();
        emitter.finalize();
        result = emitter.toHTML();
        return {
          relevance: Math.floor(relevance),
          value: result,
          language: languageName,
          illegal: false,
          emitter: emitter,
          top: top
        };
      } catch (err) {
        if (err.message && err.message.includes('Illegal')) {
          return {
            illegal: true,
            illegalBy: {
              msg: err.message,
              context: codeToHighlight.slice(index - 100, index + 100),
              mode: err.mode
            },
            sofar: result,
            relevance: 0,
            value: escape$1$1(codeToHighlight),
            emitter: emitter
          };
        } else if (SAFE_MODE) {
          return {
            illegal: false,
            relevance: 0,
            value: escape$1$1(codeToHighlight),
            emitter: emitter,
            language: languageName,
            top: top,
            errorRaised: err
          };
        } else {
          throw err;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result = {
        relevance: 0,
        emitter: new options.__emitter(options),
        value: escape$1$1(code),
        illegal: false,
        top: PLAINTEXT_LANGUAGE
      };
      result.emitter.addText(code);
      return result;
    }
    function highlightAuto(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
        _highlight(name, code, false)
      );
      results.unshift(plaintext);
      const sorted = results.sort((a, b) => {
        if (a.relevance !== b.relevance) return b.relevance - a.relevance;
        if (a.language && b.language) {
          if (getLanguage(a.language).supersetOf === b.language) {
            return 1;
          } else if (getLanguage(b.language).supersetOf === a.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result = best;
      result.second_best = secondBest;
      return result;
    }
    function fixMarkup(html) {
      if (!(options.tabReplace || options.useBR)) {
        return html;
      }
      return html.replace(fixMarkupRe, match => {
        if (match === '\n') {
          return options.useBR ? '<br>' : match;
        } else if (options.tabReplace) {
          return match.replace(/\t/g, options.tabReplace);
        }
        return match;
      });
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang ? aliases[currentLang] : resultLang;
      element.classList.add("hljs");
      if (language) element.classList.add(language);
    }
    const brPlugin = {
      "before:highlightElement": ({ el }) => {
        if (options.useBR) {
          el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
        }
      },
      "after:highlightElement": ({ result }) => {
        if (options.useBR) {
          result.value = result.value.replace(/\n/g, "<br>");
        }
      }
    };
    const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
    const tabReplacePlugin = {
      "after:highlightElement": ({ result }) => {
        if (options.tabReplace) {
          result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
            m.replace(/\t/g, options.tabReplace)
          );
        }
      }
    };
    function highlightElement(element) {
      let node = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language)) return;
      fire("before:highlightElement",
        { el: element, language: language });
      node = element;
      const text = node.textContent;
      const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);
      fire("after:highlightElement", { el: element, result, text });
      element.innerHTML = result.value;
      updateClassName(element, language, result.language);
      element.result = {
        language: result.language,
        re: result.relevance,
        relavance: result.relevance
      };
      if (result.second_best) {
        element.second_best = {
          language: result.second_best.language,
          re: result.second_best.relevance,
          relavance: result.second_best.relevance
        };
      }
    }
    function configure(userOptions) {
      if (userOptions.useBR) {
        deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
        deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
      }
      options = inherit$1(options, userOptions);
    }
    const initHighlighting = () => {
      if (initHighlighting.called) return;
      initHighlighting.called = true;
      deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
      const blocks = document.querySelectorAll('pre code');
      blocks.forEach(highlightElement);
    };
    function initHighlightingOnLoad() {
      deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
      wantsHighlight = true;
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll('pre code');
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight) highlightAll();
    }
    if (typeof window !== 'undefined' && window.addEventListener) {
      window.addEventListener('DOMContentLoaded', boot, false);
    }
    function registerLanguage(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs);
      } catch (error$1) {
        error("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name) lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs);
      if (lang.aliases) {
        registerAliases(lang.aliases, { languageName });
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases)) {
        if (aliases[alias] === languageName) {
          delete aliases[alias];
        }
      }
    }
    function listLanguages() {
      return Object.keys(languages);
    }
    function requireLanguage(name) {
      deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
      deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
      const lang = getLanguage(name);
      if (lang) { return lang; }
      const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
      throw err;
    }
    function getLanguage(name) {
      name = (name || '').toLowerCase();
      return languages[name] || languages[aliases[name]];
    }
    function registerAliases(aliasList, { languageName }) {
      if (typeof aliasList === 'string') {
        aliasList = [aliasList];
      }
      aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
    }
    function autoDetection(name) {
      const lang = getLanguage(name);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](
            Object.assign({ block: data.el }, data)
          );
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](
            Object.assign({ block: data.el }, data)
          );
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event, args) {
      const cb = event;
      plugins.forEach(function(plugin) {
        if (plugin[cb]) {
          plugin[cb](args);
        }
      });
    }
    function deprecateFixMarkup(arg) {
      deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
      deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
      return fixMarkup(arg);
    }
    function deprecateHighlightBlock(el) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el);
    }
    Object.assign(hljs, {
      highlight,
      highlightAuto,
      highlightAll,
      fixMarkup: deprecateFixMarkup,
      highlightElement,
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage,
      unregisterLanguage,
      listLanguages,
      getLanguage,
      registerAliases,
      requireLanguage,
      autoDetection,
      inherit: inherit$1,
      addPlugin,
      vuePlugin: BuildVuePlugin(hljs).VuePlugin
    });
    hljs.debugMode = function() { SAFE_MODE = false; };
    hljs.safeMode = function() { SAFE_MODE = true; };
    hljs.versionString = version;
    for (const key in MODES) {
      if (typeof MODES[key] === "object") {
        deepFreezeEs6(MODES[key]);
      }
    }
    Object.assign(hljs, MODES);
    hljs.addPlugin(brPlugin);
    hljs.addPlugin(mergeHTMLPlugin);
    hljs.addPlugin(tabReplacePlugin);
    return hljs;
  };
  var highlight = HLJS({});
  var core = highlight;

  const MODES$1 = (hljs) => {
    return {
      IMPORTANT: {
        className: 'meta',
        begin: '!important'
      },
      HEXCOLOR: {
        className: 'number',
        begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
      },
      ATTRIBUTE_SELECTOR_MODE: {
        className: 'selector-attr',
        begin: /\[/,
        end: /\]/,
        illegal: '$',
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      }
    };
  };
  const TAGS = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'p',
    'q',
    'quote',
    'samp',
    'section',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video'
  ];
  const MEDIA_FEATURES = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height'
  ];
  const PSEUDO_CLASSES = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where'
  ];
  const PSEUDO_ELEMENTS = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error'
  ];
  const ATTRIBUTES = [
    'align-content',
    'align-items',
    'align-self',
    'animation',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-timing-function',
    'auto',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-repeat',
    'background-size',
    'border',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-decoration-break',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'clear',
    'clip',
    'clip-path',
    'color',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'content',
    'counter-increment',
    'counter-reset',
    'cursor',
    'direction',
    'display',
    'empty-cells',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-size',
    'font-size-adjust',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-variant-ligatures',
    'font-variation-settings',
    'font-weight',
    'height',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'inherit',
    'initial',
    'justify-content',
    'left',
    'letter-spacing',
    'line-height',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-bottom',
    'margin-left',
    'margin-right',
    'margin-top',
    'marks',
    'mask',
    'max-height',
    'max-width',
    'min-height',
    'min-width',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'padding',
    'padding-bottom',
    'padding-left',
    'padding-right',
    'padding-top',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'perspective',
    'perspective-origin',
    'pointer-events',
    'position',
    'quotes',
    'resize',
    'right',
    'src',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-last',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-style',
    'text-indent',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-transform',
    'text-underline-position',
    'top',
    'transform',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'unicode-bidi',
    'vertical-align',
    'visibility',
    'white-space',
    'widows',
    'width',
    'word-break',
    'word-spacing',
    'word-wrap',
    'z-index'
  ].reverse();
  function source$1(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead(re) {
    return concat$1('(?=', re, ')');
  }
  function concat$1(...args) {
    const joined = args.map((x) => source$1(x)).join("");
    return joined;
  }
  function css(hljs) {
    const modes = MODES$1(hljs);
    const FUNCTION_DISPATCH = {
      className: "built_in",
      begin: /[\w-]+(?=\()/
    };
    const VENDOR_PREFIX = {
      begin: /-(webkit|moz|ms|o)-(?=[a-z])/
    };
    const AT_MODIFIERS = "and or not only";
    const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
    const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
    const STRINGS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ];
    return {
      name: 'CSS',
      case_insensitive: true,
      illegal: /[=|'\$]/,
      keywords: {
        keyframePosition: "from to"
      },
      classNameAliases: {
        keyframePosition: "selector-tag"
      },
      contains: [
        hljs.C_BLOCK_COMMENT_MODE,
        VENDOR_PREFIX,
        hljs.CSS_NUMBER_MODE,
        {
          className: 'selector-id',
          begin: /#[A-Za-z0-9_-]+/,
          relevance: 0
        },
        {
          className: 'selector-class',
          begin: '\\.' + IDENT_RE,
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: 'selector-pseudo',
          variants: [
            {
              begin: ':(' + PSEUDO_CLASSES.join('|') + ')'
            },
            {
              begin: '::(' + PSEUDO_ELEMENTS.join('|') + ')'
            }
          ]
        },
        {
          className: 'attribute',
          begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b'
        },
        {
          begin: ':',
          end: '[;}]',
          contains: [
            modes.HEXCOLOR,
            modes.IMPORTANT,
            hljs.CSS_NUMBER_MODE,
            ...STRINGS,
            {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              keywords: {
                built_in: "url data-uri"
              },
              contains: [
                {
                  className: "string",
                  begin: /[^)]/,
                  endsWithParent: true,
                  excludeEnd: true
                }
              ]
            },
            FUNCTION_DISPATCH
          ]
        },
        {
          begin: lookahead(/@/),
          end: '[{;]',
          relevance: 0,
          illegal: /:/,
          contains: [
            {
              className: 'keyword',
              begin: AT_PROPERTY_RE
            },
            {
              begin: /\s/,
              endsWithParent: true,
              excludeEnd: true,
              relevance: 0,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: AT_MODIFIERS,
                attribute: MEDIA_FEATURES.join(" ")
              },
              contains: [
                {
                  begin: /[a-z-]+(?=:)/,
                  className: "attribute"
                },
                ...STRINGS,
                hljs.CSS_NUMBER_MODE
              ]
            }
          ]
        },
        {
          className: 'selector-tag',
          begin: '\\b(' + TAGS.join('|') + ')\\b'
        }
      ]
    };
  }
  var css_1 = css;

  var decimalDigits = '[0-9](_*[0-9])*';
  var frac = `\\.(${decimalDigits})`;
  var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
  var NUMERIC = {
    className: 'number',
    variants: [
      { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
        `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
      { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${frac})[fFdD]?\\b` },
      { begin: `\\b(${decimalDigits})[fFdD]\\b` },
      { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
        `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
      { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
      { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
      { begin: '\\b0(_*[0-7])*[lL]?\\b' },
      { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
    ],
    relevance: 0
  };
  function java(hljs) {
    var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
    var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
    var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
      'for true while long strictfp finally protected import native final void ' +
      'enum else break transient catch instanceof byte super volatile case assert short ' +
      'package default double public try this switch continue throws protected public private ' +
      'module requires exports do';
    var ANNOTATION = {
      className: 'meta',
      begin: '@' + JAVA_IDENT_RE,
      contains: [
        {
          begin: /\(/,
          end: /\)/,
          contains: ["self"]
        },
      ]
    };
    const NUMBER = NUMERIC;
    return {
      name: 'Java',
      aliases: ['jsp'],
      keywords: KEYWORDS,
      illegal: /<\/|#/,
      contains: [
        hljs.COMMENT(
          '/\\*\\*',
          '\\*/',
          {
            relevance: 0,
            contains: [
              {
                begin: /\w+@/, relevance: 0
              },
              {
                className: 'doctag',
                begin: '@[A-Za-z]+'
              }
            ]
          }
        ),
        {
          begin: /import java\.[a-z]+\./,
          keywords: "import",
          relevance: 2
        },
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        {
          className: 'class',
          beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
          relevance: 1,
          keywords: 'class interface enum',
          illegal: /[:"\[\]]/,
          contains: [
            { beginKeywords: 'extends implements' },
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          beginKeywords: 'new throw return else',
          relevance: 0
        },
        {
          className: 'class',
          begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
          returnBegin: true,
          excludeEnd: true,
          end: /[{;=]/,
          keywords: KEYWORDS,
          contains: [
            { beginKeywords: "record" },
            {
              begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
              returnBegin: true,
              relevance: 0,
              contains: [hljs.UNDERSCORE_TITLE_MODE]
            },
            {
              className: 'params',
              begin: /\(/, end: /\)/,
              keywords: KEYWORDS,
              relevance: 0,
              contains: [
                hljs.C_BLOCK_COMMENT_MODE
              ]
            },
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE
          ]
        },
        {
          className: 'function',
          begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
          excludeEnd: true,
          keywords: KEYWORDS,
          contains: [
            {
              begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
              relevance: 0,
              contains: [hljs.UNDERSCORE_TITLE_MODE]
            },
            {
              className: 'params',
              begin: /\(/, end: /\)/,
              keywords: KEYWORDS,
              relevance: 0,
              contains: [
                ANNOTATION,
                hljs.APOS_STRING_MODE,
                hljs.QUOTE_STRING_MODE,
                NUMBER,
                hljs.C_BLOCK_COMMENT_MODE
              ]
            },
            hljs.C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE
          ]
        },
        NUMBER,
        ANNOTATION
      ]
    };
  }
  var java_1 = java;

  const IDENT_RE$1 = '[A-Za-z$_][0-9A-Za-z$_]*';
  const KEYWORDS = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES = [
    "Intl",
    "DataView",
    "Number",
    "Math",
    "Date",
    "String",
    "RegExp",
    "Object",
    "Function",
    "Boolean",
    "Error",
    "Symbol",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "Proxy",
    "Reflect",
    "JSON",
    "Promise",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Float32Array",
    "Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "ArrayBuffer",
    "BigInt64Array",
    "BigUint64Array",
    "BigInt"
  ];
  const ERROR_TYPES = [
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
  ];
  const BUILT_INS = [].concat(
    BUILT_IN_GLOBALS,
    BUILT_IN_VARIABLES,
    TYPES,
    ERROR_TYPES
  );
  function source$2(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$1(re) {
    return concat$2('(?=', re, ')');
  }
  function concat$2(...args) {
    const joined = args.map((x) => source$2(x)).join("");
    return joined;
  }
  function javascript(hljs) {
    const hasClosingTag = (match, { after }) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$1$1 = IDENT_RE$1;
    const FRAGMENT = {
      begin: '<>',
      end: '</>'
    };
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (nextChar === "<") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE$1,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS
    };
    const decimalDigits = '[0-9](_?[0-9])*';
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: 'number',
      variants: [
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
          `[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        { begin: "\\b0[0-7]+n?\\b" },
      ],
      relevance: 0
    };
    const SUBST = {
      className: 'subst',
      begin: '\\$\\{',
      end: '\\}',
      keywords: KEYWORDS$1,
      contains: []
    };
    const HTML_TEMPLATE = {
      begin: 'html`',
      end: '',
      starts: {
        end: '`',
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: 'xml'
      }
    };
    const CSS_TEMPLATE = {
      begin: 'css`',
      end: '',
      starts: {
        end: '`',
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: 'css'
      }
    };
    const TEMPLATE_STRING = {
      className: 'string',
      begin: '`',
      end: '`',
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(
      /\/\*\*(?!\/)/,
      '\\*/',
      {
        relevance: 0,
        contains: [
          {
            className: 'doctag',
            begin: '@[A-Za-z]+',
            contains: [
              {
                className: 'type',
                begin: '\\{',
                end: '\\}',
                relevance: 0
              },
              {
                className: 'variable',
                begin: IDENT_RE$1$1 + '(?=\\s*(-)|$)',
                endsParent: true,
                relevance: 0
              },
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      }
    );
    const COMMENT = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER,
      hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS
      .concat({
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: 'params',
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    return {
      name: 'Javascript',
      aliases: ['js', 'jsx', 'mjs', 'cjs'],
      keywords: KEYWORDS$1,
      exports: { PARAMS_CONTAINS },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        {
          label: "use_strict",
          className: 'meta',
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/
        },
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT,
        NUMBER,
        {
          begin: concat$2(/[{,\n]\s*/,
            lookahead$1(concat$2(
              /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
              IDENT_RE$1$1 + '\\s*:'))),
          relevance: 0,
          contains: [
            {
              className: 'attr',
              begin: IDENT_RE$1$1 + lookahead$1('\\s*:'),
              relevance: 0
            }
          ]
        },
        {
          begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
          keywords: 'return throw case',
          contains: [
            COMMENT,
            hljs.REGEXP_MODE,
            {
              className: 'function',
              begin: '(\\(' +
              '[^()]*(\\(' +
              '[^()]*(\\(' +
              '[^()]*' +
              '\\)[^()]*)*' +
              '\\)[^()]*)*' +
              '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
              returnBegin: true,
              end: '\\s*=>',
              contains: [
                {
                  className: 'params',
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              begin: /,/, relevance: 0
            },
            {
              className: '',
              begin: /\s/,
              end: /\s*/,
              skip: true
            },
            {
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                {
                  begin: XML_TAG.begin,
                  'on:begin': XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: 'xml',
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ['self']
                }
              ]
            }
          ],
          relevance: 0
        },
        {
          className: 'function',
          beginKeywords: 'function',
          end: /[{;]/,
          excludeEnd: true,
          keywords: KEYWORDS$1,
          contains: [
            'self',
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
            PARAMS
          ],
          illegal: /%/
        },
        {
          beginKeywords: "while if switch catch for"
        },
        {
          className: 'function',
          begin: hljs.UNDERSCORE_IDENT_RE +
            '\\(' +
            '[^()]*(\\(' +
              '[^()]*(\\(' +
                '[^()]*' +
              '\\)[^()]*)*' +
            '\\)[^()]*)*' +
            '\\)\\s*\\{',
          returnBegin:true,
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
          ]
        },
        {
          variants: [
            { begin: '\\.' + IDENT_RE$1$1 },
            { begin: '\\$' + IDENT_RE$1$1 }
          ],
          relevance: 0
        },
        {
          className: 'class',
          beginKeywords: 'class',
          end: /[{;=]/,
          excludeEnd: true,
          illegal: /[:"[\]]/,
          contains: [
            { beginKeywords: 'extends' },
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          begin: /\b(?=constructor)/,
          end: /[{;]/,
          excludeEnd: true,
          contains: [
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
            'self',
            PARAMS
          ]
        },
        {
          begin: '(get|set)\\s+(?=' + IDENT_RE$1$1 + '\\()',
          end: /\{/,
          keywords: "get set",
          contains: [
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
            { begin: /\(\)/ },
            PARAMS
          ]
        },
        {
          begin: /\$[(.]/
        }
      ]
    };
  }
  var javascript_1 = javascript;

  function json(hljs) {
    const LITERALS = {
      literal: 'true false null'
    };
    const ALLOWED_COMMENTS = [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE
    ];
    const TYPES = [
      hljs.QUOTE_STRING_MODE,
      hljs.C_NUMBER_MODE
    ];
    const VALUE_CONTAINER = {
      end: ',',
      endsWithParent: true,
      excludeEnd: true,
      contains: TYPES,
      keywords: LITERALS
    };
    const OBJECT = {
      begin: /\{/,
      end: /\}/,
      contains: [
        {
          className: 'attr',
          begin: /"/,
          end: /"/,
          contains: [hljs.BACKSLASH_ESCAPE],
          illegal: '\\n'
        },
        hljs.inherit(VALUE_CONTAINER, {
          begin: /:/
        })
      ].concat(ALLOWED_COMMENTS),
      illegal: '\\S'
    };
    const ARRAY = {
      begin: '\\[',
      end: '\\]',
      contains: [hljs.inherit(VALUE_CONTAINER)],
      illegal: '\\S'
    };
    TYPES.push(OBJECT, ARRAY);
    ALLOWED_COMMENTS.forEach(function(rule) {
      TYPES.push(rule);
    });
    return {
      name: 'JSON',
      contains: TYPES,
      keywords: LITERALS,
      illegal: '\\S'
    };
  }
  var json_1 = json;

  const MODES$2 = (hljs) => {
    return {
      IMPORTANT: {
        className: 'meta',
        begin: '!important'
      },
      HEXCOLOR: {
        className: 'number',
        begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
      },
      ATTRIBUTE_SELECTOR_MODE: {
        className: 'selector-attr',
        begin: /\[/,
        end: /\]/,
        illegal: '$',
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      }
    };
  };
  const TAGS$1 = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'p',
    'q',
    'quote',
    'samp',
    'section',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video'
  ];
  const MEDIA_FEATURES$1 = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height'
  ];
  const PSEUDO_CLASSES$1 = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where'
  ];
  const PSEUDO_ELEMENTS$1 = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error'
  ];
  const ATTRIBUTES$1 = [
    'align-content',
    'align-items',
    'align-self',
    'animation',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-timing-function',
    'auto',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-repeat',
    'background-size',
    'border',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-decoration-break',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'clear',
    'clip',
    'clip-path',
    'color',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'content',
    'counter-increment',
    'counter-reset',
    'cursor',
    'direction',
    'display',
    'empty-cells',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-size',
    'font-size-adjust',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-variant-ligatures',
    'font-variation-settings',
    'font-weight',
    'height',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'inherit',
    'initial',
    'justify-content',
    'left',
    'letter-spacing',
    'line-height',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-bottom',
    'margin-left',
    'margin-right',
    'margin-top',
    'marks',
    'mask',
    'max-height',
    'max-width',
    'min-height',
    'min-width',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'padding',
    'padding-bottom',
    'padding-left',
    'padding-right',
    'padding-top',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'perspective',
    'perspective-origin',
    'pointer-events',
    'position',
    'quotes',
    'resize',
    'right',
    'src',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-last',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-style',
    'text-indent',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-transform',
    'text-underline-position',
    'top',
    'transform',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'unicode-bidi',
    'vertical-align',
    'visibility',
    'white-space',
    'widows',
    'width',
    'word-break',
    'word-spacing',
    'word-wrap',
    'z-index'
  ].reverse();
  function scss(hljs) {
    const modes = MODES$2(hljs);
    const PSEUDO_ELEMENTS$1$1 = PSEUDO_ELEMENTS$1;
    const PSEUDO_CLASSES$1$1 = PSEUDO_CLASSES$1;
    const AT_IDENTIFIER = '@[a-z-]+';
    const AT_MODIFIERS = "and or not only";
    const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
    const VARIABLE = {
      className: 'variable',
      begin: '(\\$' + IDENT_RE + ')\\b'
    };
    return {
      name: 'SCSS',
      case_insensitive: true,
      illegal: '[=/|\']',
      contains: [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        {
          className: 'selector-id',
          begin: '#[A-Za-z0-9_-]+',
          relevance: 0
        },
        {
          className: 'selector-class',
          begin: '\\.[A-Za-z0-9_-]+',
          relevance: 0
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: 'selector-tag',
          begin: '\\b(' + TAGS$1.join('|') + ')\\b',
          relevance: 0
        },
        {
          className: 'selector-pseudo',
          begin: ':(' + PSEUDO_CLASSES$1$1.join('|') + ')'
        },
        {
          className: 'selector-pseudo',
          begin: '::(' + PSEUDO_ELEMENTS$1$1.join('|') + ')'
        },
        VARIABLE,
        {
          begin: /\(/,
          end: /\)/,
          contains: [ hljs.CSS_NUMBER_MODE ]
        },
        {
          className: 'attribute',
          begin: '\\b(' + ATTRIBUTES$1.join('|') + ')\\b'
        },
        {
          begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b'
        },
        {
          begin: ':',
          end: ';',
          contains: [
            VARIABLE,
            modes.HEXCOLOR,
            hljs.CSS_NUMBER_MODE,
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            modes.IMPORTANT
          ]
        },
        {
          begin: '@(page|font-face)',
          lexemes: AT_IDENTIFIER,
          keywords: '@page @font-face'
        },
        {
          begin: '@',
          end: '[{;]',
          returnBegin: true,
          keywords: {
            $pattern: /[a-z-]+/,
            keyword: AT_MODIFIERS,
            attribute: MEDIA_FEATURES$1.join(" ")
          },
          contains: [
            {
              begin: AT_IDENTIFIER,
              className: "keyword"
            },
            {
              begin: /[a-z-]+(?=:)/,
              className: "attribute"
            },
            VARIABLE,
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            modes.HEXCOLOR,
            hljs.CSS_NUMBER_MODE
          ]
        }
      ]
    };
  }
  var scss_1 = scss;

  const MODES$3 = (hljs) => {
    return {
      IMPORTANT: {
        className: 'meta',
        begin: '!important'
      },
      HEXCOLOR: {
        className: 'number',
        begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
      },
      ATTRIBUTE_SELECTOR_MODE: {
        className: 'selector-attr',
        begin: /\[/,
        end: /\]/,
        illegal: '$',
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      }
    };
  };
  const TAGS$2 = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'p',
    'q',
    'quote',
    'samp',
    'section',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video'
  ];
  const MEDIA_FEATURES$2 = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height'
  ];
  const PSEUDO_CLASSES$2 = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where'
  ];
  const PSEUDO_ELEMENTS$2 = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error'
  ];
  const ATTRIBUTES$2 = [
    'align-content',
    'align-items',
    'align-self',
    'animation',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-timing-function',
    'auto',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-repeat',
    'background-size',
    'border',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-decoration-break',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'clear',
    'clip',
    'clip-path',
    'color',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'content',
    'counter-increment',
    'counter-reset',
    'cursor',
    'direction',
    'display',
    'empty-cells',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-size',
    'font-size-adjust',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-variant-ligatures',
    'font-variation-settings',
    'font-weight',
    'height',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'inherit',
    'initial',
    'justify-content',
    'left',
    'letter-spacing',
    'line-height',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-bottom',
    'margin-left',
    'margin-right',
    'margin-top',
    'marks',
    'mask',
    'max-height',
    'max-width',
    'min-height',
    'min-width',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'padding',
    'padding-bottom',
    'padding-left',
    'padding-right',
    'padding-top',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'perspective',
    'perspective-origin',
    'pointer-events',
    'position',
    'quotes',
    'resize',
    'right',
    'src',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-last',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-style',
    'text-indent',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-transform',
    'text-underline-position',
    'top',
    'transform',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'unicode-bidi',
    'vertical-align',
    'visibility',
    'white-space',
    'widows',
    'width',
    'word-break',
    'word-spacing',
    'word-wrap',
    'z-index'
  ].reverse();
  const PSEUDO_SELECTORS = PSEUDO_CLASSES$2.concat(PSEUDO_ELEMENTS$2);
  function less(hljs) {
    const modes = MODES$3(hljs);
    const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
    const AT_MODIFIERS = "and or not only";
    const IDENT_RE = '[\\w-]+';
    const INTERP_IDENT_RE = '(' + IDENT_RE + '|@\\{' + IDENT_RE + '\\})';
    const RULES = []; const VALUE_MODES = [];
    const STRING_MODE = function(c) {
      return {
        className: 'string',
        begin: '~?' + c + '.*?' + c
      };
    };
    const IDENT_MODE = function(name, begin, relevance) {
      return {
        className: name,
        begin: begin,
        relevance: relevance
      };
    };
    const AT_KEYWORDS = {
      $pattern: /[a-z-]+/,
      keyword: AT_MODIFIERS,
      attribute: MEDIA_FEATURES$2.join(" ")
    };
    const PARENS_MODE = {
      begin: '\\(',
      end: '\\)',
      contains: VALUE_MODES,
      keywords: AT_KEYWORDS,
      relevance: 0
    };
    VALUE_MODES.push(
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      STRING_MODE("'"),
      STRING_MODE('"'),
      hljs.CSS_NUMBER_MODE,
      {
        begin: '(url|data-uri)\\(',
        starts: {
          className: 'string',
          end: '[\\)\\n]',
          excludeEnd: true
        }
      },
      modes.HEXCOLOR,
      PARENS_MODE,
      IDENT_MODE('variable', '@@?' + IDENT_RE, 10),
      IDENT_MODE('variable', '@\\{' + IDENT_RE + '\\}'),
      IDENT_MODE('built_in', '~?`[^`]*?`'),
      {
        className: 'attribute',
        begin: IDENT_RE + '\\s*:',
        end: ':',
        returnBegin: true,
        excludeEnd: true
      },
      modes.IMPORTANT
    );
    const VALUE_WITH_RULESETS = VALUE_MODES.concat({
      begin: /\{/,
      end: /\}/,
      contains: RULES
    });
    const MIXIN_GUARD_MODE = {
      beginKeywords: 'when',
      endsWithParent: true,
      contains: [
        {
          beginKeywords: 'and not'
        }
      ].concat(VALUE_MODES)
    };
    const RULE_MODE = {
      begin: INTERP_IDENT_RE + '\\s*:',
      returnBegin: true,
      end: /[;}]/,
      relevance: 0,
      contains: [
        {
          begin: /-(webkit|moz|ms|o)-/
        },
        {
          className: 'attribute',
          begin: '\\b(' + ATTRIBUTES$2.join('|') + ')\\b',
          end: /(?=:)/,
          starts: {
            endsWithParent: true,
            illegal: '[<=$]',
            relevance: 0,
            contains: VALUE_MODES
          }
        }
      ]
    };
    const AT_RULE_MODE = {
      className: 'keyword',
      begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
      starts: {
        end: '[;{}]',
        keywords: AT_KEYWORDS,
        returnEnd: true,
        contains: VALUE_MODES,
        relevance: 0
      }
    };
    const VAR_RULE_MODE = {
      className: 'variable',
      variants: [
        {
          begin: '@' + IDENT_RE + '\\s*:',
          relevance: 15
        },
        {
          begin: '@' + IDENT_RE
        }
      ],
      starts: {
        end: '[;}]',
        returnEnd: true,
        contains: VALUE_WITH_RULESETS
      }
    };
    const SELECTOR_MODE = {
      variants: [
        {
          begin: '[\\.#:&\\[>]',
          end: '[;{}]'
        },
        {
          begin: INTERP_IDENT_RE,
          end: /\{/
        }
      ],
      returnBegin: true,
      returnEnd: true,
      illegal: '[<=\'$"]',
      relevance: 0,
      contains: [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        MIXIN_GUARD_MODE,
        IDENT_MODE('keyword', 'all\\b'),
        IDENT_MODE('variable', '@\\{' + IDENT_RE + '\\}'),
        {
          begin: '\\b(' + TAGS$2.join('|') + ')\\b',
          className: 'selector-tag'
        },
        IDENT_MODE('selector-tag', INTERP_IDENT_RE + '%?', 0),
        IDENT_MODE('selector-id', '#' + INTERP_IDENT_RE),
        IDENT_MODE('selector-class', '\\.' + INTERP_IDENT_RE, 0),
        IDENT_MODE('selector-tag', '&', 0),
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: 'selector-pseudo',
          begin: ':(' + PSEUDO_CLASSES$2.join('|') + ')'
        },
        {
          className: 'selector-pseudo',
          begin: '::(' + PSEUDO_ELEMENTS$2.join('|') + ')'
        },
        {
          begin: '\\(',
          end: '\\)',
          contains: VALUE_WITH_RULESETS
        },
        {
          begin: '!important'
        }
      ]
    };
    const PSEUDO_SELECTOR_MODE = {
      begin: IDENT_RE + ':(:)?' + `(${PSEUDO_SELECTORS$1.join('|')})`,
      returnBegin: true,
      contains: [ SELECTOR_MODE ]
    };
    RULES.push(
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      AT_RULE_MODE,
      VAR_RULE_MODE,
      PSEUDO_SELECTOR_MODE,
      RULE_MODE,
      SELECTOR_MODE
    );
    return {
      name: 'Less',
      case_insensitive: true,
      illegal: '[=>\'/<($"]',
      contains: RULES
    };
  }
  var less_1 = less;

  const MODES$4 = (hljs) => {
    return {
      IMPORTANT: {
        className: 'meta',
        begin: '!important'
      },
      HEXCOLOR: {
        className: 'number',
        begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
      },
      ATTRIBUTE_SELECTOR_MODE: {
        className: 'selector-attr',
        begin: /\[/,
        end: /\]/,
        illegal: '$',
        contains: [
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      }
    };
  };
  const TAGS$3 = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'p',
    'q',
    'quote',
    'samp',
    'section',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video'
  ];
  const MEDIA_FEATURES$3 = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height'
  ];
  const PSEUDO_CLASSES$3 = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where'
  ];
  const PSEUDO_ELEMENTS$3 = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error'
  ];
  const ATTRIBUTES$3 = [
    'align-content',
    'align-items',
    'align-self',
    'animation',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-timing-function',
    'auto',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-repeat',
    'background-size',
    'border',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-decoration-break',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'clear',
    'clip',
    'clip-path',
    'color',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'content',
    'counter-increment',
    'counter-reset',
    'cursor',
    'direction',
    'display',
    'empty-cells',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-size',
    'font-size-adjust',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-variant-ligatures',
    'font-variation-settings',
    'font-weight',
    'height',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'inherit',
    'initial',
    'justify-content',
    'left',
    'letter-spacing',
    'line-height',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-bottom',
    'margin-left',
    'margin-right',
    'margin-top',
    'marks',
    'mask',
    'max-height',
    'max-width',
    'min-height',
    'min-width',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'padding',
    'padding-bottom',
    'padding-left',
    'padding-right',
    'padding-top',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'perspective',
    'perspective-origin',
    'pointer-events',
    'position',
    'quotes',
    'resize',
    'right',
    'src',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-last',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-style',
    'text-indent',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-transform',
    'text-underline-position',
    'top',
    'transform',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'unicode-bidi',
    'vertical-align',
    'visibility',
    'white-space',
    'widows',
    'width',
    'word-break',
    'word-spacing',
    'word-wrap',
    'z-index'
  ].reverse();
  function stylus(hljs) {
    const modes = MODES$4(hljs);
    const AT_MODIFIERS = "and or not only";
    const VARIABLE = {
      className: 'variable',
      begin: '\\$' + hljs.IDENT_RE
    };
    const AT_KEYWORDS = [
      'charset',
      'css',
      'debug',
      'extend',
      'font-face',
      'for',
      'import',
      'include',
      'keyframes',
      'media',
      'mixin',
      'page',
      'warn',
      'while'
    ];
    const LOOKAHEAD_TAG_END = '(?=[.\\s\\n[:,(])';
    const ILLEGAL = [
      '\\?',
      '(\\bReturn\\b)',
      '(\\bEnd\\b)',
      '(\\bend\\b)',
      '(\\bdef\\b)',
      ';',
      '#\\s',
      '\\*\\s',
      '===\\s',
      '\\|',
      '%'
    ];
    return {
      name: 'Stylus',
      aliases: [ 'styl' ],
      case_insensitive: false,
      keywords: 'if else for in',
      illegal: '(' + ILLEGAL.join('|') + ')',
      contains: [
        hljs.QUOTE_STRING_MODE,
        hljs.APOS_STRING_MODE,
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        modes.HEXCOLOR,
        {
          begin: '\\.[a-zA-Z][a-zA-Z0-9_-]*' + LOOKAHEAD_TAG_END,
          className: 'selector-class'
        },
        {
          begin: '#[a-zA-Z][a-zA-Z0-9_-]*' + LOOKAHEAD_TAG_END,
          className: 'selector-id'
        },
        {
          begin: '\\b(' + TAGS$3.join('|') + ')' + LOOKAHEAD_TAG_END,
          className: 'selector-tag'
        },
        {
          className: 'selector-pseudo',
          begin: '&?:(' + PSEUDO_CLASSES$3.join('|') + ')' + LOOKAHEAD_TAG_END
        },
        {
          className: 'selector-pseudo',
          begin: '&?::(' + PSEUDO_ELEMENTS$3.join('|') + ')' + LOOKAHEAD_TAG_END
        },
        modes.ATTRIBUTE_SELECTOR_MODE,
        {
          className: "keyword",
          begin: /@media/,
          starts: {
            end: /[{;}]/,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES$3.join(" ")
            },
            contains: [ hljs.CSS_NUMBER_MODE ]
          }
        },
        {
          className: 'keyword',
          begin: '\@((-(o|moz|ms|webkit)-)?(' + AT_KEYWORDS.join('|') + '))\\b'
        },
        VARIABLE,
        hljs.CSS_NUMBER_MODE,
        {
          className: 'function',
          begin: '^[a-zA-Z][a-zA-Z0-9_\-]*\\(.*\\)',
          illegal: '[\\n]',
          returnBegin: true,
          contains: [
            {
              className: 'title',
              begin: '\\b[a-zA-Z][a-zA-Z0-9_\-]*'
            },
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              contains: [
                modes.HEXCOLOR,
                VARIABLE,
                hljs.APOS_STRING_MODE,
                hljs.CSS_NUMBER_MODE,
                hljs.QUOTE_STRING_MODE
              ]
            }
          ]
        },
        {
          className: 'attribute',
          begin: '\\b(' + ATTRIBUTES$3.join('|') + ')\\b',
          starts: {
            end: /;|$/,
            contains: [
              modes.HEXCOLOR,
              VARIABLE,
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              hljs.CSS_NUMBER_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              modes.IMPORTANT
            ],
            illegal: /\./,
            relevance: 0
          }
        }
      ]
    };
  }
  var stylus_1 = stylus;

  function shell(hljs) {
    return {
      name: 'Shell Session',
      aliases: [ 'console' ],
      contains: [
        {
          className: 'meta',
          begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#]/,
          starts: {
            end: /[^\\](?=\s*$)/,
            subLanguage: 'bash'
          }
        }
      ]
    };
  }
  var shell_1 = shell;

  function source$3(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function concat$3(...args) {
    const joined = args.map((x) => source$3(x)).join("");
    return joined;
  }
  function bash(hljs) {
    const VAR = {};
    const BRACED_VAR = {
      begin: /\$\{/,
      end:/\}/,
      contains: [
        "self",
        {
          begin: /:-/,
          contains: [ VAR ]
        }
      ]
    };
    Object.assign(VAR,{
      className: 'variable',
      variants: [
        {begin: concat$3(/\$[\w\d#@][\w\d_]*/,
          `(?![\\w\\d])(?![$])`) },
        BRACED_VAR
      ]
    });
    const SUBST = {
      className: 'subst',
      begin: /\$\(/, end: /\)/,
      contains: [hljs.BACKSLASH_ESCAPE]
    };
    const HERE_DOC = {
      begin: /<<-?\s*(?=\w+)/,
      starts: {
        contains: [
          hljs.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            className: 'string'
          })
        ]
      }
    };
    const QUOTE_STRING = {
      className: 'string',
      begin: /"/, end: /"/,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        VAR,
        SUBST
      ]
    };
    SUBST.contains.push(QUOTE_STRING);
    const ESCAPED_QUOTE = {
      className: '',
      begin: /\\"/
    };
    const APOS_STRING = {
      className: 'string',
      begin: /'/, end: /'/
    };
    const ARITHMETIC = {
      begin: /\$\(\(/,
      end: /\)\)/,
      contains: [
        { begin: /\d+#[0-9a-f]+/, className: "number" },
        hljs.NUMBER_MODE,
        VAR
      ]
    };
    const SH_LIKE_SHELLS = [
      "fish",
      "bash",
      "zsh",
      "sh",
      "csh",
      "ksh",
      "tcsh",
      "dash",
      "scsh",
    ];
    const KNOWN_SHEBANG = hljs.SHEBANG({
      binary: `(${SH_LIKE_SHELLS.join("|")})`,
      relevance: 10
    });
    const FUNCTION = {
      className: 'function',
      begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
      returnBegin: true,
      contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\w[\w\d_]*/})],
      relevance: 0
    };
    return {
      name: 'Bash',
      aliases: ['sh', 'zsh'],
      keywords: {
        $pattern: /\b[a-z._-]+\b/,
        keyword:
          'if then else elif fi for while in do done case esac function',
        literal:
          'true false',
        built_in:
          'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' +
          'trap umask unset ' +
          'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' +
          'read readarray source type typeset ulimit unalias ' +
          'set shopt ' +
          'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' +
          'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' +
          'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' +
          'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' +
          'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' +
          'zpty zregexparse zsocket zstyle ztcp'
      },
      contains: [
        KNOWN_SHEBANG,
        hljs.SHEBANG(),
        FUNCTION,
        ARITHMETIC,
        hljs.HASH_COMMENT_MODE,
        HERE_DOC,
        QUOTE_STRING,
        ESCAPED_QUOTE,
        APOS_STRING,
        VAR
      ]
    };
  }
  var bash_1 = bash;

  function source$4(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$2(re) {
    return concat$4('(?=', re, ')');
  }
  function optional(re) {
    return concat$4('(', re, ')?');
  }
  function concat$4(...args) {
    const joined = args.map((x) => source$4(x)).join("");
    return joined;
  }
  function cpp(hljs) {
    const C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$', {
      contains: [
        {
          begin: /\\\n/
        }
      ]
    });
    const DECLTYPE_AUTO_RE = 'decltype\\(auto\\)';
    const NAMESPACE_RE = '[a-zA-Z_]\\w*::';
    const TEMPLATE_ARGUMENT_RE = '<[^<>]+>';
    const FUNCTION_TYPE_RE = '(' +
      DECLTYPE_AUTO_RE + '|' +
      optional(NAMESPACE_RE) +
      '[a-zA-Z_]\\w*' + optional(TEMPLATE_ARGUMENT_RE) +
    ')';
    const CPP_PRIMITIVE_TYPES = {
      className: 'keyword',
      begin: '\\b[a-z\\d_]*_t\\b'
    };
    const CHARACTER_ESCAPES = '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)';
    const STRINGS = {
      className: 'string',
      variants: [
        {
          begin: '(u8?|U|L)?"',
          end: '"',
          illegal: '\\n',
          contains: [ hljs.BACKSLASH_ESCAPE ]
        },
        {
          begin: '(u8?|U|L)?\'(' + CHARACTER_ESCAPES + "|.)",
          end: '\'',
          illegal: '.'
        },
        hljs.END_SAME_AS_BEGIN({
          begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
          end: /\)([^()\\ ]{0,16})"/
        })
      ]
    };
    const NUMBERS = {
      className: 'number',
      variants: [
        {
          begin: '\\b(0b[01\']+)'
        },
        {
          begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)'
        },
        {
          begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
        }
      ],
      relevance: 0
    };
    const PREPROCESSOR = {
      className: 'meta',
      begin: /#\s*[a-z]+\b/,
      end: /$/,
      keywords: {
        'meta-keyword':
          'if else elif endif define undef warning error line ' +
          'pragma _Pragma ifdef ifndef include'
      },
      contains: [
        {
          begin: /\\\n/,
          relevance: 0
        },
        hljs.inherit(STRINGS, {
          className: 'meta-string'
        }),
        {
          className: 'meta-string',
          begin: /<.*?>/
        },
        C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE
      ]
    };
    const TITLE_MODE = {
      className: 'title',
      begin: optional(NAMESPACE_RE) + hljs.IDENT_RE,
      relevance: 0
    };
    const FUNCTION_TITLE = optional(NAMESPACE_RE) + hljs.IDENT_RE + '\\s*\\(';
    const COMMON_CPP_HINTS = [
      'asin',
      'atan2',
      'atan',
      'calloc',
      'ceil',
      'cosh',
      'cos',
      'exit',
      'exp',
      'fabs',
      'floor',
      'fmod',
      'fprintf',
      'fputs',
      'free',
      'frexp',
      'auto_ptr',
      'deque',
      'list',
      'queue',
      'stack',
      'vector',
      'map',
      'set',
      'pair',
      'bitset',
      'multiset',
      'multimap',
      'unordered_set',
      'fscanf',
      'future',
      'isalnum',
      'isalpha',
      'iscntrl',
      'isdigit',
      'isgraph',
      'islower',
      'isprint',
      'ispunct',
      'isspace',
      'isupper',
      'isxdigit',
      'tolower',
      'toupper',
      'labs',
      'ldexp',
      'log10',
      'log',
      'malloc',
      'realloc',
      'memchr',
      'memcmp',
      'memcpy',
      'memset',
      'modf',
      'pow',
      'printf',
      'putchar',
      'puts',
      'scanf',
      'sinh',
      'sin',
      'snprintf',
      'sprintf',
      'sqrt',
      'sscanf',
      'strcat',
      'strchr',
      'strcmp',
      'strcpy',
      'strcspn',
      'strlen',
      'strncat',
      'strncmp',
      'strncpy',
      'strpbrk',
      'strrchr',
      'strspn',
      'strstr',
      'tanh',
      'tan',
      'unordered_map',
      'unordered_multiset',
      'unordered_multimap',
      'priority_queue',
      'make_pair',
      'array',
      'shared_ptr',
      'abort',
      'terminate',
      'abs',
      'acos',
      'vfprintf',
      'vprintf',
      'vsprintf',
      'endl',
      'initializer_list',
      'unique_ptr',
      'complex',
      'imaginary',
      'std',
      'string',
      'wstring',
      'cin',
      'cout',
      'cerr',
      'clog',
      'stdin',
      'stdout',
      'stderr',
      'stringstream',
      'istringstream',
      'ostringstream'
    ];
    const CPP_KEYWORDS = {
      keyword: 'int float while private char char8_t char16_t char32_t catch import module export virtual operator sizeof ' +
        'dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace ' +
        'unsigned long volatile static protected bool template mutable if public friend ' +
        'do goto auto void enum else break extern using asm case typeid wchar_t ' +
        'short reinterpret_cast|10 default double register explicit signed typename try this ' +
        'switch continue inline delete alignas alignof constexpr consteval constinit decltype ' +
        'concept co_await co_return co_yield requires ' +
        'noexcept static_assert thread_local restrict final override ' +
        'atomic_bool atomic_char atomic_schar ' +
        'atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong ' +
        'atomic_ullong new throw return ' +
        'and and_eq bitand bitor compl not not_eq or or_eq xor xor_eq',
      built_in: '_Bool _Complex _Imaginary',
      _relevance_hints: COMMON_CPP_HINTS,
      literal: 'true false nullptr NULL'
    };
    const FUNCTION_DISPATCH = {
      className: "function.dispatch",
      relevance: 0,
      keywords: CPP_KEYWORDS,
      begin: concat$4(
        /\b/,
        /(?!decltype)/,
        /(?!if)/,
        /(?!for)/,
        /(?!while)/,
        hljs.IDENT_RE,
        lookahead$2(/\s*\(/))
    };
    const EXPRESSION_CONTAINS = [
      FUNCTION_DISPATCH,
      PREPROCESSOR,
      CPP_PRIMITIVE_TYPES,
      C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      NUMBERS,
      STRINGS
    ];
    const EXPRESSION_CONTEXT = {
      variants: [
        {
          begin: /=/,
          end: /;/
        },
        {
          begin: /\(/,
          end: /\)/
        },
        {
          beginKeywords: 'new throw return else',
          end: /;/
        }
      ],
      keywords: CPP_KEYWORDS,
      contains: EXPRESSION_CONTAINS.concat([
        {
          begin: /\(/,
          end: /\)/,
          keywords: CPP_KEYWORDS,
          contains: EXPRESSION_CONTAINS.concat([ 'self' ]),
          relevance: 0
        }
      ]),
      relevance: 0
    };
    const FUNCTION_DECLARATION = {
      className: 'function',
      begin: '(' + FUNCTION_TYPE_RE + '[\\*&\\s]+)+' + FUNCTION_TITLE,
      returnBegin: true,
      end: /[{;=]/,
      excludeEnd: true,
      keywords: CPP_KEYWORDS,
      illegal: /[^\w\s\*&:<>.]/,
      contains: [
        {
          begin: DECLTYPE_AUTO_RE,
          keywords: CPP_KEYWORDS,
          relevance: 0
        },
        {
          begin: FUNCTION_TITLE,
          returnBegin: true,
          contains: [ TITLE_MODE ],
          relevance: 0
        },
        {
          begin: /::/,
          relevance: 0
        },
        {
          begin: /:/,
          endsWithParent: true,
          contains: [
            STRINGS,
            NUMBERS
          ]
        },
        {
          className: 'params',
          begin: /\(/,
          end: /\)/,
          keywords: CPP_KEYWORDS,
          relevance: 0,
          contains: [
            C_LINE_COMMENT_MODE,
            hljs.C_BLOCK_COMMENT_MODE,
            STRINGS,
            NUMBERS,
            CPP_PRIMITIVE_TYPES,
            {
              begin: /\(/,
              end: /\)/,
              keywords: CPP_KEYWORDS,
              relevance: 0,
              contains: [
                'self',
                C_LINE_COMMENT_MODE,
                hljs.C_BLOCK_COMMENT_MODE,
                STRINGS,
                NUMBERS,
                CPP_PRIMITIVE_TYPES
              ]
            }
          ]
        },
        CPP_PRIMITIVE_TYPES,
        C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        PREPROCESSOR
      ]
    };
    return {
      name: 'C++',
      aliases: [
        'cc',
        'c++',
        'h++',
        'hpp',
        'hh',
        'hxx',
        'cxx'
      ],
      keywords: CPP_KEYWORDS,
      illegal: '</',
      classNameAliases: {
        "function.dispatch": "built_in"
      },
      contains: [].concat(
        EXPRESSION_CONTEXT,
        FUNCTION_DECLARATION,
        FUNCTION_DISPATCH,
        EXPRESSION_CONTAINS,
        [
          PREPROCESSOR,
          {
            begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<',
            end: '>',
            keywords: CPP_KEYWORDS,
            contains: [
              'self',
              CPP_PRIMITIVE_TYPES
            ]
          },
          {
            begin: hljs.IDENT_RE + '::',
            keywords: CPP_KEYWORDS
          },
          {
            className: 'class',
            beginKeywords: 'enum class struct union',
            end: /[{;:<>=]/,
            contains: [
              {
                beginKeywords: "final class struct"
              },
              hljs.TITLE_MODE
            ]
          }
        ]),
      exports: {
        preprocessor: PREPROCESSOR,
        strings: STRINGS,
        keywords: CPP_KEYWORDS
      }
    };
  }
  var cpp_1 = cpp;

  function go(hljs) {
    const GO_KEYWORDS = {
      keyword:
        'break default func interface select case map struct chan else goto package switch ' +
        'const fallthrough if range type continue for import return var go defer ' +
        'bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 ' +
        'uint16 uint32 uint64 int uint uintptr rune',
      literal:
         'true false iota nil',
      built_in:
        'append cap close complex copy imag len make new panic print println real recover delete'
    };
    return {
      name: 'Go',
      aliases: ['golang'],
      keywords: GO_KEYWORDS,
      illegal: '</',
      contains: [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        {
          className: 'string',
          variants: [
            hljs.QUOTE_STRING_MODE,
            hljs.APOS_STRING_MODE,
            {
              begin: '`',
              end: '`'
            }
          ]
        },
        {
          className: 'number',
          variants: [
            {
              begin: hljs.C_NUMBER_RE + '[i]',
              relevance: 1
            },
            hljs.C_NUMBER_MODE
          ]
        },
        {
          begin: /:=/
        },
        {
          className: 'function',
          beginKeywords: 'func',
          end: '\\s*(\\{|$)',
          excludeEnd: true,
          contains: [
            hljs.TITLE_MODE,
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              keywords: GO_KEYWORDS,
              illegal: /["']/
            }
          ]
        }
      ]
    };
  }
  var go_1 = go;

  function source$5(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$3(re) {
    return concat$5('(?=', re, ')');
  }
  function optional$1(re) {
    return concat$5('(', re, ')?');
  }
  function concat$5(...args) {
    const joined = args.map((x) => source$5(x)).join("");
    return joined;
  }
  function either$1(...args) {
    const joined = '(' + args.map((x) => source$5(x)).join("|") + ")";
    return joined;
  }
  function xml(hljs) {
    const TAG_NAME_RE = concat$5(/[A-Z_]/, optional$1(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
    const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
    const XML_ENTITIES = {
      className: 'symbol',
      begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
    };
    const XML_META_KEYWORDS = {
      begin: /\s/,
      contains: [
        {
          className: 'meta-keyword',
          begin: /#?[a-z_][a-z1-9_-]+/,
          illegal: /\n/
        }
      ]
    };
    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
      begin: /\(/,
      end: /\)/
    });
    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
      className: 'meta-string'
    });
    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      className: 'meta-string'
    });
    const TAG_INTERNALS = {
      endsWithParent: true,
      illegal: /</,
      relevance: 0,
      contains: [
        {
          className: 'attr',
          begin: XML_IDENT_RE,
          relevance: 0
        },
        {
          begin: /=\s*/,
          relevance: 0,
          contains: [
            {
              className: 'string',
              endsParent: true,
              variants: [
                {
                  begin: /"/,
                  end: /"/,
                  contains: [ XML_ENTITIES ]
                },
                {
                  begin: /'/,
                  end: /'/,
                  contains: [ XML_ENTITIES ]
                },
                {
                  begin: /[^\s"'=<>`]+/
                }
              ]
            }
          ]
        }
      ]
    };
    return {
      name: 'HTML, XML',
      aliases: [
        'html',
        'xhtml',
        'rss',
        'atom',
        'xjb',
        'xsd',
        'xsl',
        'plist',
        'wsf',
        'svg'
      ],
      case_insensitive: true,
      contains: [
        {
          className: 'meta',
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            XML_META_KEYWORDS,
            QUOTE_META_STRING_MODE,
            APOS_META_STRING_MODE,
            XML_META_PAR_KEYWORDS,
            {
              begin: /\[/,
              end: /\]/,
              contains: [
                {
                  className: 'meta',
                  begin: /<![a-z]/,
                  end: />/,
                  contains: [
                    XML_META_KEYWORDS,
                    XML_META_PAR_KEYWORDS,
                    QUOTE_META_STRING_MODE,
                    APOS_META_STRING_MODE
                  ]
                }
              ]
            }
          ]
        },
        hljs.COMMENT(
          /<!--/,
          /-->/,
          {
            relevance: 10
          }
        ),
        {
          begin: /<!\[CDATA\[/,
          end: /\]\]>/,
          relevance: 10
        },
        XML_ENTITIES,
        {
          className: 'meta',
          begin: /<\?xml/,
          end: /\?>/,
          relevance: 10
        },
        {
          className: 'tag',
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: {
            name: 'style'
          },
          contains: [ TAG_INTERNALS ],
          starts: {
            end: /<\/style>/,
            returnEnd: true,
            subLanguage: [
              'css',
              'xml'
            ]
          }
        },
        {
          className: 'tag',
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: {
            name: 'script'
          },
          contains: [ TAG_INTERNALS ],
          starts: {
            end: /<\/script>/,
            returnEnd: true,
            subLanguage: [
              'javascript',
              'handlebars',
              'xml'
            ]
          }
        },
        {
          className: 'tag',
          begin: /<>|<\/>/
        },
        {
          className: 'tag',
          begin: concat$5(
            /</,
            lookahead$3(concat$5(
              TAG_NAME_RE,
              either$1(/\/>/, />/, /\s/)
            ))
          ),
          end: /\/?>/,
          contains: [
            {
              className: 'name',
              begin: TAG_NAME_RE,
              relevance: 0,
              starts: TAG_INTERNALS
            }
          ]
        },
        {
          className: 'tag',
          begin: concat$5(
            /<\//,
            lookahead$3(concat$5(
              TAG_NAME_RE, />/
            ))
          ),
          contains: [
            {
              className: 'name',
              begin: TAG_NAME_RE,
              relevance: 0
            },
            {
              begin: />/,
              relevance: 0,
              endsParent: true
            }
          ]
        }
      ]
    };
  }
  var xml_1 = xml;

  function source$6(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$4(re) {
    return concat$6('(?=', re, ')');
  }
  function concat$6(...args) {
    const joined = args.map((x) => source$6(x)).join("");
    return joined;
  }
  function python(hljs) {
    const RESERVED_WORDS = [
      'and',
      'as',
      'assert',
      'async',
      'await',
      'break',
      'class',
      'continue',
      'def',
      'del',
      'elif',
      'else',
      'except',
      'finally',
      'for',
      'from',
      'global',
      'if',
      'import',
      'in',
      'is',
      'lambda',
      'nonlocal|10',
      'not',
      'or',
      'pass',
      'raise',
      'return',
      'try',
      'while',
      'with',
      'yield'
    ];
    const BUILT_INS = [
      '__import__',
      'abs',
      'all',
      'any',
      'ascii',
      'bin',
      'bool',
      'breakpoint',
      'bytearray',
      'bytes',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'exec',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'print',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip'
    ];
    const LITERALS = [
      '__debug__',
      'Ellipsis',
      'False',
      'None',
      'NotImplemented',
      'True'
    ];
    const TYPES = [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ];
    const KEYWORDS = {
      $pattern: /[A-Za-z]\w+|__\w+__/,
      keyword: RESERVED_WORDS,
      built_in: BUILT_INS,
      literal: LITERALS,
      type: TYPES
    };
    const PROMPT = {
      className: 'meta',
      begin: /^(>>>|\.\.\.) /
    };
    const SUBST = {
      className: 'subst',
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS,
      illegal: /#/
    };
    const LITERAL_BRACKET = {
      begin: /\{\{/,
      relevance: 0
    };
    const STRING = {
      className: 'string',
      contains: [ hljs.BACKSLASH_ESCAPE ],
      variants: [
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
          end: /'''/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            PROMPT
          ],
          relevance: 10
        },
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
          end: /"""/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            PROMPT
          ],
          relevance: 10
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'''/,
          end: /'''/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            PROMPT,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"""/,
          end: /"""/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            PROMPT,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([uU]|[rR])'/,
          end: /'/,
          relevance: 10
        },
        {
          begin: /([uU]|[rR])"/,
          end: /"/,
          relevance: 10
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])'/,
          end: /'/
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])"/,
          end: /"/
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'/,
          end: /'/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"/,
          end: /"/,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    };
    const digitpart = '[0-9](_?[0-9])*';
    const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
    const NUMBER = {
      className: 'number',
      relevance: 0,
      variants: [
        {
          begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?\\b`
        },
        {
          begin: `(${pointfloat})[jJ]?`
        },
        {
          begin: '\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b'
        },
        {
          begin: '\\b0[bB](_?[01])+[lL]?\\b'
        },
        {
          begin: '\\b0[oO](_?[0-7])+[lL]?\\b'
        },
        {
          begin: '\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b'
        },
        {
          begin: `\\b(${digitpart})[jJ]\\b`
        }
      ]
    };
    const COMMENT_TYPE = {
      className: "comment",
      begin: lookahead$4(/# type:/),
      end: /$/,
      keywords: KEYWORDS,
      contains: [
        {
          begin: /# type:/
        },
        {
          begin: /#/,
          end: /\b\B/,
          endsWithParent: true
        }
      ]
    };
    const PARAMS = {
      className: 'params',
      variants: [
        {
          className: "",
          begin: /\(\s*\)/,
          skip: true
        },
        {
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: KEYWORDS,
          contains: [
            'self',
            PROMPT,
            NUMBER,
            STRING,
            hljs.HASH_COMMENT_MODE
          ]
        }
      ]
    };
    SUBST.contains = [
      STRING,
      NUMBER,
      PROMPT
    ];
    return {
      name: 'Python',
      aliases: [
        'py',
        'gyp',
        'ipython'
      ],
      keywords: KEYWORDS,
      illegal: /(<\/|->|\?)|=>/,
      contains: [
        PROMPT,
        NUMBER,
        {
          begin: /\bself\b/
        },
        {
          beginKeywords: "if",
          relevance: 0
        },
        STRING,
        COMMENT_TYPE,
        hljs.HASH_COMMENT_MODE,
        {
          variants: [
            {
              className: 'function',
              beginKeywords: 'def'
            },
            {
              className: 'class',
              beginKeywords: 'class'
            }
          ],
          end: /:/,
          illegal: /[${=;\n,]/,
          contains: [
            hljs.UNDERSCORE_TITLE_MODE,
            PARAMS,
            {
              begin: /->/,
              endsWithParent: true,
              keywords: KEYWORDS
            }
          ]
        },
        {
          className: 'meta',
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [
            NUMBER,
            PARAMS,
            STRING
          ]
        }
      ]
    };
  }
  var python_1 = python;

  const IDENT_RE$2 = '[A-Za-z$_][0-9A-Za-z$_]*';
  const KEYWORDS$1 = [
    "as",
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS$1 = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES$1 = [
    "Intl",
    "DataView",
    "Number",
    "Math",
    "Date",
    "String",
    "RegExp",
    "Object",
    "Function",
    "Boolean",
    "Error",
    "Symbol",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "Proxy",
    "Reflect",
    "JSON",
    "Promise",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Float32Array",
    "Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "ArrayBuffer",
    "BigInt64Array",
    "BigUint64Array",
    "BigInt"
  ];
  const ERROR_TYPES$1 = [
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS$1 = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES$1 = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
  ];
  const BUILT_INS$1 = [].concat(
    BUILT_IN_GLOBALS$1,
    BUILT_IN_VARIABLES$1,
    TYPES$1,
    ERROR_TYPES$1
  );
  function source$7(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$5(re) {
    return concat$7('(?=', re, ')');
  }
  function concat$7(...args) {
    const joined = args.map((x) => source$7(x)).join("");
    return joined;
  }
  function javascript$1(hljs) {
    const hasClosingTag = (match, { after }) => {
      const tag = "</" + match[0].slice(1);
      const pos = match.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$1 = IDENT_RE$2;
    const FRAGMENT = {
      begin: '<>',
      end: '</>'
    };
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      isTrulyOpeningTag: (match, response) => {
        const afterMatchIndex = match[0].length + match.index;
        const nextChar = match.input[afterMatchIndex];
        if (nextChar === "<") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
      }
    };
    const KEYWORDS$1$1 = {
      $pattern: IDENT_RE$2,
      keyword: KEYWORDS$1,
      literal: LITERALS$1,
      built_in: BUILT_INS$1
    };
    const decimalDigits = '[0-9](_?[0-9])*';
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: 'number',
      variants: [
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
          `[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        { begin: "\\b0[0-7]+n?\\b" },
      ],
      relevance: 0
    };
    const SUBST = {
      className: 'subst',
      begin: '\\$\\{',
      end: '\\}',
      keywords: KEYWORDS$1$1,
      contains: []
    };
    const HTML_TEMPLATE = {
      begin: 'html`',
      end: '',
      starts: {
        end: '`',
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: 'xml'
      }
    };
    const CSS_TEMPLATE = {
      begin: 'css`',
      end: '',
      starts: {
        end: '`',
        returnEnd: false,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: 'css'
      }
    };
    const TEMPLATE_STRING = {
      className: 'string',
      begin: '`',
      end: '`',
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs.COMMENT(
      /\/\*\*(?!\/)/,
      '\\*/',
      {
        relevance: 0,
        contains: [
          {
            className: 'doctag',
            begin: '@[A-Za-z]+',
            contains: [
              {
                className: 'type',
                begin: '\\{',
                end: '\\}',
                relevance: 0
              },
              {
                className: 'variable',
                begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
                endsParent: true,
                relevance: 0
              },
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      }
    );
    const COMMENT = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs.C_BLOCK_COMMENT_MODE,
        hljs.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER,
      hljs.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS
      .concat({
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: 'params',
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1$1,
      contains: PARAMS_CONTAINS
    };
    return {
      name: 'Javascript',
      aliases: ['js', 'jsx', 'mjs', 'cjs'],
      keywords: KEYWORDS$1$1,
      exports: { PARAMS_CONTAINS },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        {
          label: "use_strict",
          className: 'meta',
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/
        },
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT,
        NUMBER,
        {
          begin: concat$7(/[{,\n]\s*/,
            lookahead$5(concat$7(
              /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
              IDENT_RE$1 + '\\s*:'))),
          relevance: 0,
          contains: [
            {
              className: 'attr',
              begin: IDENT_RE$1 + lookahead$5('\\s*:'),
              relevance: 0
            }
          ]
        },
        {
          begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
          keywords: 'return throw case',
          contains: [
            COMMENT,
            hljs.REGEXP_MODE,
            {
              className: 'function',
              begin: '(\\(' +
              '[^()]*(\\(' +
              '[^()]*(\\(' +
              '[^()]*' +
              '\\)[^()]*)*' +
              '\\)[^()]*)*' +
              '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
              returnBegin: true,
              end: '\\s*=>',
              contains: [
                {
                  className: 'params',
                  variants: [
                    {
                      begin: hljs.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              begin: /,/, relevance: 0
            },
            {
              className: '',
              begin: /\s/,
              end: /\s*/,
              skip: true
            },
            {
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                {
                  begin: XML_TAG.begin,
                  'on:begin': XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: 'xml',
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ['self']
                }
              ]
            }
          ],
          relevance: 0
        },
        {
          className: 'function',
          beginKeywords: 'function',
          end: /[{;]/,
          excludeEnd: true,
          keywords: KEYWORDS$1$1,
          contains: [
            'self',
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
            PARAMS
          ],
          illegal: /%/
        },
        {
          beginKeywords: "while if switch catch for"
        },
        {
          className: 'function',
          begin: hljs.UNDERSCORE_IDENT_RE +
            '\\(' +
            '[^()]*(\\(' +
              '[^()]*(\\(' +
                '[^()]*' +
              '\\)[^()]*)*' +
            '\\)[^()]*)*' +
            '\\)\\s*\\{',
          returnBegin:true,
          contains: [
            PARAMS,
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
          ]
        },
        {
          variants: [
            { begin: '\\.' + IDENT_RE$1 },
            { begin: '\\$' + IDENT_RE$1 }
          ],
          relevance: 0
        },
        {
          className: 'class',
          beginKeywords: 'class',
          end: /[{;=]/,
          excludeEnd: true,
          illegal: /[:"[\]]/,
          contains: [
            { beginKeywords: 'extends' },
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          begin: /\b(?=constructor)/,
          end: /[{;]/,
          excludeEnd: true,
          contains: [
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
            'self',
            PARAMS
          ]
        },
        {
          begin: '(get|set)\\s+(?=' + IDENT_RE$1 + '\\()',
          end: /\{/,
          keywords: "get set",
          contains: [
            hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
            { begin: /\(\)/ },
            PARAMS
          ]
        },
        {
          begin: /\$[(.]/
        }
      ]
    };
  }
  function typescript(hljs) {
    const IDENT_RE$1 = IDENT_RE$2;
    const NAMESPACE = {
      beginKeywords: 'namespace', end: /\{/, excludeEnd: true
    };
    const INTERFACE = {
      beginKeywords: 'interface', end: /\{/, excludeEnd: true,
      keywords: 'interface extends'
    };
    const USE_STRICT = {
      className: 'meta',
      relevance: 10,
      begin: /^\s*['"]use strict['"]/
    };
    const TYPES = [
      "any",
      "void",
      "number",
      "boolean",
      "string",
      "object",
      "never",
      "enum"
    ];
    const TS_SPECIFIC_KEYWORDS = [
      "type",
      "namespace",
      "typedef",
      "interface",
      "public",
      "private",
      "protected",
      "implements",
      "declare",
      "abstract",
      "readonly"
    ];
    const KEYWORDS$1$1 = {
      $pattern: IDENT_RE$2,
      keyword: KEYWORDS$1.concat(TS_SPECIFIC_KEYWORDS),
      literal: LITERALS$1,
      built_in: BUILT_INS$1.concat(TYPES)
    };
    const DECORATOR = {
      className: 'meta',
      begin: '@' + IDENT_RE$1,
    };
    const swapMode = (mode, label, replacement) => {
      const indx = mode.contains.findIndex(m => m.label === label);
      if (indx === -1) { throw new Error("can not find mode to replace"); }
      mode.contains.splice(indx, 1, replacement);
    };
    const tsLanguage = javascript$1(hljs);
    Object.assign(tsLanguage.keywords, KEYWORDS$1$1);
    tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
    tsLanguage.contains = tsLanguage.contains.concat([
      DECORATOR,
      NAMESPACE,
      INTERFACE,
    ]);
    swapMode(tsLanguage, "shebang", hljs.SHEBANG());
    swapMode(tsLanguage, "use_strict", USE_STRICT);
    const functionDeclaration = tsLanguage.contains.find(m => m.className === "function");
    functionDeclaration.relevance = 0;
    Object.assign(tsLanguage, {
      name: 'TypeScript',
      aliases: ['ts', 'tsx']
    });
    return tsLanguage;
  }
  var typescript_1 = typescript;

  function source$8(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function concat$8(...args) {
    const joined = args.map((x) => source$8(x)).join("");
    return joined;
  }
  function either$2(...args) {
    const joined = '(' + args.map((x) => source$8(x)).join("|") + ")";
    return joined;
  }
  function sql(hljs) {
    const COMMENT_MODE = hljs.COMMENT('--', '$');
    const STRING = {
      className: 'string',
      variants: [
        {
          begin: /'/,
          end: /'/,
          contains: [
            {begin: /''/ }
          ]
        }
      ]
    };
    const QUOTED_IDENTIFIER = {
      begin: /"/,
      end: /"/,
      contains: [ { begin: /""/ } ]
    };
    const LITERALS = [
      "true",
      "false",
      "unknown"
    ];
    const MULTI_WORD_TYPES = [
      "double precision",
      "large object",
      "with timezone",
      "without timezone"
    ];
    const TYPES = [
      'bigint',
      'binary',
      'blob',
      'boolean',
      'char',
      'character',
      'clob',
      'date',
      'dec',
      'decfloat',
      'decimal',
      'float',
      'int',
      'integer',
      'interval',
      'nchar',
      'nclob',
      'national',
      'numeric',
      'real',
      'row',
      'smallint',
      'time',
      'timestamp',
      'varchar',
      'varying',
      'varbinary'
    ];
    const NON_RESERVED_WORDS = [
      "add",
      "asc",
      "collation",
      "desc",
      "final",
      "first",
      "last",
      "view"
    ];
    const RESERVED_WORDS = [
      "abs",
      "acos",
      "all",
      "allocate",
      "alter",
      "and",
      "any",
      "are",
      "array",
      "array_agg",
      "array_max_cardinality",
      "as",
      "asensitive",
      "asin",
      "asymmetric",
      "at",
      "atan",
      "atomic",
      "authorization",
      "avg",
      "begin",
      "begin_frame",
      "begin_partition",
      "between",
      "bigint",
      "binary",
      "blob",
      "boolean",
      "both",
      "by",
      "call",
      "called",
      "cardinality",
      "cascaded",
      "case",
      "cast",
      "ceil",
      "ceiling",
      "char",
      "char_length",
      "character",
      "character_length",
      "check",
      "classifier",
      "clob",
      "close",
      "coalesce",
      "collate",
      "collect",
      "column",
      "commit",
      "condition",
      "connect",
      "constraint",
      "contains",
      "convert",
      "copy",
      "corr",
      "corresponding",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "create",
      "cross",
      "cube",
      "cume_dist",
      "current",
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_row",
      "current_schema",
      "current_time",
      "current_timestamp",
      "current_path",
      "current_role",
      "current_transform_group_for_type",
      "current_user",
      "cursor",
      "cycle",
      "date",
      "day",
      "deallocate",
      "dec",
      "decimal",
      "decfloat",
      "declare",
      "default",
      "define",
      "delete",
      "dense_rank",
      "deref",
      "describe",
      "deterministic",
      "disconnect",
      "distinct",
      "double",
      "drop",
      "dynamic",
      "each",
      "element",
      "else",
      "empty",
      "end",
      "end_frame",
      "end_partition",
      "end-exec",
      "equals",
      "escape",
      "every",
      "except",
      "exec",
      "execute",
      "exists",
      "exp",
      "external",
      "extract",
      "false",
      "fetch",
      "filter",
      "first_value",
      "float",
      "floor",
      "for",
      "foreign",
      "frame_row",
      "free",
      "from",
      "full",
      "function",
      "fusion",
      "get",
      "global",
      "grant",
      "group",
      "grouping",
      "groups",
      "having",
      "hold",
      "hour",
      "identity",
      "in",
      "indicator",
      "initial",
      "inner",
      "inout",
      "insensitive",
      "insert",
      "int",
      "integer",
      "intersect",
      "intersection",
      "interval",
      "into",
      "is",
      "join",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "language",
      "large",
      "last_value",
      "lateral",
      "lead",
      "leading",
      "left",
      "like",
      "like_regex",
      "listagg",
      "ln",
      "local",
      "localtime",
      "localtimestamp",
      "log",
      "log10",
      "lower",
      "match",
      "match_number",
      "match_recognize",
      "matches",
      "max",
      "member",
      "merge",
      "method",
      "min",
      "minute",
      "mod",
      "modifies",
      "module",
      "month",
      "multiset",
      "national",
      "natural",
      "nchar",
      "nclob",
      "new",
      "no",
      "none",
      "normalize",
      "not",
      "nth_value",
      "ntile",
      "null",
      "nullif",
      "numeric",
      "octet_length",
      "occurrences_regex",
      "of",
      "offset",
      "old",
      "omit",
      "on",
      "one",
      "only",
      "open",
      "or",
      "order",
      "out",
      "outer",
      "over",
      "overlaps",
      "overlay",
      "parameter",
      "partition",
      "pattern",
      "per",
      "percent",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "period",
      "portion",
      "position",
      "position_regex",
      "power",
      "precedes",
      "precision",
      "prepare",
      "primary",
      "procedure",
      "ptf",
      "range",
      "rank",
      "reads",
      "real",
      "recursive",
      "ref",
      "references",
      "referencing",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "release",
      "result",
      "return",
      "returns",
      "revoke",
      "right",
      "rollback",
      "rollup",
      "row",
      "row_number",
      "rows",
      "running",
      "savepoint",
      "scope",
      "scroll",
      "search",
      "second",
      "seek",
      "select",
      "sensitive",
      "session_user",
      "set",
      "show",
      "similar",
      "sin",
      "sinh",
      "skip",
      "smallint",
      "some",
      "specific",
      "specifictype",
      "sql",
      "sqlexception",
      "sqlstate",
      "sqlwarning",
      "sqrt",
      "start",
      "static",
      "stddev_pop",
      "stddev_samp",
      "submultiset",
      "subset",
      "substring",
      "substring_regex",
      "succeeds",
      "sum",
      "symmetric",
      "system",
      "system_time",
      "system_user",
      "table",
      "tablesample",
      "tan",
      "tanh",
      "then",
      "time",
      "timestamp",
      "timezone_hour",
      "timezone_minute",
      "to",
      "trailing",
      "translate",
      "translate_regex",
      "translation",
      "treat",
      "trigger",
      "trim",
      "trim_array",
      "true",
      "truncate",
      "uescape",
      "union",
      "unique",
      "unknown",
      "unnest",
      "update   ",
      "upper",
      "user",
      "using",
      "value",
      "values",
      "value_of",
      "var_pop",
      "var_samp",
      "varbinary",
      "varchar",
      "varying",
      "versioning",
      "when",
      "whenever",
      "where",
      "width_bucket",
      "window",
      "with",
      "within",
      "without",
      "year",
    ];
    const RESERVED_FUNCTIONS = [
      "abs",
      "acos",
      "array_agg",
      "asin",
      "atan",
      "avg",
      "cast",
      "ceil",
      "ceiling",
      "coalesce",
      "corr",
      "cos",
      "cosh",
      "count",
      "covar_pop",
      "covar_samp",
      "cume_dist",
      "dense_rank",
      "deref",
      "element",
      "exp",
      "extract",
      "first_value",
      "floor",
      "json_array",
      "json_arrayagg",
      "json_exists",
      "json_object",
      "json_objectagg",
      "json_query",
      "json_table",
      "json_table_primitive",
      "json_value",
      "lag",
      "last_value",
      "lead",
      "listagg",
      "ln",
      "log",
      "log10",
      "lower",
      "max",
      "min",
      "mod",
      "nth_value",
      "ntile",
      "nullif",
      "percent_rank",
      "percentile_cont",
      "percentile_disc",
      "position",
      "position_regex",
      "power",
      "rank",
      "regr_avgx",
      "regr_avgy",
      "regr_count",
      "regr_intercept",
      "regr_r2",
      "regr_slope",
      "regr_sxx",
      "regr_sxy",
      "regr_syy",
      "row_number",
      "sin",
      "sinh",
      "sqrt",
      "stddev_pop",
      "stddev_samp",
      "substring",
      "substring_regex",
      "sum",
      "tan",
      "tanh",
      "translate",
      "translate_regex",
      "treat",
      "trim",
      "trim_array",
      "unnest",
      "upper",
      "value_of",
      "var_pop",
      "var_samp",
      "width_bucket",
    ];
    const POSSIBLE_WITHOUT_PARENS = [
      "current_catalog",
      "current_date",
      "current_default_transform_group",
      "current_path",
      "current_role",
      "current_schema",
      "current_transform_group_for_type",
      "current_user",
      "session_user",
      "system_time",
      "system_user",
      "current_time",
      "localtime",
      "current_timestamp",
      "localtimestamp"
    ];
    const COMBOS = [
      "create table",
      "insert into",
      "primary key",
      "foreign key",
      "not null",
      "alter table",
      "add constraint",
      "grouping sets",
      "on overflow",
      "character set",
      "respect nulls",
      "ignore nulls",
      "nulls first",
      "nulls last",
      "depth first",
      "breadth first"
    ];
    const FUNCTIONS = RESERVED_FUNCTIONS;
    const KEYWORDS = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => {
      return !RESERVED_FUNCTIONS.includes(keyword);
    });
    const VARIABLE = {
      className: "variable",
      begin: /@[a-z0-9]+/,
    };
    const OPERATOR = {
      className: "operator",
      begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
      relevance: 0,
    };
    const FUNCTION_CALL = {
      begin: concat$8(/\b/, either$2(...FUNCTIONS), /\s*\(/),
      keywords: {
        built_in: FUNCTIONS
      }
    };
    function reduceRelevancy(list, {exceptions, when} = {}) {
      const qualifyFn = when;
      exceptions = exceptions || [];
      return list.map((item) => {
        if (item.match(/\|\d+$/) || exceptions.includes(item)) {
          return item;
        } else if (qualifyFn(item)) {
          return `${item}|0`;
        } else {
          return item;
        }
      });
    }
    return {
      name: 'SQL',
      case_insensitive: true,
      illegal: /[{}]|<\//,
      keywords: {
        $pattern: /\b[\w\.]+/,
        keyword:
          reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
        literal: LITERALS,
        type: TYPES,
        built_in: POSSIBLE_WITHOUT_PARENS
      },
      contains: [
        {
          begin: either$2(...COMBOS),
          keywords: {
            $pattern: /[\w\.]+/,
            keyword: KEYWORDS.concat(COMBOS),
            literal: LITERALS,
            type: TYPES
          },
        },
        {
          className: "type",
          begin: either$2(...MULTI_WORD_TYPES)
        },
        FUNCTION_CALL,
        VARIABLE,
        STRING,
        QUOTED_IDENTIFIER,
        hljs.C_NUMBER_MODE,
        hljs.C_BLOCK_COMMENT_MODE,
        COMMENT_MODE,
        OPERATOR
      ]
    };
  }
  var sql_1 = sql;

  function source$9(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead$6(re) {
    return concat$9('(?=', re, ')');
  }
  function concat$9(...args) {
    const joined = args.map((x) => source$9(x)).join("");
    return joined;
  }
  function ruby(hljs) {
    const RUBY_METHOD_RE = '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)';
    const RUBY_KEYWORDS = {
      keyword:
        'and then defined module in return redo if BEGIN retry end for self when ' +
        'next until do begin unless END rescue else break undef not super class case ' +
        'require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor ' +
        '__FILE__',
      built_in: 'proc lambda',
      literal:
        'true false nil'
    };
    const YARDOCTAG = {
      className: 'doctag',
      begin: '@[A-Za-z]+'
    };
    const IRB_OBJECT = {
      begin: '#<',
      end: '>'
    };
    const COMMENT_MODES = [
      hljs.COMMENT(
        '#',
        '$',
        {
          contains: [ YARDOCTAG ]
        }
      ),
      hljs.COMMENT(
        '^=begin',
        '^=end',
        {
          contains: [ YARDOCTAG ],
          relevance: 10
        }
      ),
      hljs.COMMENT('^__END__', '\\n$')
    ];
    const SUBST = {
      className: 'subst',
      begin: /#\{/,
      end: /\}/,
      keywords: RUBY_KEYWORDS
    };
    const STRING = {
      className: 'string',
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /"/,
          end: /"/
        },
        {
          begin: /`/,
          end: /`/
        },
        {
          begin: /%[qQwWx]?\(/,
          end: /\)/
        },
        {
          begin: /%[qQwWx]?\[/,
          end: /\]/
        },
        {
          begin: /%[qQwWx]?\{/,
          end: /\}/
        },
        {
          begin: /%[qQwWx]?</,
          end: />/
        },
        {
          begin: /%[qQwWx]?\//,
          end: /\//
        },
        {
          begin: /%[qQwWx]?%/,
          end: /%/
        },
        {
          begin: /%[qQwWx]?-/,
          end: /-/
        },
        {
          begin: /%[qQwWx]?\|/,
          end: /\|/
        },
        {
          begin: /\B\?(\\\d{1,3})/
        },
        {
          begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
        },
        {
          begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
        },
        {
          begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
        },
        {
          begin: /\B\?\\(c|C-)[\x20-\x7e]/
        },
        {
          begin: /\B\?\\?\S/
        },
        {
          begin: /<<[-~]?'?(\w+)\n(?:[^\n]*\n)*?\s*\1\b/,
          returnBegin: true,
          contains: [
            {
              begin: /<<[-~]?'?/
            },
            hljs.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              contains: [
                hljs.BACKSLASH_ESCAPE,
                SUBST
              ]
            })
          ]
        }
      ]
    };
    const decimal = '[1-9](_?[0-9])*|0';
    const digits = '[0-9](_?[0-9])*';
    const NUMBER = {
      className: 'number',
      relevance: 0,
      variants: [
        {
          begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b`
        },
        {
          begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
        },
        {
          begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
        },
        {
          begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b"
        },
        {
          begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
        },
        {
          begin: "\\b0(_?[0-7])+r?i?\\b"
        }
      ]
    };
    const PARAMS = {
      className: 'params',
      begin: '\\(',
      end: '\\)',
      endsParent: true,
      keywords: RUBY_KEYWORDS
    };
    const RUBY_DEFAULT_CONTAINS = [
      STRING,
      {
        className: 'class',
        beginKeywords: 'class module',
        end: '$|;',
        illegal: /=/,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {
            begin: '[A-Za-z_]\\w*(::\\w+)*(\\?|!)?'
          }),
          {
            begin: '<\\s*',
            contains: [
              {
                begin: '(' + hljs.IDENT_RE + '::)?' + hljs.IDENT_RE,
                relevance: 0
              }
            ]
          }
        ].concat(COMMENT_MODES)
      },
      {
        className: 'function',
        begin: concat$9(/def\s+/, lookahead$6(RUBY_METHOD_RE + "\\s*(\\(|;|$)")),
        relevance: 0,
        keywords: "def",
        end: '$|;',
        contains: [
          hljs.inherit(hljs.TITLE_MODE, {
            begin: RUBY_METHOD_RE
          }),
          PARAMS
        ].concat(COMMENT_MODES)
      },
      {
        begin: hljs.IDENT_RE + '::'
      },
      {
        className: 'symbol',
        begin: hljs.UNDERSCORE_IDENT_RE + '(!|\\?)?:',
        relevance: 0
      },
      {
        className: 'symbol',
        begin: ':(?!\\s)',
        contains: [
          STRING,
          {
            begin: RUBY_METHOD_RE
          }
        ],
        relevance: 0
      },
      NUMBER,
      {
        className: "variable",
        begin: '(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])' + `(?![A-Za-z])(?![@$?'])`
      },
      {
        className: 'params',
        begin: /\|/,
        end: /\|/,
        relevance: 0,
        keywords: RUBY_KEYWORDS
      },
      {
        begin: '(' + hljs.RE_STARTERS_RE + '|unless)\\s*',
        keywords: 'unless',
        contains: [
          {
            className: 'regexp',
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ],
            illegal: /\n/,
            variants: [
              {
                begin: '/',
                end: '/[a-z]*'
              },
              {
                begin: /%r\{/,
                end: /\}[a-z]*/
              },
              {
                begin: '%r\\(',
                end: '\\)[a-z]*'
              },
              {
                begin: '%r!',
                end: '![a-z]*'
              },
              {
                begin: '%r\\[',
                end: '\\][a-z]*'
              }
            ]
          }
        ].concat(IRB_OBJECT, COMMENT_MODES),
        relevance: 0
      }
    ].concat(IRB_OBJECT, COMMENT_MODES);
    SUBST.contains = RUBY_DEFAULT_CONTAINS;
    PARAMS.contains = RUBY_DEFAULT_CONTAINS;
    const SIMPLE_PROMPT = "[>?]>";
    const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+>";
    const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
    const IRB_DEFAULT = [
      {
        begin: /^\s*=>/,
        starts: {
          end: '$',
          contains: RUBY_DEFAULT_CONTAINS
        }
      },
      {
        className: 'meta',
        begin: '^(' + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + '|' + RVM_PROMPT + ')(?=[ ])',
        starts: {
          end: '$',
          contains: RUBY_DEFAULT_CONTAINS
        }
      }
    ];
    COMMENT_MODES.unshift(IRB_OBJECT);
    return {
      name: 'Ruby',
      aliases: [
        'rb',
        'gemspec',
        'podspec',
        'thor',
        'irb'
      ],
      keywords: RUBY_KEYWORDS,
      illegal: /\/\*/,
      contains: [
        hljs.SHEBANG({
          binary: "ruby"
        })
      ]
        .concat(IRB_DEFAULT)
        .concat(COMMENT_MODES)
        .concat(RUBY_DEFAULT_CONTAINS)
    };
  }
  var ruby_1 = ruby;

  function vim(hljs) {
    return {
      name: 'Vim Script',
      keywords: {
        $pattern: /[!#@\w]+/,
        keyword:
          'N|0 P|0 X|0 a|0 ab abc abo al am an|0 ar arga argd arge argdo argg argl argu as au aug aun b|0 bN ba bad bd be bel bf bl bm bn bo bp br brea breaka breakd breakl bro bufdo buffers bun bw c|0 cN cNf ca cabc caddb cad caddf cal cat cb cc ccl cd ce cex cf cfir cgetb cgete cg changes chd che checkt cl cla clo cm cmapc cme cn cnew cnf cno cnorea cnoreme co col colo com comc comp con conf cope ' +
          'cp cpf cq cr cs cst cu cuna cunme cw delm deb debugg delc delf dif diffg diffo diffp diffpu diffs diffthis dig di dl dell dj dli do doautoa dp dr ds dsp e|0 ea ec echoe echoh echom echon el elsei em en endfo endf endt endw ene ex exe exi exu f|0 files filet fin fina fini fir fix fo foldc foldd folddoc foldo for fu go gr grepa gu gv ha helpf helpg helpt hi hid his ia iabc if ij il im imapc ' +
          'ime ino inorea inoreme int is isp iu iuna iunme j|0 ju k|0 keepa kee keepj lN lNf l|0 lad laddb laddf la lan lat lb lc lch lcl lcs le lefta let lex lf lfir lgetb lgete lg lgr lgrepa lh ll lla lli lmak lm lmapc lne lnew lnf ln loadk lo loc lockv lol lope lp lpf lr ls lt lu lua luad luaf lv lvimgrepa lw m|0 ma mak map mapc marks mat me menut mes mk mks mksp mkv mkvie mod mz mzf nbc nb nbs new nm nmapc nme nn nnoreme noa no noh norea noreme norm nu nun nunme ol o|0 om omapc ome on ono onoreme opt ou ounme ow p|0 ' +
          'profd prof pro promptr pc ped pe perld po popu pp pre prev ps pt ptN ptf ptj ptl ptn ptp ptr pts pu pw py3 python3 py3d py3f py pyd pyf quita qa rec red redi redr redraws reg res ret retu rew ri rightb rub rubyd rubyf rund ru rv sN san sa sal sav sb sbN sba sbf sbl sbm sbn sbp sbr scrip scripte scs se setf setg setl sf sfir sh sim sig sil sl sla sm smap smapc sme sn sni sno snor snoreme sor ' +
          'so spelld spe spelli spellr spellu spellw sp spr sre st sta startg startr star stopi stj sts sun sunm sunme sus sv sw sy synti sync tN tabN tabc tabdo tabe tabf tabfir tabl tabm tabnew ' +
          'tabn tabo tabp tabr tabs tab ta tags tc tcld tclf te tf th tj tl tm tn to tp tr try ts tu u|0 undoj undol una unh unl unlo unm unme uns up ve verb vert vim vimgrepa vi viu vie vm vmapc vme vne vn vnoreme vs vu vunme windo w|0 wN wa wh wi winc winp wn wp wq wqa ws wu wv x|0 xa xmapc xm xme xn xnoreme xu xunme y|0 z|0 ~ ' +
          'Next Print append abbreviate abclear aboveleft all amenu anoremenu args argadd argdelete argedit argglobal arglocal argument ascii autocmd augroup aunmenu buffer bNext ball badd bdelete behave belowright bfirst blast bmodified bnext botright bprevious brewind break breakadd breakdel breaklist browse bunload ' +
          'bwipeout change cNext cNfile cabbrev cabclear caddbuffer caddexpr caddfile call catch cbuffer cclose center cexpr cfile cfirst cgetbuffer cgetexpr cgetfile chdir checkpath checktime clist clast close cmap cmapclear cmenu cnext cnewer cnfile cnoremap cnoreabbrev cnoremenu copy colder colorscheme command comclear compiler continue confirm copen cprevious cpfile cquit crewind cscope cstag cunmap ' +
          'cunabbrev cunmenu cwindow delete delmarks debug debuggreedy delcommand delfunction diffupdate diffget diffoff diffpatch diffput diffsplit digraphs display deletel djump dlist doautocmd doautoall deletep drop dsearch dsplit edit earlier echo echoerr echohl echomsg else elseif emenu endif endfor ' +
          'endfunction endtry endwhile enew execute exit exusage file filetype find finally finish first fixdel fold foldclose folddoopen folddoclosed foldopen function global goto grep grepadd gui gvim hardcopy help helpfind helpgrep helptags highlight hide history insert iabbrev iabclear ijump ilist imap ' +
          'imapclear imenu inoremap inoreabbrev inoremenu intro isearch isplit iunmap iunabbrev iunmenu join jumps keepalt keepmarks keepjumps lNext lNfile list laddexpr laddbuffer laddfile last language later lbuffer lcd lchdir lclose lcscope left leftabove lexpr lfile lfirst lgetbuffer lgetexpr lgetfile lgrep lgrepadd lhelpgrep llast llist lmake lmap lmapclear lnext lnewer lnfile lnoremap loadkeymap loadview ' +
          'lockmarks lockvar lolder lopen lprevious lpfile lrewind ltag lunmap luado luafile lvimgrep lvimgrepadd lwindow move mark make mapclear match menu menutranslate messages mkexrc mksession mkspell mkvimrc mkview mode mzscheme mzfile nbclose nbkey nbsart next nmap nmapclear nmenu nnoremap ' +
          'nnoremenu noautocmd noremap nohlsearch noreabbrev noremenu normal number nunmap nunmenu oldfiles open omap omapclear omenu only onoremap onoremenu options ounmap ounmenu ownsyntax print profdel profile promptfind promptrepl pclose pedit perl perldo pop popup ppop preserve previous psearch ptag ptNext ' +
          'ptfirst ptjump ptlast ptnext ptprevious ptrewind ptselect put pwd py3do py3file python pydo pyfile quit quitall qall read recover redo redir redraw redrawstatus registers resize retab return rewind right rightbelow ruby rubydo rubyfile rundo runtime rviminfo substitute sNext sandbox sargument sall saveas sbuffer sbNext sball sbfirst sblast sbmodified sbnext sbprevious sbrewind scriptnames scriptencoding ' +
          'scscope set setfiletype setglobal setlocal sfind sfirst shell simalt sign silent sleep slast smagic smapclear smenu snext sniff snomagic snoremap snoremenu sort source spelldump spellgood spellinfo spellrepall spellundo spellwrong split sprevious srewind stop stag startgreplace startreplace ' +
          'startinsert stopinsert stjump stselect sunhide sunmap sunmenu suspend sview swapname syntax syntime syncbind tNext tabNext tabclose tabedit tabfind tabfirst tablast tabmove tabnext tabonly tabprevious tabrewind tag tcl tcldo tclfile tearoff tfirst throw tjump tlast tmenu tnext topleft tprevious ' + 'trewind tselect tunmenu undo undojoin undolist unabbreviate unhide unlet unlockvar unmap unmenu unsilent update vglobal version verbose vertical vimgrep vimgrepadd visual viusage view vmap vmapclear vmenu vnew ' +
          'vnoremap vnoremenu vsplit vunmap vunmenu write wNext wall while winsize wincmd winpos wnext wprevious wqall wsverb wundo wviminfo xit xall xmapclear xmap xmenu xnoremap xnoremenu xunmap xunmenu yank',
        built_in:
          'synIDtrans atan2 range matcharg did_filetype asin feedkeys xor argv ' +
          'complete_check add getwinposx getqflist getwinposy screencol ' +
          'clearmatches empty extend getcmdpos mzeval garbagecollect setreg ' +
          'ceil sqrt diff_hlID inputsecret get getfperm getpid filewritable ' +
          'shiftwidth max sinh isdirectory synID system inputrestore winline ' +
          'atan visualmode inputlist tabpagewinnr round getregtype mapcheck ' +
          'hasmapto histdel argidx findfile sha256 exists toupper getcmdline ' +
          'taglist string getmatches bufnr strftime winwidth bufexists ' +
          'strtrans tabpagebuflist setcmdpos remote_read printf setloclist ' +
          'getpos getline bufwinnr float2nr len getcmdtype diff_filler luaeval ' +
          'resolve libcallnr foldclosedend reverse filter has_key bufname ' +
          'str2float strlen setline getcharmod setbufvar index searchpos ' +
          'shellescape undofile foldclosed setqflist buflisted strchars str2nr ' +
          'virtcol floor remove undotree remote_expr winheight gettabwinvar ' +
          'reltime cursor tabpagenr finddir localtime acos getloclist search ' +
          'tanh matchend rename gettabvar strdisplaywidth type abs py3eval ' +
          'setwinvar tolower wildmenumode log10 spellsuggest bufloaded ' +
          'synconcealed nextnonblank server2client complete settabwinvar ' +
          'executable input wincol setmatches getftype hlID inputsave ' +
          'searchpair or screenrow line settabvar histadd deepcopy strpart ' +
          'remote_peek and eval getftime submatch screenchar winsaveview ' +
          'matchadd mkdir screenattr getfontname libcall reltimestr getfsize ' +
          'winnr invert pow getbufline byte2line soundfold repeat fnameescape ' +
          'tagfiles sin strwidth spellbadword trunc maparg log lispindent ' +
          'hostname setpos globpath remote_foreground getchar synIDattr ' +
          'fnamemodify cscope_connection stridx winbufnr indent min ' +
          'complete_add nr2char searchpairpos inputdialog values matchlist ' +
          'items hlexists strridx browsedir expand fmod pathshorten line2byte ' +
          'argc count getwinvar glob foldtextresult getreg foreground cosh ' +
          'matchdelete has char2nr simplify histget searchdecl iconv ' +
          'winrestcmd pumvisible writefile foldlevel haslocaldir keys cos ' +
          'matchstr foldtext histnr tan tempname getcwd byteidx getbufvar ' +
          'islocked escape eventhandler remote_send serverlist winrestview ' +
          'synstack pyeval prevnonblank readfile cindent filereadable changenr ' +
          'exp'
      },
      illegal: /;/,
      contains: [
        hljs.NUMBER_MODE,
        {
          className: 'string',
          begin: '\'',
          end: '\'',
          illegal: '\\n'
        },
        {
          className: 'string',
          begin: /"(\\"|\n\\|[^"\n])*"/
        },
        hljs.COMMENT('"', '$'),
        {
          className: 'variable',
          begin: /[bwtglsav]:[\w\d_]*/
        },
        {
          className: 'function',
          beginKeywords: 'function function!',
          end: '$',
          relevance: 0,
          contains: [
            hljs.TITLE_MODE,
            {
              className: 'params',
              begin: '\\(',
              end: '\\)'
            }
          ]
        },
        {
          className: 'symbol',
          begin: /<[\w-]+>/
        }
      ]
    };
  }
  var vim_1 = vim;

  function php(hljs) {
    const VARIABLE = {
      className: 'variable',
      begin: '\\$+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*' +
        `(?![A-Za-z0-9])(?![$])`
    };
    const PREPROCESSOR = {
      className: 'meta',
      variants: [
        { begin: /<\?php/, relevance: 10 },
        { begin: /<\?[=]?/ },
        { begin: /\?>/ }
      ]
    };
    const SUBST = {
      className: 'subst',
      variants: [
        { begin: /\$\w+/ },
        { begin: /\{\$/, end: /\}/ }
      ]
    };
    const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
      illegal: null,
    });
    const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
      illegal: null,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
    });
    const HEREDOC = hljs.END_SAME_AS_BEGIN({
      begin: /<<<[ \t]*(\w+)\n/,
      end: /[ \t]*(\w+)\b/,
      contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
    });
    const STRING = {
      className: 'string',
      contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
      variants: [
        hljs.inherit(SINGLE_QUOTED, {
          begin: "b'", end: "'",
        }),
        hljs.inherit(DOUBLE_QUOTED, {
          begin: 'b"', end: '"',
        }),
        DOUBLE_QUOTED,
        SINGLE_QUOTED,
        HEREDOC
      ]
    };
    const NUMBER = {
      className: 'number',
      variants: [
        { begin: `\\b0b[01]+(?:_[01]+)*\\b` },
        { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` },
        { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` },
        { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?` }
      ],
      relevance: 0
    };
    const KEYWORDS = {
      keyword:
      '__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ ' +
      'die echo exit include include_once print require require_once ' +
      'array abstract and as binary bool boolean break callable case catch class clone const continue declare ' +
      'default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends ' +
      'final finally float for foreach from global goto if implements instanceof insteadof int integer interface ' +
      'isset iterable list match|0 mixed new object or private protected public real return string switch throw trait ' +
      'try unset use var void while xor yield',
      literal: 'false null true',
      built_in:
      'Error|0 ' +
      'AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ' +
      'ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap ' +
      'Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass'
    };
    return {
      aliases: ['php3', 'php4', 'php5', 'php6', 'php7', 'php8'],
      case_insensitive: true,
      keywords: KEYWORDS,
      contains: [
        hljs.HASH_COMMENT_MODE,
        hljs.COMMENT('//', '$', {contains: [PREPROCESSOR]}),
        hljs.COMMENT(
          '/\\*',
          '\\*/',
          {
            contains: [
              {
                className: 'doctag',
                begin: '@[A-Za-z]+'
              }
            ]
          }
        ),
        hljs.COMMENT(
          '__halt_compiler.+?;',
          false,
          {
            endsWithParent: true,
            keywords: '__halt_compiler'
          }
        ),
        PREPROCESSOR,
        {
          className: 'keyword', begin: /\$this\b/
        },
        VARIABLE,
        {
          begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
        },
        {
          className: 'function',
          relevance: 0,
          beginKeywords: 'fn function', end: /[;{]/, excludeEnd: true,
          illegal: '[$%\\[]',
          contains: [
            {
              beginKeywords: 'use',
            },
            hljs.UNDERSCORE_TITLE_MODE,
            {
              begin: '=>',
              endsParent: true
            },
            {
              className: 'params',
              begin: '\\(', end: '\\)',
              excludeBegin: true,
              excludeEnd: true,
              keywords: KEYWORDS,
              contains: [
                'self',
                VARIABLE,
                hljs.C_BLOCK_COMMENT_MODE,
                STRING,
                NUMBER
              ]
            }
          ]
        },
        {
          className: 'class',
          variants: [
            { beginKeywords: "enum", illegal: /[($"]/ },
            { beginKeywords: "class interface trait", illegal: /[:($"]/ }
          ],
          relevance: 0,
          end: /\{/,
          excludeEnd: true,
          contains: [
            {beginKeywords: 'extends implements'},
            hljs.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          beginKeywords: 'namespace',
          relevance: 0,
          end: ';',
          illegal: /[.']/,
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        {
          beginKeywords: 'use',
          relevance: 0,
          end: ';',
          contains: [hljs.UNDERSCORE_TITLE_MODE]
        },
        STRING,
        NUMBER
      ]
    };
  }
  var php_1 = php;

  function source$a(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function concat$a(...args) {
    const joined = args.map((x) => source$a(x)).join("");
    return joined;
  }
  function either$3(...args) {
    const joined = '(' + args.map((x) => source$a(x)).join("|") + ")";
    return joined;
  }
  function perl(hljs) {
    const KEYWORDS = [
      'abs',
      'accept',
      'alarm',
      'and',
      'atan2',
      'bind',
      'binmode',
      'bless',
      'break',
      'caller',
      'chdir',
      'chmod',
      'chomp',
      'chop',
      'chown',
      'chr',
      'chroot',
      'close',
      'closedir',
      'connect',
      'continue',
      'cos',
      'crypt',
      'dbmclose',
      'dbmopen',
      'defined',
      'delete',
      'die',
      'do',
      'dump',
      'each',
      'else',
      'elsif',
      'endgrent',
      'endhostent',
      'endnetent',
      'endprotoent',
      'endpwent',
      'endservent',
      'eof',
      'eval',
      'exec',
      'exists',
      'exit',
      'exp',
      'fcntl',
      'fileno',
      'flock',
      'for',
      'foreach',
      'fork',
      'format',
      'formline',
      'getc',
      'getgrent',
      'getgrgid',
      'getgrnam',
      'gethostbyaddr',
      'gethostbyname',
      'gethostent',
      'getlogin',
      'getnetbyaddr',
      'getnetbyname',
      'getnetent',
      'getpeername',
      'getpgrp',
      'getpriority',
      'getprotobyname',
      'getprotobynumber',
      'getprotoent',
      'getpwent',
      'getpwnam',
      'getpwuid',
      'getservbyname',
      'getservbyport',
      'getservent',
      'getsockname',
      'getsockopt',
      'given',
      'glob',
      'gmtime',
      'goto',
      'grep',
      'gt',
      'hex',
      'if',
      'index',
      'int',
      'ioctl',
      'join',
      'keys',
      'kill',
      'last',
      'lc',
      'lcfirst',
      'length',
      'link',
      'listen',
      'local',
      'localtime',
      'log',
      'lstat',
      'lt',
      'ma',
      'map',
      'mkdir',
      'msgctl',
      'msgget',
      'msgrcv',
      'msgsnd',
      'my',
      'ne',
      'next',
      'no',
      'not',
      'oct',
      'open',
      'opendir',
      'or',
      'ord',
      'our',
      'pack',
      'package',
      'pipe',
      'pop',
      'pos',
      'print',
      'printf',
      'prototype',
      'push',
      'q|0',
      'qq',
      'quotemeta',
      'qw',
      'qx',
      'rand',
      'read',
      'readdir',
      'readline',
      'readlink',
      'readpipe',
      'recv',
      'redo',
      'ref',
      'rename',
      'require',
      'reset',
      'return',
      'reverse',
      'rewinddir',
      'rindex',
      'rmdir',
      'say',
      'scalar',
      'seek',
      'seekdir',
      'select',
      'semctl',
      'semget',
      'semop',
      'send',
      'setgrent',
      'sethostent',
      'setnetent',
      'setpgrp',
      'setpriority',
      'setprotoent',
      'setpwent',
      'setservent',
      'setsockopt',
      'shift',
      'shmctl',
      'shmget',
      'shmread',
      'shmwrite',
      'shutdown',
      'sin',
      'sleep',
      'socket',
      'socketpair',
      'sort',
      'splice',
      'split',
      'sprintf',
      'sqrt',
      'srand',
      'stat',
      'state',
      'study',
      'sub',
      'substr',
      'symlink',
      'syscall',
      'sysopen',
      'sysread',
      'sysseek',
      'system',
      'syswrite',
      'tell',
      'telldir',
      'tie',
      'tied',
      'time',
      'times',
      'tr',
      'truncate',
      'uc',
      'ucfirst',
      'umask',
      'undef',
      'unless',
      'unlink',
      'unpack',
      'unshift',
      'untie',
      'until',
      'use',
      'utime',
      'values',
      'vec',
      'wait',
      'waitpid',
      'wantarray',
      'warn',
      'when',
      'while',
      'write',
      'x|0',
      'xor',
      'y|0'
    ];
    const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
    const PERL_KEYWORDS = {
      $pattern: /[\w.]+/,
      keyword: KEYWORDS.join(" ")
    };
    const SUBST = {
      className: 'subst',
      begin: '[$@]\\{',
      end: '\\}',
      keywords: PERL_KEYWORDS
    };
    const METHOD = {
      begin: /->\{/,
      end: /\}/
    };
    const VAR = {
      variants: [
        {
          begin: /\$\d/
        },
        {
          begin: concat$a(
            /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
            `(?![A-Za-z])(?![@$%])`
          )
        },
        {
          begin: /[$%@][^\s\w{]/,
          relevance: 0
        }
      ]
    };
    const STRING_CONTAINS = [
      hljs.BACKSLASH_ESCAPE,
      SUBST,
      VAR
    ];
    const REGEX_DELIMS = [
      /!/,
      /\//,
      /\|/,
      /\?/,
      /'/,
      /"/,
      /#/
    ];
    const PAIRED_DOUBLE_RE = (prefix, open, close = '\\1') => {
      const middle = (close === '\\1')
        ? close
        : concat$a(close, open);
      return concat$a(
        concat$a("(?:", prefix, ")"),
        open,
        /(?:\\.|[^\\\/])*?/,
        middle,
        /(?:\\.|[^\\\/])*?/,
        close,
        REGEX_MODIFIERS
      );
    };
    const PAIRED_RE = (prefix, open, close) => {
      return concat$a(
        concat$a("(?:", prefix, ")"),
        open,
        /(?:\\.|[^\\\/])*?/,
        close,
        REGEX_MODIFIERS
      );
    };
    const PERL_DEFAULT_CONTAINS = [
      VAR,
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT(
        /^=\w/,
        /=cut/,
        {
          endsWithParent: true
        }
      ),
      METHOD,
      {
        className: 'string',
        contains: STRING_CONTAINS,
        variants: [
          {
            begin: 'q[qwxr]?\\s*\\(',
            end: '\\)',
            relevance: 5
          },
          {
            begin: 'q[qwxr]?\\s*\\[',
            end: '\\]',
            relevance: 5
          },
          {
            begin: 'q[qwxr]?\\s*\\{',
            end: '\\}',
            relevance: 5
          },
          {
            begin: 'q[qwxr]?\\s*\\|',
            end: '\\|',
            relevance: 5
          },
          {
            begin: 'q[qwxr]?\\s*<',
            end: '>',
            relevance: 5
          },
          {
            begin: 'qw\\s+q',
            end: 'q',
            relevance: 5
          },
          {
            begin: '\'',
            end: '\'',
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: '"',
            end: '"'
          },
          {
            begin: '`',
            end: '`',
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: /\{\w+\}/,
            relevance: 0
          },
          {
            begin: '-?\\w+\\s*=>',
            relevance: 0
          }
        ]
      },
      {
        className: 'number',
        begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
        relevance: 0
      },
      {
        begin: '(\\/\\/|' + hljs.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
        keywords: 'split return print reverse grep',
        relevance: 0,
        contains: [
          hljs.HASH_COMMENT_MODE,
          {
            className: 'regexp',
            variants: [
              { begin: PAIRED_DOUBLE_RE("s|tr|y", either$3(...REGEX_DELIMS)) },
              { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
              { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
              { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
            ],
            relevance: 2
          },
          {
            className: 'regexp',
            variants: [
              {
                begin: /(m|qr)\/\//,
                relevance: 0
              },
              { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//)},
              { begin: PAIRED_RE("m|qr", either$3(...REGEX_DELIMS), /\1/)},
              { begin: PAIRED_RE("m|qr", /\(/, /\)/)},
              { begin: PAIRED_RE("m|qr", /\[/, /\]/)},
              { begin: PAIRED_RE("m|qr", /\{/, /\}/)}
            ]
          }
        ]
      },
      {
        className: 'function',
        beginKeywords: 'sub',
        end: '(\\s*\\(.*?\\))?[;{]',
        excludeEnd: true,
        relevance: 5,
        contains: [ hljs.TITLE_MODE ]
      },
      {
        begin: '-\\w\\b',
        relevance: 0
      },
      {
        begin: "^__DATA__$",
        end: "^__END__$",
        subLanguage: 'mojolicious',
        contains: [
          {
            begin: "^@@.*",
            end: "$",
            className: "comment"
          }
        ]
      }
    ];
    SUBST.contains = PERL_DEFAULT_CONTAINS;
    METHOD.contains = PERL_DEFAULT_CONTAINS;
    return {
      name: 'Perl',
      aliases: [
        'pl',
        'pm'
      ],
      keywords: PERL_KEYWORDS,
      contains: PERL_DEFAULT_CONTAINS
    };
  }
  var perl_1 = perl;

  function powershell(hljs) {
    const TYPES = [
      "string",
      "char",
      "byte",
      "int",
      "long",
      "bool",
      "decimal",
      "single",
      "double",
      "DateTime",
      "xml",
      "array",
      "hashtable",
      "void"
    ];
    const VALID_VERBS =
      'Add|Clear|Close|Copy|Enter|Exit|Find|Format|Get|Hide|Join|Lock|' +
      'Move|New|Open|Optimize|Pop|Push|Redo|Remove|Rename|Reset|Resize|' +
      'Search|Select|Set|Show|Skip|Split|Step|Switch|Undo|Unlock|' +
      'Watch|Backup|Checkpoint|Compare|Compress|Convert|ConvertFrom|' +
      'ConvertTo|Dismount|Edit|Expand|Export|Group|Import|Initialize|' +
      'Limit|Merge|Mount|Out|Publish|Restore|Save|Sync|Unpublish|Update|' +
      'Approve|Assert|Build|Complete|Confirm|Deny|Deploy|Disable|Enable|Install|Invoke|' +
      'Register|Request|Restart|Resume|Start|Stop|Submit|Suspend|Uninstall|' +
      'Unregister|Wait|Debug|Measure|Ping|Repair|Resolve|Test|Trace|Connect|' +
      'Disconnect|Read|Receive|Send|Write|Block|Grant|Protect|Revoke|Unblock|' +
      'Unprotect|Use|ForEach|Sort|Tee|Where';
    const COMPARISON_OPERATORS =
      '-and|-as|-band|-bnot|-bor|-bxor|-casesensitive|-ccontains|-ceq|-cge|-cgt|' +
      '-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|' +
      '-creplace|-csplit|-eq|-exact|-f|-file|-ge|-gt|-icontains|-ieq|-ige|-igt|' +
      '-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|' +
      '-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-not|' +
      '-notcontains|-notin|-notlike|-notmatch|-or|-regex|-replace|-shl|-shr|' +
      '-split|-wildcard|-xor';
    const KEYWORDS = {
      $pattern: /-?[A-z\.\-]+\b/,
      keyword:
        'if else foreach return do while until elseif begin for trap data dynamicparam ' +
        'end break throw param continue finally in switch exit filter try process catch ' +
        'hidden static parameter',
      built_in:
        'ac asnp cat cd CFS chdir clc clear clhy cli clp cls clv cnsn compare copy cp ' +
        'cpi cpp curl cvpa dbp del diff dir dnsn ebp echo|0 epal epcsv epsn erase etsn exsn fc fhx ' +
        'fl ft fw gal gbp gc gcb gci gcm gcs gdr gerr ghy gi gin gjb gl gm gmo gp gps gpv group ' +
        'gsn gsnp gsv gtz gu gv gwmi h history icm iex ihy ii ipal ipcsv ipmo ipsn irm ise iwmi ' +
        'iwr kill lp ls man md measure mi mount move mp mv nal ndr ni nmo npssc nsn nv ogv oh ' +
        'popd ps pushd pwd r rbp rcjb rcsn rd rdr ren ri rjb rm rmdir rmo rni rnp rp rsn rsnp ' +
        'rujb rv rvpa rwmi sajb sal saps sasv sbp sc scb select set shcm si sl sleep sls sort sp ' +
        'spjb spps spsv start stz sujb sv swmi tee trcm type wget where wjb write'
    };
    const TITLE_NAME_RE = /\w[\w\d]*((-)[\w\d]+)*/;
    const BACKTICK_ESCAPE = {
      begin: '`[\\s\\S]',
      relevance: 0
    };
    const VAR = {
      className: 'variable',
      variants: [
        {
          begin: /\$\B/
        },
        {
          className: 'keyword',
          begin: /\$this/
        },
        {
          begin: /\$[\w\d][\w\d_:]*/
        }
      ]
    };
    const LITERAL = {
      className: 'literal',
      begin: /\$(null|true|false)\b/
    };
    const QUOTE_STRING = {
      className: "string",
      variants: [
        {
          begin: /"/,
          end: /"/
        },
        {
          begin: /@"/,
          end: /^"@/
        }
      ],
      contains: [
        BACKTICK_ESCAPE,
        VAR,
        {
          className: 'variable',
          begin: /\$[A-z]/,
          end: /[^A-z]/
        }
      ]
    };
    const APOS_STRING = {
      className: 'string',
      variants: [
        {
          begin: /'/,
          end: /'/
        },
        {
          begin: /@'/,
          end: /^'@/
        }
      ]
    };
    const PS_HELPTAGS = {
      className: "doctag",
      variants: [
        {
          begin: /\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/
        },
        {
          begin: /\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/
        }
      ]
    };
    const PS_COMMENT = hljs.inherit(
      hljs.COMMENT(null, null),
      {
        variants: [
          {
            begin: /#/,
            end: /$/
          },
          {
            begin: /<#/,
            end: /#>/
          }
        ],
        contains: [ PS_HELPTAGS ]
      }
    );
    const CMDLETS = {
      className: 'built_in',
      variants: [
        {
          begin: '('.concat(VALID_VERBS, ')+(-)[\\w\\d]+')
        }
      ]
    };
    const PS_CLASS = {
      className: 'class',
      beginKeywords: 'class enum',
      end: /\s*[{]/,
      excludeEnd: true,
      relevance: 0,
      contains: [ hljs.TITLE_MODE ]
    };
    const PS_FUNCTION = {
      className: 'function',
      begin: /function\s+/,
      end: /\s*\{|$/,
      excludeEnd: true,
      returnBegin: true,
      relevance: 0,
      contains: [
        {
          begin: "function",
          relevance: 0,
          className: "keyword"
        },
        {
          className: "title",
          begin: TITLE_NAME_RE,
          relevance: 0
        },
        {
          begin: /\(/,
          end: /\)/,
          className: "params",
          relevance: 0,
          contains: [ VAR ]
        }
      ]
    };
    const PS_USING = {
      begin: /using\s/,
      end: /$/,
      returnBegin: true,
      contains: [
        QUOTE_STRING,
        APOS_STRING,
        {
          className: 'keyword',
          begin: /(using|assembly|command|module|namespace|type)/
        }
      ]
    };
    const PS_ARGUMENTS = {
      variants: [
        {
          className: 'operator',
          begin: '('.concat(COMPARISON_OPERATORS, ')\\b')
        },
        {
          className: 'literal',
          begin: /(-)[\w\d]+/,
          relevance: 0
        }
      ]
    };
    const HASH_SIGNS = {
      className: 'selector-tag',
      begin: /@\B/,
      relevance: 0
    };
    const PS_METHODS = {
      className: 'function',
      begin: /\[.*\]\s*[\w]+[ ]??\(/,
      end: /$/,
      returnBegin: true,
      relevance: 0,
      contains: [
        {
          className: 'keyword',
          begin: '('.concat(
            KEYWORDS.keyword.toString().replace(/\s/g, '|'
            ), ')\\b'),
          endsParent: true,
          relevance: 0
        },
        hljs.inherit(hljs.TITLE_MODE, {
          endsParent: true
        })
      ]
    };
    const GENTLEMANS_SET = [
      PS_METHODS,
      PS_COMMENT,
      BACKTICK_ESCAPE,
      hljs.NUMBER_MODE,
      QUOTE_STRING,
      APOS_STRING,
      CMDLETS,
      VAR,
      LITERAL,
      HASH_SIGNS
    ];
    const PS_TYPE = {
      begin: /\[/,
      end: /\]/,
      excludeBegin: true,
      excludeEnd: true,
      relevance: 0,
      contains: [].concat(
        'self',
        GENTLEMANS_SET,
        {
          begin: "(" + TYPES.join("|") + ")",
          className: "built_in",
          relevance: 0
        },
        {
          className: 'type',
          begin: /[\.\w\d]+/,
          relevance: 0
        }
      )
    };
    PS_METHODS.contains.unshift(PS_TYPE);
    return {
      name: 'PowerShell',
      aliases: [
        "ps",
        "ps1"
      ],
      case_insensitive: true,
      keywords: KEYWORDS,
      contains: GENTLEMANS_SET.concat(
        PS_CLASS,
        PS_FUNCTION,
        PS_USING,
        PS_ARGUMENTS,
        PS_TYPE
      )
    };
  }
  var powershell_1 = powershell;

  function makefile(hljs) {
    const VARIABLE = {
      className: 'variable',
      variants: [
        {
          begin: '\\$\\(' + hljs.UNDERSCORE_IDENT_RE + '\\)',
          contains: [ hljs.BACKSLASH_ESCAPE ]
        },
        {
          begin: /\$[@%<?\^\+\*]/
        }
      ]
    };
    const QUOTE_STRING = {
      className: 'string',
      begin: /"/,
      end: /"/,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        VARIABLE
      ]
    };
    const FUNC = {
      className: 'variable',
      begin: /\$\([\w-]+\s/,
      end: /\)/,
      keywords: {
        built_in:
          'subst patsubst strip findstring filter filter-out sort ' +
          'word wordlist firstword lastword dir notdir suffix basename ' +
          'addsuffix addprefix join wildcard realpath abspath error warning ' +
          'shell origin flavor foreach if or and call eval file value'
      },
      contains: [ VARIABLE ]
    };
    const ASSIGNMENT = {
      begin: '^' + hljs.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)'
    };
    const META = {
      className: 'meta',
      begin: /^\.PHONY:/,
      end: /$/,
      keywords: {
        $pattern: /[\.\w]+/,
        'meta-keyword': '.PHONY'
      }
    };
    const TARGET = {
      className: 'section',
      begin: /^[^\s]+:/,
      end: /$/,
      contains: [ VARIABLE ]
    };
    return {
      name: 'Makefile',
      aliases: [
        'mk',
        'mak',
        'make',
      ],
      keywords: {
        $pattern: /[\w-]+/,
        keyword: 'define endef undefine ifdef ifndef ifeq ifneq else endif ' +
        'include -include sinclude override export unexport private vpath'
      },
      contains: [
        hljs.HASH_COMMENT_MODE,
        VARIABLE,
        QUOTE_STRING,
        FUNC,
        ASSIGNMENT,
        META,
        TARGET
      ]
    };
  }
  var makefile_1 = makefile;

  [{
    lang: 'java',
    mod: java_1
  }, {
    lang: 'javascript',
    mod: javascript_1
  }, {
    lang: 'json',
    mod: json_1
  }, {
    lang: 'css',
    mod: css_1
  }, {
    lang: 'scss',
    mod: scss_1
  }, {
    lang: 'less',
    mod: less_1
  }, {
    lang: 'stylus',
    mod: stylus_1
  }, {
    lang: 'shell',
    mod: shell_1
  }, {
    lang: 'bash',
    mod: bash_1
  }, {
    lang: 'cpp',
    mod: cpp_1
  }, {
    lang: 'go',
    mod: go_1
  }, {
    lang: 'xml',
    mod: xml_1
  }, {
    lang: 'python',
    mod: python_1
  }, {
    lang: 'typescript',
    mod: typescript_1
  }, {
    lang: 'sql',
    mod: sql_1
  }, {
    lang: 'ruby',
    mod: ruby_1
  }, {
    lang: 'vim',
    mod: vim_1
  }, {
    lang: 'php',
    mod: php_1
  }, {
    lang: 'perl',
    mod: perl_1
  }, {
    lang: 'powershell',
    mod: powershell_1
  }, {
    lang: 'makefile',
    mod: makefile_1
  }].forEach(function (item) {
    core.registerLanguage(item.lang, item.mod);
  });
  var script$v = {
    name: 'bk-diff',
    directives: {
      highlight: function highlight(el) {
        var blocks = el.querySelectorAll('code');
        blocks.forEach(function (block) {
          core.highlightElement(block);
        });
      }
    },
    props: {
      oldContent: {
        type: String,
        default: ''
      },
      newContent: {
        type: String,
        default: ''
      },
      context: {
        type: Number,
        default: Infinity
      },
      format: {
        type: String,
        default: 'line-by-line'
      },
      theme: {
        type: String,
        default: 'light',
        validator: function validator(value) {
          return ['light', 'dark'].includes(value);
        }
      },
      language: {
        type: String,
        required: true
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    computed: {
      html: function html() {
        function htmlReplace(html) {
          return html.replace(/<span class="d2h-code-line-ctn">(.+?)<\/span>/g, '<span class="d2h-code-line-ctn"><code>$1</code></span>');
        }
        var oldContent = this.oldContent + '\n// --end--';
        var newContent = this.newContent + "\n// -- end--";
        var args = ['', oldContent, newContent, '', '', {
          context: this.context
        }];
        var dd = diff_1.apply(void 0, args);
        var outStr = diff2html_1.getJsonFromDiff(dd, {
          inputFormat: 'diff',
          outputFormat: this.format,
          showFiles: false,
          matching: 'lines'
        });
        var html = diff2html_1.getPrettyHtml(outStr, {
          inputFormat: 'json',
          outputFormat: this.format,
          showFiles: false,
          matching: 'lines'
        });
        return htmlReplace(html);
      },
      classes: function classes() {
        return [this.theme, this.extCls, "format-".concat(this.format)];
      }
    },
    watch: {
      language: {
        handler: function handler(language) {
          core.configure({
            languages: [language]
          });
        },
        immediate: true
      }
    }
  };

  /* script */
  var __vue_script__$v = script$v;
  /* template */

  var __vue_render__$v = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "html",
      staticClass: "bk-diff",
      class: _vm.classes
    }, [_c('div', {
      directives: [{
        name: "highlight",
        rawName: "v-highlight"
      }],
      domProps: {
        "innerHTML": _vm._s(_vm.html)
      }
    })]);
  };

  var __vue_staticRenderFns__$v = [];
  /* style */

  var __vue_inject_styles__$v = undefined;
  /* scoped */

  var __vue_scope_id__$v = undefined;
  /* module identifier */

  var __vue_module_identifier__$v = undefined;
  /* functional template */

  var __vue_is_functional_template__$v = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$v = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$v,
    staticRenderFns: __vue_staticRenderFns__$v
  }, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$v);

  var variable = {
    dropdownMarginBottom: '4px'
  };
  var variable_1 = variable.dropdownMarginBottom;

  var script$w = {
    name: 'bk-dropdown-menu',
    directives: {
      clickoutside: bkClickoutside
    },
    props: {
      trigger: {
        type: String,
        default: 'mouseover',
        validator: function validator(event) {
          return ['click', 'mouseover'].includes(event);
        }
      },
      align: {
        type: String,
        default: 'left'
      },
      disabled: {
        type: Boolean,
        default: false
      },
      positionFixed: {
        type: Boolean,
        default: false
      },
      fontSize: {
        type: String,
        default: 'normal'
      },
      extCls: {
        type: String,
        default: ''
      },
      openDelay: {
        type: Number,
        default: 0
      },
      closeDelay: {
        type: Number,
        default: 100
      }
    },
    data: function data() {
      return {
        menuStyle: null,
        timer: 0,
        isShow: false,
        popInstance: null
      };
    },
    computed: {
      fontSizeCls: function fontSizeCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-font';
        } else if (this.fontSize === 'large') {
          cls = 'large-font';
        }
        return cls;
      }
    },
    mounted: function mounted() {
      var placement = "bottom".concat(this.getPlacementFix());
      this.popInstance = new Popper(this.$refs.refDropTrigger, this.$refs.refDropContent, {
        placement: placement,
        positionFixed: this.positionFixed,
        modifiers: {
          offset: {
            offset: "0, ".concat(variable_1)
          },
          keepTogether: {}
        }
      });
    },
    beforeDestroy: function beforeDestroy() {
      if (this.popInstance) {
        this.popInstance.destroy();
        this.popInstance = null;
      }
    },
    methods: {
      getPlacementFix: function getPlacementFix() {
        var placementFix = {
          'left': '-start',
          'right': '-end',
          'center': ''
        };
        var fixAppend = placementFix[this.align];
        if (fixAppend !== undefined) {
          return fixAppend;
        }
        return '';
      },
      handleClick: function handleClick() {
        if (this.disabled || this.trigger !== 'click') {
          return;
        }
        this.isShow ? this.hide() : this.show();
      },
      handleMouseover: function handleMouseover() {
        if (this.trigger === 'mouseover' && !this.disabled) {
          this.show();
        }
      },
      handleMouseout: function handleMouseout() {
        if (this.trigger === 'mouseover' && !this.disabled) {
          this.hide();
        }
      },
      handleClickoutside: function handleClickoutside() {
        if (this.isShow) {
          this.hide();
        }
      },
      show: function show() {
        var _this = this;
        clearTimeout(this.openTimer);
        clearTimeout(this.closeTimer);
        this.openTimer = setTimeout(function () {
          _this.isShow = true;
        }, this.openDelay);
        this.popInstance.scheduleUpdate();
      },
      hide: function hide() {
        var _this2 = this;
        clearTimeout(this.closeTimer);
        clearTimeout(this.openTimer);
        this.closeTimer = setTimeout(function () {
          _this2.isShow = false;
        }, this.closeDelay);
        this.popInstance.scheduleUpdate();
      }
    }
  };

  /* script */
  var __vue_script__$w = script$w;
  /* template */

  var __vue_render__$w = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleClickoutside,
        expression: "handleClickoutside"
      }],
      staticClass: "bk-dropdown-menu",
      class: [_vm.disabled ? 'disabled' : '', _vm.positionFixed ? '' : 'bk-dropdown-full-width', _vm.fontSizeCls, _vm.extCls],
      attrs: {
        "tabindex": "0"
      },
      on: {
        "keydown": [function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.handleMouseover($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
            return null;
          }

          $event.stopPropagation();
          $event.preventDefault();
          return _vm.handleMouseout($event);
        }],
        "click": _vm.handleClick,
        "mouseover": _vm.handleMouseover,
        "mouseout": _vm.handleMouseout
      }
    }, [_c('div', {
      ref: "refDropTrigger",
      staticClass: "bk-dropdown-trigger"
    }, [_vm._t("dropdown-trigger")], 2), _c('div', {
      ref: "refDropContent",
      class: ['bk-dropdown-content', {
        'is-show': _vm.isShow,
        'right-align': _vm.align === 'right',
        'center-align': _vm.align === 'center',
        'left-align': _vm.align === 'left'
      }]
    }, [_vm._t("dropdown-content")], 2)]);
  };

  var __vue_staticRenderFns__$w = [];
  /* style */

  var __vue_inject_styles__$w = undefined;
  /* scoped */

  var __vue_scope_id__$w = undefined;
  /* module identifier */

  var __vue_module_identifier__$w = undefined;
  /* functional template */

  var __vue_is_functional_template__$w = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$w = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$w,
    staticRenderFns: __vue_staticRenderFns__$w
  }, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$w);

  var img$1 = new Image(); img$1.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPmpK3lnIblvaLlpIfku70tNV8yXyk7fQoJLnN0MntmaWxsOnVybCgj55+p5b2iXzE5Xyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2i5aSH5Lu9LTIxXzFfKTt9Cgkuc3Q0e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfNl8pO30KCS5zdDV7ZmlsbDojRUFFQ0VGO30KCS5zdDZ7ZmlsbDp1cmwoI+efqeW9ol8yMF8pO30KCS5zdDd7ZmlsbDojRjRGNEY1O30KCS5zdDh7ZmlsbDojRjlGOUZBO30KCS5zdDl7ZmlsbDojOTc5Nzk3O30KCS5zdDEwe2ZpbGw6I0U4RUFFQzt9Cgkuc3QxMXtmaWxsOiNGN0Y4RkE7fQoJLnN0MTJ7ZmlsbDp1cmwoI+efqeW9ol8yMV8pO30KCS5zdDEze2ZpbGw6dXJsKCPnn6nlvaLlpIfku70tMjJfMV8pO30KCS5zdDE0e2ZpbGw6dXJsKCPot6/lvoQtMjNfMV8pO30KCS5zdDE1e2ZpbGw6dXJsKCPnn6nlvaJfMjJfKTt9Cgkuc3QxNntmaWxsOiNEQ0RERTA7fQoJLnN0MTd7ZmlsbDp1cmwoI+i3r+W+hC0xOV8xXyk7fQoJLnN0MTh7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0MTl7ZmlsbDojQ0RDRUQxO30KCS5zdDIwe2ZpbGw6bm9uZTtzdHJva2U6dXJsKCPot6/lvoQtMjFfMV8pO30KCS5zdDIxe2ZpbGw6I0M2QzdDQjt9Cgkuc3QyMntmaWxsOiNEMUQyRDY7c3Ryb2tlOiNFQUVERjA7c3Ryb2tlLXdpZHRoOjI7fQoJLnN0MjN7ZmlsbDojRjlGQUZDO30KCS5zdDI0e2ZpbGw6dXJsKCPnn6nlvaJfMjNfKTt9Cgkuc3QyNXtmaWxsOiNGMUYzRjU7fQoJLnN0MjZ7ZmlsbDojRTZFOEVCO30KCS5zdDI3e2ZpbGw6I0QxRDJENjt9Cgkuc3QyOHtmaWxsOnVybCgj5qSt5ZyG5b2i5aSH5Lu9LThfMV8pO30KCS5zdDI5e2ZpbGw6I0VFRUZGMzt9Cgkuc3QzMHtmaWxsOiNENEQ2REE7fQoJLnN0MzF7ZmlsbDojRThFQUVEO3N0cm9rZTojRDlEQkRFO30KCS5zdDMye2ZpbGw6I0Q4RDhEODtzdHJva2U6I0NGRDBEMzt9Cgkuc3QzM3tmaWxsOiNERERFRTA7fQoJLnN0MzR7ZmlsbDojRUVGMEYyO30KCS5zdDM1e2ZpbGw6bm9uZTtzdHJva2U6dXJsKCPnn6nlvaJfMjRfKTtzdHJva2Utd2lkdGg6Mjt9Cgkuc3QzNntmaWxsOm5vbmU7c3Ryb2tlOnVybCgj55+p5b2iXzI1Xyk7c3Ryb2tlLXdpZHRoOjAuNzt9Cgkuc3QzN3tmaWxsOnVybCgj55+p5b2iXzI2Xyk7fQoJLnN0Mzh7ZmlsbDp1cmwoI+efqeW9ol8yN18pO30KCS5zdDM5e2ZpbGw6dXJsKCPnn6nlvaJfMjhfKTt9Cgkuc3Q0MHtmaWxsOiM5NTk2OTk7ZmlsbC1vcGFjaXR5OjAuMTI7fQoJLnN0NDF7ZmlsbDojQzRDNkNDO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekuiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg3MC4wMDAwMDAsIC0xODgyLjAwMDAwMCkiPgoJCTxnIGlkPSLlip/og73lu7rorr7nsbsiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1Ny4wMDAwMDAsIDE3NTEuMDAwMDAwKSI+CgkJCTxnIGlkPSLnvJbnu4QtMTEiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCA3My4wMDAwMDApIj4KCQkJCTxnIGlkPSLlip/og73lu7rorr7nsbst5o+S5Zu+IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1MTMuMDAwMDAwLCA1OC4wMDAwMDApIj4KCQkJCQk8ZyBpZD0i5Zu+5qGIIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg1OC4wMDAwMDAsIDE3LjAwMDAwMCkiPgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IkZpbGwtMV8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMDYuMzkyNyIgeTE9IjE1OC41MjkiIHgyPSIyMDkuODg5IiB5Mj0iMTkxLjc5NDgiPgoJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YyRjRGNyIvPgoJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNMTQzLjQsMTY2LjRjMTguNi00LjIsNDUuNS02LjEsNjMuNy01LjFjMTguMiwwLjksMzMuMyw0LjEsMzQuNCwzLjQKCQkJCQkJCWMzLjYtMi40LDExLjQtMy41LDExLTIuNnMtNS40LDMuOS0zLjgsNC4zczE3LjgsMi4zLDI0LjYsMy43YzYuNywxLjQsMTEuMSwyLjgsMTIuNSwyLjhjMS41LDAsMy44LTIsMTMuNS0xCgkJCQkJCQljMC4yLDAuNC0yLjIsMC41LTQuMywxLjZjLTIuMiwxLjEtMy43LDEtMy43LDEuM3MxLjItMC40LDMuNywxLjNjMi41LDEuNiw3LDIuMSw3LDIuNmMwLDAuNC01LjcsMi4zLTE1LjEtMC43CgkJCQkJCQljLTIuNC0wLjgtOCw1LjgtMzMuOCw3LjdzLTY5LjQsMy4zLTY5LjQsMy4zczIuNiwzLjQsNi40LDQuM2MwLjIsMC4zLTEuNSwxLjYtOC45LDAuMmMtNy40LTEuNC0xMS40LTQuNS0xMS40LTQuNQoJCQkJCQkJcy0xNC43LTAuOS0yMC4yLTEuOWMtNS42LTAuOS0xMS45LTMuMy0xNi4zLTMuN3MtMjQuMi0yLjgtMTYuNy04QzExNi43LDE3NS4zLDEyNC43LDE3MC42LDE0My40LDE2Ni40eiIvPgoJCQkJCQk8ZyBpZD0i57yW57uELTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM3LjAwMDAwMCwgMC4wMDAwMDApIj4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaLlpIfku70tNV8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxOTcuNDMyOCIgeTE9Ii05Ljk3MjYiIHgyPSIxOTcuNDMyOCIgeTI9Ii04Ljk3MjYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTQuMzExNCAwIDAgMTcuNjQ4NSAtMjgxMi4yOTAzIDI1OC43NTkxKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VBRUNFRSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDRENGRDEiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTUiIGNsYXNzPSJzdDEiIGQ9Ik0xMy4yLDEwMC40YzMuMSwwLDcuMi02LjUsNy4yLTEwLjVzLTMuMi03LjItNy4yLTcuMlM2LjEsODYsNi4xLDg5LjkKCQkJCQkJCQlDNi4xLDkzLjksMTAuMSwxMDAuNCwxMy4yLDEwMC40eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8xOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTE1MS4zNjY0IiB5MT0iLTIuMjE1NiIgeDI9Ii0xNTEuMzY2NCIgeTI9Ii0xLjIxNTgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMS4xMDA5IDAgMCA3OS40MTgyIDE3Ny42ODkzIDE4NS45NTkzKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCMkI1QkUiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSIxMC41IiB5PSIxMCIgY2xhc3M9InN0MiIgd2lkdGg9IjEuMSIgaGVpZ2h0PSI3OS40Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2i5aSH5Lu9LTIxXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ii0xNTEuMzY4OSIgeTE9Ii0yLjIxNTYiIHgyPSItMTUxLjM2ODkiIHkyPSItMS4yMTU4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEuMTAwOSAwIDAgNzkuNDE4MiAxODAuOTkyIDE4NS45NTkzKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCMkI1QkUiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTIxIiB4PSIxMy44IiB5PSIxMCIgY2xhc3M9InN0MyIgd2lkdGg9IjEuMSIgaGVpZ2h0PSI3OS40Ii8+CgoJCQkJCQkJCTxnIGlkPSLnvJbnu4QtMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjIuOTQxNzI1LCA3My44NDE3OTMpIHJvdGF0ZSgtMzkuMDAwMDAwKSB0cmFuc2xhdGUoLTYyLjk0MTcyNSwgLTczLjg0MTc5MykgdHJhbnNsYXRlKDUwLjQ0MTcyNSwgLTEwLjY1ODIwNykiPgoJCQkJCQkJCTxnIGlkPSLnvJbnu4QtMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDM4LjUxMzU0OCkiPgoKCQkJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjkzLjY5OTEiIHkxPSIzMy4xMTMzIiB4Mj0iOTMuNjk5MSIgeTI9IjM0LjA5MjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjQuNTE2MyAtNy41NzQ3MzJlLTA1IDcuMjY0MTQ3ZS0wNSAxMjkuNTQ1NiAtMjI3OC45OTU4IC00MjYzLjUyMzkpIj4KCQkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNEU2RTkiLz4KCQkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDQkNFRDYiLz4KCQkJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0NCIgZD0iTTI0LjUsMGwwLDEwMi43bDAsMTRsMCwxMi44SDBMMCwwTDI0LjUsMHogTTEyLjMsMTIzLjFsLTEwLDUuM2gyMC4xTDEyLjMsMTIzLjF6CgkJCQkJCQkJCQkgTTIzLjMsMTE3LjNsLTkuOCw1LjFsOS44LDUuMUwyMy4zLDExNy4zeiBNMS4yLDExNy4zbDAsMTAuM2w5LjgtNS4xTDEuMiwxMTcuM3ogTTIyLDExNi43SDIuNWw5LjcsNS4xTDIyLDExNi43egoJCQkJCQkJCQkJIE0xMi4zLDExMC40bC05LjcsNS4xSDIyTDEyLjMsMTEwLjR6IE0xLjIsMTA0LjZsMCwxMC4zbDkuOC01LjFMMS4yLDEwNC42eiBNMjMuMywxMDQuNmwtOS44LDUuMWw5LjgsNS4xTDIzLjMsMTA0LjZ6CgkJCQkJCQkJCQkgTTIyLjMsMTAzLjlsLTIwLjEsMGwxMCw1LjNMMjIuMywxMDMuOXogTTEyLjMsOTcuNWwtMTAsNS4zbDIwLjEsMEwxMi4zLDk3LjV6IE0xLjIsOTEuNmwwLDEwLjNsOS44LTUuMUwxLjIsOTEuNnoKCQkJCQkJCQkJCSBNMjMuMyw5MS42bC05LjgsNS4xbDkuOCw1LjFMMjMuMyw5MS42eiBNMjIsOTFMMi41LDkxbDkuNyw1LjFMMjIsOTF6IE0xMi4zLDg0LjhsLTkuNyw1LjFsMTkuNSwwTDEyLjMsODQuOHogTTEuMiw3OQoJCQkJCQkJCQkJbDAsMTAuM2w5LjgtNS4xTDEuMiw3OXogTTIzLjMsNzlsLTkuOCw1LjFsOS44LDUuMUwyMy4zLDc5eiBNMjIuMyw3OC4ySDIuMmwxMCw1LjNMMjIuMyw3OC4yeiBNMTIuMyw3MS44TDIuMiw3N2wyMC4xLDAKCQkJCQkJCQkJCUwxMi4zLDcxLjh6IE0xLjIsNjZsMCwxMC4zbDkuOC01LjFMMS4yLDY2eiBNMjMuMyw2NmwtOS44LDUuMWw5LjgsNS4xTDIzLjMsNjZ6IE0yMiw2NS40bC0xOS41LDBsOS43LDUuMUwyMiw2NS40egoJCQkJCQkJCQkJIE0xMi4zLDU5LjFsLTkuNyw1LjFsMTkuNSwwTDEyLjMsNTkuMXogTTEuMiw1My4zbDAsMTAuM2w5LjgtNS4xTDEuMiw1My4zeiBNMjMuMyw1My4zbC05LjgsNS4xbDkuOCw1LjFMMjMuMyw1My4zegoJCQkJCQkJCQkJIE0yMi4zLDUyLjVsLTIwLjEsMGwxMCw1LjNMMjIuMyw1Mi41eiBNMTIuMyw0Ni4xbC0xMCw1LjNsMjAuMSwwTDEyLjMsNDYuMXogTTIzLjMsNDAuM2wtOS44LDUuMWw5LjgsNS4xTDIzLjMsNDAuM3oKCQkJCQkJCQkJCSBNMS4yLDQwLjNsMCwxMC4zbDkuOC01LjFMMS4yLDQwLjN6IE0yMiwzOS43bC0xOS41LDBsOS43LDUuMUwyMiwzOS43eiBNMTIuMywzMy40bC05LjcsNS4xbDE5LjUsMEwxMi4zLDMzLjR6IE0xLjIsMjcuNgoJCQkJCQkJCQkJbDAsMTAuM2w5LjgtNS4xTDEuMiwyNy42eiBNMjMuMywyNy42bC05LjgsNS4xbDkuOCw1LjFMMjMuMywyNy42eiBNMjIuMywyNi44bC0yMC4xLDBsMTAsNS4zTDIyLjMsMjYuOHogTTEyLjMsMjAuNAoJCQkJCQkJCQkJbC0xMCw1LjNsMjAuMSwwTDEyLjMsMjAuNHogTTEuMiwxNC42bDAsMTAuM2w5LjgtNS4xTDEuMiwxNC42eiBNMjMuMywxNC42bC05LjgsNS4xbDkuOCw1LjFMMjMuMywxNC42eiBNMjIsMTRMMi41LDE0CgkJCQkJCQkJCQlsOS43LDUuMUwyMiwxNHogTTEyLjMsNy43bC05LjcsNS4xbDE5LjUsMEwxMi4zLDcuN3ogTTEuMiwxLjlsMCwxMC4zTDExLDcuMUwxLjIsMS45eiBNMjMuMywxLjlMMTMuNSw3bDkuOCw1LjFMMjMuMywxLjl6CgkJCQkJCQkJCQkgTTIyLjMsMS4ybC0yMC4xLDBsMTAsNS4zTDIyLjMsMS4yeiIvPgoJCQkJCQkJCTwvZz4KCgkJCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaIiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjc3NzEgLTAuNjI5MyAwLjYyOTMgLTAuNzc3MSAxOS4xNDkxIDE0LjkyMDEpIiBjbGFzcz0ic3Q1IiBjeD0iMTIuMiIgY3k9IjQuMSIgcng9IjQuMSIgcnk9IjQuMSIvPgoKCQkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjBfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjExNS45NzExIiB5MT0iMzIuMTc3NCIgeDI9IjExNS45NzExIiB5Mj0iMzMuMTc3NCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxOS44NDY1IDMuNjY3NjMxZS0wNSAtOC42NDUwMzZlLTA2IDMxLjUxMTEgLTIyODMuMTA0NyAtMTAwMC4wNzA5KSI+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjAiLz4KCQkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U0RTZFOSIvPgoJCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQkJPHBvbHlnb24gaWQ9IuefqeW9ol8yXyIgY2xhc3M9InN0NiIgcG9pbnRzPSI3LDUuOCAxNy41LDUuOCAyMi4yLDM3LjMgMi4zLDM3LjMgCQkJCQkJCQkiLz4KCQkJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTE3IiBjbGFzcz0ic3Q3IiBwb2ludHM9IjAsMzguNSAyLjMsMzcuMyAyMi4yLDM3LjMgMjQuNSwzOC41IAkJCQkJCQkJIi8+CgkJCQkJCQkJPHBvbHlnb24gaWQ9Iui3r+W+hC0xOCIgY2xhc3M9InN0OCIgcG9pbnRzPSI4LjIsNS44IDguMiw0LjYgMTYuMyw0LjYgMTYuMyw1LjggCQkJCQkJCQkiLz4KCQkJCQkJCTwvZz4KCQkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDkiIGQ9Ik0xMi43LDk5LjN2Ny4ydjAuMWMtMC4yLDAtMC40LTAuMS0wLjYtMC4xYy0xLjUsMC0yLjgsMS4zLTIuOCwzczEuMiwzLDIuOCwzCgkJCQkJCQkJYzEuMywwLDIuNS0xLDIuNy0yLjRoMS4xYy0wLjMsMi0xLjksMy42LTMuOCwzLjZjLTIuMSwwLTMuOS0xLjktMy45LTQuMmMwLTIuMSwxLjQtMy44LDMuMy00LjF2LTZMMTIuNyw5OS4zTDEyLjcsOTkuM3oiLz4KCQkJCQkJCTxwYXRoIGlkPSLmpK3lnIblvaJfMV8iIGNsYXNzPSJzdDEwIiBkPSJNMTIuMSwxMDAuNGMzLjEsMCw3LjItNi41LDcuMi0xMC41cy0zLjItNy4yLTcuMi03LjJTNSw4Niw1LDg5LjkKCQkJCQkJCQlDNSw5My45LDksMTAwLjQsMTIuMSwxMDAuNHoiLz4KCQkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfM18iIHg9IjEyMi44IiB5PSIxMjEuNCIgY2xhc3M9InN0MTEiIHdpZHRoPSIxMDIuNCIgaGVpZ2h0PSIyLjIiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMC4wMTg3IiB5MT0iLTEuMTk2NiIgeDI9IjEwMC4wMTg3IiB5Mj0iLTAuMjE2NiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgzLjQzMDEgMC43MjkxIC0xNC42NDAzIDY4Ljg3NzQgLTE2Ny45MTYxIDY1LjM3MjIpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUFFREYwIi8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U3RTdFQiIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfNF8iIGNsYXNzPSJzdDEyIiBkPSJNMTkxLjMsNTQuMWwzLjQsMC43bC0xNC42LDY4LjVjLTAuNywwLjEtMS4zLDAuMS0xLjksMGMtMC41LTAuMS0xLjEtMC40LTEuNS0wLjcKCQkJCQkJCQlMMTkxLjMsNTQuMXoiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaLlpIfku70tMjJfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTI2LjUyOTciIHkxPSI1Ljk2NiIgeDI9IjEyNi41Mjk3IiB5Mj0iNi45NDYyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEuNjQ2NyAzLjA5NzEgLTQyLjI3MjQgMjIuNDc2NiAyODEuMjI3MSAtNDIzLjY4NzkpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUZGMkY1Ii8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U3RTdFQiIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaLlpIfku70tMjIiIGNsYXNzPSJzdDEzIiBkPSJNMjM3LjQsMTAwLjNsMS42LDMuMWwtMzkuNSwyMC43Yy0wLjQsMC0xLjItMC4xLTIuNC0wLjNjLTEuMi0wLjItMS45LTAuNi0yLTEKCQkJCQkJCQlMMjM3LjQsMTAwLjN6Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i6Lev5b6ELTIzXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMC41MTkxIiB5MT0iLTUzLjE4NjciIHgyPSIxMDAuNTE5MSIgeTI9Ii01Mi4xODY3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDMuMzAyNiAwIDAgMy4zMDkxIC05OC42MjQzIDI3OC42MTQ2KSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0U3RThFQiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNDQUNERDEiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTIzIiBjbGFzcz0ic3QxNCIgZD0iTTIzMy40LDEwMi42bC0xLjcsMC43YzAsMC40LDAuMiwwLjksMC42LDEuNWMwLjQsMC41LDAuOCwwLjksMS4zLDEuMWwxLjQtMC42CgkJCQkJCQkJTDIzMy40LDEwMi42eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjIxLjUyODEiIHkxPSItOC44NjUzIiB4Mj0iMjIxLjUyODEiIHkyPSItNy44NjUzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDgzLjY2NjcgMCAwIDE5Ljg1NDUgLTE4MzUxLjE3NTggMzEyLjgxNjEpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTNFNUU4Ii8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMC45NzEzIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0RDRUQxIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol81XyIgeD0iMTQxLjUiIHk9IjEzNi44IiBjbGFzcz0ic3QxNSIgd2lkdGg9IjgzLjciIGhlaWdodD0iMTkuOSIvPgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0yMCIgY2xhc3M9InN0MTYiIGQ9Ik0xNDAuNCwxNTYuN2gxMC4yYy0wLjEtMy4xLDItNS4yLDYuNC02LjNzMjcuMS0zLjcsNjguMi03Ljl2LTMuMXYtOS4yaC04NC44CgkJCQkJCQkJTDE0MC40LDE1Ni43TDE0MC40LDE1Ni43eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9Iui3r+W+hC0xOV8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMjMuMDY1NCIgeTE9Ii01LjMxNzkiIHgyPSIyMjMuMDY1NCIgeTI9Ii00LjMyNjQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTIxLjA5NjUgMCAwIDMzLjA5MDkgLTI2ODQ3Ljc0MjIgMjk5LjU3NTEpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxLjE4NzcxMWUtMDIiIHN0eWxlPSJzdG9wLWNvbG9yOiNGM0YzRjUiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0xOSIgY2xhc3M9InN0MTciIGQ9Ik0yMjUuMiwxMjMuNkgxMDQuMXYzMy4xSDE0NGMxLTQuMSwyLjgtNi42LDUuNC03LjVjMi42LTAuOSwyNy45LTMuMiw3NS45LTYuOQoJCQkJCQkJCUwyMjUuMiwxMjMuNkwyMjUuMiwxMjMuNnoiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjE2LjI4NzQiIHkxPSItNS4zMDUyIiB4Mj0iMjE2LjI4NzQiIHkyPSItNC4zMjU1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQwLjczMTYgMCAwIDMzLjA5MDkgLTg2ODUuMjgxMiAyOTkuNTc1MSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNEU3RUIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDhEQURDIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8yXyIgY2xhc3M9InN0MTgiIGQ9Ik0xNDQuOCwxMjMuNnYyNS42YzAsMS0wLjcsMS44LTEuNiwybC0zMC41LDUuNWgtOC42di0zMy4xSDE0NC44eiIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol82XyIgeD0iMTI5LjQiIHk9IjE1Ni43IiBjbGFzcz0ic3QxOSIgd2lkdGg9IjM3LjQiIGhlaWdodD0iMi4yIi8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i6Lev5b6ELTIxXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIyNC4yODg2IiB5MT0iLTEuNjQxOSIgeDI9IjIyNS4wNzM4IiB5Mj0iLTEuNDcwMiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMTkuMDc0NiAwIDAgODkuMzQ1NSAtNDkwNzYuNjYwMiAxODguMTYxNikiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNENUQ4REYiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQjVCOEMxIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBvbHlsaW5lIGlkPSLot6/lvoQtMjEiIGNsYXNzPSJzdDIwIiBwb2ludHM9IjE4LjIsMTIuMiAxOTIuOSw1My43IDIzNy4zLDEwMS41IAkJCQkJCQkiLz4KCQkJCQkJCTxwYXRoIGlkPSLot6/lvoQtMjIiIGNsYXNzPSJzdDIxIiBkPSJNMTg5LjksNTkuOWMwLjQsMC4zLDAuOSwwLjUsMS40LDAuN3MxLDAuMiwxLjYsMC4xbDAuMy0xLjRsLTMtMC44TDE4OS45LDU5Ljl6Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzJfIiBjbGFzcz0ic3QyMiIgY3g9IjE5My4yIiBjeT0iNTQuMSIgcng9IjQuNSIgcnk9IjQuNSIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9oi00IiB4PSIxMjIuOCIgeT0iMTIzLjYiIGNsYXNzPSJzdDIzIiB3aWR0aD0iMTAyLjQiIGhlaWdodD0iMS4xIi8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzIzXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMTAuNDAzNSIgeTE9Ii0zLjY5ODIiIHgyPSIyMTEuMTExMSIgeTI9Ii0zLjY5ODIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjYuNDIxMSAwIDAgNDEuOTE1MSAtNTMzMS4xMDMgMjkyLjk2MikiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFRkYwRjIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwLjQ3MjQiIHN0eWxlPSJzdG9wLWNvbG9yOiNGNEY1RjciLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol83XyIgeD0iMjI0LjEiIHk9IjExNyIgY2xhc3M9InN0MjQiIHdpZHRoPSIyNi40IiBoZWlnaHQ9IjQxLjkiLz4KCQkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfOF8iIHg9IjIyMyIgeT0iMTIxLjQiIGNsYXNzPSJzdDI1IiB3aWR0aD0iMS4xIiBoZWlnaHQ9IjMuMyIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yMyIgeD0iMjIzIiB5PSIxMjQuNyIgY2xhc3M9InN0MjYiIHdpZHRoPSIxLjEiIGhlaWdodD0iMTcuNiIvPgoJCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol85XyIgeD0iMjIzIiB5PSIxNDIuMyIgY2xhc3M9InN0MjciIHdpZHRoPSIxLjEiIGhlaWdodD0iMTQuMyIvPgoJCQkJCQkJPGVsbGlwc2UgaWQ9IuakreWchuW9ol8zXyIgY2xhc3M9InN0MjMiIGN4PSIyMzcuMyIgY3k9IjExNyIgcng9IjEzLjIiIHJ5PSIyLjIiLz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaLlpIfku70tOF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyMTAuNDAzNSIgeTE9Ii0zOS4zODQzIiB4Mj0iMjExLjExMTEiIHkyPSItMzkuMzg0MyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyNi40MjExIDAgMCA0LjQxMjEgLTUzMzEuMTAzIDMzMi42Njc0KSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VGRjBGMiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAuNDcyNCIgc3R5bGU9InN0b3AtY29sb3I6I0Y0RjVGNyIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFRUYwRjIiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTgiIGNsYXNzPSJzdDI4IiBjeD0iMjM3LjMiIGN5PSIxNTguOSIgcng9IjEzLjIiIHJ5PSIyLjIiLz4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTBfIiBjbGFzcz0ic3QyOSIgZD0iTTIzNi4yLDEwNS45aDMuM3YxMC41Yy0wLjYsMC4zLTEuMSwwLjUtMS43LDAuNXMtMS4xLTAuMi0xLjctMC41TDIzNi4yLDEwNS45CgkJCQkJCQkJTDIzNi4yLDEwNS45eiIvPgoJCQkJCQkJPHBhdGggaWQ9Iui3r+W+hC0yNCIgY2xhc3M9InN0MzAiIGQ9Ik0yMzYuMiwxMDZ2MS43YzAuNCwwLjMsMSwwLjQsMS43LDAuNHMxLjItMC4xLDEuNy0wLjR2LTEuOEwyMzYuMiwxMDZ6Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTkiIGNsYXNzPSJzdDIyIiBjeD0iMjM3LjMiIGN5PSIxMDIuNiIgcng9IjQuNSIgcnk9IjQuNSIvPgoJCQkJCQkJPGcgaWQ9Iue8lue7hC02IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg2OS45Mzc1MTYsIDE1OC44NzA1OTQpIj4KCQkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzRfIiBjbGFzcz0ic3QzMSIgY3g9IjExLjEiIGN5PSIxMSIgcng9IjguOCIgcnk9IjguNyIvPgoJCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaLlpIfku70tMTAiIGNsYXNzPSJzdDMxIiBjeD0iMTQxLjkiIGN5PSIxMSIgcng9IjguOCIgcnk9IjguNyIvPgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTFfIiBjbGFzcz0ic3QzMiIgZD0iTTExLjEsMTAuOWg3YzAuNywwLDEuMiwwLjYsMS4yLDEuMmwwLDBjMCwwLjctMC42LDEuMi0xLjIsMS4yaC03CgkJCQkJCQkJCWMtMC43LDAtMS4yLTAuNi0xLjItMS4ybDAsMEM5LjgsMTEuNSwxMC40LDEwLjksMTEuMSwxMC45eiIvPgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTJfIiBjbGFzcz0ic3QzMiIgZD0iTTEzNC45LDEwLjloN2MwLjcsMCwxLjIsMC42LDEuMiwxLjJsMCwwYzAsMC43LTAuNiwxLjItMS4yLDEuMmgtNwoJCQkJCQkJCQljLTAuNywwLTEuMi0wLjYtMS4yLTEuMmwwLDBDMTMzLjcsMTEuNSwxMzQuMywxMC45LDEzNC45LDEwLjl6Ii8+CgkJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xM18iIGNsYXNzPSJzdDMzIiBkPSJNMTAuOSw5LjhoMTMxLjNjMC44LDAsMS41LDAuNywxLjUsMS41djAuNWMwLDAuOC0wLjcsMS41LTEuNSwxLjVIMTAuOQoJCQkJCQkJCQljLTAuOCwwLTEuNS0wLjctMS41LTEuNXYtMC41QzkuNCwxMC41LDEwLjEsOS44LDEwLjksOS44eiIvPgoJCQkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfM18iIGNsYXNzPSJzdDM0IiBkPSJNMTQyLjIsOS44YzAuNywwLDEuMywwLjUsMS41LDEuMkg5LjRjMC4yLTAuNywwLjctMS4yLDEuNS0xLjJIMTQyLjJ6Ii8+CgoJCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yNF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iODMuODcwMyIgeTE9Ii04Ljc1ODciIHgyPSI4My44NzAzIiB5Mj0iLTcuNzczNCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNTEuMDIxOSAwIDAgMjAuMDYwNiAtMTI1ODkuNzU3OCAxNzYuOTk5OSkiPgoJCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOERCIi8+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNEMEQzRDYiLz4KCQkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTRfIiBjbGFzcz0ic3QzNSIgZD0iTTEwLjUsMWgxMzJjNS4yLDAsOS41LDQuMyw5LjUsOS41djEuMWMwLDUuMi00LjMsOS41LTkuNSw5LjVoLTEzMgoJCQkJCQkJCQljLTUuMiwwLTkuNS00LjMtOS41LTkuNXYtMS4xQzEsNS4zLDUuMywxLDEwLjUsMXoiLz4KCgkJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzI1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI4My44MTI5IiB5MT0iLTEwLjM4NDQiIHgyPSI4My44MTI5IiB5Mj0iLTkuNDI0MiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNDcuOTE4NCAwIDAgMTYuOTQ4NSAtMTIzMjAuOTE3IDE3OC41NTY0KSI+CgkJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNDRENFRDEiLz4KCQkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0VFRUZGMSIvPgoJCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xNV8iIGNsYXNzPSJzdDM2IiBkPSJNMTAuMSwyLjZIMTQzYzQuMSwwLDcuNSwzLjQsNy41LDcuNVYxMmMwLDQuMS0zLjQsNy41LTcuNSw3LjVIMTAuMQoJCQkJCQkJCQljLTQuMSwwLTcuNS0zLjQtNy41LTcuNXYtMS45QzIuNiw1LjksNS45LDIuNiwxMC4xLDIuNnoiLz4KCQkJCQkJCTwvZz4KCgkJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMjZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIxNi41NTc1IiB5MT0iLTQuMzU0IiB4Mj0iMjE2LjU1NzUiIHkyPSItMy4zNTQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNDEuODMzMyAwIDAgNDAuNDIyNyAtODkzNi40NjY4IDI5MS44NDkyKSI+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjFGMiIvPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNkU4RUIiLz4KCQkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCQk8cGF0aCBpZD0i55+p5b2iXzE2XyIgY2xhc3M9InN0MzciIGQ9Ik0xMTUuOSwxMTUuOWgyNS44YzEuMSwwLDIsMC45LDIsMnYyOS43YzAsMS0wLjcsMS44LTEuNiwybC0zNy44LDYuOAoJCQkJCQkJCWMtMS4xLDAuMi0yLjEtMC41LTIuMy0xLjZjMC0wLjEsMC0wLjIsMC0wLjRWMTMwQzEwMS45LDEyMi4xLDEwOC4xLDExNS45LDExNS45LDExNS45eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8yN18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjA0LjI3MzIiIHkxPSItNy45NzgiIHgyPSIyMDQuMjczMiIgeTI9Ii02Ljk3OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxOC43MTQ5IDAgMCAyMi4wNjA2IC0zNzA4LjQwMzEgMjk1LjE2MTUpIj4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCIi8+CgkJCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDlEQyIvPgoJCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMTdfIiBjbGFzcz0ic3QzOCIgZD0iTTExNS4yLDExOS4yaDguN2wwLDB2MjAuOWwtMTguNywxLjJ2LTEyLjFDMTA1LjIsMTIzLjYsMTA5LjYsMTE5LjIsMTE1LjIsMTE5LjJ6Ii8+CgoJCQkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzI4XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxOTcuNDMzMiIgeTE9Ii04LjM5OCIgeDI9IjE5Ny40MzMyIiB5Mj0iLTcuMzk4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDE0LjMxMTQgMCAwIDIwLjk1NzYgLTI2OTIuMjk1MiAyOTUuMTU3OSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNkU4RUIiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOURDIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8xOF8iIGNsYXNzPSJzdDM5IiBkPSJNMTI2LjEsMTE5LjJoMTMuM2MwLjYsMCwxLDAuNCwxLDFWMTM5bDAsMGwtMTQuMywxLjIKCQkJCQkJCQlDMTI2LjEsMTQwLjIsMTI2LjEsMTE5LjIsMTI2LjEsMTE5LjJ6Ii8+CgkJCQkJCTwvZz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF80XyIgY2xhc3M9InN0NDAiIGQ9Ik0xOTIuMiwxNjkuOGM4Ny41LTcuNywxNTYuOC0zMywxNTQuNy01Ni43Yy0yLjEtMjMuNi03NC43LTM2LjYtMTYyLjItMjkKCQkJCQkJCVMyOCwxMTcuMiwzMCwxNDAuOVMxMDQuNywxNzcuNSwxOTIuMiwxNjkuOHogTTE5Mi4yLDE2OC44Yy04Ni45LDcuNi0xNTkuMS01LjMtMTYxLjEtMjhzNjYuOS00OCwxNTMuOC01NS42CgkJCQkJCQlzMTU5LjEsNS4zLDE2MS4xLDI4QzM0Ny45LDEzNiwyNzksMTYxLjIsMTkyLjIsMTY4Ljh6Ii8+CgkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfNV8iIGNsYXNzPSJzdDQwIiBkPSJNMjM1LjMsNTEuOWM0NS4xLTE3LjMsNzkuOS0yMS4yLDg4LTcuM2MxMiwyMC44LTQwLjIsNzMuNC0xMTYuNSwxMTcuNQoJCQkJCQkJcy0xNDgsNjMtMTYwLDQyLjFTODcsMTMwLjgsMTYzLjMsODYuN0MxODQuNiw3NC41LDIwNS42LDY0LjEsMjI1LDU2YzAuMSwwLjMsMC4zLDAuNiwwLjQsMC45QzIwNiw2NSwxODUsNzUuMywxNjMuNyw4Ny42CgkJCQkJCQlDODcuOSwxMzEuNSwzNiwxODMuOCw0Ny42LDIwMy44czgyLjgsMS4zLDE1OC43LTQyLjVTMzM0LDY1LjIsMzIyLjQsNDUuMmMtNy43LTEzLjQtNDIuMi05LjQtODYuOCw3LjgKCQkJCQkJCUMyMzUuNSw1Mi42LDIzNS40LDUyLjMsMjM1LjMsNTEuOUwyMzUuMyw1MS45eiIvPgoJCQkJCQk8ZyBpZD0i57yW57uELTkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuMDAwMDAwLCAzOC4wMDAwMDApIj4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfNV8iIGNsYXNzPSJzdDQxIiBjeD0iMzAzLjEiIGN5PSI1MC4yIiByeD0iMi44IiByeT0iMi44Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzZfIiBjbGFzcz0ic3Q0MSIgY3g9IjMxNi4zIiBjeT0iMS43IiByeD0iMS43IiByeT0iMS43Ii8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzdfIiBjbGFzcz0ic3Q0MSIgY3g9IjEyMS42IiBjeT0iMTM2LjIiIHJ4PSIyLjgiIHJ5PSIyLjgiLz4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfOF8iIGNsYXNzPSJzdDQxIiBjeD0iMzMiIGN5PSI5MC40IiByeD0iMS4xIiByeT0iMS4xIi8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2iXzlfIiBjbGFzcz0ic3Q0MSIgY3g9IjI5MC41IiBjeT0iMTE0LjciIHJ4PSIxLjEiIHJ5PSIxLjEiLz4KCQkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaJfMTBfIiBjbGFzcz0ic3Q0MSIgY3g9IjcwLjQiIGN5PSIzNS4zIiByeD0iMi4yIiByeT0iMi4yIi8+CgkJCQkJCQk8ZWxsaXBzZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTYiIGNsYXNzPSJzdDQxIiBjeD0iMS43IiBjeT0iNjguOSIgcng9IjEuNyIgcnk9IjEuNyIvPgoJCQkJCQkJPGVsbGlwc2UgaWQ9IuakreWchuW9ouWkh+S7vS01XzFfIiBjbGFzcz0ic3Q0MSIgY3g9IjIzMy44IiBjeT0iMTU5LjMiIHJ4PSIxLjciIHJ5PSIxLjciLz4KCQkJCQkJPC9nPgoJCQkJCTwvZz4KCQkJCTwvZz4KCQkJPC9nPgoJCTwvZz4KCTwvZz4KPC9nPgo8L3N2Zz4K'; var Building = img$1.src;

  var img$2 = new Image(); img$2.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPnn6nlvaJfOV8pO30KCS5zdDJ7ZmlsbDp1cmwoI+efqeW9ol8xMF8pO30KCS5zdDN7ZmlsbDojRjBGMkY1O3N0cm9rZTp1cmwoI+efqeW9ol8xMV8pO30KCS5zdDR7ZmlsbDojOTc5QkE1O3N0cm9rZTp1cmwoI+efqeW9ol8xMl8pO30KCS5zdDV7ZmlsbDojOTc5QkE1O3N0cm9rZTp1cmwoI+efqeW9ouWkh+S7vS05XzFfKTt9Cgkuc3Q2e2ZpbGw6Izk3OUJBNTtzdHJva2U6dXJsKCPlvaLnirbnu5PlkIhfNl8pO30KCS5zdDd7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF84Xyk7fQoJLnN0OHtmaWxsOnVybCgj5b2i54q257uT5ZCI5aSH5Lu9LTNfMV8pO30KCS5zdDl7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0MTB7ZmlsbDojRTFFM0U2O30KCS5zdDExe2ZpbGw6I0YwRjJGNTt9Cgkuc3QxMntmaWxsOiNGNEY0RjQ7fQoJLnN0MTN7ZmlsbDp1cmwoI+i3r+W+hC01XzFfKTt9Cgkuc3QxNHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzEwXyk7fQoJLnN0MTV7ZmlsbDp1cmwoI+W9oueKtue7k+WQiOWkh+S7vS00XzFfKTt9Cgkuc3QxNntmaWxsOiNDN0M5Q0M7fQoJLnN0MTd7ZmlsbDojRTVFN0U5O30KCS5zdDE4e2ZpbGw6I0VDRUVGMDt9Cgkuc3QxOXtmaWxsOiNDNEM2Q0M7fQoJLnN0MjB7ZmlsbDojRURFRUYzO30KCS5zdDIxe2ZpbGw6IzM0MzQzNDtmaWxsLW9wYWNpdHk6My4wMDAwMDBlLTAyO30KPC9zdHlsZT4KPGcgaWQ9IkV4Y2VwdGlvbl94MkZf5byC5bi45o+Q56S6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODcwLjAwMDAwMCwgLTEzMzUuMDAwMDAwKSI+Cgk8ZyBpZD0iX3gzNF8wNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU3LjAwMDAwMCwgMTIxNi4wMDAwMDApIj4KCQk8ZyBpZD0iX3gzNF8wNC3mj5Llm74iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxMy4wMDAwMDAsIDExOS4wMDAwMDApIj4KCQkJPGcgaWQ9Iue8lue7hC0xMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAuMDAwMDAwLCAxMS4wMzY2NDgpIj4KCQkJCTxnIGlkPSJfeDM0XzA05Li75L2TIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5NC4zMjQwMjIsIDQyLjUzODc3MSkiPgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjE0MS4zOTEyIiB5MT0iNTUuNjg2OSIgeDI9IjE1Mi4zMzA3IiB5Mj0iMTE3LjcyNzciPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjhGQ0ZEIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSJGaWxsLTEiIGNsYXNzPSJzdDAiIGQ9Ik00NS4zLDcyLjljMjkuMy02LjYsNzEuNS05LjYsMTAwLjItOC4xczUyLjQsNi41LDU0LjEsNS4zYzUuNy0zLjgsMTcuOS01LjUsMTcuMy00CgkJCQkJCXMtOC41LDYuMS02LDYuOGMyLjUsMC43LDI4LDMuNywzOC42LDUuOWMxMC42LDIuMiwxNy40LDQuNCwxOS43LDQuNGMyLjMsMCw1LjktMy4xLDIxLjMtMS42YzAuMywwLjYtMy40LDAuOC02LjgsMi41CgkJCQkJCXMtNS45LDEuNi01LjksMnMxLjktMC42LDUuOSwyYzQsMi41LDExLDMuNCwxMSw0cy04LjksMy42LTIzLjgtMS4xYy0zLjgtMS4yLTEyLjYsOS4yLTUzLjEsMTIuMXMtMTA5LjEsNS4yLTEwOS4xLDUuMgoJCQkJCQlzNC4xLDUuMywxMC4xLDYuOGMwLjMsMC41LTIuNCwyLjUtMTQsMC4zcy0xNy45LTcuMS0xNy45LTcuMXMtMjMuMS0xLjUtMzEuOC0yLjlzLTE4LjctNS4yLTI1LjYtNS45Uy04LjUsOTUsMy4zLDg2LjkKCQkJCQkJQzMuMyw4Ni45LDE2LDc5LjUsNDUuMyw3Mi45eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMzA0Ljg0NjciIHkxPSIxMDEuMjQ5MiIgeDI9IjMwNC44NDY3IiB5Mj0iMTAwLjI1NDYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOTMuMzkwNyAwIDAgLTkzLjQ2MjcgLTI4MzM1Ljk0NTMgOTQ2My4wMjczKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQ0VFRjAiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDlEQiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuefqeW9ol8xXyIgY2xhc3M9InN0MSIgZD0iTTg5LjIsMGg4OS40YzEuMSwwLDIsMC45LDIsMnY4OS41YzAsMS4xLTAuOSwyLTIsMkg4OS4yYy0xLjEsMC0yLTAuOS0yLTJWMgoJCQkJCQlDODcuMiwwLjksODguMSwwLDg5LjIsMHoiLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzEwXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIzMDMuODkxNSIgeTE9IjEwMS42NTMyIiB4Mj0iMzAzLjg5MTUiIHkyPSIxMDAuNjUzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDgxLjcxNjkgMCAwIC04MS43Nzk5IC0yNDY5OS4yMjQ2IDgzMTguOTkwMikiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjVGN0ZBIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjAiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLnn6nlvaJfMl8iIGNsYXNzPSJzdDIiIGQ9Ik05NCw1LjhoNzkuN2MwLjYsMCwxLDAuNCwxLDF2NzkuOGMwLDAuNi0wLjQsMS0xLDFIOTRjLTAuNiwwLTEtMC40LTEtMVY2LjgKCQkJCQkJQzkzLDYuMyw5My41LDUuOCw5NCw1Ljh6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol8xMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk5LjQxODYiIHkxPSIxMDMuNTA1MiIgeDI9IjI5OS40MTg2IiB5Mj0iMTAyLjU1OTkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNTEuNTMyMyAwIDAgLTUxLjU3MjggLTE1Mjk1Ljg3NyA1MzYwLjk3MzYpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjdGOUZDIi8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i55+p5b2iXzNfIiBjbGFzcz0ic3QzIiBkPSJNMTA5LjEsMjAuOWg0OS41YzAuNiwwLDEsMC40LDEsMXY0OS42YzAsMC42LTAuNCwxLTEsMWgtNDkuNWMtMC42LDAtMS0wLjQtMS0xVjIxLjkKCQkJCQkJQzEwOC4xLDIxLjQsMTA4LjYsMjAuOSwxMDkuMSwyMC45eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaJfMTJfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjE5NS40ODc5IiB5MT0iMTE5LjIyMzciIHgyPSIxOTUuNDg3OSIgeTI9IjExOC4yNTY2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDUuMzc3NyAwIDAgLTEyLjY4MjggLTkyOC4zNzU1IDE1NDYuODUxNikiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFMkU2Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNF8iIHg9IjEyMC4yIiB5PSIzNC41IiBjbGFzcz0ic3Q0IiB3aWR0aD0iNS40IiBoZWlnaHQ9IjEyLjciLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2i5aSH5Lu9LTlfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTk1LjQ5MDEiIHkxPSIxMTkuMjIzNyIgeDI9IjE5NS40OTAxIiB5Mj0iMTE4LjI1NjYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNS4zNzc3IDAgMCAtMTIuNjgyOCAtOTA2LjQ4NzEgMTU0Ni44NTE2KSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUyRTYiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjJGNSIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS05IiB4PSIxNDIuMSIgeT0iMzQuNSIgY2xhc3M9InN0NSIgd2lkdGg9IjUuNCIgaGVpZ2h0PSIxMi43Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF82XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNDcuNTY2IiB5MT0iMTI1LjQ1MTQiIHgyPSIyNDcuNTY2IiB5Mj0iMTI0LjQ4NDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOS43NTU0IDAgMCAtOS43NjIxIC0yMjgxLjIwNTEgMTI3Ni45MDYpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjBGMkY1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIIiBjbGFzcz0ic3Q2IiBkPSJNMTI5LDU2LjdMMTI5LDU2LjdjMC4xLTIuNiwyLjMtNC43LDQuOS00LjdjMi42LDAsNC43LDIsNC45LDQuN3YwLjJ2NC45SDEyOXYtMC41di00LjQKCQkJCQkJVjU2Ljd6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF84XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIzMDIuOTc2MSIgeTE9IjEwMS4yMzc1IiB4Mj0iMzAyLjk3NjEiIHkyPSIxMDAuMzAxNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg3Mi45NjE1IDAgMCAtOTMuNDYyNyAtMjE4NzkuNzQ0MSA5NDYzLjAyNzMpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURGMDtzdG9wLW9wYWNpdHk6MC45OTE3Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUzRTYiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDciIGQ9Ik0yNDQuOCwwaDIuOXY1OC40aDE0LjZ2MTcuNWgtMTQuNnYxNy41aC0yMC40Vjc1LjloLTM3LjlWNTguNEwyMjcuMywwSDI0NC44egoJCQkJCQkgTTIyNy4zLDI4LjJsLTE4LjgsMzAuM2gxOC44VjI4LjJ6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjMwMi45NzU2IiB5MT0iMTAxLjIzNzUiIHgyPSIzMDIuOTc1NiIgeTI9IjEwMC4zMDE2IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDcyLjk2MTUgMCAwIC05My40NjI3IC0yMjA2My42MDc0IDk0NjMuMDI3MykiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREYwO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTNFNiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zIiBjbGFzcz0ic3Q4IiBkPSJNNjAuOSwwaDIuOXY1OC40aDE0LjZ2MTcuNUg2My44djE3LjVINDMuNFY3NS45SDUuNVY1OC40TDQzLjQsMEg2MC45egoJCQkJCQkgTTQzLjQsMjguMkwyNC42LDU4LjRoMTguOFYyOC4yeiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfOV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk5LjA0NjYiIHkxPSIxMDcuMjgyNyIgeDI9IjI5OS4wNTM1IiB5Mj0iMTA3LjAxMSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg1MC4wMDM1IDAgMCAtMjguNjA1MyAtMTQ4NTcuNzUyOSAzMjE2LjczOTUpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjBGMkY1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzJfIiBjbGFzcz0ic3Q5IiBkPSJNOTkuNiwxMzcuM2MxMS43LDAsMjEuMiw1LjYsMjEuMiwxMi40YzAsNi45LTkuNSwxMi40LTIxLjIsMTIuNAoJCQkJCQljLTQuNCwwLTguNS0wLjgtMTEuOS0yLjFsLTcsNS45bC0xLjktMi4ybDYtNS4xYy0zLjktMi4zLTYuNC01LjQtNi40LTguOWMwLTAuMiwwLTAuNSwwLTAuN2wtNS44LDUuMWwtMS45LTIuMmwxNS40LTEzLjQKCQkJCQkJbDEuMSwxLjJDOTAuNywxMzguMSw5NSwxMzcuMyw5OS42LDEzNy4zeiIvPgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNV8iIHg9IjIyNS44IiB5PSI4Ny42IiBjbGFzcz0ic3QxMCIgd2lkdGg9IjIzLjMiIGhlaWdodD0iNS44Ii8+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ol82XyIgeD0iMjI3LjMiIHk9Ijg2LjIiIGNsYXNzPSJzdDExIiB3aWR0aD0iMjAuNCIgaGVpZ2h0PSIxLjUiLz4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzdfIiB4PSI0MS45IiB5PSI4Ny42IiBjbGFzcz0ic3QxMCIgd2lkdGg9IjIzLjMiIGhlaWdodD0iNS44Ii8+CgkJCQkJPHJlY3QgaWQ9IuefqeW9ol84XyIgeD0iNDMuNCIgeT0iODYuMiIgY2xhc3M9InN0MTEiIHdpZHRoPSIyMC40IiBoZWlnaHQ9IjEuNSIvPgoJCQkJCTxwYXRoIGlkPSLot6/lvoQtNCIgY2xhc3M9InN0MTEiIGQ9Ik0wLDAiLz4KCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTgiIGNsYXNzPSJzdDEyIiBkPSJNMTE1LjYsMTM0LjljMi40LTIuMiw5LjctMy40LDIxLjktMy40YzYuNCwwLDExLDAuNywzOS45LDUuN2MyLjksMC41LDUuMywwLjksNy43LDEuMwoJCQkJCQljMjUuOCw0LjMsNDAuOCw1LjcsNDguNiwzLjNsLTAuNC0xLjRjLTcuNSwyLjItMjIuNSwwLjktNDgtMy40Yy0yLjMtMC40LTQuOC0wLjgtNy42LTEuM2MtMjkuMS01LjEtMzMuNi01LjgtNDAuMi01LjgKCQkJCQkJYy0xMi42LDAtMjAuMSwxLjItMjIuOSwzLjhMMTE1LjYsMTM0Ljl6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9Iui3r+W+hC01XzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjMwNy4xMTA1IiB5MT0iMTAzLjQ4MSIgeDI9IjMwNy4xMTA1IiB5Mj0iMTAyLjQ5MjIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTQxLjI1IDAgMCAtNTIuMDk2MiAtNDMyMDEuNzIyNyA1NDgxLjM2MTMpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0RDREVFNSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojOTc5QkE1Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i6Lev5b6ELTUiIGNsYXNzPSJzdDEzIiBkPSJNMjI1LjgsODkuOGgtMjBjLTYuOSwwLTEwLjcsMy4xLTgsNy41YzIuNyw0LjYsMTEuOSw5LjcsMjcuMSwxNC40CgkJCQkJCWMxNS41LDQuOCwyNC45LDE1LjUsMjEsMjIuNWMtNC41LDguMS0yNC40LDguOS01Ni4zLTAuOGMtNDguNC0xNC42LTc1LjgtMTYuMS04Mi42LTQuMWwxLjMsMC43YzYuMi0xMS4xLDMzLjItOS43LDgwLjksNC43CgkJCQkJCWMzMi41LDkuOCw1Myw5LjEsNTgsMC4xYzQuNS04LTUuNi0xOS41LTIxLjktMjQuNmMtMTQuOC00LjYtMjMuOC05LjYtMjYuMi0xMy43Yy0xLjgtMy4xLDAuOC01LjMsNi44LTUuM2gyMHYtMS40SDIyNS44eiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMTBfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI5NC4xODM1IiB5MT0iMTAxLjQ1NzgiIHgyPSIyOTQuNzA3NCIgeTI9IjEwMS40MDIyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM3Ljc5OTMgNy4zNDc0IDcuNjMzNyAtMzkuMjcyIC0xMTgwMy44MjUyIDE5NTkuNDUyKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUI7c3RvcC1vcGFjaXR5OjAuOTM2NSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0RDRkQxIi8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzNfIiBjbGFzcz0ic3QxNCIgZD0iTTExMS43LDEyNS4yYzQsNC45LDQuNywxMS4zLDIuNCwxMy41bC0wLjEsMC4xbC01LjUsNS42YzAuNiwyLjksMC41LDUuMy0xLjEsNi43CgkJCQkJCWwwLDBsMCwwbC04LjIsOC43bC0yMS44LTMwLjZsOC4zLTQuOHYwLjFjMS43LTAuOSw0LjEtMC42LDYuNywwLjRsNi44LTQuMmwwLjEtMC4xQzEwMiwxMTguNywxMDcuOCwxMjAuMywxMTEuNywxMjUuMnoiLz4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTRfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMjk1LjQwNTQiIHkxPSI4Mi4zMTk3IiB4Mj0iMjk2LjEyODciIHkyPSI4Mi4yOTk0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDIzLjgyNDMgMjkuNDIwNiAxNS44NjE0IC0xMi44NDQzIC04MjU1Ljg0MzggLTc1MDQuODQ1NykiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREVGIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNEOERBREMiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tNCIgY2xhc3M9InN0MTUiIGQ9Ik0xMDMuMywxMzIuNGM1LjksNy4yLDcuMiwxNS40LDQsMTguOWwwLDBsLTguMSw4LjVMNzYsMTI5LjlsOS40LTUuNWwwLDAKCQkJCQkJQzg5LjUsMTIyLjEsOTcuNSwxMjUuMiwxMDMuMywxMzIuNHoiLz4KCgkJCQkJCTxlbGxpcHNlIGlkPSLmpK3lnIblvaLlpIfku70tMiIgdHJhbnNmb3JtPSJtYXRyaXgoMC43NzcxIC0wLjYyOTMgMC42MjkzIDAuNzc3MSAtNzEuNzU3MyA4Ny4zODA5KSIgY2xhc3M9InN0MTYiIGN4PSI4Ny41IiBjeT0iMTQ1IiByeD0iOS41IiByeT0iMTkiLz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODUuMjg4NzA1LCAxNTUuNjk1NDY1KSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtODUuMjg4NzA1LCAtMTU1LjY5NTQ2NSkgdHJhbnNsYXRlKDc5LjE0MzQ1MywgMTQ2Ljc1NjkxNykiPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTkiIGNsYXNzPSJzdDE3IiBwb2ludHM9IjEyLjIsMS4xIDEyLjIsNi4xIDEuMiwxNy41IDEuMiwxMi41IAkJCQkJCSIvPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTEwIiBjbGFzcz0ic3QxMSIgcG9pbnRzPSIxMi4yLDEuMSAxMS4zLDAgMC4zLDExLjEgMS4yLDEyLjUgCQkJCQkJIi8+CgkJCQkJCTxwb2x5Z29uIGlkPSLot6/lvoQtMTEiIGNsYXNzPSJzdDE4IiBwb2ludHM9IjAuMywxMS4xIDEuMiwxMi41IDEuMiwxNy41IDAuMywxNi4xIAkJCQkJCSIvPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNeWkh+S7vSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzYuODI2Mjc3LCAxNDMuODg1MTA1KSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtNzYuODI2Mjc3LCAtMTQzLjg4NTEwNSkgdHJhbnNsYXRlKDcwLjY4MTAyNSwgMTM0Ljk0NjU1OCkiPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTlfMV8iIGNsYXNzPSJzdDE3IiBwb2ludHM9IjEyLjIsMS4xIDEyLjIsNi4xIDEuMiwxNy41IDEuMiwxMi41IAkJCQkJCSIvPgoJCQkJCQk8cG9seWdvbiBpZD0i6Lev5b6ELTEwXzFfIiBjbGFzcz0ic3QxMSIgcG9pbnRzPSIxMi4yLDEuMSAxMS4zLDAgMC4zLDExLjEgMS4yLDEyLjUgCQkJCQkJIi8+CgkJCQkJCTxwb2x5Z29uIGlkPSLot6/lvoQtMTFfMV8iIGNsYXNzPSJzdDE4IiBwb2ludHM9IjAuMywxMS4xIDEuMiwxMi41IDEuMiwxNy41IDAuMywxNi4xIAkJCQkJCSIvPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNV8xXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODQuNjQzMzQ5LCAxNTYuMjAzMTgzKSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtODQuNjQzMzQ5LCAtMTU2LjIwMzE4MykgdHJhbnNsYXRlKDc4LjEzNjYxMiwgMTQ2LjYyOTc5NikiPgoJCQkJCTwvZz4KCgkJCQkJCTxnIGlkPSLnvJbnu4QtNeWkh+S7vV8xXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzYuMjU3OTg1LCAxNDQuMjkxOTQyKSByb3RhdGUoNi4wMDAwMDApIHRyYW5zbGF0ZSgtNzYuMjU3OTg1LCAtMTQ0LjI5MTk0MikgdHJhbnNsYXRlKDY5Ljc1MTI0OCwgMTM0LjcxODU1NSkiPgoJCQkJCTwvZz4KCQkJCTwvZz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9oiIgY2xhc3M9InN0MTkiIGN4PSIxLjciIGN5PSI4MCIgcj0iMS43Ii8+CgkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzRfIiBjbGFzcz0ic3QyMCIgZD0iTTEyMy43LDYyLjlsLTEuMiwxLjhjLTU4LjQsMTQuNi05Ny4zLDM0LjgtOTUuMiw1MS44YzEuMiwxMCwxNi41LDE3LjYsNDEsMjIuMgoJCQkJCWM3LjktOC42LDE4LjMtMTcuOSwzMC43LTI3LjV2MS45Qzg3LjQsMTIyLjIsNzcuNiwxMzEsNzAsMTM5YzkuMiwxLjYsMTkuNywyLjksMzEuMiwzLjdjMS41LDAuNywzLjQsMS4zLDUuNSwxLjgKCQkJCQljLTE0LjEtMC44LTI2LjktMi4yLTM3LjgtNC4yQzU1LDE1NS4xLDQ5LDE2Ny41LDUzLDE3NS40YzguNiwxNi45LDYxLjIsOC44LDEyNi44LTE3LjZjMC41LDAuMywxLDAuNiwxLjYsMQoJCQkJCWMtNjYuOCwyNy0xMjAuNSwzNS4yLTEyOS42LDE3LjNjLTQuMi04LjMsMS43LTIxLjEsMTUuNC0zNi4yYy0yNC43LTQuOC00MC0xMi43LTQxLjMtMjMuMkMyMy42LDk4LjUsNjMuNyw3Ny43LDEyMy43LDYyLjl6CgkJCQkJIE0zMTMuMywxMTguNGg1LjFjLTYuOCwyLjEtMTMuOSw0LjEtMjEuNCw2Yy0xLjQtMC4yLTIuOC0wLjQtMy45LTAuNUMzMDAuMiwxMjIuMSwzMDYuOSwxMjAuMywzMTMuMywxMTguNHogTTI4My4xLDEwNS44djEuNwoJCQkJCWMtMi45LDEuOC01LjgsMy41LTguOCw1LjN2LTEuN0MyNzcuMywxMDkuMywyODAuMiwxMDcuNiwyODMuMSwxMDUuOHogTTM3OC41LDkuNmM0LjcsOS4yLTMuMSwyNC0yMC4yLDQxLjMKCQkJCQljMTguOSw0LjksMzAuNCwxMiwzMS42LDIxYzEuMywxMC40LTExLjQsMjEuNi0zMy43LDMyLjJ2LTEuNmMyMS40LTEwLjEsMzMuNC0yMC44LDMyLjMtMzAuNGMtMS4xLTguNi0xMi41LTE1LjQtMzEuMy0yMC4xCgkJCQkJbC0wLjMsMC4zYy00LjUsNC41LTkuNiw5LjEtMTUuMywxMy45di0xLjljNS00LjMsOS42LTguNCwxMy43LTEyLjRsMC4zLTAuM2MtNC4zLTEtOS0xLjktMTQtMi43di0xLjVjNS40LDAuOSwxMC41LDEuOSwxNS4xLDMKCQkJCQljMTcuMS0xNy4xLDI1LTMxLjUsMjAuNi00MC4zYy0xMC0xOS43LTc5LjktNS40LTE2MC40LDMyLjJoLTMuNEMyOTUuOSwzLjQsMzY3LjgtMTEuNSwzNzguNSw5LjZ6IE0xMzYuOSw4NC41djEuOAoJCQkJCWMtNS44LDMuNy0xMS40LDcuNC0xNi43LDExLjFsMi0zLjFDMTI3LDkwLjksMTMxLjksODcuNywxMzYuOSw4NC41eiBNMzIxLjEsODAuNHYxLjhjLTQuMiwzLTguNSw2LjEtMTMsOS4ybDItMy4xCgkJCQkJQzMxMy45LDg1LjYsMzE3LjUsODMsMzIxLjEsODAuNHogTTE4MC44LDU4Ljl2MS43Yy04LjEsNC4zLTE1LjksOC43LTIzLjQsMTMuMVY3MkMxNjQuOSw2Ny42LDE3Mi43LDYzLjIsMTgwLjgsNTguOXoKCQkJCQkgTTE4MC44LDUxLjZ2MS41Yy04LDEuMi0xNS44LDIuNi0yMy40LDR2LTEuNUMxNjUsNTQuMSwxNzIuOCw1Mi44LDE4MC44LDUxLjZ6IE0zMTkuNSw0NC45bC0wLjksMS40CgkJCQkJYy0xMy40LTEuMS0yOC4zLTEuNS00NC4zLTEuM3YtMC41YzAtMC4zLTAuMS0wLjctMC4yLTAuOUMyOTAuNSw0My4zLDMwNS44LDQzLjcsMzE5LjUsNDQuOXoiLz4KCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfNV8iIGNsYXNzPSJzdDIxIiBkPSJNMzc4LjUsOS42YzQuNyw5LjItMy4xLDI0LTIwLjIsNDEuM2MxOC45LDQuOSwzMC40LDEyLDMxLjYsMjEKCQkJCQljMi45LDI0LTY4LjYsNTIuOC0xNjIuNCw2Ni4xYy04Ni45LDQyLjktMTY0LjYsNTkuOS0xNzUuOCwzOGMtNC4yLTguMywxLjctMjEuMSwxNS40LTM2LjJjLTI0LjctNC44LTQwLTEyLjctNDEuMy0yMy4yCgkJCQkJYy0xLjctMTMuOCwyMS4xLTI5LjEsNTguNS00Mi4ybDAuMywxLjRjLTM2LjYsMTIuOC01OSwyNy42LTU3LjQsNDAuNmMxLjIsMTAsMTYuNSwxNy42LDQxLDIyLjJjNi44LTcuMywxNS40LTE1LjIsMjUuNS0yMy40CgkJCQkJbDAuMywxLjJsMC44LTAuMmMtOS44LDcuOS0xOC4yLDE1LjUtMjQuOSwyMi42YzM0LjQsNi4xLDg2LjIsNi42LDE0My4zLTAuNGM0LjctMC42LDkuMy0xLjIsMTMuOC0xLjhjMi43LTEuNCw1LjUtMi43LDguMy00LjEKCQkJCQljNTEuOC0yNi40LDk1LTU2LjEsMTE5LjktODAuNmwwLjMtMC4zYy0yLjctMC42LTUuNS0xLjItOC40LTEuOGwtMC40LTEuNWMzLjUsMC42LDYuOCwxLjQsMTAsMi4xYzE3LjEtMTcuMSwyNS0zMS41LDIwLjYtNDAuMwoJCQkJCWMtNC4yLTguMy0xOS4yLTEwLjYtNDEuMS03LjZsLTAuMy0xLjRDMzU4LjUtMS44LDM3NCwwLjcsMzc4LjUsOS42eiBNMjIyLjksMTM4LjdsLTAuNCwwLjFjLTMsMC40LTYsMC44LTksMS4yCgkJCQkJYy01Ny43LDcuMS0xMTAsNi43LTE0NC43LDAuMkM1NSwxNTUuMSw0OSwxNjcuNSw1MywxNzUuNEM2My40LDE5NS45LDEzOC40LDE3OS43LDIyMi45LDEzOC43eiBNMzU3LjEsNTJsLTAuMywwLjMKCQkJCQljLTI1LDI0LjgtNjguNSw1NC44LTEyMC44LDgxLjRjLTEuNCwwLjctMi45LDEuNS00LjMsMi4yYzkwLjYtMTMuNSwxNTkuNS00MS41LDE1Ni43LTYzLjlDMzg3LjQsNjMuNSwzNzUuOSw1Ni43LDM1Ny4xLDUyeiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzFfIiBjbGFzcz0ic3QxOSIgY3g9IjEzNS4yIiBjeT0iMTQ0LjIiIHI9IjIuMiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2i5aSH5Lu9LTQiIGNsYXNzPSJzdDE5IiBjeD0iMzU3IiBjeT0iNTAuOSIgcj0iMy45Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaLlpIfku70iIGNsYXNzPSJzdDE5IiBjeD0iNDMuNiIgY3k9IjkzLjkiIHI9IjIuMiIvPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzJfIiBjbGFzcz0ic3QxOSIgY3g9IjM3Mi4xIiBjeT0iMy40IiByPSIyLjIiLz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8zXyIgY2xhc3M9InN0MTkiIGN4PSI3My4yIiBjeT0iNTAuOSIgcj0iMS43Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfNF8iIGNsYXNzPSJzdDE5IiBjeD0iMjkzLjMiIGN5PSIxNjkuNCIgcj0iMS43Ii8+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfNV8iIGNsYXNzPSJzdDE5IiBjeD0iMzk4LjMiIGN5PSIxNS4yIiByPSIxLjciLz4KCQkJPC9nPgoJCTwvZz4KCTwvZz4KPC9nPgo8L3N2Zz4K'; var notFound = img$2.src;

  var img$3 = new Image(); img$3.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOm5vbmU7fQoJLnN0MXtmaWxsOiNDNEM2Q0M7fQoJLnN0MntmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qze2ZpbGw6dXJsKCPnn6nlvaJfNF8pO30KCS5zdDR7ZmlsbDojOTc5QkE1O30KCS5zdDV7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Q2e2ZpbGw6I0Y4RjlGQTt9Cgkuc3Q3e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMV8pO30KCS5zdDh7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF82Xyk7fQoJLnN0OXtmaWxsOiNEQ0RFRTA7fQo8L3N0eWxlPgo8ZyBpZD0i6aG16Z2iLTEiPgoJPGcgaWQ9IkV4Y2VwdGlvbl94MkZf5byC5bi45o+Q56S6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtODcwLjAwMDAwMCwgLTIzODEuMDAwMDAwKSI+CgkJPGcgaWQ9IuaXoOadg+mZkOexuyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzU3LjAwMDAwMCwgMjI4Ny4wMDAwMDApIj4KCQkJPGcgaWQ9Iue8lue7hC0xMiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDczLjAwMDAwMCkiPgoJCQkJPGcgaWQ9IuaXoOadg+mZkOexuy3mj5Llm74iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUxMy4wMDAwMDAsIDIxLjAwMDAwMCkiPgoJCQkJCTxnIGlkPSLmsqHmnInmnYPpmZAiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyOC4wMDAwMDAsIDQyLjAwMDAwMCkiPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiBjbGFzcz0ic3QwIiB3aWR0aD0iMjI0IiBoZWlnaHQ9IjE4MyIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaIiIGNsYXNzPSJzdDEiIGN4PSIxMzIiIGN5PSIxMSIgcj0iMSIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfMV8iIGNsYXNzPSJzdDEiIGN4PSIxNzMiIGN5PSI5NCIgcj0iMiIvPgoJCQkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaJfMl8iIGNsYXNzPSJzdDEiIGN4PSI1OSIgY3k9IjY2IiByPSIyIi8+CgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjExNi4zNTg3IiB5MT0iMTI5LjQwNzUiIHgyPSIxMTkuMzMxNCIgeTI9IjE1Ny42OTA2Ij4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZDRkQiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAuOTk4OCIgc3R5bGU9InN0b3AtY29sb3I6I0YyRjRGNyIvPgoJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QyIiBkPSJNNjAuNSwxMzYuMWMxNi4yLTMuNSw0MC42LTQuNyw1Ni41LTMuOWMxNS44LDAuOCwzMy4xLDMuMSwzMy4xLDMuMXM0LjUtMS45LDQuMS0xLjIKCQkJCQkJCWMtMC4zLDAuOC0yLjQsMS45LTEsMi4zYzEuNCwwLjQsMTUuNSwxLjksMjEuNCwzLjFzOC42LDIuMyw4LjYsMi4zczMuOC02LjYsMTIuMy01LjhjMCwwLjYtMy4xLDEuNC00LjIsMy4xUzE4OCwxNDIsMTg4LDE0MgoJCQkJCQkJczEuOC0xLDQuOSwwLjVzNi4xLDIsNi4xLDIuMnMtMS40LDMuNS0xMi43LDEuMmMtNC42LTEuMi02LjksNS4xLTI5LjMsNi42cy02MC4zLDIuNy02MC4zLDIuN3MxLjcsMi4zLDUuMiwzLjEKCQkJCQkJCWMwLDAtMi40LDIuMy03LjIsMS42Yy00LjgtMC44LTEwLTQuNy0xMC00LjdzLTEyLjctMC44LTE3LjYtMS42cy0xMC4zLTIuNy0xNC4xLTMuMWMtMy44LTAuNC0yMS0yLjMtMTQuNS02LjYKCQkJCQkJCUMzOC41LDE0My45LDQ0LjMsMTM5LjYsNjAuNSwxMzYuMXoiLz4KCgkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol80XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNTYuMTY2NyIgeTE9Ii0yLjUxNDMiIHgyPSIxNTYuMTY2NyIgeTI9Ii0xLjUxNDMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoOTYgMCAwIDcwIC0xNDg3OSAyNTIpIj4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkYzRjUiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFNUU4RUIiLz4KCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJPHBhdGggaWQ9IuefqeW9ol8yXyIgY2xhc3M9InN0MyIgZD0iTTcwLDc2aDg2YzIuOCwwLDUsMi4yLDUsNXY2MGMwLDIuOC0yLjIsNS01LDVINzBjLTIuOCwwLTUtMi4yLTUtNVY4MQoJCQkJCQkJQzY1LDc4LjIsNjcuMiw3Niw3MCw3NnoiLz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTU5LjMsMTM4djExLjdINzF2Mi4zSDU5LjNsMCwwSDU3di0xNEg1OS4zeiIvPgoJCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTQiIGNsYXNzPSJzdDEiIGQ9Ik0xNjYuNywxMzh2MTEuN0gxNTV2Mi4zaDExLjdsMCwwaDIuM3YtMTRIMTY2Ljd6Ii8+CgkJCQkJCTxnPgoJCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF81XyIgY2xhc3M9InN0NCIgZD0iTTExNi41LDExNi44bDEuNiw3LjljMC4yLDAuOC0wLjQsMS42LTEuMiwxLjhjLTAuMSwwLTAuMiwwLTAuMywwaC03LjIKCQkJCQkJCQljLTAuOCwwLTEuNS0wLjctMS41LTEuNWMwLTAuMSwwLTAuMiwwLTAuM2wxLjYtNy45Yy0zLTEuMy01LTQuMS01LTcuM2MwLTQuNCwzLjgtOCw4LjUtOHM4LjUsMy42LDguNSw4CgkJCQkJCQkJQzEyMS41LDExMi43LDExOS41LDExNS41LDExNi41LDExNi44eiIvPgoKCQkJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEzNi4wMjk0IiB5MT0iLTYuODAxMSIgeDI9IjEzNi4wMjk0IiB5Mj0iLTYuMjc4OSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxNyAwIDAgMjUgLTIxOTkuNSAyNzcuNSkiPgoJCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMUUyRTYiLz4KCQkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCQkJPHBhdGggY2xhc3M9InN0NSIgZD0iTTExNywxMjcuNWgtNy42Yy0xLjQsMC0yLjUtMS4xLTIuNS0yLjVsMC0wLjVsMS40LTcuMWMtMy0xLjYtNC45LTQuNi00LjktNy45YzAtNSw0LjMtOSw5LjUtOQoJCQkJCQkJCXM5LjUsNCw5LjUsOWMwLDMuMy0xLjksNi4zLTQuOSw3LjlsMS40LDcuMWMwLjMsMS4yLTAuNiwyLjYtMS45LDNMMTE3LDEyNy41eiBNMTA4LjksMTI0Ljh2MC4yYzAsMC4yLDAuMywwLjUsMC41LDAuNWg3LjMKCQkJCQkJCQljMC4yLTAuMSwwLjQtMC40LDAuNC0wLjZsLTEuOC04LjdsMC43LTAuM2MyLjctMS4yLDQuNC0zLjYsNC40LTYuNGMwLTMuOS0zLjQtNy03LjUtN3MtNy41LDMuMS03LjUsN2MwLDIuOCwxLjcsNS4yLDQuNCw2LjQKCQkJCQkJCQlsMC43LDAuM0wxMDguOSwxMjQuOHoiLz4KCQkJCQkJPC9nPgoJCQkJCQk8cGF0aCBpZD0i55+p5b2iXzNfIiBjbGFzcz0ic3Q2IiBkPSJNNzAsNzZoODZjMi44LDAsNSwyLjIsNSw1bDAsMGMwLDIuOC0yLjIsNS01LDVINzBjLTIuOCwwLTUtMi4yLTUtNWwwLDAKCQkJCQkJCUM2NSw3OC4yLDY3LjIsNzYsNzAsNzZ6Ii8+CgoJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTU1LjAyNjMiIHkxPSItMi42NjY3IiB4Mj0iMTU1LjAyNjMiIHkyPSItMS42NzI3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDc2IDAgMCA2NiAtMTE2NjkgMTkyKSI+CgkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjNGNEY1Ii8+CgkJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCIi8+CgkJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMl8iIGNsYXNzPSJzdDciIGQ9Ik0xNDEuNSw1NC42YzAtMTYtMTIuOC0yOS0yOC41LTI5cy0yOC41LDEzLTI4LjUsMjlsMCwwdjI1LjhjMCwwLjktMi4xLDEuNi00LjgsMS42CgkJCQkJCQljLTIuNSwwLTQuNi0wLjctNC43LTEuNXYtMC4xVjU0LjZDNzUsMzMuMyw5MiwxNiwxMTMsMTZzMzgsMTcuMywzOCwzOC42bDAsMHYyNS44YzAsMC45LTIuMSwxLjYtNC44LDEuNnMtNC44LTAuNy00LjgtMS42CgkJCQkJCQlsMCwwVjU0LjZIMTQxLjV6Ii8+CgoJCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfNl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTUzLjc5MDMiIHkxPSItMy4yMzg1IiB4Mj0iMTUzLjc5MDMiIHkyPSItMi4yNTkyIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDYyIDAgMCA1NCAtOTQyMiAyMDEpIj4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUIiLz4KCQkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFN0U5RUIiLz4KCQkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8zXyIgY2xhc3M9InN0OCIgZD0iTTgyLDU0LjVDODIuMywzOC4yLDk2LDI1LDExMywyNWMxNy4xLDAsMzEsMTMuNCwzMSwzMGgtMy4xYzAtMTQuOS0xMi41LTI3LTI3LjktMjcKCQkJCQkJCVM4NS4xLDQwLjEsODUuMSw1NXYyNEg4MlY1NVY1NC41eiBNMTQ0LDU1djI0aC0zLjFWNTVIMTQ0eiIvPgoJCQkJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzRfIiBjbGFzcz0ic3Q5IiBkPSJNODAsNzhjMi43LDAsNC45LTAuOCw1LTEuOVY3NnY0YzAsMS4xLTIuMiwyLTUsMmMtMi43LDAtNC45LTAuOC01LTEuOVY4MHYtNAoJCQkJCQkJQzc1LDc3LjEsNzcuMiw3OCw4MCw3OHoiLz4KCQkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0zIiBjbGFzcz0ic3Q5IiBkPSJNMTQ2LDc4YzIuNywwLDQuOS0wLjgsNS0xLjlWNzZ2NGMwLDEuMS0yLjIsMi01LDJjLTIuNywwLTQuOS0wLjgtNS0xLjlWODB2LTQKCQkJCQkJCUMxNDEsNzcuMSwxNDMuMiw3OCwxNDYsNzh6Ii8+CgkJCQkJPC9nPgoJCQkJPC9nPgoJCQk8L2c+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo='; var permissions = img$3.src;

  var img$4 = new Image(); img$4.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6I0M0QzZDQzt9Cgkuc3Qye2ZpbGw6dXJsKCPnn6nlvaItMl8xXyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2iXzZfKTt9Cgkuc3Q0e2ZpbGw6I0RDREVFMDt9Cgkuc3Q1e2ZpbGw6I0QxRDNENjt9Cgkuc3Q2e2ZpbGw6dXJsKCPnn6nlvaItM18xXyk7fQoJLnN0N3tmaWxsOiNFNUU3RUM7fQoJLnN0OHtmaWxsOnVybCgj5LiJ6KeS5b2iXzFfKTt9Cgkuc3Q5e2ZpbGw6Izk3OUJBNTt9Cjwvc3R5bGU+CjxnIGlkPSLpobXpnaItMSI+Cgk8ZyBpZD0iRXhjZXB0aW9uX3gyRl/lvILluLjmj5DnpLoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04NjkuMDAwMDAwLCAtMjkxOC4wMDAwMDApIj4KCQk8ZyBpZD0i5byC5bi45aSx6LSl57G7IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNTcuMDAwMDAwLCAyODIzLjAwMDAwMCkiPgoJCQk8ZyBpZD0i5byC5bi45aSx6LSl57G7LeaPkuWbviIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTEyLjAwMDAwMCwgOTUuMDAwMDAwKSI+CgkJCQk8ZyBpZD0i57yW57uELTIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyMy4wMDAwMDAsIDMzLjAwMDAwMCkiPgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEyNi41Njk5IiB5MT0iMTM0Ljk4ODkiIHgyPSIxMzAuMTYzOCIgeTI9IjE2OS4xODI3Ij4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNNjAsMTQzYzE5LjMtNC4yLDQ4LjQtNS43LDY3LjMtNC43czM5LjQsMy44LDM5LjQsMy44czUuMy0yLjQsNC45LTEuNAoJCQkJCQljLTAuNCwwLjktMi45LDIuNC0xLjIsMi44YzEuNiwwLjUsMTguNSwyLjQsMjUuNCwzLjhjNywxLjQsMTAuMywyLjgsMTAuMywyLjhzNC42LTgsMTQuNy03LjFjMCwwLjgtMy43LDEuNy01LDMuOAoJCQkJCQljLTEuMiwyLjEtNCwzLjMtNCwzLjNzMi4yLTEuMiw1LjksMC42czcuMywyLjQsNy4zLDIuN3MtMS42LDQuMi0xNS4yLDEuNGMtNS41LTEuNC04LjIsNi4xLTM0LjksOHMtNzEuOCwzLjMtNzEuOCwzLjMKCQkJCQkJczIuMSwyLjgsNi4yLDMuOGMwLDAtMi45LDIuOC04LjYsMS45Yy01LjctMC45LTExLjktNS43LTExLjktNS43cy0xNS4yLTAuOS0yMC45LTEuOXMtMTIuMy0zLjMtMTYuOC0zLjhzLTI1LTIuOC0xNy4yLTgKCQkJCQkJQzMzLjgsMTUyLjQsNDAuNywxNDcuMyw2MCwxNDN6Ii8+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTYwLjgsMTQ3djkuMkg3MHYxLjhINTl2LTExSDYwLjh6Ii8+CgkJCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiOWkh+S7vSIgY2xhc3M9InN0MSIgZD0iTTY2LDMxLjhoLTkuMlY0MUg1NXYtOS4ybDAsMFYzMGgxMVYzMS44eiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tMiIgY2xhc3M9InN0MSIgZD0iTTE1Ny4yLDQxdi05LjJIMTQ4VjMwaDkuMmwwLDBoMS44djExSDE1Ny4yeiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaItMl8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjUuNzcyNyIgeTE9Ii0xLjU1OTciIHgyPSIxNjUuNzcyNyIgeTI9Ii0wLjYyMzgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoODggMCAwIDExMiAtMTQ0ODAgMjE0KSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFQkVERjA7c3RvcC1vcGFjaXR5OjAuOTkxNyIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cGF0aCBpZD0i55+p5b2iLTIiIGNsYXNzPSJzdDIiIGQ9Ik02NSwzOGg4NmMwLjYsMCwxLDAuNCwxLDF2MTEwYzAsMC42LTAuNCwxLTEsMUg2NWMtMC42LDAtMS0wLjQtMS0xVjM5CgkJCQkJCUM2NCwzOC40LDY0LjQsMzgsNjUsMzh6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9ol82XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjQuODAxNCIgeTE9Ii0xLjgxNDQiIHgyPSIxNjQuODAxNCIgeTI9Ii0wLjgyNTkiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNzMgMCAwIDk3IC0xMTkyMyAyMjEpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZGRkZGRiIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSI3MSIgeT0iNDUiIGNsYXNzPSJzdDMiIHdpZHRoPSI3MyIgaGVpZ2h0PSI5NyIvPgoJCQkJCTxyZWN0IGlkPSLnn6nlvaJfMl8iIHg9Ijg2IiB5PSI0OSIgY2xhc3M9InN0NCIgd2lkdGg9IjQzIiBoZWlnaHQ9IjIiLz4KCQkJCQk8cmVjdCBpZD0i55+p5b2iXzNfIiB4PSI3MSIgeT0iMTQwIiBjbGFzcz0ic3Q1IiB3aWR0aD0iNzMiIGhlaWdodD0iMiIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLnn6nlvaItM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjAuODI1NiIgeTE9Ii0xMS43MzMzIiB4Mj0iMTYwLjgyNTYiIHkyPSItMTAuNzQxMiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0MyAwIDAgMTUgLTY4MDggMjEwKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFREVGRjIiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U4RUFFRCIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHJlY3QgaWQ9IuefqeW9oi0zIiB4PSI4NiIgeT0iMzQiIGNsYXNzPSJzdDYiIHdpZHRoPSI0MyIgaGVpZ2h0PSIxNSIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDUiIGQ9Ik0xNTIsMTA1djQ0YzAsMC42LTAuNCwxLTEsMWgtMjQuNkwxNTIsMTA1eiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMl8iIGNsYXNzPSJzdDciIGQ9Ik0xNDQsMTE5LjJWMTQwaC0xMkwxNDQsMTE5LjJ6Ii8+CgoJCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuS4ieinkuW9ol8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNjMuOTE0MyIgeTE9Ii0zLjA4MTIiIHgyPSIxNjMuOTE0MyIgeTI9Ii0yLjE0NTMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNjMuMTc5OSAwIDAgNTYuOTAzMyAtMTAxOTguMTcxOSAyNzcuMDk0NSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q0RDZEOSIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9IuS4ieinkuW9oiIgY2xhc3M9InN0OCIgZD0iTTE1OS43LDEwMi4xbDEuNSwyLjZsMCwwbDI4LjEsNTAuM2MwLjUsMSwwLjIsMi4yLTAuOCwyLjdjLTAuMywwLjItMC42LDAuMy0xLDAuM2gtNTkuMgoJCQkJCQljLTEuMSwwLTItMC45LTItMmMwLTAuMywwLjEtMC43LDAuMy0xbDI5LjYtNTIuOWMwLjUtMSwxLjgtMS4zLDIuNy0wLjhDMTU5LjMsMTAxLjUsMTU5LjYsMTAxLjgsMTU5LjcsMTAyLjF6Ii8+CgkJCQkJPHBhdGggaWQ9Il94MjFfIiBjbGFzcz0ic3Q5IiBkPSJNMTYwLjcsMTI0bC0wLjYsMTYuNGgtNC4ybC0wLjYtMTYuNEMxNTUuMywxMjQsMTYwLjcsMTI0LDE2MC43LDEyNHogTTE1NSwxNDUuOAoJCQkJCQljMC0wLjksMC4zLTEuNiwwLjktMi4yczEuMy0wLjgsMi4xLTAuOGMwLjksMCwxLjYsMC4zLDIuMSwwLjhjMC42LDAuNiwwLjgsMS4zLDAuOCwyLjFzLTAuMywxLjYtMC44LDIuMQoJCQkJCQljLTAuNiwwLjYtMS4yLDAuOS0yLDAuOWMtMSwwLTEuNy0wLjMtMi4zLTAuOUMxNTUuMywxNDcuMywxNTUsMTQ2LjYsMTU1LDE0NS44eiIvPgoJCQkJCTxnIGlkPSLnvJbnu4QtMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAxLjAwMDAwMCwgNzQuMDAwMDAwKSI+CgkJCQkJCTxyZWN0IGlkPSLnn6nlvaJfNF8iIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9IiB4PSI3LjYiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTIiIHg9IjE1LjEiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjIyLjciIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTQiIHg9IjMwLjIiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMSIvPgoJCQkJCTwvZz4KCQkJCQk8ZyBpZD0i57yW57uELTNfMV8iIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEyNC4wMDAwMDAsIDkxLjAwMDAwMCkiPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2iXzVfIiB4PSI3LjgiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjkiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjkiIGhlaWdodD0iMSIvPgoJCQkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9XzFfIiB4PSIxNS42IiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yXzFfIiB4PSIyMy41IiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0zXzFfIiB4PSIzMS4zIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS00XzFfIiB4PSIzOS4xIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy45IiBoZWlnaHQ9IjEiLz4KCQkJCQk8L2c+CgkJCQk8L2c+CgkJCTwvZz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg=='; var maintain = img$4.src;

  var img$5 = new Image(); img$5.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPot6/lvoQtM18xXyk7fQoJLnN0MntmaWxsOnVybCgj5b2i54q257uT5ZCIXzJfKTt9Cgkuc3Qze2ZpbGw6I0M0QzZDQzt9Cjwvc3R5bGU+CjxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI0MS40NDI3IiB5MT0iODQuOTYwMSIgeDI9IjI0Ny41MTg0IiB5Mj0iNTAuNTAyOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDI0MCkiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZCRkNGRCIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0YwRjJGNSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cGF0aCBpZD0iRmlsbC0xIiBjbGFzcz0ic3QwIiBkPSJNMTg4LDE2NC43YzE2LjMtMy43LDM5LjctNS4zLDU1LjYtNC41czI5LjEsMy42LDMwLDIuOWMzLjItMi4xLDEwLTMsOS42LTIuMgoJYy0wLjMsMC44LTQuNywzLjQtMy4zLDMuOGMxLjQsMC40LDE1LjYsMiwyMS41LDMuM2M1LjksMS4yLDkuNywyLjQsMTEsMi40czMuMy0xLjcsMTEuOC0wLjljMC4yLDAuMy0xLjksMC40LTMuOCwxLjQKCXMtMy4zLDAuOS0zLjMsMS4xczEuMS0wLjMsMy4zLDEuMWMyLjIsMS40LDYuMSwxLjksNi4xLDIuMnMtNC45LDItMTMuMi0wLjZjLTIuMS0wLjctNyw1LjEtMjkuNSw2LjdzLTYwLjUsMi45LTYwLjUsMi45CglzMi4zLDIuOSw1LjYsMy44YzAuMiwwLjMtMS4zLDEuNC03LjgsMC4ycy05LjktMy45LTkuOS0zLjlzLTEyLjgtMC44LTE3LjYtMS42cy0xMC40LTIuOS0xNC4yLTMuM2MtMy44LTAuNC0yMS4xLTIuNC0xNC41LTYuOQoJQzE2NC43LDE3Mi41LDE3MS43LDE2OC40LDE4OCwxNjQuN3oiLz4KPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI0MTIuNTYwNiIgeTE9Ii0zLjExMzMiIHgyPSI0MTIuNTYwNiIgeTI9Ii0yLjE3NzMiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTA1LjYgMCAwIDU2LjMyIC00MzMyNi40MDIzIDI3OC40MDAxKSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTZFOEVCO3N0b3Atb3BhY2l0eTowLjk5MTciLz4KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNENEQ2RDkiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBvbHlnb24gaWQ9Iui3r+W+hC0zIiBjbGFzcz0ic3QxIiBwb2ludHM9IjE4Ny4yLDEzNy42IDIxMC43LDEwMi40IDI2OS4zLDEwMi40IDI5Mi44LDEzNy42IDI5Mi44LDE1OC43IDE4Ny4yLDE1OC43ICIvPgo8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8yXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI0MTIuNTYwNiIgeTE9Ii01IiB4Mj0iNDEyLjU2MDYiIHkyPSItNC4wMDc5IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEwNS42IDAgMCAzNS4yIC00MzMyNi40MDIzIDMxMy42MDA0KSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRURFRkYyIi8+Cgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRThFQUVEIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIGlkPSLlvaLnirbnu5PlkIgiIGNsYXNzPSJzdDIiIGQ9Ik0yMTIuNiwxNzIuOGgtMjMuNGMtMS4xLDAtMi0wLjktMi0ydi0zMy4yaDIzLjRjMS4xLDAsMiwwLjksMiwydjcuNGMwLDEuMSwwLjgsMS45LDEuOSwyCgloMC4xaDUwLjhjMS4xLDAsMS45LTAuOCwyLTEuOVYxNDd2LTcuNGMwLTEuMSwwLjktMiwyLTJoMjMuNHYzMy4yYzAsMS4xLTAuOSwyLTIsMmgtMjMuNEgyMTIuNnoiLz4KPHBhdGggaWQ9IuW9oueKtue7k+WQiF8xXyIgY2xhc3M9InN0MyIgZD0iTTE4Mi40LDE2OS42djhoOHYxLjZoLTkuNnYtOS42SDE4Mi40eiIvPgo8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9IiBjbGFzcz0ic3QzIiBkPSJNMjg5LjYsMTc3LjZoOHYtOGgxLjZ2OS42aC05LjZWMTc3LjZ6Ii8+CjxnIGlkPSLnvJbnu4QtNCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoOTEuNjg4ODkwLCAxMS44NzQ5MzYpIHJvdGF0ZSgyMS4wMDAwMDApIHRyYW5zbGF0ZSgtOTEuNjg4ODkwLCAtMTEuODc0OTM2KSB0cmFuc2xhdGUoOTAuODg4ODkwLCAwLjY3NDkzNikiPgoKCQk8cmVjdCBpZD0i55+p5b2iXzFfIiB4PSIxODMuMSIgeT0iMjQuNSIgdHJhbnNmb3JtPSJtYXRyaXgoNS40NDk4OTllLTA2IDEgLTEgNS40NDk4OTllLTA2IDIwOS45Mzc5IC0xNTkuMzkzOCkiIGNsYXNzPSJzdDMiIHdpZHRoPSIzLjIiIGhlaWdodD0iMS42Ii8+CgoJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tNiIgeD0iMTgzLjEiIHk9IjMwLjkiIHRyYW5zZm9ybT0ibWF0cml4KDUuNDQ5ODk4ZS0wNiAxIC0xIDUuNDQ5ODk4ZS0wNiAyMTYuMzM3OCAtMTUyLjk5MzkpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMy4yIiBoZWlnaHQ9IjEuNiIvPgoKCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTciIHg9IjE4My4xIiB5PSIzNy4zIiB0cmFuc2Zvcm09Im1hdHJpeCg1LjQ0OTg5OGUtMDYgMSAtMSA1LjQ0OTg5OGUtMDYgMjIyLjczNzkgLTE0Ni41OTM5KSIgY2xhc3M9InN0MyIgd2lkdGg9IjMuMiIgaGVpZ2h0PSIxLjYiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS04IiB4PSIxODMuMSIgeT0iNDMuNyIgdHJhbnNmb3JtPSJtYXRyaXgoNS40NDk4OTllLTA2IDEgLTEgNS40NDk4OTllLTA2IDIyOS4xMzc5IC0xNDAuMTkzOSkiIGNsYXNzPSJzdDMiIHdpZHRoPSIzLjIiIGhlaWdodD0iMS42Ii8+CjwvZz4KPGcgaWQ9Iue8lue7hC0zIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzNi4wMDAwMDAsIDI3LjIwMDAwMCkgcm90YXRlKC0zMi4wMDAwMDApIHRyYW5zbGF0ZSgtMzYuMDAwMDAwLCAtMjcuMjAwMDAwKSB0cmFuc2xhdGUoMzUuMjAwMDAwLCAxMi44MDAwMDApIj4KCgkJPHJlY3QgaWQ9IuefqeW9ol8yXyIgeD0iOTEuNyIgeT0iMTYxLjEiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDUuNDI2MzM3ZS0wNiAtNS40MjYzMzdlLTA2IC0xIDE4NS4wNzUzIDMyNS40NDM4KSIgY2xhc3M9InN0MyIgd2lkdGg9IjEuNiIgaGVpZ2h0PSIzLjIiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS0yIiB4PSI5MS43IiB5PSIxNjcuNSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgNS40MjYzMzZlLTA2IC01LjQyNjMzNmUtMDYgLTEgMTg1LjA3NTUgMzM4LjI0MzgpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMS42IiBoZWlnaHQ9IjMuMiIvPgoKCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjkxLjciIHk9IjE3My45IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSA1LjQyNjMzNmUtMDYgLTUuNDI2MzM2ZS0wNiAtMSAxODUuMDc1NSAzNTEuMDQzOSkiIGNsYXNzPSJzdDMiIHdpZHRoPSIxLjYiIGhlaWdodD0iMy4yIi8+CgoJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tNCIgeD0iOTEuNyIgeT0iMTgwLjMiIHRyYW5zZm9ybT0ibWF0cml4KC0xIDUuNDI2MzM2ZS0wNiAtNS40MjYzMzZlLTA2IC0xIDE4NS4wNzU1IDM2My44NDM4KSIgY2xhc3M9InN0MyIgd2lkdGg9IjEuNiIgaGVpZ2h0PSIzLjIiLz4KCgkJPHJlY3QgaWQ9IuefqeW9ouWkh+S7vS01IiB4PSI5MS43IiB5PSIxODYuNyIgdHJhbnNmb3JtPSJtYXRyaXgoLTEgNS40MjYzMzdlLTA2IC01LjQyNjMzN2UtMDYgLTEgMTg1LjA3NTUgMzc2LjY0MzgpIiBjbGFzcz0ic3QzIiB3aWR0aD0iMS42IiBoZWlnaHQ9IjMuMiIvPgo8L2c+CjxjaXJjbGUgaWQ9IuakreWchuW9oiIgY2xhc3M9InN0MyIgY3g9IjI2OC44IiBjeT0iOTQuNCIgcj0iMS42Ii8+CjxjaXJjbGUgaWQ9IuakreWchuW9ouWkh+S7vSIgY2xhc3M9InN0MyIgY3g9IjIyNy4yIiBjeT0iMTIwIiByPSIxLjYiLz4KPC9zdmc+Cg=='; var empty = img$5.src;

  var img$6 = new Image(); img$6.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjRmlsbC0xXzFfKTt9Cgkuc3Qxe2ZpbGw6I0M0QzZDQzt9Cgkuc3Qye2ZpbGw6dXJsKCPnn6nlvaItMl8xXyk7fQoJLnN0M3tmaWxsOnVybCgj55+p5b2iXzZfKTt9Cgkuc3Q0e2ZpbGw6I0RDREVFMDt9Cgkuc3Q1e2ZpbGw6I0QxRDNENjt9Cgkuc3Q2e2ZpbGw6dXJsKCPnn6nlvaItM18xXyk7fQoJLnN0N3tmaWxsOiNFNUU3RUM7fQoJLnN0OHtmaWxsOiNEQ0RERTA7fQoJLnN0OXtmaWxsOnVybCgj6Lev5b6ELTEzXzFfKTt9Cgkuc3QxMHtmaWxsOnVybCgj5qSt5ZyG5b2iXzNfKTtzdHJva2U6dXJsKCPmpK3lnIblvaJfNF8pO30KCS5zdDExe2ZpbGw6dXJsKCPmpK3lnIblvaJfNV8pO3N0cm9rZTp1cmwoI+akreWchuW9ol82Xyk7fQoJLnN0MTJ7ZmlsbDojRkZGRkZGO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekuiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg2OS4wMDAwMDAsIC0yOTE4LjAwMDAwMCkiPgoJCTxnIGlkPSLmkJzntKLkuLrnqboiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDg2OS4wMDAwMDAsIDI5MTguMDAwMDAwKSI+CgkJCTxsaW5lYXJHcmFkaWVudCBpZD0iRmlsbC0xXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjI0My4wNDY0IiB5MT0iMTY3Ljk3OTMiIHgyPSIyNDUuODA3MSIgeTI9IjE5NC4yNDU2Ij4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZDRkQiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHBhdGggaWQ9IkZpbGwtMSIgY2xhc3M9InN0MCIgZD0iTTE5My4xLDE3NC4yYzE0LjgtMy4zLDM2LTQuOCw1MC41LTQuMWMxNC40LDAuNywyNi40LDMuMywyNy4zLDIuN2MyLjktMS45LDktMi44LDguNy0yCgkJCQljLTAuMywwLjctNC4zLDMuMS0zLDMuNGMxLjMsMC40LDE0LjEsMS45LDE5LjUsM2M1LjMsMS4xLDguOCwyLjIsOS45LDIuMmMxLjIsMCwzLTEuNiwxMC43LTAuOGMwLjEsMC4zLTEuNywwLjQtMy40LDEuMwoJCQkJYy0xLjcsMC45LTMsMC44LTMsMXMxLTAuMywzLDFzNS41LDEuNyw1LjUsMnMtNC41LDEuOC0xMi0wLjZjLTEuOS0wLjYtNi4zLDQuNi0yNi44LDYuMXMtNTUsMi42LTU1LDIuNnMyLjEsMi43LDUuMSwzLjQKCQkJCWMwLjIsMC4zLTEuMiwxLjMtNy4xLDAuMmMtNS45LTEuMS05LTMuNi05LTMuNnMtMTEuNi0wLjctMTYtMS41Yy00LjQtMC43LTkuNC0yLjYtMTIuOS0zcy0xOS4yLTIuMi0xMy4yLTYuMwoJCQkJQzE3MiwxODEuMiwxNzguMywxNzcuNSwxOTMuMSwxNzQuMnoiLz4KCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiCIgY2xhc3M9InN0MSIgZD0iTTE5My4xLDE3Ny40djkuNGg5LjR2MS45aC0xMS4ydi0xMS4yTDE5My4xLDE3Ny40TDE5My4xLDE3Ny40eiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9IiBjbGFzcz0ic3QxIiBkPSJNMjAwLjYsNjQuOWgtOS40djkuNGgtMS45di05LjRsMCwwVjYzaDExLjJMMjAwLjYsNjQuOUwyMDAuNiw2NC45eiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCI5aSH5Lu9LTIiIGNsYXNzPSJzdDEiIGQ9Ik0yODguOCw3NC4ydi05LjRoLTkuNFY2M2g5LjRsMCwwaDEuOXYxMS4ySDI4OC44eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iLTJfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDExLjY3NjgiIHkxPSItMS42MDY2IiB4Mj0iNDExLjY3NjgiIHkyPSItMC42NzA3IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDg2LjI1IDAgMCAxMDguNzUgLTM1MjY3LjEyNSAyNDYuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURGMDtzdG9wLW9wYWNpdHk6MC45OTE3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTFFM0U2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLnn6nlvaItMiIgY2xhc3M9InN0MiIgZD0iTTE5Ny45LDcwLjVoODQuMmMwLjYsMCwxLDAuNCwxLDF2MTA2LjhjMCwwLjYtMC40LDEtMSwxaC04NC4yYy0wLjYsMC0xLTAuNC0xLTFWNzEuNQoJCQkJQzE5Ni45LDcwLjksMTk3LjMsNzAuNSwxOTcuOSw3MC41eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i55+p5b2iXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjQxMC42NjE0IiB5MT0iLTEuODc3MyIgeDI9IjQxMC42NjE0IiB5Mj0iLTAuODg4OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg3MS4yNSAwIDAgOTMuNzUgLTI5MDE5LjYyNSAyNTQpIj4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRkZGRkYiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMkY0RjciLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHJlY3QgaWQ9IuefqeW9ol8xXyIgeD0iMjA0LjQiIHk9Ijc4IiBjbGFzcz0ic3QzIiB3aWR0aD0iNzEuMiIgaGVpZ2h0PSI5My44Ii8+CgkJCTxyZWN0IGlkPSLnn6nlvaJfMl8iIHg9IjIxOS40IiB5PSI4MS44IiBjbGFzcz0ic3Q0IiB3aWR0aD0iNDEuMiIgaGVpZ2h0PSIxLjkiLz4KCQkJPHJlY3QgaWQ9IuefqeW9ol8zXyIgeD0iMjA0LjQiIHk9IjE3MS44IiBjbGFzcz0ic3Q1IiB3aWR0aD0iNzEuMiIgaGVpZ2h0PSIxLjkiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuefqeW9oi0zXzFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjQwNi40MTUyIiB5MT0iLTExLjczMzQiIHgyPSI0MDYuNDE1MiIgeTI9Ii0xMC43NDEzIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQxLjI1IDAgMCAxNSAtMTY1MjQuNjI1IDI0Mi43NSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VERUZGMiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0U4RUFFRCIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cmVjdCBpZD0i55+p5b2iLTMiIHg9IjIxOS40IiB5PSI2Ni44IiBjbGFzcz0ic3Q2IiB3aWR0aD0iNDEuMiIgaGVpZ2h0PSIxNSIvPgoJCQk8ZyBpZD0i57yW57uELTMiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIyMy4xMjUwMDAsIDk4LjYyNTAwMCkiPgoJCQkJPHJlY3QgaWQ9IuefqeW9ol80XyIgY2xhc3M9InN0MSIgd2lkdGg9IjMuOCIgaGVpZ2h0PSIxLjkiLz4KCQkJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70iIHg9IjcuNSIgY2xhc3M9InN0MSIgd2lkdGg9IjMuOCIgaGVpZ2h0PSIxLjkiLz4KCQkJCTxyZWN0IGlkPSLnn6nlvaLlpIfku70tMiIgeD0iMTUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMS45Ii8+CgkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTMiIHg9IjIyLjUiIGNsYXNzPSJzdDEiIHdpZHRoPSIzLjgiIGhlaWdodD0iMS45Ii8+CgkJCQk8cmVjdCBpZD0i55+p5b2i5aSH5Lu9LTQiIHg9IjMwIiBjbGFzcz0ic3QxIiB3aWR0aD0iMy44IiBoZWlnaHQ9IjEuOSIvPgoJCQk8L2c+CgkJCTxnIGlkPSLnvJbnu4QtNiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjI4Ljc1MDAwMCwgMTEzLjYyNTAwMCkiPgoJCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iIiBjbGFzcz0ic3Q3IiBjeD0iMjQuNCIgY3k9IjI2LjIiIHI9IjI0LjQiLz4KCQkJCTxwYXRoIGlkPSLot6/lvoQtMTIiIGNsYXNzPSJzdDciIGQ9Ik0zOSw0NWwzLjEsMy4yYy0wLjYsMC44LTAuNiwxLjUsMCwyLjJzMi4yLDIuNSw0LjcsNS4zdi03LjVsLTYuMS01TDM5LDQ1eiIvPgoKCQkJCQk8ZyBpZD0i57yW57uELTQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwLjIyNjMxNywgNTEuNzA5MDc3KSByb3RhdGUoLTQ1LjAwMDAwMCkgdHJhbnNsYXRlKC01MC4yMjYzMTcsIC01MS43MDkwNzcpIHRyYW5zbGF0ZSg0NC42MDEzMTcsIDM2LjcwOTA3NykiPgoKCQkJCQkJPHJlY3QgaWQ9IuefqeW9ol81XyIgeD0iMy44IiB5PSIwIiB0cmFuc2Zvcm09Im1hdHJpeCgtMSA1LjA3MDM2M2UtMDYgLTUuMDcwMzYzZS0wNiAtMSAxMS40IDkuMzUpIiBjbGFzcz0ic3Q4IiB3aWR0aD0iMy43IiBoZWlnaHQ9IjkuNCIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtMTNfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTEwOS4zOTE1IiB5MT0iLTU1LjkzODMiIHgyPSItMTA5LjU1NzgiIHkyPSItNTUuODkwNSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg5LjIxMjkgMCAwIDIyLjUgMTAxMy45Mjg1IDEyNzcuMjgxKSI+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNEN0Q4REIiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0JFQkZDMiIvPgoJCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQkJPHBhdGggaWQ9Iui3r+W+hC0xMyIgY2xhc3M9InN0OSIgZD0iTTMuNyw1LjdoNGMwLjUsMCwxLDAuNCwxLDAuOWwxLjUsMjAuNWMwLDAuNi0wLjQsMS0wLjksMS4xYzAsMCwwLDAtMC4xLDBIMgoJCQkJCQljLTAuNiwwLTEtMC40LTEtMXYtMC4xTDIuNyw2LjZDMi43LDYuMSwzLjIsNS43LDMuNyw1Ljd6Ii8+CgkJCQk8L2c+CgkJCQk8ZyBpZD0i57yW57uELTUiPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTQ5LjcxMTUiIHkxPSItMy42ODU5IiB4Mj0iLTQ5LjcxMTUiIHkyPSItMi42ODU5IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ3Ljc1IDAgMCA0Ny43NSAyMzk4LjEyNSAxNzYuNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxLjUzMDgyOGUtMDMiIHN0eWxlPSJzdG9wLWNvbG9yOiNERERFRTAiLz4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMC45OTgiIHN0eWxlPSJzdG9wLWNvbG9yOiNDM0M1QzciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfNF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTQ5LjcxMTUiIHkxPSItMy42ODU4IiB4Mj0iLTQ5LjcxMTUiIHkyPSItMi43MDU0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ3Ljc1IDAgMCA0Ny43NSAyMzk4LjEyNSAxNzYuNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRERERUUwIi8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNCRUMwQzIiLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8xXyIgY2xhc3M9InN0MTAiIGN4PSIyNC40IiBjeT0iMjQuNCIgcj0iMjMuOSIvPgoKCQkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLmpK3lnIblvaJfNV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTUyLjM5NjYiIHkxPSItNC44MjIiIHgyPSItNTIuMzk2NiIgeTI9Ii0zLjgzOCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgzNi41IDAgMCAzNi41IDE5MzYuODc1IDE4Mi4xMjUpIj4KCQkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZFRkVGRSIvPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjJGNEY3Ii8+CgkJCQkJPC9saW5lYXJHcmFkaWVudD4KCgkJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5qSt5ZyG5b2iXzZfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ii01Mi4zOTY2IiB5MT0iLTQuODIyIiB4Mj0iLTUyLjM5NjYiIHkyPSItMy44Mzk4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM2LjUgMCAwIDM2LjUgMTkzNi44NzUgMTgyLjEyNSkiPgoJCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjNGNEY1Ii8+CgkJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGM0Y1RjciLz4KCQkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol8yXyIgY2xhc3M9InN0MTEiIGN4PSIyNC40IiBjeT0iMjQuNCIgcj0iMTguMiIvPgoJCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDEyIiBkPSJNMjMuNSwxMi4zYzUuOCwwLDEwLjksMy4zLDEzLjQsOC4yYy0yLjUtMS42LTUuNS0yLjYtOC43LTIuNmMtNCwwLTcuNywxLjUtMTAuNSw0CgkJCQkJCUwxNCwxNS43QzE2LjYsMTMuNiwxOS45LDEyLjMsMjMuNSwxMi4zeiIvPgoJCQkJPC9nPgoJCQkJPHBvbHlnb24gaWQ9Iui3r+W+hC0xNCIgY2xhc3M9InN0NSIgcG9pbnRzPSI0Ni45LDUzLjQgNDYuOSw1NS42IDU0LjQsNjQuNCA1NC40LDYyLjMgCQkJCSIvPgoJCQk8L2c+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo='; var searchEmpty = img$6.src;

  var img$7 = new Image(); img$7.src = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIyLjEuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IuWbvuWxgl8yXzFfIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiCgkgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDgwIDI0MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDgwIDI0MDsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzNfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfN18pO30KCS5zdDJ7ZmlsbDojQzRDNkNDO30KCS5zdDN7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF85Xyk7fQoJLnN0NHtmaWxsOnVybCgj5b2i54q257uT5ZCIXzEwXyk7ZmlsbC1vcGFjaXR5OjAuNjt9Cgkuc3Q1e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTFfKTt9Cgkuc3Q2e2ZpbGw6dXJsKCPot6/lvoQtM18xXyk7fQoJLnN0N3tmaWxsOnVybCgj5b2i54q257uT5ZCIXzEyXyk7fQoJLnN0OHtmaWxsOnVybCgj6Lev5b6ELTNfNF8pO30KCS5zdDl7ZmlsbDp1cmwoI+W9oueKtue7k+WQiF8xM18pO30KCS5zdDEwe2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTVfKTt9Cgkuc3QxMXtmaWxsOiM5NzlCQTU7fQoJLnN0MTJ7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3QxM3tmaWxsOnVybCgjU1ZHSURfMl8pO30KCS5zdDE0e2ZpbGw6dXJsKCPlvaLnirbnu5PlkIhfMTZfKTt9Cgkuc3QxNXtmaWxsOnVybCgj5b2i54q257uT5ZCI5aSH5Lu9LTJfMl8pO30KCS5zdDE2e2ZpbGw6IzM0MzQzNDtmaWxsLW9wYWNpdHk6MC4xO30KPC9zdHlsZT4KPGcgaWQ9Iumhtemdoi0xIj4KCTxnIGlkPSJFeGNlcHRpb25feDJGX+W8guW4uOaPkOekul94MkZf54Gw55m95a+55q+UIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtOTI0LjAwMDAwMCwgLTcwNy4wMDAwMDApIj4KCQk8ZyBpZD0i6ZyA6KaB55m75b2VIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5MjQuMDAwMDAwLCA3MDcuMDAwMDAwKSI+CgoJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfM18iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTAxOS45MDA2IiB5MT0iLTguMzM1NCIgeDI9IjEwMTkuOTAwNiIgeTI9Ii03LjMzNjciIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMjAwLjAyNTcgMCAwIDU4LjMwNDcgLTIwMzc1OS41NDY5IDY2My45OTQ0KSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRjVGNkY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRjdGOUZDIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMzBfIiBjbGFzcz0ic3QwIiBkPSJNMjQ5LjYsMTc4djguN2MwLDIuNSwyLjEsNC42LDQuNiw0LjZzNC41LDEuOSw0LjYsNC40djAuMnYwLjkKCQkJCWMxLjEtMC41LDIuMy0wLjgsMy41LTAuOGM0LjMsMCw3LjgsMy4yLDguNCw3LjNjMS0wLjgsMi4yLTEuMywzLjYtMS4zYzEuMiwwLDIuMywwLjQsMy4yLDFjMi4zLTQuMiw2LjctNywxMS44LTcKCQkJCWM3LjIsMCwxMyw1LjYsMTMuNSwxMi43YzQuOSwwLjcsMTAuMSwxLjUsMTMuMywyLjFjNy4yLDEuNSwxMS44LDMsMTMuNCwzczQtMi4xLDE0LjUtMS4xYzAuMiwwLjQtMi4zLDAuNS00LjcsMS43cy00LDEuMS00LDEuNAoJCQkJczEuMy0wLjQsNCwxLjNzNy41LDIuMyw3LjUsMi44cy02LjEsMi40LTE2LjItMC44Yy0yLjYtMC44LTguNiw2LjItMzYuMSw4LjJjLTI3LjYsMi03NC4yLDMuNS03NC4yLDMuNXMyLjgsMy42LDYuOSw0LjYKCQkJCWMwLjIsMC40LTEuNiwxLjctOS42LDAuMmMtNy45LTEuNS0xMi4yLTQuOC0xMi4yLTQuOHMtMTUuNy0xLTIxLjYtMmMtNS45LTEtMTIuNy0zLjUtMTcuNC00cy0yNS45LTMtMTcuOC04LjUKCQkJCWMwLDAsNy4yLTQuMiwyMy42LTguM2MyLTMuNSw1LjctNS45LDEwLjEtNS45YzIuNywwLDUuMiwwLjksNy4xLDIuNWMxLjQtMC4yLDIuOS0wLjQsNC40LTAuNmMxLjItMS4xLDIuOC0xLjgsNC41LTEuOAoJCQkJYzEuMiwwLDIuMywwLjMsMy4yLDAuOWwwLjUtMC4xYzEtMy45LDQuNS02LjgsOC43LTYuOGMyLjgsMCw1LjQsMS4zLDcsMy4zdi0yLjhjMC0yLjksMi40LTUuMyw1LjMtNS4zYzIuOCwwLDUuMi0yLjIsNS4zLTUuMQoJCQkJdi0wLjJ2LThMMjQ5LjYsMTc4TDI0OS42LDE3OHoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF83XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMDAzLjIzODQiIHkxPSItNDMuNjgxOCIgeDI9IjEwMDMuOTQ2MSIgeTI9Ii00My42ODE4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQ0IDAgMCAxMSAtNDM5MTkuMTk5MiA2NTUuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UyRTNFNiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRUNFRUYwIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFNEU2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjlfIiBjbGFzcz0ic3QxIiBkPSJNMjE2LjgsMTY5LjVoNDR2NmMwLDIuOC05LjgsNS0yMiw1cy0yMi0yLjItMjItNWwwLDBMMjE2LjgsMTY5LjVMMjE2LjgsMTY5LjV6Ii8+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku71fMV8iIGNsYXNzPSJzdDIiIGQ9Ik0yMTYuOCwxNjVoNDR2NmMwLDIuOC05LjgsNS0yMiw1cy0yMi0yLjItMjItNWwwLDBMMjE2LjgsMTY1TDIxNi44LDE2NXoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF85XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NDcuNDg4OCIgeTE9Ii04LjM4NDgiIHgyPSI5NDguMTg2MyIgeTI9Ii04LjM4NDgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTIgMCAwIDU0LjcgLTExMTc3LjIwMDIgNTgxLjI5OTEpIj4KCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMUYzRjUiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjAuNDU3NiIgc3R5bGU9InN0b3AtY29sb3I6I0Y0RjVGNyIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0VDRUVGMCIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzI4XyIgY2xhc3M9InN0MyIgZD0iTTE5Ni44LDk1LjNjMS44LDAsNiw4LjMsNiwxMS43bDAsMHY0M2gtMTJ2LTQzdi0wLjJDMTkwLjksMTAzLjQsMTk1LDk1LjMsMTk2LjgsOTUuMwoJCQkJeiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzEwXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NDcuODQ2NCIgeTE9Ii0xOS44MjgyIiB4Mj0iOTQ3LjgyNyIgeTI9Ii0xOS42NDE4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEyIDAgMCAyNC4yIC0xMTA5My4yMDAyIDYwMi45OTkzKSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0REMEQyO3N0b3Atb3BhY2l0eTowIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQ0REMEQyIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwb2x5Z29uIGlkPSLlvaLnirbnu5PlkIhfMjZfIiBjbGFzcz0ic3Q0IiBwb2ludHM9IjI3NC44LDExNyAyNzQuOCwxMzIuNiAyNzkuNywxNDEuMiAyODYuOCwxMzUuNCAyODYuOCwxMjYgCQkJIi8+CgoJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLlvaLnirbnu5PlkIhfMTFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9Ijk0OC4xNzE2IiB5MT0iLTguMzg0OCIgeDI9Ijk0Ny40NzQxIiB5Mj0iLTguMzg0OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxMiAwIDAgNTQuNyAtMTEwOTMuMjAwMiA1ODEuMjk5MSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0YxRjNGNSIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTc2IiBzdHlsZT0ic3RvcC1jb2xvcjojRjRGNUY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUNFRUYwIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjVfIiBjbGFzcz0ic3Q1IiBkPSJNMjgwLjgsOTUuM2MtMS44LDAtNiw4LjMtNiwxMS43bDAsMHY0M2gxMnYtNDN2LTAuMgoJCQkJQzI4Ni42LDEwMy40LDI4Mi41LDk1LjMsMjgwLjgsOTUuM3oiLz4KCQkJPGcgaWQ9Iue8lue7hF8zXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODAuNzYwNDk5LCA3Ny4wMDAwMDApIj4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM18xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI1MTQuMzE0MSIgeTE9Ii02Ljg5MDUiIHgyPSI1MTQuMzk0MyIgeTI9Ii02LjUyMDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMzYgMCAwIDY2IC0xODM5NS43MzI0IDUwNikiPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNFOEU5RUIiLz4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRDdEOERCIi8+CgkJCQk8L2xpbmVhckdyYWRpZW50PgoJCQkJPHBhdGggaWQ9Iui3r+W+hC0zXzNfIiBjbGFzcz0ic3Q2IiBkPSJNMTM1LDIwYy0xLjQsNy00LjUsMTMuMy05LjQsMTkuMWMtNy4zLDguNy0xNS4yLDEzLjYtMTguNCwyMy44CgkJCQkJYy0yLjEsNi44LTMuMiwxMi45LTMuMiwxOC4zbDMyLjEsNC44bDMuOS00LjhMMTM1LDIweiIvPgoKCQkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8xMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNDY5LjEyNSIgeTE9Ii02Ljk4IiB4Mj0iNDY5LjEyNjMiIHkyPSItNi45NjgxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEzIDAgMCA2NC41IC01OTY1LjY4MTYgNTA3LjUpIj4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRUJFREVGO3N0b3Atb3BhY2l0eTowIi8+CgkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0M4Q0FDQyIvPgoJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMjRfIiBjbGFzcz0ic3Q3IiBkPSJNMTM1LjIsMjEuNWw0LjgsNTkuN2wtMy45LDQuOGwtOS4xLTEuNGwzLjMtNTIuMmMyLTMuNSwzLjQtNy4xLDQuNC0xMC45CgkJCQkJQzEzNC43LDIxLjUsMTM1LjIsMjEuNSwxMzUuMiwyMS41eiIvPgoJCQk8L2c+CgoJCQkJPGcgaWQ9Iue8lue7hF8yXyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTcxLjAwMDAwMCwgMTEwLjAwMDAwMCkgc2NhbGUoLTEsIDEpIHRyYW5zbGF0ZSgtMTcxLjAwMDAwMCwgLTExMC4wMDAwMDApIHRyYW5zbGF0ZSgxNTMuMDAwMDAwLCA3Ny4wMDAwMDApIj4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSLot6/lvoQtM180XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIyNi4xMTk1IiB5MT0iLTYuNzUwNiIgeDI9IjI2LjE5OTgiIHkyPSItNi4zODA1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDM2IDAgMCA2NiAtMTAyNCA1MDYpIj4KCQkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRThFOUVCIi8+CgkJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0Q3RDhEQiIvPgoJCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJCTxwYXRoIGlkPSLot6/lvoQtM18yXyIgY2xhc3M9InN0OCIgZD0iTS03MywyMGMtMS40LDctNC41LDEzLjMtOS40LDE5LjFjLTcuMyw4LjctMTUuMiwxMy42LTE4LjQsMjMuOAoJCQkJCWMtMi4xLDYuOC0zLjIsMTIuOS0zLjIsMTguM2wzMi4xLDQuOGwzLjktNC44TC03MywyMHoiLz4KCQkJPC9nPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzEzXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2NTkuNjQ1MyIgeTE9Ii02Ljk4IiB4Mj0iNjU5LjY0NjUiIHkyPSItNi45NjgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTEzIDAgMCA2NC41IDg4MzkuMjE0OCA1ODQuNSkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VCRURFRjtzdG9wLW9wYWNpdHk6MCIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0M4Q0FDQyIvPgoJCQk8L2xpbmVhckdyYWRpZW50PgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzJfIiBjbGFzcz0ic3Q5IiBkPSJNMjYxLjYsOTguNWwtNC44LDU5LjdsMy45LDQuOGw5LjEtMS40bC0zLjMtNTIuMmMtMi0zLjUtMy40LTcuMS00LjQtMTAuOQoJCQkJQzI2Mi4xLDk4LjUsMjYxLjYsOTguNSwyNjEuNiw5OC41eiIvPgoKCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0i5b2i54q257uT5ZCIXzE1XyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMDA0Ljk4MTEiIHkxPSItMi42NTU4IiB4Mj0iMTAwNS42ODg3IiB5Mj0iLTIuNjU1OCIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0OCAwIDAgMTU0IC00ODAxNy4xOTkyIDUwNikiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0VBRUJFRCIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NTQzIiBzdHlsZT0ic3RvcC1jb2xvcjojRjRGNUY3Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRUVGMEYyIi8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMThfIiBjbGFzcz0ic3QxMCIgZD0iTTIzOC44LDIwYzcsMCwyNCwyNy43LDI0LDQxbDAsMHYxMDZjMCwwLjEsMCwwLjIsMCwwLjNzMCwwLjIsMCwwLjIKCQkJCWMwLDMuNi0xMC43LDYuNS0yNCw2LjVzLTI0LTIuOS0yNC02LjVjMC0wLjEsMC0wLjIsMC0wLjJjMC0wLjEsMC0wLjIsMC0wLjNWNjF2LTAuNEMyMTUuMSw0Ny4yLDIzMS44LDIwLDIzOC44LDIweiIvPgoJCQk8Zz4KCQkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol83XyIgY2xhc3M9InN0MTEiIGN4PSIyMzguOCIgY3k9IjcxIiByPSI5LjUiLz4KCgkJCQkJPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI5NzYuMDc5IiB5MT0iLTI1LjMzMzQiIHgyPSI5NzYuMDc5IiB5Mj0iLTI0LjgyNDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTkgMCAwIDE5IC0xODMwNi42OTkyIDU0Ny41KSI+CgkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQk8cGF0aCBjbGFzcz0ic3QxMiIgZD0iTTIzOC44LDgxYy01LjUsMC0xMC00LjUtMTAtMTBzNC41LTEwLDEwLTEwczEwLDQuNSwxMCwxMFMyNDQuMyw4MSwyMzguOCw4MXogTTIzOC44LDYyYy01LDAtOSw0LTksOQoJCQkJCXM0LDksOSw5czktNCw5LTlTMjQzLjgsNjIsMjM4LjgsNjJ6Ii8+CgkJCTwvZz4KCQkJPGc+CgkJCQk8Y2lyY2xlIGlkPSLmpK3lnIblvaLlpIfku70tMTFfMV8iIGNsYXNzPSJzdDExIiBjeD0iMjM4LjgiIGN5PSI4OSIgcj0iMy41Ii8+CgoJCQkJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iODkzLjA3MTUiIHkxPSItNjkuMjA0OCIgeDI9Ijg5My4wNzE1IiB5Mj0iLTY4LjY1MjIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNyAwIDAgNyAtNjAxMi43MDAyIDU3MS41KSI+CgkJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UxRTJFNiIvPgoJCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGMEYyRjUiLz4KCQkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCQk8cGF0aCBjbGFzcz0ic3QxMyIgZD0iTTIzOC44LDkzYy0yLjIsMC00LTEuOC00LTRzMS44LTQsNC00czQsMS44LDQsNFMyNDEsOTMsMjM4LjgsOTN6IE0yMzguOCw4NmMtMS43LDAtMywxLjMtMywzczEuMywzLDMsMwoJCQkJCXMzLTEuMywzLTNTMjQwLjUsODYsMjM4LjgsODZ6Ii8+CgkJCTwvZz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiF8xNl8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTAwNC45ODExIiB5MT0iLTcwLjk3MDYiIHgyPSIxMDA1LjY4NTQiIHkyPSItNzAuOTcwNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0OCAwIDAgNi44IC00ODAxNy4xOTkyIDYyNC4wMDA0KSI+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFM0U2Ii8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIwLjQ3NjYiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQkZERkYiLz4KCQkJCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNFMkU0RTYiLz4KCQkJPC9saW5lYXJHcmFkaWVudD4KCQkJPHBhdGggaWQ9IuW9oueKtue7k+WQiF8xNF8iIGNsYXNzPSJzdDE0IiBkPSJNMjYyLjgsMTM4djIuNWMtMy45LDIuNS0xMy4yLDQuMy0yNCw0LjNzLTIwLjEtMS44LTI0LTQuM1YxMzhsMCwwCgkJCQljMC42LDIuOCwxMS4xLDUuNSwyNCw1LjVTMjYyLjIsMTQwLjgsMjYyLjgsMTM4TDI2Mi44LDEzOHoiLz4KCgkJCQk8bGluZWFyR3JhZGllbnQgaWQ9IuW9oueKtue7k+WQiOWkh+S7vS0yXzJfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEwMDQuOTgxMSIgeTE9Ii03MC45NzA2IiB4Mj0iMTAwNS42ODU0IiB5Mj0iLTcwLjk3MDYiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoNDggMCAwIDYuOCAtNDgwMTcuMTk5MiA2MjkuMDAwNCkiPgoJCQkJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0UyRTNFNiIvPgoJCQkJPHN0b3AgIG9mZnNldD0iMC40NzY2IiBzdHlsZT0ic3RvcC1jb2xvcjojRkJGREZGIi8+CgkJCQk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRTJFNEU2Ii8+CgkJCTwvbGluZWFyR3JhZGllbnQ+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIjlpIfku70tMl8xXyIgY2xhc3M9InN0MTUiIGQ9Ik0yNjIuOCwxNDN2Mi41Yy0zLjksMi41LTEzLjIsNC4zLTI0LDQuM3MtMjAuMS0xLjgtMjQtNC4zVjE0M2wwLDAKCQkJCWMwLjYsMi44LDExLjEsNS41LDI0LDUuNVMyNjIuMiwxNDUuOCwyNjIuOCwxNDNMMjYyLjgsMTQzeiIvPgoJCQk8cGF0aCBpZD0i5b2i54q257uT5ZCIXzhfIiBjbGFzcz0ic3QxNiIgZD0iTTI2Mi44LDczYzQzLjItOC42LDc3LjEtNi4zLDgwLjksNi43YzQuNiwxNS45LTM3LjQsNDEuOS05My42LDU4LjEKCQkJCXMtMTA1LjYsMTYuMy0xMTAuMiwwLjRjLTQtMTQuMSwyOC40LTM2LjEsNzQuOS01Mi4xdjEuMWMtNDUuOCwxNS45LTc3LjcsMzcuNS03My45LDUwLjhjNC4zLDE1LjEsNTMuMiwxNC45LDEwOC45LTEuMQoJCQkJczk3LjMtNDEuNyw5Mi45LTU2LjhjLTMuNS0xMi40LTM3LjItMTQuNS03OS45LTZWNzNMMjYyLjgsNzN6Ii8+CgkJCTxwYXRoIGlkPSLlvaLnirbnu5PlkIhfMV8iIGNsYXNzPSJzdDE2IiBkPSJNMTA1LjIsNzZjMy44LTE0LDUwLjctMTQsMTA5LjUtMS4xdjFjLTU4LjMtMTIuOC0xMDUtMTIuOS0xMDguNiwwLjMKCQkJCWMtNCwxNS4xLDQ5LjEsNDMuMiwxMTguNSw2MS44czEyOS41LDIwLjksMTMzLjYsNS44YzMuNi0xMy40LTM3LjctMzctOTUuNi01NS4xdi0xLjFjNTguNiwxOC4zLDEwMC4zLDQyLjIsOTYuNSw1Ni40CgkJCQljLTQuMywxNi02NC42LDEzLjctMTM0LjgtNS4xUzEwMSw5MiwxMDUuMiw3NnoiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzZfIiBjbGFzcz0ic3QyIiBjeD0iMzE3LjgiIGN5PSIxMDkiIHI9IjIiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzVfIiBjbGFzcz0ic3QyIiBjeD0iMTE3LjMiIGN5PSIxMjEuNSIgcj0iMS41Ii8+CgkJCTxjaXJjbGUgaWQ9IuakreWchuW9ol80XyIgY2xhc3M9InN0MiIgY3g9IjI4MS44IiBjeT0iNTgiIHI9IjEiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzNfIiBjbGFzcz0ic3QyIiBjeD0iMTkxLjgiIGN5PSIxNjQiIHI9IjEiLz4KCQkJPGNpcmNsZSBpZD0i5qSt5ZyG5b2iXzFfIiBjbGFzcz0ic3QyIiBjeD0iMzUxLjgiIGN5PSIxNTAiIHI9IjIiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPC9zdmc+Cg=='; var login = img$7.src;

  var script$x = {
    name: 'bk-exception',
    mixins: [locale.mixin],
    props: {
      type: {
        type: [String, Number],
        default: 404,
        validator: function validator(value) {
          return ['404', '403', '500', 'building', 'empty', 'search-empty', 'login'].indexOf(value + '') > -1;
        }
      },
      scene: {
        type: String,
        default: 'page',
        valudator: function valudator(value) {
          return ['page', 'part'].indexOf(value) > -1;
        }
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        images: {
          403: permissions,
          404: notFound,
          500: maintain,
          building: Building,
          empty: empty,
          'search-empty': searchEmpty,
          login: login
        },
        tipText: {}
      };
    },
    created: function created() {
      this.tipText = _extends({}, {
        403: this.t('bk.exception.403'),
        404: this.t('bk.exception.404'),
        500: this.t('bk.exception.500'),
        building: this.t('bk.exception.building'),
        empty: this.t('bk.exception.empty'),
        'search-empty': this.t('bk.exception.searchEmpty'),
        login: this.t('bk.exception.login')
      });
    }
  };

  /* script */
  var __vue_script__$x = script$x;
  /* template */

  var __vue_render__$x = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-exception",
      class: _vm.extCls
    }, [_c('div', {
      staticClass: "bk-exception-img",
      class: _vm.scene + '-img'
    }, [_c('img', {
      staticClass: "exception-image",
      attrs: {
        "src": _vm.images[_vm.type],
        "alt": _vm.type
      }
    })]), _c('div', {
      staticClass: "bk-exception-text",
      class: _vm.scene + '-text'
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.tipText[_vm.type]))])], 2)]);
  };

  var __vue_staticRenderFns__$x = [];
  /* style */

  var __vue_inject_styles__$x = undefined;
  /* scoped */

  var __vue_scope_id__$x = undefined;
  /* module identifier */

  var __vue_module_identifier__$x = undefined;
  /* functional template */

  var __vue_is_functional_template__$x = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$x = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$x,
    staticRenderFns: __vue_staticRenderFns__$x
  }, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$x);

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');
  _iterators.Arguments = _iterators.Array;

  var TO_STRING_TAG = _wks('toStringTag');
  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');
  for (var i$1 = 0; i$1 < DOMIterables.length; i$1++) {
    var NAME = DOMIterables[i$1];
    var Collection = _global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };

  var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  });

  var SPECIES = _wks('species');
  var _speciesConstructor = function (O, D) {
    var C = _anObject(O).constructor;
    var S;
    return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
  };

  var _invoke = function (fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0: return un ? fn()
                        : fn.call(that);
      case 1: return un ? fn(args[0])
                        : fn.call(that, args[0]);
      case 2: return un ? fn(args[0], args[1])
                        : fn.call(that, args[0], args[1]);
      case 3: return un ? fn(args[0], args[1], args[2])
                        : fn.call(that, args[0], args[1], args[2]);
      case 4: return un ? fn(args[0], args[1], args[2], args[3])
                        : fn.call(that, args[0], args[1], args[2], args[3]);
    } return fn.apply(that, args);
  };

  var process = _global.process;
  var setTask = _global.setImmediate;
  var clearTask = _global.clearImmediate;
  var MessageChannel = _global.MessageChannel;
  var Dispatch = _global.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;
  var run = function () {
    var id = +this;
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };
  var listener = function (event) {
    run.call(event.data);
  };
  if (!setTask || !clearTask) {
    setTask = function setImmediate(fn) {
      var args = [];
      var i = 1;
      while (arguments.length > i) args.push(arguments[i++]);
      queue[++counter] = function () {
        _invoke(typeof fn == 'function' ? fn : Function(fn), args);
      };
      defer(counter);
      return counter;
    };
    clearTask = function clearImmediate(id) {
      delete queue[id];
    };
    if (_cof(process) == 'process') {
      defer = function (id) {
        process.nextTick(_ctx(run, id, 1));
      };
    } else if (Dispatch && Dispatch.now) {
      defer = function (id) {
        Dispatch.now(_ctx(run, id, 1));
      };
    } else if (MessageChannel) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = _ctx(port.postMessage, port, 1);
    } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
      defer = function (id) {
        _global.postMessage(id + '', '*');
      };
      _global.addEventListener('message', listener, false);
    } else if (ONREADYSTATECHANGE in _domCreate('script')) {
      defer = function (id) {
        _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
          _html.removeChild(this);
          run.call(id);
        };
      };
    } else {
      defer = function (id) {
        setTimeout(_ctx(run, id, 1), 0);
      };
    }
  }
  var _task = {
    set: setTask,
    clear: clearTask
  };

  var macrotask = _task.set;
  var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
  var process$1 = _global.process;
  var Promise$1 = _global.Promise;
  var isNode = _cof(process$1) == 'process';
  var _microtask = function () {
    var head, last, notify;
    var flush = function () {
      var parent, fn;
      if (isNode && (parent = process$1.domain)) parent.exit();
      while (head) {
        fn = head.fn;
        head = head.next;
        try {
          fn();
        } catch (e) {
          if (head) notify();
          else last = undefined;
          throw e;
        }
      } last = undefined;
      if (parent) parent.enter();
    };
    if (isNode) {
      notify = function () {
        process$1.nextTick(flush);
      };
    } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
      var toggle = true;
      var node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = !toggle;
      };
    } else if (Promise$1 && Promise$1.resolve) {
      var promise = Promise$1.resolve(undefined);
      notify = function () {
        promise.then(flush);
      };
    } else {
      notify = function () {
        macrotask.call(_global, flush);
      };
    }
    return function (fn) {
      var task = { fn: fn, next: undefined };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      } last = task;
    };
  };

  function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = _aFunction(resolve);
    this.reject = _aFunction(reject);
  }
  var f$7 = function (C) {
    return new PromiseCapability(C);
  };
  var _newPromiseCapability = {
  	f: f$7
  };

  var _perform = function (exec) {
    try {
      return { e: false, v: exec() };
    } catch (e) {
      return { e: true, v: e };
    }
  };

  var navigator$1 = _global.navigator;
  var _userAgent = navigator$1 && navigator$1.userAgent || '';

  var _promiseResolve = function (C, x) {
    _anObject(C);
    if (_isObject(x) && x.constructor === C) return x;
    var promiseCapability = _newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var _redefineAll = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];
      else _hide(target, key, src[key]);
    } return target;
  };

  var SPECIES$1 = _wks('species');
  var _setSpecies = function (KEY) {
    var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
    if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
      configurable: true,
      get: function () { return this; }
    });
  };

  var task = _task.set;
  var microtask = _microtask();
  var PROMISE = 'Promise';
  var TypeError$1 = _global.TypeError;
  var process$2 = _global.process;
  var versions = process$2 && process$2.versions;
  var v8 = versions && versions.v8 || '';
  var $Promise = _global[PROMISE];
  var isNode$1 = _classof(process$2) == 'process';
  var empty$1 = function () {  };
  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
  var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
  var USE_NATIVE$1 = !!function () {
    try {
      var promise = $Promise.resolve(1);
      var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
        exec(empty$1, empty$1);
      };
      return (isNode$1 || typeof PromiseRejectionEvent == 'function')
        && promise.then(empty$1) instanceof FakePromise
        && v8.indexOf('6.6') !== 0
        && _userAgent.indexOf('Chrome/66') === -1;
    } catch (e) {  }
  }();
  var isThenable = function (it) {
    var then;
    return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };
  var notify = function (promise, isReject) {
    if (promise._n) return;
    promise._n = true;
    var chain = promise._c;
    microtask(function () {
      var value = promise._v;
      var ok = promise._s == 1;
      var i = 0;
      var run = function (reaction) {
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;
        try {
          if (handler) {
            if (!ok) {
              if (promise._h == 2) onHandleUnhandled(promise);
              promise._h = 1;
            }
            if (handler === true) result = value;
            else {
              if (domain) domain.enter();
              result = handler(value);
              if (domain) {
                domain.exit();
                exited = true;
              }
            }
            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (e) {
          if (domain && !exited) domain.exit();
          reject(e);
        }
      };
      while (chain.length > i) run(chain[i++]);
      promise._c = [];
      promise._n = false;
      if (isReject && !promise._h) onUnhandled(promise);
    });
  };
  var onUnhandled = function (promise) {
    task.call(_global, function () {
      var value = promise._v;
      var unhandled = isUnhandled(promise);
      var result, handler, console;
      if (unhandled) {
        result = _perform(function () {
          if (isNode$1) {
            process$2.emit('unhandledRejection', value, promise);
          } else if (handler = _global.onunhandledrejection) {
            handler({ promise: promise, reason: value });
          } else if ((console = _global.console) && console.error) {
            console.error('Unhandled promise rejection', value);
          }
        });
        promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
      } promise._a = undefined;
      if (unhandled && result.e) throw result.v;
    });
  };
  var isUnhandled = function (promise) {
    return promise._h !== 1 && (promise._a || promise._c).length === 0;
  };
  var onHandleUnhandled = function (promise) {
    task.call(_global, function () {
      var handler;
      if (isNode$1) {
        process$2.emit('rejectionHandled', promise);
      } else if (handler = _global.onrejectionhandled) {
        handler({ promise: promise, reason: promise._v });
      }
    });
  };
  var $reject = function (value) {
    var promise = this;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise;
    promise._v = value;
    promise._s = 2;
    if (!promise._a) promise._a = promise._c.slice();
    notify(promise, true);
  };
  var $resolve = function (value) {
    var promise = this;
    var then;
    if (promise._d) return;
    promise._d = true;
    promise = promise._w || promise;
    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      if (then = isThenable(value)) {
        microtask(function () {
          var wrapper = { _w: promise, _d: false };
          try {
            then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
          } catch (e) {
            $reject.call(wrapper, e);
          }
        });
      } else {
        promise._v = value;
        promise._s = 1;
        notify(promise, false);
      }
    } catch (e) {
      $reject.call({ _w: promise, _d: false }, e);
    }
  };
  if (!USE_NATIVE$1) {
    $Promise = function Promise(executor) {
      _anInstance(this, $Promise, PROMISE, '_h');
      _aFunction(executor);
      Internal.call(this);
      try {
        executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
      } catch (err) {
        $reject.call(this, err);
      }
    };
    Internal = function Promise(executor) {
      this._c = [];
      this._a = undefined;
      this._s = 0;
      this._d = false;
      this._v = undefined;
      this._h = 0;
      this._n = false;
    };
    Internal.prototype = _redefineAll($Promise.prototype, {
      then: function then(onFulfilled, onRejected) {
        var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = isNode$1 ? process$2.domain : undefined;
        this._c.push(reaction);
        if (this._a) this._a.push(reaction);
        if (this._s) notify(this, false);
        return reaction.promise;
      },
      'catch': function (onRejected) {
        return this.then(undefined, onRejected);
      }
    });
    OwnPromiseCapability = function () {
      var promise = new Internal();
      this.promise = promise;
      this.resolve = _ctx($resolve, promise, 1);
      this.reject = _ctx($reject, promise, 1);
    };
    _newPromiseCapability.f = newPromiseCapability = function (C) {
      return C === $Promise || C === Wrapper
        ? new OwnPromiseCapability(C)
        : newGenericPromiseCapability(C);
    };
  }
  _export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
  _setToStringTag($Promise, PROMISE);
  _setSpecies(PROMISE);
  Wrapper = _core[PROMISE];
  _export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
    reject: function reject(r) {
      var capability = newPromiseCapability(this);
      var $$reject = capability.reject;
      $$reject(r);
      return capability.promise;
    }
  });
  _export(_export.S + _export.F * (_library ), PROMISE, {
    resolve: function resolve(x) {
      return _promiseResolve( this === Wrapper ? $Promise : this, x);
    }
  });
  _export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
    $Promise.all(iter)['catch'](empty$1);
  })), PROMISE, {
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = _perform(function () {
        var values = [];
        var index = 0;
        var remaining = 1;
        _forOf(iterable, false, function (promise) {
          var $index = index++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          C.resolve(promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[$index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.e) reject(result.v);
      return capability.promise;
    },
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability(C);
      var reject = capability.reject;
      var result = _perform(function () {
        _forOf(iterable, false, function (promise) {
          C.resolve(promise).then(capability.resolve, reject);
        });
      });
      if (result.e) reject(result.v);
      return capability.promise;
    }
  });

  _export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
    var C = _speciesConstructor(this, _core.Promise || _global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return _promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return _promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  } });

  _export(_export.S, 'Promise', { 'try': function (callbackfn) {
    var promiseCapability = _newPromiseCapability.f(this);
    var result = _perform(callbackfn);
    (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
    return promiseCapability.promise;
  } });

  var promise = _core.Promise;

  var promise$1 = promise;

  var script$y = {
    name: 'bk-form',
    props: {
      formType: {
        type: String,
        default: 'horizontal',
        validator: function validator(val) {
          return ['vertical', 'inline', 'horizontal'].indexOf(val) > -1;
        }
      },
      rules: {
        type: Object
      },
      labelWidth: {
        type: Number,
        default: 150
      },
      model: {
        type: Object
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        formItems: []
      };
    },
    computed: {
      formCls: function formCls() {
        var style = ['bk-form'];
        if (this.formType === 'vertical') {
          style.push('bk-form-vertical');
        } else if (this.formType === 'inline') {
          style.push('bk-inline-form');
        }
        return style;
      }
    },
    provide: function provide() {
      return {
        form: this
      };
    },
    created: function created() {
      var _this = this;
      this.$on('form-item-add', function (item) {
        if (item) {
          _this.formItems.push(item);
        }
        return false;
      });
      this.$on('form-item-delete', function (item) {
        var index = _this.formItems.findIndex(function (fromItem) {
          return fromItem.id === item.id;
        });
        if (item && index !== -1) {
          _this.formItems.splice(index, 1);
        }
        return false;
      });
    },
    methods: {
      formSubmit: function formSubmit(e) {
        this.$emit('submit', this.formItems);
        e.preventDefault();
      },
      clearFieldError: function clearFieldError(field) {
        if (!field) {
          return;
        }
        var _iterator = _createForOfIteratorHelper(this.formItems),
            _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var formItem = _step.value;
            if (field === formItem.property) {
              formItem.clearError();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      clearError: function clearError() {
        var _iterator2 = _createForOfIteratorHelper(this.formItems),
            _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var field = _step2.value;
            field.clearError();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      validateField: function validateField(field) {
        if (!field) {
          return promise$1.reject(new Error('field 不能为空'));
        }
        var _iterator3 = _createForOfIteratorHelper(this.formItems),
            _step3;
        try {
          var _loop = function _loop() {
            var formItem = _step3.value;
            if (field === formItem.property) {
              return {
                v: new promise$1(function (resolve, reject) {
                  formItem.validate('', function (validator) {
                    if (validator && validator.state === 'error') {
                      reject(validator);
                    } else {
                      resolve();
                    }
                  });
                })
              };
            }
          };
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _ret = _loop();
            if (_typeof(_ret) === "object") return _ret.v;
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return promise$1.reject(new Error('filed 不存在'));
      },
      validate: function validate(callback) {
        var _this2 = this;
        return new promise$1(function (resolve, reject) {
          var valid = true;
          var count = 0;
          var that = _this2;
          var _iterator4 = _createForOfIteratorHelper(_this2.formItems),
              _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var field = _step4.value;
              field.validate('', function (validator) {
                if (validator && validator.state === 'error') {
                  valid = false;
                  reject(validator);
                  return false;
                }
                if (++count === that.formItems.length) {
                  resolve(valid);
                  if (typeof callback === 'function') {
                    callback(valid);
                  }
                }
              });
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        });
      }
    }
  };

  /* script */
  var __vue_script__$y = script$y;
  /* template */

  var __vue_render__$y = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('form', {
      class: [_vm.formCls, _vm.extCls],
      on: {
        "submit": _vm.formSubmit
      }
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$y = [];
  /* style */

  var __vue_inject_styles__$y = undefined;
  /* scoped */

  var __vue_scope_id__$y = undefined;
  /* module identifier */

  var __vue_module_identifier__$y = undefined;
  /* functional template */

  var __vue_is_functional_template__$y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$y = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$y,
    staticRenderFns: __vue_staticRenderFns__$y
  }, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$y);

  var $assign = Object.assign;
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
      }
    } return T;
  } : $assign;

  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  var assign = _core.Object.assign;

  var assign$1 = assign;

  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers$1 = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration$1 = 0;
  for (var i$2 = 0; i$2 < longerTimeoutBrowsers$1.length; i$2 += 1) {
    if (isBrowser$1 && navigator.userAgent.indexOf(longerTimeoutBrowsers$1[i$2]) >= 0) {
      timeoutDuration$1 = 1;
      break;
    }
  }
  function microtaskDebounce$1(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce$1(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration$1);
      }
    };
  }
  var supportsMicroTasks$1 = isBrowser$1 && window.Promise;
  var debounce$3 = supportsMicroTasks$1 ? microtaskDebounce$1 : taskDebounce$1;
  function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  function getStyleComputedProperty$1(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode$1(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent$1(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty$1(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent$1(getParentNode$1(element));
  }
  var isIE11$1 = isBrowser$1 && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10$1 = isBrowser$1 && /MSIE 10/.test(navigator.userAgent);
  function isIE$1(version) {
    if (version === 11) {
      return isIE11$1;
    }
    if (version === 10) {
      return isIE10$1;
    }
    return isIE11$1 || isIE10$1;
  }
  function getOffsetParent$1(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE$1(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty$1(offsetParent, 'position') === 'static') {
      return getOffsetParent$1(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer$1(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent$1(element.firstElementChild) === element;
  }
  function getRoot$1(node) {
    if (node.parentNode !== null) {
      return getRoot$1(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent$1(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer$1(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent$1(commonAncestorContainer);
    }
    var element1root = getRoot$1(element1);
    if (element1root.host) {
      return findCommonOffsetParent$1(element1root.host, element2);
    } else {
      return findCommonOffsetParent$1(element1, getRoot$1(element2).host);
    }
  }
  function getScroll$1(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll$1(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll$1(element, 'top');
    var scrollLeft = getScroll$1(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize$1(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return _parseFloat$2(styles["border".concat(sideA, "Width")], 10) + _parseFloat$2(styles["border".concat(sideB, "Width")], 10);
  }
  function getSize$1(axis, body, html, computedStyle) {
    return Math.max(body["offset".concat(axis)], body["scroll".concat(axis)], html["client".concat(axis)], html["offset".concat(axis)], html["scroll".concat(axis)], isIE$1(10) ? _parseInt$2(html["offset".concat(axis)]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Top' : 'Left')]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  function getWindowSizes$1(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE$1(10) && getComputedStyle(html);
    return {
      height: getSize$1('Height', body, html, computedStyle),
      width: getSize$1('Width', body, html, computedStyle)
    };
  }
  var _extends$2 = assign$1 || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect$1(offsets) {
    return _extends$2({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect$1(element) {
    var rect = {};
    try {
      if (isIE$1(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll$1(element, 'top');
        var scrollLeft = getScroll$1(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === 'HTML' ? getWindowSizes$1(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty$1(element);
      horizScrollbar -= getBordersSize$1(styles, 'x');
      vertScrollbar -= getBordersSize$1(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect$1(result);
  }
  function getOffsetRectRelativeToArbitraryNode$1(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE$1(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect$1(children);
    var parentRect = getBoundingClientRect$1(parent);
    var scrollParent = getScrollParent$1(children);
    var styles = getStyleComputedProperty$1(parent);
    var borderTopWidth = _parseFloat$2(styles.borderTopWidth, 10);
    var borderLeftWidth = _parseFloat$2(styles.borderLeftWidth, 10);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect$1({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE10 && isHTML) {
      var marginTop = _parseFloat$2(styles.marginTop, 10);
      var marginLeft = _parseFloat$2(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll$1(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode$1(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode$1(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll$1(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll$1(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect$1(offset);
  }
  function isFixed$1(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty$1(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode$1(element);
    if (!parentNode) {
      return false;
    }
    return isFixed$1(parentNode);
  }
  function getFixedPositionOffsetParent$1(element) {
    if (!element || !element.parentElement || isIE$1()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty$1(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries$1(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent$1(popper) : findCommonOffsetParent$1(popper, reference);
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode$1(offsetParent, fixedPosition);
    } else {
      var boundariesNode;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent$1(getParentNode$1(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode$1(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === 'HTML' && !isFixed$1(offsetParent)) {
        var _getWindowSizes = getWindowSizes$1(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea$1(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement$1(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
    var boundaries = getBoundaries$1(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = keys$1(rects).map(function (key) {
      return _extends$2({
        key: key
      }, rects[key], {
        area: getArea$1(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? "-".concat(variation) : '');
  }
  function getReferenceOffsets$1(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent$1(popper) : findCommonOffsetParent$1(popper, reference);
    return getOffsetRectRelativeToArbitraryNode$1(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes$1(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = _parseFloat$2(styles.marginTop || 0) + _parseFloat$2(styles.marginBottom || 0);
    var y = _parseFloat$2(styles.marginLeft || 0) + _parseFloat$2(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement$1(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets$1(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
    var popperRect = getOuterSizes$1(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement$1(secondarySide)];
    }
    return popperOffsets;
  }
  function find$1(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex$1(arr, prop, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
    var match = find$1(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers$1(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn;
      if (modifier.enabled && isFunction$1(fn)) {
        data.offsets.popper = getClientRect$1(data.offsets.popper);
        data.offsets.reference = getClientRect$1(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function _update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets$1(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement$1(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets$1(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
    data = runModifiers$1(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled$1(modifiers, modifierName) {
    return modifiers.some(function (_ref3) {
      var name = _ref3.name,
          enabled = _ref3.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName$1(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var _i = 0; _i < prefixes.length; _i++) {
      var prefix = prefixes[_i];
      var toCheck = prefix ? "".concat(prefix).concat(upperProp) : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  function _destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled$1(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName$1('transform')] = '';
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow$1(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents$1(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });
    if (!isBody) {
      attachToScrollParents$1(getScrollParent$1(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners$1(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow$1(reference).addEventListener('resize', state.updateBound, {
      passive: true
    });
    var scrollElement = getScrollParent$1(reference);
    attachToScrollParents$1(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function _enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners$1(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners$1(reference, state) {
    getWindow$1(reference).removeEventListener('resize', state.updateBound);
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function _disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners$1(this.reference, this.state);
    }
  }
  function isNumeric$1(n) {
    return n !== '' && !isNaN(_parseFloat$2(n)) && isFinite(n);
  }
  function setStyles$1(element, styles) {
    keys$1(styles).forEach(function (prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric$1(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  function setAttributes$1(element, attributes) {
    keys$1(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  function applyStyle$1(data) {
    setStyles$1(data.instance.popper, data.styles);
    setAttributes$1(data.instance.popper, data.attributes);
    if (data.arrowElement && keys$1(data.arrowStyles).length) {
      setStyles$1(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad$1(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets$1(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement$1(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement);
    setStyles$1(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  function getRoundedOffsets$1(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox$1 = isBrowser$1 && /Firefox/i.test(navigator.userAgent);
  function computeStyle$1(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent$1(data.instance.popper);
    var offsetParentRect = getBoundingClientRect$1(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets$1(data, window.devicePixelRatio < 2 || !isFirefox$1);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
    var prefixedProperty = getSupportedPropertyName$1('transform');
    var left, top;
    if (sideA === 'bottom') {
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = "translate3d(".concat(left, "px, ").concat(top, "px, 0)");
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = "".concat(sideA, ", ").concat(sideB);
    }
    var attributes = {
      'x-placement': data.placement
    };
    data.attributes = _extends$2({}, attributes, data.attributes);
    data.styles = _extends$2({}, styles, data.styles);
    data.arrowStyles = _extends$2({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired$1(modifiers, requestingName, requestedName) {
    var requesting = find$1(modifiers, function (_ref4) {
      var name = _ref4.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = "`".concat(requestingName, "`");
      var requested = "`".concat(requestedName, "`");
      console.warn("".concat(requested, " modifier is required by ").concat(_requesting, " modifier in order to work, be sure to include it before ").concat(_requesting, "!"));
    }
    return isRequired;
  }
  function arrow$1(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired$1(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
    var placement = data.placement.split('-')[0];
    var _data$offsets2 = data.offsets,
        popper = _data$offsets2.popper,
        reference = _data$offsets2.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes$1(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect$1(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty$1(data.instance.popper);
    var popperMarginSide = _parseFloat$2(css["margin".concat(sideCapitalized)], 10);
    var popperBorderSide = _parseFloat$2(css["border".concat(sideCapitalized, "Width")], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation$1(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  var placements$1 = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var validPlacements$1 = placements$1.slice(3);
  function clockwise$1(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements$1.indexOf(placement);
    var arr = validPlacements$1.slice(index + 1).concat(validPlacements$1.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS$1 = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  function flip$1(data, options) {
    if (isModifierEnabled$1(data.instance.modifiers, 'inner')) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries$1(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement$1(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS$1.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS$1.CLOCKWISE:
        flipOrder = clockwise$1(placement);
        break;
      case BEHAVIORS$1.COUNTERCLOCKWISE:
        flipOrder = clockwise$1(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement$1(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation$1(variation);
        }
        data.placement = placement + (variation ? '-' + variation : '');
        data.offsets.popper = _extends$2({}, data.offsets.popper, getPopperOffsets$1(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers$1(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  function keepTogether$1(data) {
    var _data$offsets3 = data.offsets,
        popper = _data$offsets3.popper,
        reference = _data$offsets3.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue$1(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf('%') === 0) {
      var element;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect$1(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      var size;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset$1(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find$1(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function (op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      .map(function (str) {
        return toValue$1(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric$1(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset$1(data, _ref5) {
    var offset = _ref5.offset;
    var placement = data.placement,
        _data$offsets4 = data.offsets,
        popper = _data$offsets4.popper,
        reference = _data$offsets4.reference;
    var basePlacement = placement.split('-')[0];
    var offsets;
    if (isNumeric$1(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset$1(offset, popper, reference, basePlacement);
    }
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow$1(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent$1(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent$1(boundariesElement);
    }
    var transformProp = getSupportedPropertyName$1('transform');
    var popperStyles = data.instance.popper.style;
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries$1(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return _defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return _defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$2({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift$1(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
    if (shiftvariation) {
      var _data$offsets5 = data.offsets,
          reference = _data$offsets5.reference,
          popper = _data$offsets5.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: _defineProperty({}, side, reference[side]),
        end: _defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$2({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide$1(data) {
    if (!isModifierRequired$1(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find$1(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
    return data;
  }
  function inner$1(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets6 = data.offsets,
        popper = _data$offsets6.popper,
        reference = _data$offsets6.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement$1(placement);
    data.offsets.popper = getClientRect$1(popper);
    return data;
  }
  var modifiers$1 = {
    shift: {
      order: 100,
      enabled: true,
      fn: shift$1
    },
    offset: {
      order: 200,
      enabled: true,
      fn: offset$1,
      offset: 0
    },
    preventOverflow: {
      order: 300,
      enabled: true,
      fn: preventOverflow$1,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: {
      order: 400,
      enabled: true,
      fn: keepTogether$1
    },
    arrow: {
      order: 500,
      enabled: true,
      fn: arrow$1,
      element: '[x-arrow]'
    },
    flip: {
      order: 600,
      enabled: true,
      fn: flip$1,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: false,
      flipVariationsByContent: false
    },
    inner: {
      order: 700,
      enabled: false,
      fn: inner$1
    },
    hide: {
      order: 800,
      enabled: true,
      fn: hide$1
    },
    computeStyle: {
      order: 850,
      enabled: true,
      fn: computeStyle$1,
      gpuAcceleration: true,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: true,
      fn: applyStyle$1,
      onLoad: applyStyleOnLoad$1,
      gpuAcceleration: undefined
    }
  };
  var Defaults$1 = {
    placement: 'bottom',
    positionFixed: false,
    eventsEnabled: true,
    removeOnDestroy: false,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: modifiers$1
  };
  var Popper$1 = function () {
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce$3(this.update.bind(this));
      this.options = _extends$2({}, Popper.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      keys$1(_extends$2({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$2({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = keys$1(this.options.modifiers).map(function (name) {
        return _extends$2({
          name: name
        }, _this.options.modifiers[name]);
      })
      .sort(function (a, b) {
        return a.order - b.order;
      });
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    _createClass(Popper, [{
      key: "update",
      value: function update() {
        return _update.call(this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        return _destroy.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function enableEventListeners() {
        return _enableEventListeners.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function disableEventListeners() {
        return _disableEventListeners.call(this);
      }
    }]);
    return Popper;
  }();
  Popper$1.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper$1.placements = placements$1;
  Popper$1.Defaults = Defaults$1;

  function _extends$3() {
    _extends$3 = assign$1 || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  var version$1 = "4.3.4";
  var isBrowser$2 = typeof window !== 'undefined' && typeof document !== 'undefined';
  var ua = isBrowser$2 ? navigator.userAgent : '';
  var isIE$2 = /MSIE |Trident\//.test(ua);
  var isUCBrowser = /UCBrowser\//.test(ua);
  var isIOS = isBrowser$2 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
  var defaultProps = {
    a11y: true,
    allowHTML: true,
    animateFill: true,
    animation: 'shift-away',
    appendTo: function appendTo() {
      return document.body;
    },
    aria: 'describedby',
    arrow: false,
    arrowType: 'sharp',
    boundary: 'scrollParent',
    content: '',
    delay: 0,
    distance: 10,
    duration: [325, 275],
    flip: true,
    flipBehavior: 'flip',
    flipOnUpdate: false,
    followCursor: false,
    hideOnClick: true,
    ignoreAttributes: false,
    inertia: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    lazy: true,
    width: 'auto',
    maxWidth: 'auto',
    multiple: false,
    offset: 0,
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    placement: 'top',
    popperOptions: {},
    role: 'tooltip',
    showOnInit: false,
    size: 'regular',
    sticky: false,
    target: '',
    theme: 'dark',
    touch: true,
    touchHold: false,
    trigger: 'mouseenter focus',
    triggerTarget: null,
    updateDuration: 0,
    wait: null,
    zIndex: 9999,
    extCls: ''
  };
  var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
  var elementProto = isBrowser$2 ? Element.prototype : {};
  var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function closest(element, selector) {
    return closestCallback(element, function (el) {
      return matches.call(el, selector);
    });
  }
  function closestCallback(element, callback) {
    while (element) {
      if (callback(element)) {
        return element;
      }
      element = element.parentElement;
    }
    return null;
  }
  var PASSIVE = {
    passive: true
  };
  var PADDING = 4;
  var PLACEMENT_ATTRIBUTE = 'x-placement';
  var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries';
  var IOS_CLASS = "tippy-iOS";
  var ACTIVE_CLASS = "tippy-active";
  var POPPER_CLASS = "tippy-popper";
  var TOOLTIP_CLASS = "tippy-tooltip";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var ROUND_ARROW_CLASS = "tippy-roundarrow";
  var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
  var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
  var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
  var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
  var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
  var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
  var isUsingTouch = false;
  function onDocumentTouch() {
    if (isUsingTouch) {
      return;
    }
    isUsingTouch = true;
    if (isIOS) {
      document.body.classList.add(IOS_CLASS);
    }
    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  var lastMouseMoveTime = 0;
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      isUsingTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
      if (!isIOS) {
        document.body.classList.remove(IOS_CLASS);
      }
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var _document = document,
        activeElement = _document.activeElement;
    if (activeElement && activeElement.blur && activeElement._tippy) {
      activeElement.blur();
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
    window.addEventListener('blur', onWindowBlur);
  }
  var keys$2 = keys$1(defaultProps);
  function getDataAttributeOptions(reference) {
    return keys$2.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
  }
  function polyfillElementPrototypeProperties(virtualReference) {
    var polyfills = {
      isVirtual: true,
      attributes: virtualReference.attributes || {},
      contains: function contains() {},
      setAttribute: function setAttribute(key, value) {
        virtualReference.attributes[key] = value;
      },
      getAttribute: function getAttribute(key) {
        return virtualReference.attributes[key];
      },
      removeAttribute: function removeAttribute(key) {
        delete virtualReference.attributes[key];
      },
      hasAttribute: function hasAttribute(key) {
        return key in virtualReference.attributes;
      },
      addEventListener: function addEventListener() {},
      removeEventListener: function removeEventListener() {},
      classList: {
        classNames: {},
        add: function add(key) {
          virtualReference.classList.classNames[key] = true;
        },
        remove: function remove(key) {
          delete virtualReference.classList.classNames[key];
        },
        contains: function contains(key) {
          return key in virtualReference.classList.classNames;
        }
      }
    };
    for (var key in polyfills) {
      virtualReference[key] = polyfills[key];
    }
  }
  function isBareVirtualElement(value) {
    return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
  }
  function isReferenceElement(value) {
    return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
  }
  function hasOwnProperty$1(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getArrayOfElements(value) {
    if (isSingular(value)) {
      return [value];
    }
    if (value instanceof NodeList) {
      return arrayFrom(value);
    }
    if (isArray$1(value)) {
      return value;
    }
    try {
      return arrayFrom(document.querySelectorAll(value));
    } catch (e) {
      return [];
    }
  }
  function getValue(value, index, defaultValue) {
    if (isArray$1(value)) {
      var v = value[index];
      return v == null ? defaultValue : v;
    }
    return value;
  }
  function debounce$4(fn, ms) {
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function getModifier(obj, key) {
    return obj && obj.modifiers && obj.modifiers[key];
  }
  function includes(a, b) {
    return a.indexOf(b) > -1;
  }
  function isRealElement(value) {
    return value instanceof Element;
  }
  function isSingular(value) {
    return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);
  }
  function innerHTML() {
    return 'innerHTML';
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(null, args) : value;
  }
  function setFlipModifierEnabled(modifiers, value) {
    modifiers.filter(function (m) {
      return m.name === 'flip';
    })[0].enabled = value;
  }
  function canReceiveFocus(element) {
    return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
  }
  function div() {
    return document.createElement('div');
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = "".concat(value, "ms");
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function evaluateProps(reference, props) {
    var out = _extends$3({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
    if (out.arrow || isUCBrowser) {
      out.animateFill = false;
    }
    return out;
  }
  function validateOptions(options, defaultProps) {
    keys$1(options).forEach(function (option) {
      if (!hasOwnProperty$1(defaultProps, option)) {
        throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
      }
    });
  }
  function setInnerHTML(element, html) {
    element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
  }
  function setContent(contentEl, props) {
    if (isRealElement(props.content)) {
      setInnerHTML(contentEl, '');
      contentEl.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      var key = props.allowHTML ? 'innerHTML' : 'textContent';
      contentEl[key] = props.content;
    }
  }
  function getChildren(popper) {
    return {
      tooltip: popper.querySelector(TOOLTIP_SELECTOR),
      backdrop: popper.querySelector(BACKDROP_SELECTOR),
      content: popper.querySelector(CONTENT_SELECTOR),
      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
    };
  }
  function addInertia(tooltip) {
    tooltip.setAttribute('data-inertia', '');
  }
  function removeInertia(tooltip) {
    tooltip.removeAttribute('data-inertia');
  }
  function createArrowElement(arrowType) {
    var arrow = div();
    if (arrowType === 'round') {
      arrow.className = ROUND_ARROW_CLASS;
      setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
    } else {
      arrow.className = ARROW_CLASS;
    }
    return arrow;
  }
  function createBackdropElement() {
    var backdrop = div();
    backdrop.className = BACKDROP_CLASS;
    backdrop.setAttribute('data-state', 'hidden');
    return backdrop;
  }
  function addInteractive(popper, tooltip) {
    popper.setAttribute('tabindex', '-1');
    tooltip.setAttribute('data-interactive', '');
  }
  function removeInteractive(popper, tooltip) {
    popper.removeAttribute('tabindex');
    tooltip.removeAttribute('data-interactive');
  }
  function updateTransitionEndListener(tooltip, action, listener) {
    var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
    tooltip[action + 'EventListener'](eventName, listener);
  }
  function getBasicPlacement(popper) {
    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
    return fullPlacement ? fullPlacement.split('-')[0] : '';
  }
  function reflow(popper) {
    void popper.offsetHeight;
  }
  function updateTheme(tooltip, action, theme) {
    theme.split(' ').forEach(function (themeName) {
      tooltip.classList[action](themeName + '-theme');
    });
  }
  function setWidth(tooltip, props, key) {
    var width = props[key];
    var parsedWidth = _parseInt$2(width);
    if (typeof width === 'number') {
      tooltip.style[key] = width + 'px';
    } else if (isNaN(parsedWidth)) {
      tooltip.style[key] = width;
    } else {
      tooltip.style[key] = parsedWidth + 'px';
    }
  }
  function createPopperElement(id, props) {
    var popper = div();
    popper.className = POPPER_CLASS + (props.extCls ? " ".concat(props.extCls) : '');
    popper.id = "tippy-".concat(id);
    popper.style.zIndex = '' + props.zIndex;
    popper.style.position = 'absolute';
    popper.style.top = '0';
    popper.style.left = '0';
    if (props.role) {
      popper.setAttribute('role', props.role);
    }
    var tooltip = div();
    tooltip.className = TOOLTIP_CLASS;
    setWidth(tooltip, props, 'maxWidth');
    setWidth(tooltip, props, 'width');
    tooltip.setAttribute('data-size', props.size);
    tooltip.setAttribute('data-animation', props.animation);
    tooltip.setAttribute('data-state', 'hidden');
    updateTheme(tooltip, 'add', props.theme);
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    if (props.interactive) {
      addInteractive(popper, tooltip);
    }
    if (props.arrow) {
      tooltip.appendChild(createArrowElement(props.arrowType));
    }
    if (props.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    }
    if (props.inertia) {
      addInertia(tooltip);
    }
    setContent(content, props);
    tooltip.appendChild(content);
    popper.appendChild(tooltip);
    return popper;
  }
  function updatePopperElement(popper, prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        tooltip = _getChildren.tooltip,
        content = _getChildren.content,
        backdrop = _getChildren.backdrop,
        arrow = _getChildren.arrow;
    popper.style.zIndex = '' + nextProps.zIndex;
    tooltip.setAttribute('data-size', nextProps.size);
    tooltip.setAttribute('data-animation', nextProps.animation);
    tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');
    if (nextProps.role) {
      popper.setAttribute('role', nextProps.role);
    } else {
      popper.removeAttribute('role');
    }
    if (prevProps.content !== nextProps.content) {
      setContent(content, nextProps);
    }
    if (!prevProps.animateFill && nextProps.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    } else if (prevProps.animateFill && !nextProps.animateFill) {
      tooltip.removeChild(backdrop);
      tooltip.removeAttribute('data-animatefill');
    }
    if (!prevProps.arrow && nextProps.arrow) {
      tooltip.appendChild(createArrowElement(nextProps.arrowType));
    } else if (prevProps.arrow && !nextProps.arrow) {
      tooltip.removeChild(arrow);
    }
    if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
      tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
    }
    if (!prevProps.interactive && nextProps.interactive) {
      addInteractive(popper, tooltip);
    } else if (prevProps.interactive && !nextProps.interactive) {
      removeInteractive(popper, tooltip);
    }
    if (!prevProps.inertia && nextProps.inertia) {
      addInertia(tooltip);
    } else if (prevProps.inertia && !nextProps.inertia) {
      removeInertia(tooltip);
    }
    if (prevProps.theme !== nextProps.theme) {
      updateTheme(tooltip, 'remove', prevProps.theme);
      updateTheme(tooltip, 'add', nextProps.theme);
    }
  }
  function hideAll() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        excludedReferenceOrInstance = _ref.exclude,
        duration = _ref.duration;
    arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
      var instance = popper._tippy;
      if (instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) {
          isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
        }
        if (!isExcluded) {
          instance.hide(duration);
        }
      }
    });
  }
  function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
    if (!popperPlacement) {
      return true;
    }
    var x = event.clientX,
        y = event.clientY;
    var interactiveBorder = props.interactiveBorder,
        distance = props.distance;
    var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
    var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
    var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
    var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  }
  function getOffsetDistanceInPx(distance) {
    return -(distance - 10) + 'px';
  }
  var idCounter = 1;
  var mouseMoveListeners = [];
  function createTippy(reference, collectionProps) {
    var props = evaluateProps(reference, collectionProps);
    if (!props.multiple && reference._tippy) {
      return null;
    }
    var lastTriggerEventType;
    var lastMouseMoveEvent;
    var showTimeoutId;
    var hideTimeoutId;
    var scheduleHideAnimationFrameId;
    var isScheduledToShow = false;
    var isBeingDestroyed = false;
    var previousPlacement;
    var wasVisibleDuringPreviousUpdate = false;
    var hasMountCallbackRun = false;
    var currentMountCallback;
    var currentTransitionEndListener;
    var listeners = [];
    var currentComputedPadding;
    var debouncedOnMouseMove = debounce$4(onMouseMove, props.interactiveDebounce);
    var id = idCounter++;
    var popper = createPopperElement(id, props);
    var popperChildren = getChildren(popper);
    var popperInstance = null;
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id: id,
      reference: reference,
      popper: popper,
      popperChildren: popperChildren,
      popperInstance: popperInstance,
      props: props,
      state: state,
      clearDelayTimeouts: clearDelayTimeouts,
      set: set,
      setContent: setContent,
      show: show,
      hide: hide,
      enable: enable,
      disable: disable,
      destroy: destroy
    };
    reference._tippy = instance;
    popper._tippy = instance;
    addTriggersToReference();
    if (!props.lazy) {
      createPopperInstance();
    }
    if (props.showOnInit) {
      scheduleShow();
    }
    if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
      getEventListenersTarget().setAttribute('tabindex', '0');
    }
    popper.addEventListener('mouseenter', function (event) {
      if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
        scheduleShow(event, true);
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
        document.addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance;
    function removeFollowCursorListener() {
      document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
    }
    function cleanupInteractiveMouseListeners() {
      document.body.removeEventListener('mouseleave', scheduleHide);
      document.removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function getEventListenersTarget() {
      return instance.props.triggerTarget || reference;
    }
    function addDocumentClickListener() {
      document.addEventListener('click', onDocumentClick, true);
    }
    function removeDocumentClickListener() {
      document.removeEventListener('click', onDocumentClick, true);
    }
    function getTransitionableElements() {
      return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
    }
    function getIsInLooseFollowCursorMode() {
      var followCursor = instance.props.followCursor;
      return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
    }
    function makeSticky() {
      setTransitionDuration([popper], isIE$2 ? 0 : instance.props.updateDuration);
      function updatePosition() {
        instance.popperInstance.scheduleUpdate();
        if (instance.state.isMounted) {
          requestAnimationFrame(updatePosition);
        } else {
          setTransitionDuration([popper], 0);
        }
      }
      updatePosition();
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var tooltip = instance.popperChildren.tooltip;
      function listener(event) {
        if (event.target === tooltip) {
          updateTransitionEndListener(tooltip, 'remove', listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(tooltip, 'add', listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      getEventListenersTarget().addEventListener(eventType, handler, options);
      listeners.push({
        eventType: eventType,
        handler: handler,
        options: options
      });
    }
    function addTriggersToReference() {
      if (instance.props.touchHold && !instance.props.target) {
        on('touchstart', onTrigger, PASSIVE);
        on('touchend', onMouseLeave, PASSIVE);
      }
      instance.props.trigger.trim().split(' ').forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }
        if (!instance.props.target) {
          on(eventType, onTrigger);
          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;
            case 'focus':
              on(isIE$2 ? 'focusout' : 'blur', onBlur);
              break;
          }
        } else {
          switch (eventType) {
            case 'mouseenter':
              on('mouseover', onDelegateShow);
              on('mouseout', onDelegateHide);
              break;
            case 'focus':
              on('focusin', onDelegateShow);
              on('focusout', onDelegateHide);
              break;
            case 'click':
              on(eventType, onDelegateShow);
              break;
          }
        }
      });
    }
    function removeTriggersFromReference() {
      listeners.forEach(function (_ref) {
        var eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        getEventListenersTarget().removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function positionVirtualReferenceNearCursor(event) {
      var _lastMouseMoveEvent = lastMouseMoveEvent = event,
          x = _lastMouseMoveEvent.clientX,
          y = _lastMouseMoveEvent.clientY;
      if (!currentComputedPadding) {
        return;
      }
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      var rect = reference.getBoundingClientRect();
      var followCursor = instance.props.followCursor;
      var isHorizontal = followCursor === 'horizontal';
      var isVertical = followCursor === 'vertical';
      var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
      var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
      var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
      var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
      var halfSize = size / 2;
      var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
      var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.popperInstance.reference = _extends$3({}, instance.popperInstance.reference, {
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              width: isVerticalPlacement ? size : 0,
              height: isVerticalPlacement ? 0 : size,
              top: (isHorizontal ? rect.top : y) - verticalIncrease,
              bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
              left: (isVertical ? rect.left : x) - horizontalIncrease,
              right: (isVertical ? rect.right : x) + horizontalIncrease
            };
          }
        });
        instance.popperInstance.update();
      }
      if (followCursor === 'initial' && instance.state.isVisible) {
        removeFollowCursorListener();
      }
    }
    function createDelegateChildTippy(event) {
      if (event) {
        var targetEl = closest(event.target, instance.props.target);
        if (targetEl && !targetEl._tippy) {
          createTippy(targetEl, _extends$3({}, instance.props, {
            content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
            appendTo: collectionProps.appendTo,
            target: '',
            showOnInit: true
          }));
        }
      }
    }
    function onTrigger(event) {
      if (!instance.state.isEnabled || isEventListenerStopped(event)) {
        return;
      }
      if (!instance.state.isVisible) {
        lastTriggerEventType = event.type;
        if (event instanceof MouseEvent) {
          lastMouseMoveEvent = event;
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        }
      }
      if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
        scheduleHide();
      } else {
        scheduleShow(event);
      }
    }
    function onMouseMove(event) {
      var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      if (isCursorOverPopper || isCursorOverReference) {
        return;
      }
      if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
        cleanupInteractiveMouseListeners();
        scheduleHide();
      }
    }
    function onMouseLeave(event) {
      if (isEventListenerStopped(event)) {
        return;
      }
      if (instance.props.interactive) {
        document.body.addEventListener('mouseleave', scheduleHide);
        document.addEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners.push(debouncedOnMouseMove);
        return;
      }
      scheduleHide();
    }
    function onBlur(event) {
      if (event.target !== getEventListenersTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide();
    }
    function onDelegateShow(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleShow(event);
      }
    }
    function onDelegateHide(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleHide();
      }
    }
    function isEventListenerStopped(event) {
      var supportsTouch = ('ontouchstart' in window);
      var isTouchEvent = includes(event.type, 'touch');
      var touchHold = instance.props.touchHold;
      return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
    }
    function runMountCallback() {
      if (!hasMountCallbackRun && currentMountCallback) {
        hasMountCallbackRun = true;
        reflow(popper);
        currentMountCallback();
      }
    }
    function createPopperInstance() {
      var popperOptions = instance.props.popperOptions;
      var _instance$popperChild = instance.popperChildren,
          tooltip = _instance$popperChild.tooltip,
          arrow = _instance$popperChild.arrow;
      var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
      function applyMutations(data) {
        if (instance.props.flip && !instance.props.flipOnUpdate) {
          if (data.flipped) {
            instance.popperInstance.options.placement = data.placement;
          }
          setFlipModifierEnabled(instance.popperInstance.modifiers, false);
        }
        tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);
        if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
          tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
        } else {
          tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
        }
        if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
          tooltip.style.transition = 'none';
          requestAnimationFrame(function () {
            tooltip.style.transition = '';
          });
        }
        previousPlacement = data.placement;
        wasVisibleDuringPreviousUpdate = instance.state.isVisible;
        var basicPlacement = getBasicPlacement(popper);
        var styles = tooltip.style;
        styles.top = styles.bottom = styles.left = styles.right = '';
        styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
        var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
        var isPaddingNumber = typeof padding === 'number';
        var computedPadding = _extends$3({
          top: isPaddingNumber ? padding : padding.top,
          bottom: isPaddingNumber ? padding : padding.bottom,
          left: isPaddingNumber ? padding : padding.left,
          right: isPaddingNumber ? padding : padding.right
        }, !isPaddingNumber && padding);
        computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
        instance.popperInstance.modifiers.filter(function (m) {
          return m.name === 'preventOverflow';
        })[0].padding = computedPadding;
        currentComputedPadding = computedPadding;
      }
      var config = _extends$3({
        eventsEnabled: false,
        placement: instance.props.placement
      }, popperOptions, {
        modifiers: _extends$3({}, popperOptions ? popperOptions.modifiers : {}, {
          preventOverflow: _extends$3({
            boundariesElement: instance.props.boundary,
            padding: PADDING
          }, preventOverflowModifier),
          arrow: _extends$3({
            element: arrow,
            enabled: !!arrow
          }, getModifier(popperOptions, 'arrow')),
          flip: _extends$3({
            enabled: instance.props.flip,
            padding: instance.props.distance + PADDING,
            behavior: instance.props.flipBehavior
          }, getModifier(popperOptions, 'flip')),
          offset: _extends$3({
            offset: instance.props.offset
          }, getModifier(popperOptions, 'offset'))
        }),
        onCreate: function onCreate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onCreate) {
            popperOptions.onCreate(data);
          }
        },
        onUpdate: function onUpdate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onUpdate) {
            popperOptions.onUpdate(data);
          }
        }
      });
      instance.popperInstance = new Popper$1(reference, popper, config);
    }
    function mount() {
      hasMountCallbackRun = false;
      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
      if (instance.popperInstance) {
        setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.reference = reference;
          instance.popperInstance.enableEventListeners();
        }
        instance.popperInstance.scheduleUpdate();
      } else {
        createPopperInstance();
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.enableEventListeners();
        }
      }
      var appendTo = instance.props.appendTo;
      var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);
      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
        instance.props.onMount(instance);
        instance.state.isMounted = true;
      }
    }
    function scheduleShow(event, shouldAvoidCallingOnTrigger) {
      clearDelayTimeouts();
      if (instance.state.isVisible) {
        return;
      }
      if (instance.props.target) {
        return createDelegateChildTippy(event);
      }
      isScheduledToShow = true;
      if (event && !shouldAvoidCallingOnTrigger) {
        instance.props.onTrigger(instance, event);
      }
      if (instance.props.wait) {
        return instance.props.wait(instance, event);
      }
      if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
        if (!instance.popperInstance) {
          createPopperInstance();
        }
        document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
      }
      addDocumentClickListener();
      var delay = getValue(instance.props.delay, 0, defaultProps.delay);
      if (delay) {
        showTimeoutId = setTimeout(function () {
          show();
        }, delay);
      } else {
        show();
      }
    }
    function scheduleHide() {
      clearDelayTimeouts();
      if (!instance.state.isVisible) {
        return removeFollowCursorListener();
      }
      isScheduledToShow = false;
      var delay = getValue(instance.props.delay, 1, defaultProps.delay);
      if (delay) {
        hideTimeoutId = setTimeout(function () {
          if (instance.state.isVisible) {
            hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrameId = requestAnimationFrame(function () {
          hide();
        });
      }
    }
    function onDocumentClick(event) {
      if (instance.props.interactive && popper.contains(event.target)) {
        return;
      }
      if (getEventListenersTarget().contains(event.target)) {
        if (isUsingTouch) {
          return;
        }
        if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
          return;
        }
      }
      if (instance.props.hideOnClick === true) {
        clearDelayTimeouts();
        hide();
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeoutId);
      clearTimeout(hideTimeoutId);
      cancelAnimationFrame(scheduleHideAnimationFrameId);
    }
    function set(options) {
      options = options || {};
      validateOptions(options, defaultProps);
      removeTriggersFromReference();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, _extends$3({}, instance.props, options, {
        ignoreAttributes: true
      }));
      nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
      instance.props = nextProps;
      addTriggersToReference();
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$4(onMouseMove, nextProps.interactiveDebounce);
      updatePopperElement(popper, prevProps, nextProps);
      instance.popperChildren = getChildren(popper);
      if (instance.popperInstance) {
        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
          return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];
        })) {
          instance.popperInstance.destroy();
          createPopperInstance();
          if (instance.state.isVisible) {
            instance.popperInstance.enableEventListeners();
          }
          if (instance.props.followCursor && lastMouseMoveEvent) {
            positionVirtualReferenceNearCursor(lastMouseMoveEvent);
          }
        } else {
          instance.popperInstance.update();
        }
      }
    }
    function setContent(content) {
      set({
        content: content
      });
    }
    function show() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
        return;
      }
      if (getEventListenersTarget().hasAttribute('disabled')) {
        return;
      }
      if (instance.props.onShow(instance) === false) {
        return;
      }
      addDocumentClickListener();
      popper.style.visibility = 'visible';
      instance.state.isVisible = true;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.add(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements.concat(popper), 0);
      currentMountCallback = function currentMountCallback() {
        if (!instance.state.isVisible) {
          return;
        }
        var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
        if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        } else if (!isInLooseFollowCursorMode) {
          instance.popperInstance.update();
        }
        if (instance.popperChildren.backdrop) {
          instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
        }
        if (instance.props.sticky) {
          makeSticky();
        }
        setTransitionDuration([popper], instance.props.updateDuration);
        setTransitionDuration(transitionableElements, duration);
        setVisibilityState(transitionableElements, 'visible');
        onTransitionedIn(duration, function () {
          if (instance.props.aria) {
            getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
          }
          instance.props.onShown(instance);
          instance.state.isShown = true;
        });
      };
      mount();
    }
    function hide() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
        return;
      }
      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
        return;
      }
      removeDocumentClickListener();
      popper.style.visibility = 'hidden';
      instance.state.isVisible = false;
      instance.state.isShown = false;
      wasVisibleDuringPreviousUpdate = false;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.remove(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'hidden');
      onTransitionedOut(duration, function () {
        if (!isScheduledToShow) {
          removeFollowCursorListener();
        }
        if (instance.props.aria) {
          getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
        }
        instance.popperInstance.disableEventListeners();
        instance.popperInstance.options.placement = instance.props.placement;
        popper.parentNode.removeChild(popper);
        instance.props.onHidden(instance);
        instance.state.isMounted = false;
      });
    }
    function destroy(destroyTargetInstances) {
      if (instance.state.isDestroyed) {
        return;
      }
      isBeingDestroyed = true;
      if (instance.state.isMounted) {
        hide(0);
      }
      removeTriggersFromReference();
      delete reference._tippy;
      var target = instance.props.target;
      if (target && destroyTargetInstances && isRealElement(reference)) {
        arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
          if (child._tippy) {
            child._tippy.destroy();
          }
        });
      }
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
      }
      isBeingDestroyed = false;
      instance.state.isDestroyed = true;
    }
  }
  function group(instances) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration;
    var isAnyTippyOpen = false;
    instances.forEach(function (instance) {
      if (instance._originalProps) {
        instance.set(instance._originalProps);
      } else {
        instance._originalProps = _extends$3({}, instance.props);
      }
    });
    function setIsAnyTippyOpen(value) {
      isAnyTippyOpen = value;
      updateInstances();
    }
    function onShow(instance) {
      instance._originalProps.onShow(instance);
      instances.forEach(function (instance) {
        instance.set({
          duration: duration
        });
        if (instance.state.isVisible) {
          instance.hide();
        }
      });
      setIsAnyTippyOpen(true);
    }
    function onHide(instance) {
      instance._originalProps.onHide(instance);
      setIsAnyTippyOpen(false);
    }
    function onShown(instance) {
      instance._originalProps.onShown(instance);
      instance.set({
        duration: instance._originalProps.duration
      });
    }
    function updateInstances() {
      instances.forEach(function (instance) {
        instance.set({
          onShow: onShow,
          onShown: onShown,
          onHide: onHide,
          delay: isAnyTippyOpen ? [0, isArray$1(delay) ? delay[1] : delay] : delay,
          duration: isAnyTippyOpen ? duration : instance._originalProps.duration
        });
      });
    }
    updateInstances();
  }
  var globalEventListenersBound = false;
  function tippy(targets, options) {
    validateOptions(options || {}, defaultProps);
    if (!globalEventListenersBound) {
      bindGlobalEventListeners();
      globalEventListenersBound = true;
    }
    var props = _extends$3({}, defaultProps, options);
    if (isBareVirtualElement(targets)) {
      polyfillElementPrototypeProperties(targets);
    }
    var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, props);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isSingular(targets) ? instances[0] : instances;
  }
  tippy.version = version$1;
  tippy.defaults = defaultProps;
  tippy.setDefaults = function (partialDefaults) {
    keys$1(partialDefaults).forEach(function (key) {
      defaultProps[key] = partialDefaults[key];
    });
  };
  tippy.hideAll = hideAll;
  tippy.group = group;
  function autoInit() {
    arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
      var content = el.getAttribute('data-tippy');
      if (content) {
        tippy(el, {
          content: content
        });
      }
    });
  }
  if (isBrowser$2) {
    setTimeout(autoInit);
  }
  var getValidTippyProps = function getValidTippyProps(props) {
    var validProps = {};
    for (var key in props) {
      if (defaultProps.hasOwnProperty(key)) {
        validProps[key] = props[key];
      }
    }
    return validProps;
  };

  var defaultOptions = {
    duration: 0,
    arrow: true,
    size: 'small',
    trigger: 'mouseenter focus',
    theme: 'dark',
    interactive: true,
    content: '',
    allowHtml: false,
    extCls: ''
  };
  var validPlacements$2 = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var createTippy$1 = function createTippy(el, binding) {
    var value = binding.value;
    var options = _objectSpread({}, defaultOptions);
    if (_typeof(value) === 'object') {
      _extends(options, value);
    } else {
      options.content = value;
    }
    var placement = validPlacements$2.find(function (placement) {
      return binding.modifiers[placement];
    });
    options.placement = options.placement || placement || (options.placements || ['top'])[0];
    var _binding$modifiers = binding.modifiers,
        click = _binding$modifiers.click,
        light = _binding$modifiers.light;
    if (click) {
      options.trigger = 'click';
    }
    if (light) {
      options.theme = 'light';
    }
    if (options.allowHtml) {
      var selector = options.content;
      if (selector instanceof Vue) {
        options.content = selector.$el;
      } else if (typeof selector === 'string') {
        var element = document.querySelector(selector);
        if (element) {
          options.content = element;
        }
      }
    }
    if (options.html) {
      options.content = options.html;
    }
    if (typeof options.onClose === 'function') {
      options.onHide = options.onClose;
    }
    var validOptions = getValidTippyProps(options);
    return tippy(el, validOptions);
  };
  var bkTooltips = {
    inserted: function inserted(el, binding) {
      var disabled = _typeof(binding.value) === 'object' ? binding.value.disabled : false;
      if (!disabled) {
        el.tippyInstance = createTippy$1(el, binding);
      }
    },
    unbind: function unbind(el) {
      el._tippy && el._tippy.destroy();
      el.tippyInstance = null;
    },
    update: function update(el, binding) {
      var value = binding.value;
      var isObject = _typeof(value) === 'object';
      var content = isObject ? value.content : value;
      var disabled = isObject ? value.disabled : false;
      if (disabled || !content) {
        el._tippy && el._tippy.destroy();
        el.tippyInstance = null;
      } else if (content) {
        if (!el._tippy) {
          el.tippyInstance = createTippy$1(el, binding);
        } else {
          if (_typeof(value) === 'object' && binding.value.allowHtml) {
            el.tippyInstance = createTippy$1(el, binding);
          } else {
            el._tippy.setContent(content);
          }
        }
      }
    }
  };
  bkTooltips.install = function (Vue) {
    Vue.directive('bkTooltips', bkTooltips);
  };

  function primiseSequence(promises, args) {
    var p = promise$1.resolve();
    var len = promises.length;
    var i = 0;
    if (len <= 0) {
      return p;
    }
    function callBack() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      return p.then(function (r) {
        return promises[i].apply(promises, [r].concat(params));
      }).then(function (r) {
        ++i;
        return i > len - 1 ? promise$1.resolve(r) : callBack.apply(void 0, params);
      });
    }
    return callBack(args);
  }

  Vue.use(bkTooltips);
  var script$z = {
    name: 'bk-form-item',
    mixins: [emitter, locale.mixin],
    inject: ['form'],
    props: {
      label: {
        type: String
      },
      desc: {
        type: [String, Object],
        default: ''
      },
      descType: {
        type: String,
        default: 'border'
      },
      descIcon: {
        type: String,
        default: 'icon-question-circle'
      },
      labelWidth: {
        type: Number
      },
      required: {
        type: Boolean,
        default: false
      },
      rules: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      iconOffset: {
        type: Number,
        default: 8
      },
      property: {
        type: String,
        default: ''
      },
      extCls: {
        type: String,
        default: ''
      },
      errorDisplayType: {
        type: String,
        default: 'tooltips'
      },
      autoCheck: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        id: uuid(),
        isChecking: false,
        validator: {
          state: '',
          content: ''
        }
      };
    },
    computed: {
      labelStyle: function labelStyle() {
        var labelWidth = this.labelWidth ? this.labelWidth : this.form.labelWidth;
        return {
          width: "".concat(labelWidth, "px")
        };
      },
      contentStyle: function contentStyle() {
        var labelWidth = this.labelWidth ? this.labelWidth : this.form.labelWidth;
        return {
          'margin-left': "".concat(labelWidth, "px")
        };
      },
      fieldValue: function fieldValue() {
        var formModel = this.form.model;
        if (!formModel || !this.property) {
          return;
        }
        var paths = this.property.split('.');
        var data = formModel;
        var _iterator = _createForOfIteratorHelper(paths),
            _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var path = _step.value;
            if (!data.hasOwnProperty(path)) {
              data = undefined;
              return false;
            }
            data = data[path];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return data;
      }
    },
    created: function created() {
      this.dispatch('bk-form', 'form-item-add', this);
    },
    mounted: function mounted() {
      this.$off('form-blur', this.handlerBlur);
      this.$off('form-change', this.handlerChange);
      this.$on('form-blur', this.handlerBlur);
      this.$on('form-focus', this.handlerFocus);
      this.$on('form-change', this.handlerChange);
      if (this.autoCheck) {
        this.validate();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.dispatch('bk-form', 'form-item-delete', this);
    },
    methods: {
      handlerBlur: function handlerBlur() {
        var _this = this;
        setTimeout(function () {
          _this.validate('blur');
        }, 0);
      },
      handlerChange: function handlerChange() {
        var _this2 = this;
        setTimeout(function () {
          _this2.validate('change');
        }, 0);
      },
      handlerFocus: function handlerFocus() {
        this.clearValidator();
      },
      setValidator: function setValidator(data) {
        this.validator = data;
      },
      clearValidator: function clearValidator() {
        this.validator.state = '';
        this.validator.content = '';
      },
      checkRule: function checkRule(rule, model) {
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var result;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(rule.required && isEmpty(model))) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 2:
                  if (!(rule.regex && !rule.regex.test(model))) {
                    _context.next = 4;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 4:
                  if (!(rule.min && isString(model) && model.length < rule.min)) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 6:
                  if (!(rule.max && isString(model) && model.length > rule.max)) {
                    _context.next = 8;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 8:
                  if (!(rule.min && isNumber(model) && model < rule.min)) {
                    _context.next = 10;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 10:
                  if (!(rule.max && isNumber(model) && model > rule.max)) {
                    _context.next = 12;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 12:
                  if (!(rule.validator && typeof rule.validator === 'function')) {
                    _context.next = 17;
                    break;
                  }
                  _context.next = 15;
                  return rule.validator(model);
                case 15:
                  result = _context.sent;
                  return _context.abrupt("return", result);
                case 17:
                  return _context.abrupt("return", true);
                case 18:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      clearError: function clearError() {
        this.validator.state = '';
        this.validator.content = '';
      },
      validate: function validate() {
        var _this3 = this;
        var trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
        var rules = this.rules;
        if (!rules.length && this.form.rules && isArray$1(this.form.rules[this.property])) {
          rules = this.form.rules[this.property];
        }
        this.isChecking = true;
        rules = rules.filter(function (item) {
          return item.trigger && item.trigger.indexOf(trigger) > -1;
        });
        var valid = true;
        if (!rules || !rules.length) {
          this.validator.state = 'success';
          this.validator.content = '';
          callback(this.validator);
          this.isChecking = false;
          return valid;
        }
        var self = this;
        var model = this.fieldValue;
        var promises = [];
        rules.forEach(function (rule) {
          promises.push(function () {
            return new promise$1( function () {
              var _ref = _asyncToGenerator( regenerator.mark(function _callee2(resolve, reject) {
                var curRule, result;
                return regenerator.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        curRule = rule;
                        _context2.prev = 1;
                        _context2.next = 4;
                        return self.checkRule(curRule, model);
                      case 4:
                        result = _context2.sent;
                        if (result) {
                          resolve(curRule);
                        } else {
                          reject(curRule);
                        }
                        _context2.next = 11;
                        break;
                      case 8:
                        _context2.prev = 8;
                        _context2.t0 = _context2["catch"](1);
                        reject(curRule);
                      case 11:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, null, [[1, 8]]);
              }));
              return function (_x, _x2) {
                return _ref.apply(this, arguments);
              };
            }());
          });
        });
        primiseSequence(promises).then(function (rule) {
          _this3.validator.field = _this3.property;
          _this3.validator.state = 'success';
          _this3.validator.content = '';
          callback(_this3.validator);
        }).catch(function (errors) {
          _this3.validator.field = _this3.property;
          _this3.validator.state = 'error';
          _this3.validator.content = typeof errors.message === 'function' ? errors.message(model) : errors.message;
          callback(_this3.validator);
        }).finally(function (errors) {
          _this3.isChecking = false;
        });
      }
    }
  };

  /* script */
  var __vue_script__$z = script$z;
  /* template */

  var __vue_render__$z = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-form-item', {
        'is-required': _vm.required,
        'is-error': _vm.validator.state === 'error',
        'is-checking': _vm.isChecking
      }, _vm.extCls]
    }, [_vm.label ? _c('label', {
      class: ['bk-label', {
        'has-desc': !!_vm.desc && _vm.descType === 'border'
      }],
      style: _vm.labelStyle
    }, [_vm.desc ? [_vm.descType === 'border' ? _c('span', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips",
        value: _vm.desc,
        expression: "desc"
      }],
      staticClass: "bk-label-text"
    }, [_vm._v(_vm._s(_vm.label))]) : _c('span', {
      staticClass: "bk-label-text"
    }, [_vm._v("\n                " + _vm._s(_vm.label) + "\n                "), _c('i', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips",
        value: _vm.desc,
        expression: "desc"
      }],
      class: "bk-icon " + _vm.descIcon
    })])] : [_c('span', {
      staticClass: "bk-label-text"
    }, [_vm._v(_vm._s(_vm.label))])]], 2) : _vm._e(), _c('div', {
      staticClass: "bk-form-content",
      style: _vm.contentStyle
    }, [_vm._t("default"), _vm.isChecking ? [_vm.isChecking ? _c('div', {
      staticClass: "bk-spin-loading bk-spin-loading-primary bk-spin-loading-mini tooltips-icon",
      style: {
        right: _vm.iconOffset + "px"
      }
    }, [_c('div', {
      staticClass: "rotate rotate1"
    }), _c('div', {
      staticClass: "rotate rotate2"
    }), _c('div', {
      staticClass: "rotate rotate3"
    }), _c('div', {
      staticClass: "rotate rotate4"
    }), _c('div', {
      staticClass: "rotate rotate5"
    }), _c('div', {
      staticClass: "rotate rotate6"
    }), _c('div', {
      staticClass: "rotate rotate7"
    }), _c('div', {
      staticClass: "rotate rotate8"
    })]) : _vm._e()] : _vm.validator.content ? [_vm.errorDisplayType === 'tooltips' ? _c('i', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips.top-end",
        value: _vm.validator,
        expression: "validator",
        modifiers: {
          "top-end": true
        }
      }],
      staticClass: "bk-icon icon-exclamation-circle-shape tooltips-icon",
      style: {
        right: _vm.iconOffset + "px"
      }
    }) : _c('p', {
      staticClass: "form-error-tip"
    }, [_vm._v(_vm._s(_vm.validator.content))])] : _vm._e(), _vm._t("tip")], 2)]);
  };

  var __vue_staticRenderFns__$z = [];
  /* style */

  var __vue_inject_styles__$z = undefined;
  /* scoped */

  var __vue_scope_id__$z = undefined;
  /* module identifier */

  var __vue_module_identifier__$z = undefined;
  /* functional template */

  var __vue_is_functional_template__$z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$z = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$z,
    staticRenderFns: __vue_staticRenderFns__$z
  }, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$z);

  var iconFactory = (function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$fontLibrary = _ref.fontLibrary,
        fontLibrary = _ref$fontLibrary === void 0 ? 'bk-icon' : _ref$fontLibrary,
        _ref$prefix = _ref.prefix,
        prefix = _ref$prefix === void 0 ? 'icon' : _ref$prefix;
    return {
      name: fontLibrary,
      props: {
        type: {
          type: String,
          required: true
        },
        svg: {
          type: Boolean,
          default: false
        },
        width: {
          type: String,
          default: '1em'
        },
        height: {
          type: String,
          default: '1em'
        },
        size: {
          type: String,
          default: 'inherit'
        }
      },
      render: function render(h) {
        var _classes;
        if (this.svg) {
          return h('svg', {
            style: {
              'width': this.width,
              'height': this.height,
              'font-size': this.size
            },
            attrs: {
              'fill': 'currentColor',
              'aria-hidden': true
            },
            props: this.$attrs,
            on: this.$listeners
          }, [h('use', {
            attrs: {
              'xlink:href': "#".concat(prefix, "-").concat(this.type)
            }
          })]);
        }
        var classes = (_classes = {}, _defineProperty(_classes, fontLibrary, true), _defineProperty(_classes, "".concat(prefix, "-").concat(this.type), true), _classes);
        return h('i', {
          style: {
            'font-size': this.size
          },
          class: classes,
          props: this.$attrs,
          on: this.$listeners
        });
      }
    };
  });

  var Icon = iconFactory();
  setInstaller(Icon);
  Icon.create = iconFactory;

  var InfoBoxConstructor = Vue.extend(__vue_component__$u);
  var instancesList = [];
  var seed = 0;
  var Info = function Info() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var id = 'bkInfoBox' + seed++;
    if (typeof opts === 'string') {
      opts = {
        title: opts
      };
    }
    var instance = new InfoBoxConstructor();
    instance.id = id;
    instance.name = 'bk-info-box';
    if (opts.width) {
      instance.width = opts.width;
    }
    instance.confirmLoading = Boolean(opts.confirmLoading);
    instance.value = true;
    instance.title = opts.title;
    instance.subTitle = opts.subTitle;
    instance.type = opts.type || '';
    instance.showFooter = opts.showFooter !== false;
    instance.closeIcon = opts.closeIcon !== false;
    instance.maskClose = opts.maskClose;
    instance.escClose = opts.escClose;
    instance.theme = opts.theme || 'primary';
    instance.icon = opts.icon;
    instance.extCls = opts.extCls;
    instance.okText = opts.okText;
    instance.cancelText = opts.cancelText;
    instance.zIndex = opts.zIndex || instance.zIndex;
    if (isVNode(opts.subHeader)) {
      instance.$slots[opts.type ? 'type-sub-header' : 'sub-header'] = opts.subHeader;
    }
    if (isVNode(opts.header)) {
      instance.$slots[opts.type ? 'type-header' : 'header'] = opts.header;
    }
    instance.confirmFn = opts.confirmFn && typeof opts.confirmFn === 'function' ? _asyncToGenerator( regenerator.mark(function _callee() {
      var res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              instance.closeIcon = false;
              _context.next = 3;
              return opts.confirmFn(instance);
            case 3:
              res = _context.sent;
              instance.closeIcon = opts.closeIcon !== false;
              if (!(!res && typeof res !== 'undefined')) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              Info.close(id);
            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })) : function () {
      Info.close(id);
    };
    instance.cancelFn = opts.cancelFn && typeof opts.cancelFn === 'function' ? opts.cancelFn : function () {};
    instance.afterLeaveFn = opts.afterLeaveFn && typeof opts.afterLeaveFn === 'function' ? opts.afterLeaveFn : function () {};
    instance.stateChangeFn = opts.stateChangeFn && typeof opts.stateChangeFn === 'function' ? opts.stateChangeFn : function () {};
    instance.onClose = function () {
      Info.close(id, opts.onClose);
    };
    var ref = document.body;
    var container = opts.container;
    if (container) {
      instance.ignoreExistMask = false;
      if (typeof container !== 'string') {
        ref = container instanceof Element ? container : container instanceof Vue ? container.$el : document.querySelector(container);
      } else {
        var element = document.querySelector(container);
        if (element) {
          ref = element;
        } else {
          throw new Error("\u6CA1\u6709\u627E\u5230 ".concat(element, " \u8282\u70B9"));
        }
      }
      instance.transfer = false;
    } else {
      instance.transfer = true;
    }
    instance.$mount();
    instance.$dom = instance.$el;
    ref.appendChild(instance.$el);
    instancesList.push(instance);
    return instance;
  };
  Info.close = function (id, optsClose) {
    var len = instancesList.length;
    var _loop = function _loop(index) {
      var targetInstance = instancesList[index];
      if (id === targetInstance.id) {
        targetInstance.value = false;
        if (typeof optsClose === 'function') {
          optsClose(targetInstance);
        }
        instancesList.splice(index, 1);
        targetInstance.$on('after-leave', function () {
          targetInstance.$el.parentNode.removeChild(targetInstance.$el);
        });
        return "break";
      }
    };
    for (var index = 0; index < len; index++) {
      var _ret = _loop(index);
      if (_ret === "break") break;
    }
  };
  Vue.prototype.$bkInfo = Info;

  _export(_export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

  var maxSafeInteger = 0x1fffffffffffff;

  var maxSafeInteger$1 = maxSafeInteger;

  _export(_export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

  var minSafeInteger = -0x1fffffffffffff;

  var minSafeInteger$1 = minSafeInteger;

  var script$A = {
    name: 'bk-input',
    mixins: [emitter, locale.mixin],
    props: {
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'textarea', 'password', 'number', 'email', 'url', 'date'].indexOf(value) > -1;
        }
      },
      value: {
        type: [String, Number],
        default: ''
      },
      placeholder: {
        type: String,
        default: ''
      },
      disabled: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        default: ''
      },
      maxlength: {
        type: [Number, String]
      },
      minlength: {
        type: [Number, String]
      },
      min: {
        type: Number,
        default: minSafeInteger$1
      },
      max: {
        type: Number,
        default: maxSafeInteger$1
      },
      size: {
        type: String,
        default: '',
        validator: function validator(val) {
          return ['', 'large', 'small'].includes(val);
        }
      },
      leftIcon: {
        type: String,
        default: ''
      },
      rightIcon: {
        type: String,
        default: ''
      },
      rows: {
        type: Number
      },
      inputStyle: {
        type: Object
      },
      fontSize: {
        type: String,
        default: 'normal'
      },
      precision: Number,
      passwordIcon: {
        type: Array,
        default: function _default() {
          return ['icon-eye-slash', 'icon-eye'];
        }
      },
      showControls: {
        type: Boolean,
        default: true
      },
      extCls: {
        type: String,
        default: ''
      },
      nativeAttributes: {
        type: Object,
        default: null
      },
      showWordLimit: {
        type: Boolean,
        default: undefined
      },
      behavior: {
        type: String,
        default: 'normal',
        validate: function validate(v) {
          return ['simplicity', 'normal'].indexOf(v) > -1;
        }
      },
      showClearOnlyHover: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        hover: false,
        curValue: '',
        prepend: false,
        append: false,
        isActive: false,
        defaultPlaceholder: '',
        rightIconStyle: {
          right: '10px'
        },
        rightPasswordIconStyle: {
          right: '10px'
        },
        inputType: this.type,
        inputSize: this.size,
        inputPasswordIcon: this.passwordIcon,
        inputRightPadding: '10px',
        iconAreaSizeObserver: null
      };
    },
    computed: {
      showClearIcon: function showClearIcon() {
        return this.clearable && this.curValue && !this.disabled && (this.showClearOnlyHover ? this.hover : true);
      },
      showPwdVisable: function showPwdVisable() {
        return this.type === 'password' && this.curValue && this.inputPasswordIcon.length && !this.readonly && !this.disabled;
      },
      showInputWordLimit: function showInputWordLimit() {
        if (!['text', 'textarea'].includes(this.type)) return false;
        return this.type === 'text' ? this.maxlength && this.showWordLimit : this.maxlength && this.showWordLimit !== false;
      },
      bindAttribute: function bindAttribute() {
        return this.getAttributeByType(this.inputType);
      },
      computedStyle: function computedStyle() {
        return _extends(this.inputType === 'textarea' ? {} : {
          'padding-right': this.inputRightPadding
        }, this.inputStyle);
      },
      showLeftIcon: function showLeftIcon() {
        return this.leftIcon;
      },
      showRightIcon: function showRightIcon() {
        return this.rightIcon || this.clearable && this.curValue || this.type === 'password' || this.maxlength;
      },
      showTwoRightIcon: function showTwoRightIcon() {
        return this.clearable && this.curValue && this.type === 'password';
      },
      wrapperClass: function wrapperClass() {
        var wrapperClass = ['bk-form-control', {
          'with-left-icon': this.showLeftIcon,
          'with-right-icon': this.showRightIcon,
          'with-two-right-icon': this.showTwoRightIcon,
          'control-prepend-group': this.prepend,
          'control-append-group': this.append,
          'control-active': this.isActive,
          'control-disable': this.disabled
        }];
        if (this.inputSize) {
          wrapperClass.push("bk-input-wrapper-".concat(this.inputSize));
        }
        return wrapperClass;
      },
      fontSizeCls: function fontSizeCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-font';
        } else if (this.fontSize === 'large') {
          cls = 'large-font';
        }
        return cls;
      },
      inputSizeCls: function inputSizeCls() {
        if (this.inputSize) {
          return "bk-input-".concat(this.inputSize);
        }
        return '';
      }
    },
    watch: {
      value: {
        handler: function handler(val, old) {
          this.setCurValue(val);
          old === undefined && this.updateNumberValue(val);
        },
        immediate: true
      },
      placeholder: function placeholder(val) {
        this.defaultPlaceholder = val || this.t('bk.input.input');
      },
      type: function type(val) {
        this.inputType = val;
      },
      size: function size(val) {
        this.inputSize = val;
      }
    },
    created: function created() {
      this.defaultPlaceholder = this.placeholder || this.t('bk.input.input');
    },
    mounted: function mounted() {
      var _this = this;
      this.prepend = this.$slots.prepend !== undefined;
      this.append = this.$slots.append !== undefined;
      if (this.$slots.append) {
        this.$nextTick(function () {
          var appendWidth = _parseFloat$2(getStyle(_this.$slots.append[0].elm, 'width'));
          _this.rightIconStyle = {
            right: _parseFloat$2(_this.rightIconStyle.right) + appendWidth + 'px'
          };
        });
      }
      if (this.clearable) {
        this.rightPasswordIconStyle = {
          right: '30px'
        };
      }
      this.observerIconSize();
    },
    beforeDestroy: function beforeDestroy() {
      this.iconAreaSizeObserver && typeof this.iconAreaSizeObserver.disconnect === 'function' && this.iconAreaSizeObserver.disconnect();
      this.iconAreaSizeObserver = null;
    },
    methods: {
      observerIconSize: function observerIconSize() {
        var _this2 = this;
        var element = this.$refs.rightIconArea;
        if (!element) return;
        if (typeof ResizeObserver !== 'undefined') {
          var defaultPadding = 10;
          this.iconAreaSizeObserver = new ResizeObserver(function (entries) {
            var _iterator = _createForOfIteratorHelper(entries),
                _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var entry = _step.value;
                var cr = entry.contentRect;
                _this2.inputRightPadding = "".concat(cr.width + defaultPadding, "px");
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          });
          this.iconAreaSizeObserver.observe(element);
        }
      },
      getAttributeByType: function getAttributeByType() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var defaultAttr = {
          type: type,
          name: this.name,
          placeholder: this.defaultPlaceholder,
          disabled: this.disabled,
          readonly: this.readonly,
          maxlength: this.maxlength,
          minlength: this.minlength,
          value: this.curValue
        };
        type = type.toLocaleLowerCase();
        var outputAttr = this.nativeAttributes || {};
        switch (type) {
          case 'number':
            var numberAttr = {
              min: this.min,
              max: this.max
            };
            _extends(outputAttr, defaultAttr, numberAttr);
            break;
          case 'textarea':
            var txtAttr = {
              rows: this.rows
            };
            _extends(outputAttr, defaultAttr, txtAttr);
            break;
          default:
            _extends(outputAttr, defaultAttr);
            break;
        }
        return outputAttr;
      },
      handleToFixed: function handleToFixed(defaultNumber, len) {
        var number = Number(defaultNumber);
        if (isNaN(number) || number >= Math.pow(10, 21)) {
          return number.toString();
        }
        if (typeof len === 'undefined' || len === 0) {
          return Math.round(number).toString();
        }
        var result = number.toString();
        var numberArr = result.split('.');
        if (numberArr.length < 2) {
          return this.handlePadNum(result, len);
        }
        var intNum = numberArr[0];
        var deciNum = numberArr[1];
        var lastNum = deciNum.substr(len, 1);
        if (deciNum.length === len) {
          return result;
        }
        if (deciNum.length < len) {
          return this.handlePadNum(result, len);
        }
        result = intNum + '.' + deciNum.substr(0, len);
        if (_parseInt$2(lastNum, 10) >= 5) {
          var times = Math.pow(10, len);
          var changedInt = Number(result.replace('.', ''));
          changedInt++;
          changedInt /= times;
          result = this.handlePadNum(changedInt + '', len);
        }
        return result;
      },
      handlePadNum: function handlePadNum(num, len) {
        var dotPos = num.indexOf('.');
        if (dotPos === -1) {
          num += '.';
          for (var i = 0; i < len; i++) {
            num += '0';
          }
          return num;
        } else {
          var need = len - (num.length - dotPos - 1);
          for (var j = 0; j < need; j++) {
            num += '0';
          }
          return num;
        }
      },
      handleNumberDelete: function handleNumberDelete(event) {
        var curNumberValue = Number(this.curValue);
        if (curNumberValue - 1 >= this.min) {
          var curLenAfterDot = (String(curNumberValue) || '').split('.')[1] || '';
          var newVal = curNumberValue - 1;
          if (typeof this.precision !== 'undefined') {
            newVal = this.handleToFixed(newVal, Math.min(16, Math.max(curLenAfterDot.length, this.precision)));
          }
          this.setCurValue(newVal);
          this.$emit('input', newVal, event);
          this.$emit('change', newVal, event);
          this.dispatch('bk-form-item', 'form-change');
        }
      },
      handleNumberAdd: function handleNumberAdd(event) {
        var curNumberValue = Number(this.curValue);
        if (curNumberValue <= this.max - 1) {
          var curLenAfterDot = (String(curNumberValue) || '').split('.')[1] || '';
          var newVal = curNumberValue + 1;
          if (typeof this.precision !== 'undefined') {
            newVal = this.handleToFixed(newVal, Math.min(16, Math.max(curLenAfterDot.length, this.precision)));
          }
          this.setCurValue(newVal);
          this.$emit('input', newVal, event);
          this.$emit('change', newVal, event);
          this.dispatch('bk-form-item', 'form-change');
        }
      },
      handlerEnter: function handlerEnter(event) {
        var value = event.target.value;
        this.$emit('enter', value, event);
      },
      handlerKeyup: function handlerKeyup(event) {
        var value = event.target.value;
        this.$emit('keyup', value, event);
      },
      handlerKeypress: function handlerKeypress(event) {
        var value = event.target.value;
        this.$emit('keypress', value, event);
      },
      handlerKeydown: function handlerKeydown(event) {
        var value = event.target.value;
        this.$emit('keydown', value, event);
      },
      handlerFocus: function handlerFocus(event) {
        var value = event.target.value;
        this.isActive = true;
        this.$emit('focus', value, event);
        this.dispatch('bk-form-item', 'form-focus');
      },
      toPrecision: function toPrecision(num, precision) {
        if (precision === undefined) precision = 0;
        return this.handleToFixed(num, precision);
      },
      handlerBlur: function handlerBlur(event) {
        var value = event.target.value;
        if (/^number$/i.test(this.type) && value !== '') {
          if (value !== '' && /^-?\d*(.\d*)?$/i.test(value)) {
            if (value > this.max || value < this.min) {
              value = this.getCurrentNumberValue();
            }
          }
          if (typeof this.precision !== 'undefined') {
            value = this.toPrecision(Number(value), this.precision, true);
          } else {
            value = Number(value);
          }
          if (value + '' !== event.target.value + '') {
            this.setCurValue(value);
            event.target.value = value;
            this.$emit('change', value, event);
            this.$emit('input', value, event);
          }
        }
        this.isActive = false;
        this.$emit('blur', value, event);
        this.dispatch('bk-form-item', 'form-blur');
      },
      handlerPaste: function handlerPaste(event) {
        var value = event.target.value;
        this.$emit('paste', value, event);
        this.$emit('change', value, event);
        this.dispatch('bk-form-item', 'form-change');
      },
      getCurrentNumberValue: function getCurrentNumberValue() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        val = val === null ? this.curValue : val;
        var value = '';
        if (val !== '' && /^-?\d*(.\d*)?$/i.test(val)) {
          value = Number(val);
          value = value > this.max ? this.max : value;
          value = value < this.min ? this.min : value;
          return value;
        }
        return '';
      },
      handlerInput: function handlerInput(event) {
        var value = event.target.value;
        this.setCurValue(value);
        this.$emit('input', value, event);
        this.$emit('change', value, event);
        this.dispatch('bk-form-item', 'form-change');
      },
      handlerClear: function handlerClear(event) {
        this.curValue = '';
        this.$emit('input', this.curValue, event);
        this.$emit('change', this.curValue, event);
        this.$emit('clear', this.curValue, event);
        this.dispatch('bk-form-item', 'form-change');
      },
      handlerLeftIcon: function handlerLeftIcon(event) {
        this.$emit('left-icon-click', this.curValue, event);
      },
      handlerRightIcon: function handlerRightIcon(event) {
        this.$emit('right-icon-click', this.curValue, event);
      },
      focus: function focus(event) {
        if (this.type === 'textarea') {
          this.$refs.textarea.focus();
        } else {
          this.$refs.input.focus();
        }
      },
      blur: function blur(event) {
        if (this.type === 'textarea') {
          this.$refs.textarea.blur();
        } else {
          this.$refs.input.blur();
        }
      },
      setCurValue: function setCurValue(val) {
        if (val === this.curValue) {
          return false;
        }
        this.curValue = val;
      },
      updateNumberValue: function updateNumberValue(val) {
        if (val !== '' && /^number$/i.test(this.type) && /^-?\d*(.\d*)?$/i.test(val)) {
          val = this.getCurrentNumberValue(val);
          this.curValue = typeof this.precision === 'number' ? this.toPrecision(Number(val), this.precision) : Number(val);
        }
      },
      togglePass: function togglePass() {
        if (this.inputType === 'password') {
          this.inputType = 'text';
        } else {
          this.inputType = 'password';
        }
      }
    }
  };

  /* script */
  var __vue_script__$A = script$A;
  /* template */

  var __vue_render__$A = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: [_vm.wrapperClass, _vm.fontSizeCls, _vm.extCls],
      on: {
        "mouseenter": function mouseenter($event) {
          _vm.hover = true;
        },
        "mouseleave": function mouseleave($event) {
          _vm.hover = false;
        }
      }
    }, [_vm.leftIcon ? _c('div', {
      staticClass: "control-icon left-icon",
      on: {
        "click": _vm.handlerLeftIcon
      }
    }, [_c('i', {
      class: ['bk-icon', _vm.leftIcon]
    })]) : _vm._e(), _vm.prepend ? _c('div', {
      staticClass: "group-box group-prepend"
    }, [_vm._t("prepend")], 2) : _vm._e(), _vm.inputType === 'textarea' ? [_c('div', {
      staticClass: "bk-textarea-wrapper"
    }, [_c('textarea', _vm._b({
      ref: "textarea",
      class: ['bk-form-textarea', {
        'textarea-maxlength': _vm.maxlength
      }],
      style: _vm.computedStyle,
      on: {
        "keyup": function keyup($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          return _vm.handlerEnter($event);
        },
        "keypress": _vm.handlerKeypress,
        "keydown": _vm.handlerKeydown,
        "focus": _vm.handlerFocus,
        "blur": _vm.handlerBlur,
        "input": _vm.handlerInput,
        "paste": _vm.handlerPaste
      }
    }, 'textarea', _vm.bindAttribute, false)), _vm.showInputWordLimit ? [_c('p', {
      staticClass: "bk-limit-box"
    }, [_c('span', {
      staticClass: "strong"
    }, [_vm._v(_vm._s(_vm.curValue && _vm.curValue.length || 0))]), _vm._v("/"), _c('span', [_vm._v(_vm._s(_vm.maxlength))])])] : _vm._e()], 2)] : [_c('div', {
      class: ["bk-input-" + _vm.type]
    }, [_c('input', _vm._b({
      ref: "input",
      class: ['bk-form-input', _vm.inputSizeCls, {
        'only-bottom-border': _vm.behavior === 'simplicity'
      }],
      style: _vm.computedStyle,
      on: {
        "keyup": [function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          return _vm.handlerEnter($event);
        }, _vm.handlerKeyup],
        "keypress": _vm.handlerKeypress,
        "keydown": _vm.handlerKeydown,
        "focus": _vm.handlerFocus,
        "blur": _vm.handlerBlur,
        "input": _vm.handlerInput,
        "paste": _vm.handlerPaste
      }
    }, 'input', _vm.bindAttribute, false)), /^number$/i.test(_vm.type) && !_vm.disabled && !_vm.readonly ? [_vm.showControls ? _c('span', {
      staticClass: "input-number-option"
    }, [_c('span', {
      staticClass: "number-option-item bk-icon icon-angle-up",
      on: {
        "click": _vm.handleNumberAdd
      }
    }), _c('span', {
      staticClass: "number-option-item bk-icon icon-angle-down",
      on: {
        "click": _vm.handleNumberDelete
      }
    })]) : _vm._e()] : _vm._e()], 2)], _vm.append ? _c('div', {
      staticClass: "group-box group-append"
    }, [_vm._t("append")], 2) : _vm._e(), !/^number$/i.test(_vm.type) ? _c('div', {
      ref: "rightIconArea",
      staticClass: "control-icon right-icon",
      style: _vm.rightIconStyle,
      on: {
        "click": _vm.handlerRightIcon
      }
    }, [_vm.showPwdVisable ? _c('i', {
      class: ['bk-icon', _vm.inputType === 'password' ? _vm.inputPasswordIcon[0] : _vm.inputPasswordIcon[1]],
      on: {
        "click": _vm.togglePass
      }
    }) : _vm._e(), _vm.showClearIcon ? _c('i', {
      staticClass: "bk-icon icon-close-circle-shape clear-icon ml5",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          $event.preventDefault();
          return _vm.handlerClear($event);
        }
      }
    }) : _vm.rightIcon ? _c('i', {
      class: ['bk-icon', _vm.rightIcon]
    }) : _vm._e(), _vm.type === 'text' ? [_c('p', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showInputWordLimit,
        expression: "showInputWordLimit"
      }],
      staticClass: "bk-limit-box ml5",
      staticStyle: {
        "position": "static"
      }
    }, [_c('span', {
      staticClass: "strong"
    }, [_vm._v(_vm._s(_vm.curValue && _vm.curValue.length || 0))]), _vm._v("/"), _c('span', [_vm._v(_vm._s(_vm.maxlength))])])] : _vm._e()], 2) : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$A = [];
  /* style */

  var __vue_inject_styles__$A = undefined;
  /* scoped */

  var __vue_scope_id__$A = undefined;
  /* module identifier */

  var __vue_module_identifier__$A = undefined;
  /* functional template */

  var __vue_is_functional_template__$A = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$A = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$A,
    staticRenderFns: __vue_staticRenderFns__$A
  }, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$A);

  var script$B = {
    name: 'bk-loading',
    props: {
      isLoading: {
        type: Boolean,
        default: false
      },
      title: {
        type: [String, Object],
        default: ''
      },
      mode: {
        type: String,
        default: 'normal'
      },
      size: {
        type: String,
        default: 'large'
      },
      theme: {
        type: String,
        default: 'colorful'
      },
      delay: {
        type: Number,
        default: 0
      },
      immediate: {
        type: Boolean,
        default: false
      },
      opacity: {
        type: Number,
        default: 0.9
      },
      color: {
        type: String,
        default: '#ffffff'
      },
      zIndex: {
        type: Number
      },
      afterLeave: {
        type: Function
      },
      extCls: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'default'
      }
    },
    data: function data() {
      return {
        timer: 0,
        hide: false,
        duration: 500,
        isShow: false
      };
    },
    computed: {
      isSpin: function isSpin() {
        return this.mode === 'spin';
      },
      bgColor: function bgColor() {
        var color = this.color.replace(/\s/gm, '');
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(color)) {
          var colors = color.substring(1).split('');
          if (colors.length === 3) {
            colors = [colors[0], colors[0], colors[1], colors[1], colors[2], colors[2]];
          }
          colors = '0x' + colors.join('');
          return 'rgba(' + [colors >> 16 & 255, colors >> 8 & 255, colors & 255].join(',') + ",".concat(this.opacity, ")");
        } else if (/^rgba?\(([^\)]+)\)/.test(color)) {
          return color.replace(/^rgb\(([^\)]+)\)/, "rgba($1,".concat(this.opacity, ")"));
        }
        return this.color;
      },
      computedClass: function computedClass() {
        return this.isSpin ? "bk-spin-loading bk-spin-loading-".concat(this.size, " bk-spin-loading-").concat(this.theme) : "bk-loading1 bk-".concat(this.theme, " bk-size-").concat(this.size);
      },
      hasZIndexOption: function hasZIndexOption() {
        if (this.type === 'fixed') {
          return;
        }
        return typeof this.zIndex === 'number' && !isNan$1(this.zIndex);
      }
    },
    watch: {
      hide: function hide(newVal) {
        var _this = this;
        if (newVal) {
          var delay = isNaN(this.delay) ? 0 : Number(this.delay);
          clearTimeout(this.timer);
          if (delay > 0) {
            this.timer = setTimeout(function () {
              _this.hideLoading();
            }, delay);
          } else {
            this.hideLoading();
          }
        }
      },
      isShow: function isShow(newVal) {
        if (newVal && !this.hasZIndexOption) {
          this.zIndex = zIndexManager.nextZIndex();
        }
      },
      isLoading: {
        handler: function handler(newVal) {
          if (this.type === 'default') {
            if (newVal) {
              this.isShow = newVal;
            } else {
              this.hide = true;
            }
          }
        },
        immediate: true
      }
    },
    mounted: function mounted() {
      this.hide = false;
    },
    methods: {
      hideLoading: function hideLoading() {
        this.isShow = false;
        this.$el.addEventListener('transitionend', this.destroyEl);
      },
      destroyEl: function destroyEl() {
        this.$el.removeEventListener('transitionend', this.destroyEl);
        this.$destroy();
        this.$el.parentNode.removeChild(this.$el);
      },
      animationFinish: function animationFinish() {
        if (this.afterLeave && typeof this.afterLeave === 'function') {
          this.afterLeave();
        }
      }
    }
  };

  /* script */
  var __vue_script__$B = script$B;
  /* template */

  var __vue_render__$B = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.type === 'default' ? _c('div', {
      staticClass: "bk-loading bk-default-loading",
      class: _vm.extCls,
      style: {
        position: 'relative'
      }
    }, [_c('div', {
      staticClass: "bk-loading-body"
    }, [_vm._t("default")], 2), _c('transition', {
      attrs: {
        "name": "fade",
        "duration": {
          enter: _vm.duration
        }
      },
      on: {
        "after-leave": _vm.animationFinish
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isShow,
        expression: "isShow"
      }],
      staticClass: "bk-loading-wrapper",
      style: {
        zIndex: _vm.zIndex,
        backgroundColor: _vm.bgColor
      }
    }, [_c('div', {
      class: _vm.computedClass
    }, [_vm.isSpin ? [_c('div', {
      staticClass: "rotate rotate1"
    }), _c('div', {
      staticClass: "rotate rotate2"
    }), _c('div', {
      staticClass: "rotate rotate3"
    }), _c('div', {
      staticClass: "rotate rotate4"
    }), _c('div', {
      staticClass: "rotate rotate5"
    }), _c('div', {
      staticClass: "rotate rotate6"
    }), _c('div', {
      staticClass: "rotate rotate7"
    }), _c('div', {
      staticClass: "rotate rotate8"
    })] : [_c('div', {
      staticClass: "point point1"
    }), _c('div', {
      staticClass: "point point2"
    }), _c('div', {
      staticClass: "point point3"
    }), _c('div', {
      staticClass: "point point4"
    })]], 2), _c('div', {
      staticClass: "bk-loading-title"
    }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])], 1) : _c('transition', {
      attrs: {
        "name": "fade",
        "duration": {
          enter: _vm.duration
        }
      },
      on: {
        "after-leave": _vm.animationFinish
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isShow,
        expression: "isShow"
      }],
      staticClass: "bk-loading",
      class: _vm.extCls,
      style: {
        position: _vm.type,
        zIndex: _vm.zIndex,
        backgroundColor: _vm.bgColor
      }
    }, [_c('div', {
      staticClass: "bk-loading-wrapper"
    }, [_c('div', {
      class: _vm.computedClass
    }, [_vm.isSpin ? [_c('div', {
      staticClass: "rotate rotate1"
    }), _c('div', {
      staticClass: "rotate rotate2"
    }), _c('div', {
      staticClass: "rotate rotate3"
    }), _c('div', {
      staticClass: "rotate rotate4"
    }), _c('div', {
      staticClass: "rotate rotate5"
    }), _c('div', {
      staticClass: "rotate rotate6"
    }), _c('div', {
      staticClass: "rotate rotate7"
    }), _c('div', {
      staticClass: "rotate rotate8"
    })] : [_c('div', {
      staticClass: "point point1"
    }), _c('div', {
      staticClass: "point point2"
    }), _c('div', {
      staticClass: "point point3"
    }), _c('div', {
      staticClass: "point point4"
    })]], 2), _c('div', {
      staticClass: "bk-loading-title"
    }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])]);
  };

  var __vue_staticRenderFns__$B = [];
  /* style */

  var __vue_inject_styles__$B = undefined;
  /* scoped */

  var __vue_scope_id__$B = undefined;
  /* module identifier */

  var __vue_module_identifier__$B = undefined;
  /* functional template */

  var __vue_is_functional_template__$B = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$B = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$B,
    staticRenderFns: __vue_staticRenderFns__$B
  }, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, false, undefined, undefined, undefined);

  var LoadingConstructor = Vue.extend(__vue_component__$B);
  var instance;
  var Loading = function Loading() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (typeof options === 'string') {
      options = {
        title: options
      };
    }
    options.type = 'fixed';
    options.opacity = options.opacity || 0.9;
    options.color = options.color || '#ffffff';
    instance = new LoadingConstructor({
      propsData: options
    });
    if (isVNode(instance.title)) {
      instance.$slots.title = [instance.title];
      instance.title = null;
    } else {
      delete instance.$slots.title;
    }
    instance.viewmodel = instance.$mount();
    document.body.appendChild(instance.viewmodel.$el);
    instance.$dom = instance.viewmodel.$el;
    instance.viewmodel.isShow = true;
    return instance.viewmodel;
  };
  Loading.hide = function () {
    instance.viewmodel.hide = true;
  };
  Vue.prototype.$bkLoading = Loading;

  var Model = Vue.extend(__vue_component__$B);
  function show(el, options) {
    if (!el.$vm) {
      el.$vm = el.viewmodel.$mount();
      el.appendChild(el.$vm.$el);
    }
    el.$vm.duration = 0;
    Vue.nextTick(function () {
      el.$vm.isShow = true;
    });
  }
  function toggle(el, options) {
    if (!el.$vm) {
      el.$vm = el.viewmodel.$mount();
      el.appendChild(el.$vm.$el);
    }
    clearTimeout(el.$vm.timer);
    if (options.isLoading) {
      Vue.nextTick(function () {
        el.$vm.isShow = true;
      });
    } else {
      var delay = isNaN(options.delay) ? 0 : Number(options.delay);
      if (delay > 0) {
        el.$vm.timer = setTimeout(function () {
          el.$vm.isShow = false;
        }, delay);
      } else {
        el.$vm.isShow = false;
      }
    }
    if (options.title) {
      el.$vm.title = options.title;
    }
  }
  var bkLoading = {
    inserted: function inserted(el, binding) {
      var value = binding.value;
      var position = getComputedStyle(el).position;
      var options = {};
      if (!position || position !== 'relative' || position !== 'absolute') {
        el.style.position = 'relative';
      }
      for (var key in value) {
        if (key !== 'isLoading') {
          options[key] = value[key];
        }
      }
      options.delay = 3000;
      options.type = 'absolute';
      options.opacity = options.opacity || 0.9;
      options.color = options.color || '#ffffff';
      el.viewmodel = new Model({
        propsData: options
      });
      if (options.immediate) {
        show(el, binding.value);
      } else {
        toggle(el, binding.value);
      }
    },
    update: function update(el, binding) {
      toggle(el, binding.value);
    }
  };

  __vue_component__$B.install = function (Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var props = __vue_component__$B.props || {};
    keys$1(options).forEach(function (key) {
      if (props.hasOwnProperty(key)) {
        if (typeof props[key] === 'function' || props[key] instanceof Array) {
          props[key] = {
            type: props[key],
            default: options[key]
          };
        } else {
          props[key].default = options[key];
        }
      }
    });
    __vue_component__$B.name = options.namespace ? __vue_component__$B.name.replace('bk', options.namespace) : __vue_component__$B.name;
    Vue.component(__vue_component__$B.name, __vue_component__$B);
    Vue.directive('bkloading', bkLoading);
  };
  var bkLoading$1 = _extends(__vue_component__$B, {
    Loading: Loading,
    directive: bkLoading
  });

  _export(_export.S, 'Date', { now: function () { return new Date().getTime(); } });

  var now = _core.Date.now;

  var now$1 = now;

  var ICONS = {
    primary: 'icon-info-circle-shape',
    error: 'icon-close-circle-shape',
    warning: 'icon-exclamation-circle-shape',
    success: 'icon-check-circle-shape'
  };
  var script$C = {
    name: 'bk-message',
    mixins: [locale.mixin],
    data: function data() {
      return {
        theme: 'primary',
        message: '',
        delay: 3000,
        icon: '',
        dismissable: true,
        verticalOffset: 0,
        horizonOffset: 0,
        visible: false,
        countID: null,
        onClose: function onClose() {},
        extCls: '',
        copied: false,
        ellipsisCopy: false,
        showCopyText: false
      };
    },
    computed: {
      themeClass: function themeClass() {
        return "bk-message-".concat(this.theme);
      },
      verticalStyle: function verticalStyle() {
        return {
          top: "".concat(this.verticalOffset, "px")
        };
      },
      tipsIcon: function tipsIcon() {
        return this.icon || ICONS[this.theme];
      },
      singleEllipsis: function singleEllipsis() {
        return this.ellipsisLine === 1;
      },
      multiEllipsis: function multiEllipsis() {
        return this.ellipsisLine > 1;
      },
      ellipsisStyle: function ellipsisStyle() {
        return {
          '--line': this.ellipsisLine
        };
      },
      localeCopyText: function localeCopyText() {
        return this.copied ? this.t('bk.message.copied') : this.t('bk.message.copy');
      }
    },
    mounted: function mounted() {
      this.startCountDown();
    },
    methods: {
      destroyEl: function destroyEl() {
        this.$destroy();
        this.$el.parentNode && this.$el.parentNode.removeChild(this.$el);
      },
      startCountDown: function startCountDown() {
        var _this = this;
        if (this.delay > 0) {
          this.countID = setTimeout(function () {
            _this.visible && _this.close();
          }, this.delay);
        }
      },
      stopCountDown: function stopCountDown() {
        clearTimeout(this.countID);
      },
      close: function close() {
        this.visible = false;
        typeof this.onClose === 'function' && this.onClose();
      },
      copyContent: function copyContent() {
        if (!this.$refs.content || this.copied) return;
        var text = this.$refs.content.textContent;
        copyText(text);
        this.copied = true;
      },
      setShowCopyText: function setShowCopyText() {
        this.showCopyText = this.ellipsisCopy && checkOverflow(this.$refs.content);
      }
    }
  };

  /* script */
  var __vue_script__$C = script$C;
  /* template */

  var __vue_render__$C = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "vertical-move"
      },
      on: {
        "after-leave": _vm.destroyEl,
        "enter": _vm.setShowCopyText
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      class: ['bk-message', _vm.themeClass, _vm.extCls],
      style: _vm.verticalStyle,
      on: {
        "mouseenter": _vm.stopCountDown,
        "mouseleave": _vm.startCountDown
      }
    }, [_c('div', {
      staticClass: "bk-message-icon"
    }, [_c('i', {
      class: ['bk-icon', _vm.tipsIcon]
    })]), _c('div', {
      ref: "content",
      class: ['bk-message-content', {
        'multi-ellipsis': _vm.multiEllipsis,
        'ellipsis': _vm.singleEllipsis
      }],
      style: _vm.ellipsisStyle
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.message))])], 2), _vm.showCopyText ? _c('div', {
      class: ['bk-message-copy', {
        'copied': _vm.copied
      }],
      on: {
        "click": _vm.copyContent
      }
    }, [_vm._v("\n            " + _vm._s(_vm.localeCopyText) + "\n        ")]) : _vm._e(), _vm.dismissable ? _c('div', {
      staticClass: "bk-message-close"
    }, [_c('i', {
      class: ['bk-icon icon-close', _vm.showCopyText ? 'ml10' : 'ml30'],
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.close($event);
        }
      }
    })]) : _vm._e()])]);
  };

  var __vue_staticRenderFns__$C = [];
  /* style */

  var __vue_inject_styles__$C = undefined;
  /* scoped */

  var __vue_scope_id__$C = undefined;
  /* module identifier */

  var __vue_module_identifier__$C = undefined;
  /* functional template */

  var __vue_is_functional_template__$C = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$C = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$C,
    staticRenderFns: __vue_staticRenderFns__$C
  }, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, false, undefined, undefined, undefined);

  var MessageComponent = Vue.extend(__vue_component__$C);
  var messageList = [];
  var seed$1 = 0;
  var BkMessage = function BkMessage(config) {
    if (config.limit === 0) {
      BkMessage.batchClose();
      return;
    }
    if (config.limit > 0) {
      BkMessage.batchClose(config.limit);
    }
    var instanceId = "messageInstance_".concat(now$1(), "_").concat(seed$1++);
    var offsetY = _parseInt$2(config.offsetY) || 30;
    var spacing = _parseInt$2(config.spacing) || 10;
    if (config.ellipsisLine === null || config.ellipsisLine === undefined || config.ellipsisLine === '' || isNaN(config.ellipsisLine)) {
      config.ellipsisLine = 1;
    }
    var ellipsisLine = config.ellipsisLine;
    var verticalOffset = offsetY;
    if (typeof config === 'string' || typeof config === 'number') {
      config = {
        message: config
      };
    }
    var configClose = config.onClose;
    config.onClose = function () {
      BkMessage.close(instanceId, configClose);
    };
    var instance = new MessageComponent({
      data: config
    });
    if (config.message !== null && _typeof(config.message) === 'object' && config.message.hasOwnProperty('componentOptions')) {
      instance.$slots.default = [config.message];
      instance.message = null;
    }
    instance.id = instanceId;
    instance.spacing = spacing;
    instance.ellipsisLine = ellipsisLine;
    instance.verticalOffset = 0;
    instance.$mount();
    instance.dom = instance.$el;
    document.body.appendChild(instance.$el);
    messageList.forEach(function (item) {
      verticalOffset += _parseInt$2(item.$el.offsetHeight) + _parseInt$2(spacing);
    });
    instance.verticalOffset = verticalOffset;
    instance.horizonOffset = spacing;
    instance.visible = true;
    messageList.push(instance);
    return instance;
  };
  BkMessage.close = function (id, configClose) {
    var instanceIndex = -1;
    messageList.some(function (item, index) {
      if (item.id === id) {
        instanceIndex = index;
        return true;
      }
    });
    if (instanceIndex > -1) {
      var instance = messageList[instanceIndex];
      if (typeof configClose === 'function') {
        configClose(instance);
      }
      messageList.forEach(function (item, i) {
        if (i > instanceIndex) {
          item.verticalOffset -= instance.dom.offsetHeight + instance.spacing;
        }
      });
      messageList.splice(instanceIndex, 1);
    }
  };
  BkMessage.batchClose = function () {
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var len = messageList.length;
    if (limit <= len) {
      var InstancesShouldClose = messageList.slice(0, len - limit + 1);
      InstancesShouldClose.forEach(function (item) {
        item.close();
      });
    }
  };
  Vue.prototype.$bkMessage = BkMessage;

  var ICONS$1 = {
    primary: 'icon-info-circle-shape',
    error: 'icon-close-circle-shape',
    warning: 'icon-exclamation-circle-shape',
    success: 'icon-check-circle-shape'
  };
  var script$D = {
    name: 'bk-notify',
    mixins: [locale.mixin],
    data: function data() {
      return {
        theme: 'primary',
        icon: '',
        title: '',
        message: '',
        position: 'top-right',
        delay: 5000,
        dismissable: true,
        limitLine: 2,
        showViewMore: false,
        verticalOffset: 0,
        horizonOffset: 0,
        visible: false,
        limit: 0,
        countID: null,
        onClose: function onClose() {},
        extCls: '',
        useHTMLString: false
      };
    },
    computed: {
      themeClass: function themeClass() {
        return "bk-notify-".concat(this.theme);
      },
      vDirection: function vDirection() {
        return /top-/.test(this.position) ? 'top' : 'bottom';
      },
      hDirection: function hDirection() {
        return this.position.indexOf('right') > -1 ? 'right' : 'left';
      },
      placementStyle: function placementStyle() {
        var _ref;
        return _ref = {}, _defineProperty(_ref, this.hDirection, "".concat(this.horizonOffset, "px")), _defineProperty(_ref, this.vDirection, "".concat(this.verticalOffset, "px")), _ref;
      },
      contentStyle: function contentStyle() {
        var contentStyle = {};
        if (this.limitLine > 0) {
          contentStyle['max-height'] = "".concat(20 * this.limitLine, "px");
        }
        return contentStyle;
      },
      tipsIcon: function tipsIcon() {
        return this.icon || ICONS$1[this.theme];
      }
    },
    mounted: function mounted() {
      this.startCountDown();
    },
    methods: {
      destroyEl: function destroyEl() {
        this.$destroy();
        this.$el.parentNode && this.$el.parentNode.removeChild(this.$el);
      },
      onClickViewMore: function onClickViewMore() {
        typeof this.onViewMoreHandler === 'function' && this.onViewMoreHandler();
      },
      startCountDown: function startCountDown() {
        var _this = this;
        if (this.delay > 0) {
          this.countID = setTimeout(function () {
            _this.visible && _this.close();
          }, this.delay);
        }
      },
      stopCountDown: function stopCountDown() {
        clearTimeout(this.countID);
      },
      close: function close() {
        this.visible = false;
        typeof this.onClose === 'function' && this.onClose();
      }
    }
  };

  /* script */
  var __vue_script__$D = script$D;
  /* template */

  var __vue_render__$D = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "placement-slide"
      },
      on: {
        "after-leave": _vm.destroyEl
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      class: ['bk-notify', _vm.themeClass, _vm.hDirection, _vm.extCls],
      style: _vm.placementStyle,
      on: {
        "mouseenter": _vm.stopCountDown,
        "mouseleave": _vm.startCountDown
      }
    }, [_c('div', {
      staticClass: "bk-notify-icon"
    }, [_c('i', {
      class: ['bk-icon', _vm.tipsIcon]
    })]), _c('div', {
      staticClass: "bk-notify-content"
    }, [_vm.title ? _c('h3', {
      staticClass: "bk-notify-content-title"
    }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._t("default", [_c('div', {
      class: ['bk-notify-content-text', {
        limitLine: _vm.limitLine > 0
      }],
      style: _vm.contentStyle
    }, [!_vm.useHTMLString ? [_vm._v(_vm._s(_vm.message))] : _c('span', {
      domProps: {
        "innerHTML": _vm._s(_vm.message)
      }
    }), _vm.showViewMore ? _c('button', {
      staticClass: "showMoreBtn",
      on: {
        "click": _vm.onClickViewMore
      }
    }, [_vm._v("\n                        " + _vm._s(_vm.t('bk.notify.showMore')) + "\n                    ")]) : _vm._e()], 2)])], 2), _vm.dismissable ? _c('div', {
      staticClass: "bk-notify-close"
    }, [_c('i', {
      staticClass: "bk-icon icon-close",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.close($event);
        }
      }
    })]) : _vm._e()])]);
  };

  var __vue_staticRenderFns__$D = [];
  /* style */

  var __vue_inject_styles__$D = undefined;
  /* scoped */

  var __vue_scope_id__$D = undefined;
  /* module identifier */

  var __vue_module_identifier__$D = undefined;
  /* functional template */

  var __vue_is_functional_template__$D = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$D = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$D,
    staticRenderFns: __vue_staticRenderFns__$D
  }, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, false, undefined, undefined, undefined);

  var NotifyComponent = Vue.extend(__vue_component__$D);
  var notifyList = [];
  var seed$2 = 0;
  var BkNotify = function BkNotify(config) {
    if (config.limit === 0) {
      BkNotify.batchClose();
      return;
    }
    if (config.limit > 0) {
      BkNotify.batchClose(config.limit);
    }
    var instanceId = "notifyInstance_".concat(now$1(), "_").concat(seed$2++);
    var offsetY = config.offsetY || 30;
    var offsetX = config.offsetX || 10;
    var spacing = config.spacing || 10;
    var verticalOffset = offsetY;
    if (typeof config === 'string' || typeof config === 'number') {
      config = {
        message: config
      };
    }
    var configClose = config.onClose;
    config.onClose = function () {
      BkNotify.close(instanceId, configClose);
    };
    var instance = new NotifyComponent({
      data: config
    });
    if (config.message !== null && _typeof(config.message) === 'object' && config.message.hasOwnProperty('componentOptions')) {
      instance.$slots.default = [config.message];
      instance.message = null;
    }
    instance.id = instanceId;
    instance.spacing = spacing;
    instance.verticalOffset = 0;
    instance.$mount();
    instance.dom = instance.$el;
    document.body.appendChild(instance.$el);
    notifyList.forEach(function (item) {
      if (item.position === config.position) {
        verticalOffset += item.$el.offsetHeight + spacing;
      }
    });
    instance.verticalOffset = verticalOffset;
    instance.horizonOffset = offsetX;
    instance.visible = true;
    notifyList.push(instance);
    return instance;
  };
  BkNotify.close = function (id, configClose) {
    var instanceIndex = -1;
    notifyList.some(function (item, index) {
      if (item.id === id) {
        instanceIndex = index;
        return true;
      }
    });
    if (instanceIndex > -1) {
      var instance = notifyList[instanceIndex];
      if (typeof configClose === 'function') {
        configClose(instance);
      }
      notifyList.forEach(function (item, i) {
        if (item.position === instance.position && i > instanceIndex) {
          item.verticalOffset -= instance.dom.offsetHeight + instance.spacing;
        }
      });
      notifyList.splice(instanceIndex, 1);
    }
  };
  BkNotify.batchClose = function () {
    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var len = notifyList.length;
    if (limit <= len) {
      var InstancesShouldClose = notifyList.slice(0, len - limit + 1);
      InstancesShouldClose.forEach(function (item) {
        item.close();
      });
    }
  };
  Vue.prototype.$bkNotify = BkNotify;

  var script$E = {
    name: 'bk-option',
    props: {
      id: {
        type: [String, Number],
        required: true
      },
      name: {
        type: [String, Number],
        required: true
      },
      disabled: Boolean
    },
    inject: ['select', 'optionGroup'],
    data: function data() {
      return {
        unmatched: false,
        isHighlight: false
      };
    },
    computed: {
      isSelected: function isSelected() {
        if (this.select.multiple && isArray$1(this.select.selected)) {
          return this.select.selected.includes(this.id);
        }
        return this.select.selected === this.id;
      },
      lowerName: function lowerName() {
        return String(this.name).toLowerCase();
      }
    },
    created: function created() {
      this.select.registerOption(this);
      if (this.optionGroup) {
        this.optionGroup.registerOption(this);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.select.removeOption(this);
      if (this.optionGroup) {
        this.optionGroup.removeOption(this);
      }
    },
    methods: {
      handleOptionClick: function handleOptionClick() {
        if (this.disabled) {
          return false;
        }
        var select = this.select;
        if (this.isSelected && select.multiple) {
          select.unselectOption(this);
        } else if (!this.isSelected) {
          select.selectOption(this);
        }
        if (!select.multiple) {
          select.close();
        }
      }
    }
  };

  /* script */
  var __vue_script__$E = script$E;
  /* template */

  var __vue_render__$E = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.unmatched,
        expression: "!unmatched"
      }],
      staticClass: "bk-option",
      class: {
        'is-selected': _vm.isSelected,
        'is-disabled': _vm.disabled,
        'is-highlight': _vm.isHighlight
      },
      on: {
        "click": _vm.handleOptionClick
      }
    }, [_c('div', {
      staticClass: "bk-option-content"
    }, [_vm._t("default", [_c('div', {
      staticClass: "bk-option-content-default",
      attrs: {
        "title": _vm.name
      }
    }, [_vm.select.multiple && _vm.isSelected ? _c('i', {
      staticClass: "bk-option-icon bk-icon icon-check-1"
    }) : _vm._e(), _c('span', {
      staticClass: "bk-option-name",
      class: _vm.select.fontSizeCls
    }, [_vm._v("\n                    " + _vm._s(_vm.name) + "\n                ")])])])], 2)]);
  };

  var __vue_staticRenderFns__$E = [];
  /* style */

  var __vue_inject_styles__$E = undefined;
  /* scoped */

  var __vue_scope_id__$E = undefined;
  /* module identifier */

  var __vue_module_identifier__$E = undefined;
  /* functional template */

  var __vue_is_functional_template__$E = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$E = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$E,
    staticRenderFns: __vue_staticRenderFns__$E
  }, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$E);

  var script$F = {
    name: 'bk-option-group',
    components: {
      bkCheckbox: __vue_component__$8
    },
    props: {
      name: {
        type: String,
        required: true
      },
      showCount: {
        type: Boolean,
        default: true
      },
      showCollapse: {
        type: Boolean,
        default: false
      },
      isCollapse: {
        type: Boolean,
        default: false
      },
      readonly: {
        type: Boolean,
        default: false
      },
      showSelectAll: {
        type: Boolean,
        default: false
      }
    },
    provide: function provide() {
      return {
        optionGroup: this
      };
    },
    inject: ['select'],
    data: function data() {
      return {
        options: [],
        selectedAll: false,
        isLocalCollapse: false
      };
    },
    computed: {
      indeterminate: function indeterminate() {
        return !this.isSelectAllItems && !this.isEmpty;
      },
      isSelectAllItems: function isSelectAllItems() {
        return Array.prototype.every.call(this.options, function (option) {
          return option.isSelected;
        });
      },
      isEmpty: function isEmpty() {
        return Array.prototype.every.call(this.options, function (option) {
          return !option.isSelected;
        });
      },
      showPrefixOpt: function showPrefixOpt() {
        return !!this.showCollapse;
      },
      prefixOptionText: function prefixOptionText() {
        return this.isLocalCollapse ? '+' : '-';
      },
      unmatchedCount: function unmatchedCount() {
        return this.options.filter(function (option) {
          return option.unmatched;
        }).length;
      },
      visible: function visible() {
        var optionCount = this.options.length;
        if (!optionCount) {
          return true;
        }
        return optionCount !== this.unmatchedCount;
      }
    },
    watch: {
      isCollapse: {
        immediate: true,
        handler: function handler(isColl) {
          this.isLocalCollapse = isColl;
        }
      }
    },
    methods: {
      handleCheckAllClick: function handleCheckAllClick(e) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();
      },
      handleSelectAll: function handleSelectAll() {
        var _this = this;
        if (this.isSelectAllItems) {
          Array.prototype.forEach.call(this.options, function (option) {
            return _this.select.unselectOption(option);
          });
        } else {
          Array.prototype.forEach.call(this.options, function (option) {
            return _this.select.selectOption(option);
          });
        }
      },
      handleGroupNameClick: function handleGroupNameClick() {
        if (this.showCollapse && !this.readonly) {
          this.isLocalCollapse = !this.isLocalCollapse;
          this.$emit('collapse', this.isLocalCollapse);
          this.$emit('update:isCollapse', this.isLocalCollapse);
        }
      },
      registerOption: function registerOption(option) {
        this.options.push(option);
      },
      removeOption: function removeOption(option) {
        var index = this.options.indexOf(option);
        if (index > -1) {
          this.options.splice(index, 1);
        }
      }
    }
  };

  /* script */
  var __vue_script__$F = script$F;
  /* template */

  var __vue_render__$F = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.visible,
        expression: "visible"
      }],
      staticClass: "bk-option-group"
    }, [_c('div', {
      staticClass: "bk-option-group-name",
      class: [_vm.select.fontSizeCls, _vm.showCollapse && !_vm.readonly ? 'is-collapse' : ''],
      on: {
        "click": _vm.handleGroupNameClick
      }
    }, [_vm.showPrefixOpt ? [_c('span', {
      class: ['bk-option-group-prefix', _vm.readonly ? 'readonly' : '']
    }, [_vm._v(_vm._s(_vm.prefixOptionText))])] : _vm._e(), _vm._t("group-name", [_vm._v(_vm._s(_vm.name) + " "), _vm.showCount ? [_vm._v("(" + _vm._s(_vm.options.length) + ")")] : _vm._e()]), _vm.showSelectAll ? [_c('span', {
      staticClass: "btn-check-all"
    }, [_c('bk-checkbox', {
      attrs: {
        "indeterminate": _vm.indeterminate,
        "checked": _vm.isSelectAllItems
      },
      on: {
        "change": _vm.handleSelectAll
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.handleCheckAllClick($event);
        }
      }
    })], 1)] : _vm._e()], 2), _c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.isLocalCollapse,
        expression: "!isLocalCollapse"
      }],
      staticClass: "bk-group-options"
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$F = [];
  /* style */

  var __vue_inject_styles__$F = undefined;
  /* scoped */

  var __vue_scope_id__$F = undefined;
  /* module identifier */

  var __vue_module_identifier__$F = undefined;
  /* functional template */

  var __vue_is_functional_template__$F = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$F = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$F,
    staticRenderFns: __vue_staticRenderFns__$F
  }, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$F);

  var meta = _meta.onFreeze;
  _objectSap('seal', function ($seal) {
    return function seal(it) {
      return $seal && _isObject(it) ? $seal(meta(it)) : it;
    };
  });

  var seal = _core.Object.seal;

  var seal$1 = seal;

  var script$G = {
    name: 'bk-popover',
    mixins: [zIndex$1],
    props: {
      placement: {
        type: String,
        default: 'top'
      },
      content: {
        type: String,
        default: ''
      },
      theme: {
        type: String,
        default: 'dark'
      },
      interactive: {
        type: [Boolean, String],
        default: true
      },
      arrow: {
        type: [Boolean, String],
        default: true
      },
      arrowType: {
        type: String,
        default: 'sharp'
      },
      boundary: {
        type: String,
        default: 'window'
      },
      showOnInit: {
        type: Boolean,
        default: false
      },
      arrowTransform: {
        type: String,
        default: ''
      },
      trigger: {
        type: String,
        default: 'mouseenter focus'
      },
      animation: {
        type: String,
        default: 'shift-away'
      },
      distance: {
        type: Number,
        default: 10
      },
      width: {
        type: [String, Number],
        default: 'auto'
      },
      maxWidth: {
        type: [String, Number],
        default: 'auto'
      },
      offset: {
        type: [Number, String],
        default: 0
      },
      always: {
        type: Boolean,
        default: false
      },
      followCursor: {
        type: [Boolean, String],
        default: false
      },
      sticky: {
        type: [Boolean, String],
        default: false
      },
      delay: {
        type: Number,
        default: 100
      },
      size: {
        type: String,
        default: 'small'
      },
      onShow: {
        type: Function,
        default: function _default() {}
      },
      onHide: {
        type: Function,
        default: function _default() {}
      },
      tippyOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      disabled: Boolean
    },
    data: function data() {
      return {
        instance: null
      };
    },
    watch: {
      disabled: function disabled(_disabled) {
        if (this.instance) {
          _disabled ? this.instance.disable() : this.instance.enable();
        }
      },
      tippyOptions: function tippyOptions(v) {
        this.instance && this.instance.set(v);
      }
    },
    mounted: function mounted() {
      var _this = this;
      var options = getValidTippyProps(_extends({}, {
        appendTo: popManager.container
      }, this.$props, this.tippyOptions));
      var onShow = options.onShow;
      var onHide = options.onHide;
      options.onShow = function (tip) {
        tip.set({
          zIndex: _this.getLocalZIndex(_this.zIndex)
        });
        onShow && onShow(tip);
        _this.$emit('show');
      };
      options.onHide = function (tip) {
        onHide && onHide(tip);
        _this.$emit('hide');
      };
      options.content = this.$refs.html;
      if (this.always) {
        options.showOnInit = true;
        options.hideOnClick = false;
        options.trigger = 'manual';
      }
      this.instance = tippy(this.$refs.reference, options);
      if (this.disabled) {
        this.instance.disable();
      }
    },
    updated: function updated() {
      this.instance.setContent(this.$refs.html);
      if (this.instance.popperInstance) {
        this.instance.popperInstance.update();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.instance.destroy();
    },
    methods: {
      showHandler: function showHandler() {
        this.instance.show();
      },
      hideHandler: function hideHandler() {
        this.instance.hide();
      }
    }
  };

  /* script */
  var __vue_script__$G = script$G;
  /* template */

  var __vue_render__$G = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-tooltip"
    }, [_c('div', {
      ref: "html",
      staticClass: "bk-tooltip-content"
    }, [_vm._t("content", [_vm._v(_vm._s(_vm.content))])], 2), _c('div', {
      ref: "reference",
      staticClass: "bk-tooltip-ref",
      attrs: {
        "tabindex": "-1"
      }
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$G = [];
  /* style */

  var __vue_inject_styles__$G = undefined;
  /* scoped */

  var __vue_scope_id__$G = undefined;
  /* module identifier */

  var __vue_module_identifier__$G = undefined;
  /* functional template */

  var __vue_is_functional_template__$G = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$G = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$G,
    staticRenderFns: __vue_staticRenderFns__$G
  }, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$G, function (Vue, options) {
    Vue.prototype.$bkPopover = function (el, options) {
      return tippy(el, options);
    };
  });

  var script$H = {
    name: 'bk-option-all',
    mixins: [locale.mixin],
    inject: ['select'],
    data: function data() {
      return {
        enabledOptions: []
      };
    },
    computed: {
      disabled: function disabled() {
        return !this.enabledOptions.length;
      },
      isAllSelected: function isAllSelected() {
        return !this.enabledOptions.some(function (option) {
          return !option.isSelected;
        });
      }
    },
    watch: {
      'select.options': {
        immediate: true,
        handler: function handler(options) {
          this.setEnabledOptions();
        }
      }
    },
    methods: {
      setEnabledOptions: function setEnabledOptions() {
        this.enabledOptions = this.select.options.filter(function (option) {
          return !option.disabled;
        });
      },
      handleOptionClick: function handleOptionClick() {
        if (this.disabled) {
          return false;
        }
        if (this.isAllSelected) {
          this.select.reset();
        } else {
          this.select.selectAll();
        }
      }
    }
  };

  /* script */
  var __vue_script__$H = script$H;
  /* template */

  var __vue_render__$H = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      staticClass: "bk-option",
      class: {
        'is-disabled': _vm.disabled
      },
      on: {
        "click": _vm.handleOptionClick
      }
    }, [_c('div', {
      staticClass: "bk-option-content"
    }, [_c('span', {
      staticClass: "bk-option-name"
    }, [_vm._v("\n            " + _vm._s(_vm.t('bk.select.selectAll')) + "\n            "), _vm.isAllSelected ? [_vm._v("\n                " + _vm._s("(" + _vm.select.selectedOptions.length + ")") + "\n            ")] : _vm._e()], 2)])]);
  };

  var __vue_staticRenderFns__$H = [];
  /* style */

  var __vue_inject_styles__$H = undefined;
  /* scoped */

  var __vue_scope_id__$H = undefined;
  /* module identifier */

  var __vue_module_identifier__$H = undefined;
  /* functional template */

  var __vue_is_functional_template__$H = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$H = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$H,
    staticRenderFns: __vue_staticRenderFns__$H
  }, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, false, undefined, undefined, undefined);

  var script$I = {
    inject: ['select'],
    data: function data() {
      return {
        overflowTagNode: null,
        overflowTagIndex: null
      };
    },
    mounted: function mounted() {
      var _this = this;
      this.calcOverflow();
      this.$watch(function () {
        return _this.select.focus;
      }, this.calcOverflow);
      this.$watch(function () {
        return _this.select.selected;
      }, this.calcOverflow);
    },
    methods: {
      handleRemoveSelected: function handleRemoveSelected(event, option) {
        if (this.select.disabled || this.select.readonly) {
          return false;
        }
        event.stopPropagation();
        this.select.handleTabRemove(option);
        this.select.unselectOption(option);
      },
      getTagDOM: function getTagDOM(index) {
        var tags = [].slice.call(this.$el.querySelectorAll('.bk-select-tag'));
        return typeof index === 'number' ? tags[index] : tags;
      },
      calcOverflow: function calcOverflow() {
        var _this2 = this;
        this.reomveOverflowTagNode();
        if (!this._isMounted || !this.select.collapseTag || this.select.focus || this.select.selected.length < 2) {
          return false;
        }
        setTimeout(function () {
          var tags = _this2.getTagDOM();
          var tagIndexInSecondRow = tags.findIndex(function (currentUser, index) {
            if (!index) {
              return false;
            }
            var previousTag = tags[index - 1];
            return previousTag.offsetTop !== currentUser.offsetTop;
          });
          if (tagIndexInSecondRow > -1) {
            _this2.overflowTagIndex = tagIndexInSecondRow;
          } else {
            _this2.overflowTagIndex = null;
          }
          _this2.$el.scrollTop = 0;
          _this2.insertOverflowTag();
        });
      },
      insertOverflowTag: function insertOverflowTag() {
        var _this3 = this;
        if (!this.overflowTagIndex) {
          return;
        }
        var overflowTagNode = this.getOverflowTagNode();
        var referenceTag = this.getTagDOM(this.overflowTagIndex);
        if (referenceTag) {
          this.setOverflowTagContent();
          this.$el.insertBefore(overflowTagNode, referenceTag);
        } else {
          this.overflowTagIndex = null;
          return;
        }
        setTimeout(function () {
          var previousTag = _this3.getTagDOM(_this3.overflowTagIndex - 1);
          if (overflowTagNode.offsetTop !== previousTag.offsetTop) {
            _this3.overflowTagIndex--;
            _this3.$el.insertBefore(overflowTagNode, overflowTagNode.previousSibling);
            _this3.setOverflowTagContent();
          }
        });
      },
      setOverflowTagContent: function setOverflowTagContent() {
        this.overflowTagNode.textContent = "+".concat(this.select.selected.length - this.overflowTagIndex);
      },
      getOverflowTagNode: function getOverflowTagNode() {
        if (this.overflowTagNode) {
          return this.overflowTagNode;
        }
        var overflowTagNode = document.createElement('span');
        overflowTagNode.className = 'bk-select-overflow-tag';
        this.overflowTagNode = overflowTagNode;
        return overflowTagNode;
      },
      reomveOverflowTagNode: function reomveOverflowTagNode() {
        if (this.overflowTagNode && this.overflowTagNode.parentNode === this.$el) {
          this.$el.removeChild(this.overflowTagNode);
        }
      }
    }
  };

  /* script */
  var __vue_script__$I = script$I;
  /* template */

  var __vue_render__$I = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-select-tag-container",
      class: {
        'is-fixed-height': _vm.select.collapseTag,
        'is-focus': _vm.select.focus,
        'is-available': !_vm.select.disabled && !_vm.select.readonly,
        'is-disabled': _vm.select.disabled,
        'is-readonly': _vm.select.readonly,
        'is-large-size': _vm.select.size === 'large',
        'is-small-size': _vm.select.size === 'small',
        'has-prefix-icon': !!_vm.select.prefixIcon
      }
    }, _vm._l(_vm.select.selectedOptions, function (option) {
      return _c('div', {
        key: option.id,
        staticClass: "bk-select-tag",
        class: {
          'width-limit-tag': _vm.select.isTagWidthLimit
        }
      }, [_c('span', [_vm._v(_vm._s(option.name))]), _c('i', {
        staticClass: "bk-icon icon-close",
        on: {
          "click": function click($event) {
            _vm.handleRemoveSelected($event, option);
          }
        }
      })]);
    }), 0);
  };

  var __vue_staticRenderFns__$I = [];
  /* style */

  var __vue_inject_styles__$I = undefined;
  /* scoped */

  var __vue_scope_id__$I = undefined;
  /* module identifier */

  var __vue_module_identifier__$I = undefined;
  /* functional template */

  var __vue_is_functional_template__$I = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$I = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$I,
    staticRenderFns: __vue_staticRenderFns__$I
  }, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, false, undefined, undefined, undefined);

  var UNIHANS = ["\u963F", "\u54CE", "\u5B89", "\u80AE", "\u51F9", "\u516B", "\u6300", "\u6273", "\u90A6", "\u52F9", "\u9642", "\u5954", "\u4F3B", "\u5C44", "\u8FB9", "\u706C", "\u618B", "\u6C43", "\u51AB", "\u7676", "\u5CEC", "\u5693", "\u5072", "\u53C2", "\u4ED3", "\u64A1", "\u518A", "\u5D7E", "\u66FD", "\u53C9", "\u8286", "\u8FBF", "\u4F25", "\u6284", "\u8F66", "\u62BB", "\u9637", "\u5403", "\u5145", "\u62BD", "\u51FA", "\u6B3B", "\u63E3", "\u5DDB", "\u5205", "\u5439", "\u65FE", "\u9034", "\u5472", "\u5306", "\u51D1", "\u7C97", "\u6C46", "\u5D14", "\u90A8", "\u6413", "\u5491", "\u5446", "\u4E39", "\u5F53", "\u5200", "\u561A", "\u6265", "\u706F", "\u6C10", "\u7538", "\u5201", "\u7239", "\u4E01", "\u4E1F", "\u4E1C", "\u543A", "\u53BE", "\u8011", "\u5796", "\u5428", "\u591A", "\u59B8", "\u8BF6", "\u5940", "\u97A5", "\u513F", "\u53D1", "\u5E06", "\u531A", "\u98DE", "\u5206", "\u4E30", "\u8985", "\u4ECF", "\u7D11", "\u592B", "\u65EE", "\u4F85", "\u7518", "\u5188", "\u768B", "\u6208", "\u7ED9", "\u6839", "\u522F", "\u5DE5", "\u52FE", "\u4F30", "\u74DC", "\u4E56", "\u5173", "\u5149", "\u5F52", "\u4E28", "\u5459", "\u54C8", "\u548D", "\u4F44", "\u592F", "\u8320", "\u8BC3", "\u9ED2", "\u62EB", "\u4EA8", "\u5677", "\u53FF", "\u9F41", "\u4E4E", "\u82B1", "\u6000", "\u6B22", "\u5DDF", "\u7070", "\u660F", "\u5419", "\u4E0C", "\u52A0", "\u620B", "\u6C5F", "\u827D", "\u9636", "\u5DFE", "\u5755", "\u5182", "\u4E29", "\u51E5", "\u59E2", "\u5658", "\u519B", "\u5494", "\u5F00", "\u520A", "\u5FFC", "\u5C3B", "\u533C", "\u808E", "\u52A5", "\u7A7A", "\u62A0", "\u625D", "\u5938", "\u84AF", "\u5BBD", "\u5321", "\u4E8F", "\u5764", "\u6269", "\u5783", "\u6765", "\u5170", "\u5577", "\u635E", "\u808B", "\u52D2", "\u5D1A", "\u54E9", "\u4FE9", "\u5941", "\u826F", "\u64A9", "\u6BDF", "\u62CE", "\u4F36", "\u6E9C", "\u56D6", "\u9F99", "\u779C", "\u565C", "\u9A74", "\u5A08", "\u63A0", "\u62A1", "\u7F57", "\u5463", "\u5988", "\u57CB", "\u5ADA", "\u7264", "\u732B", "\u4E48", "\u5445", "\u95E8", "\u753F", "\u54AA", "\u5B80", "\u55B5", "\u4E5C", "\u6C11", "\u540D", "\u8C2C", "\u6478", "\u54DE", "\u6BEA", "\u55EF", "\u62CF", "\u8149", "\u56E1", "\u56D4", "\u5B6C", "\u7592", "\u5A1E", "\u6041", "\u80FD", "\u59AE", "\u62C8", "\u5A18", "\u9E1F", "\u634F", "\u56DC", "\u5B81", "\u599E", "\u519C", "\u7FBA", "\u5974", "\u5973", "\u597B", "\u759F", "\u9EC1", "\u632A", "\u5594", "\u8BB4", "\u5991", "\u62CD", "\u7705", "\u4E53", "\u629B", "\u5478", "\u55B7", "\u5309", "\u4E15", "\u56E8", "\u527D", "\u6C15", "\u59D8", "\u4E52", "\u948B", "\u5256", "\u4EC6", "\u4E03", "\u6390", "\u5343", "\u545B", "\u6084", "\u767F", "\u4EB2", "\u9751", "\u536D", "\u4E18", "\u533A", "\u5CD1", "\u7F3A", "\u590B", "\u5465", "\u7A63", "\u5A06", "\u60F9", "\u4EBA", "\u6254", "\u65E5", "\u8338", "\u53B9", "\u909A", "\u633C", "\u5827", "\u5A51", "\u77A4", "\u637C", "\u4EE8", "\u6BE2", "\u4E09", "\u6852", "\u63BB", "\u95AA", "\u68EE", "\u50E7", "\u6740", "\u7B5B", "\u5C71", "\u4F24", "\u5F30", "\u5962", "\u7533", "\u5347", "\u5C38", "\u53CE", "\u4E66", "\u5237", "\u8870", "\u95E9", "\u53CC", "\u813D", "\u542E", "\u8BF4", "\u53B6", "\u5FEA", "\u635C", "\u82CF", "\u72FB", "\u590A", "\u5B59", "\u5506", "\u4ED6", "\u56FC", "\u574D", "\u6C64", "\u5932", "\u5FD1", "\u71A5", "\u5254", "\u5929", "\u65EB", "\u5E16", "\u5385", "\u56F2", "\u5077", "\u51F8", "\u6E4D", "\u63A8", "\u541E", "\u4E47", "\u7A75", "\u6B6A", "\u5F2F", "\u5C23", "\u5371", "\u6637", "\u7FC1", "\u631D", "\u4E4C", "\u5915", "\u8672", "\u4ED9", "\u4E61", "\u7071", "\u4E9B", "\u5FC3", "\u661F", "\u51F6", "\u4F11", "\u5401", "\u5405", "\u524A", "\u5743", "\u4E2B", "\u6079", "\u592E", "\u5E7A", "\u503B", "\u4E00", "\u56D9", "\u5E94", "\u54DF", "\u4F63", "\u4F18", "\u625C", "\u56E6", "\u66F0", "\u6655", "\u5E00", "\u707D", "\u5142", "\u5328", "\u50AE", "\u5219", "\u8D3C", "\u600E", "\u5897", "\u624E", "\u635A", "\u6CBE", "\u5F20", "\u4F4B", "\u8707", "\u8D1E", "\u4E89", "\u4E4B", "\u4E2D", "\u5DDE", "\u6731", "\u6293", "\u62FD", "\u4E13", "\u5986", "\u96B9", "\u5B92", "\u5353", "\u4E72", "\u5B97", "\u90B9", "\u79DF", "\u94BB", "\u539C", "\u5C0A", "\u6628", "\u5159"];
  var PINYINS = ['A', 'AI', 'AN', 'ANG', 'AO', 'BA', 'BAI', 'BAN', 'BANG', 'BAO', 'BEI', 'BEN', 'BENG', 'BI', 'BIAN', 'BIAO', 'BIE', 'BIN', 'BING', 'BO', 'BU', 'CA', 'CAI', 'CAN', 'CANG', 'CAO', 'CE', 'CEN', 'CENG', 'CHA', 'CHAI', 'CHAN', 'CHANG', 'CHAO', 'CHE', 'CHEN', 'CHENG', 'CHI', 'CHONG', 'CHOU', 'CHU', 'CHUA', 'CHUAI', 'CHUAN', 'CHUANG', 'CHUI', 'CHUN', 'CHUO', 'CI', 'CONG', 'COU', 'CU', 'CUAN', 'CUI', 'CUN', 'CUO', 'DA', 'DAI', 'DAN', 'DANG', 'DAO', 'DE', 'DEN', 'DENG', 'DI', 'DIAN', 'DIAO', 'DIE', 'DING', 'DIU', 'DONG', 'DOU', 'DU', 'DUAN', 'DUI', 'DUN', 'DUO', 'E', 'EI', 'EN', 'ENG', 'ER', 'FA', 'FAN', 'FANG', 'FEI', 'FEN', 'FENG', 'FIAO', 'FO', 'FOU', 'FU', 'GA', 'GAI', 'GAN', 'GANG', 'GAO', 'GE', 'GEI', 'GEN', 'GENG', 'GONG', 'GOU', 'GU', 'GUA', 'GUAI', 'GUAN', 'GUANG', 'GUI', 'GUN', 'GUO', 'HA', 'HAI', 'HAN', 'HANG', 'HAO', 'HE', 'HEI', 'HEN', 'HENG', 'HM', 'HONG', 'HOU', 'HU', 'HUA', 'HUAI', 'HUAN', 'HUANG', 'HUI', 'HUN', 'HUO', 'JI', 'JIA', 'JIAN', 'JIANG', 'JIAO', 'JIE', 'JIN', 'JING', 'JIONG', 'JIU', 'JU', 'JUAN', 'JUE', 'JUN', 'KA', 'KAI', 'KAN', 'KANG', 'KAO', 'KE', 'KEN', 'KENG', 'KONG', 'KOU', 'KU', 'KUA', 'KUAI', 'KUAN', 'KUANG', 'KUI', 'KUN', 'KUO', 'LA', 'LAI', 'LAN', 'LANG', 'LAO', 'LE', 'LEI', 'LENG', 'LI', 'LIA', 'LIAN', 'LIANG', 'LIAO', 'LIE', 'LIN', 'LING', 'LIU', 'LO', 'LONG', 'LOU', 'LU', 'LV', 'LUAN', 'LVE', 'LUN', 'LUO', 'M', 'MA', 'MAI', 'MAN', 'MANG', 'MAO', 'ME', 'MEI', 'MEN', 'MENG', 'MI', 'MIAN', 'MIAO', 'MIE', 'MIN', 'MING', 'MIU', 'MO', 'MOU', 'MU', 'N', 'NA', 'NAI', 'NAN', 'NANG', 'NAO', 'NE', 'NEI', 'NEN', 'NENG', 'NI', 'NIAN', 'NIANG', 'NIAO', 'NIE', 'NIN', 'NING', 'NIU', 'NONG', 'NOU', 'NU', 'NV', 'NUAN', 'NVE', 'NUN', 'NUO', 'O', 'OU', 'PA', 'PAI', 'PAN', 'PANG', 'PAO', 'PEI', 'PEN', 'PENG', 'PI', 'PIAN', 'PIAO', 'PIE', 'PIN', 'PING', 'PO', 'POU', 'PU', 'QI', 'QIA', 'QIAN', 'QIANG', 'QIAO', 'QIE', 'QIN', 'QING', 'QIONG', 'QIU', 'QU', 'QUAN', 'QUE', 'QUN', 'RAN', 'RANG', 'RAO', 'RE', 'REN', 'RENG', 'RI', 'RONG', 'ROU', 'RU', 'RUA', 'RUAN', 'RUI', 'RUN', 'RUO', 'SA', 'SAI', 'SAN', 'SANG', 'SAO', 'SE', 'SEN', 'SENG', 'SHA', 'SHAI', 'SHAN', 'SHANG', 'SHAO', 'SHE', 'SHEN', 'SHENG', 'SHI', 'SHOU', 'SHU', 'SHUA', 'SHUAI', 'SHUAN', 'SHUANG', 'SHUI', 'SHUN', 'SHUO', 'SI', 'SONG', 'SOU', 'SU', 'SUAN', 'SUI', 'SUN', 'SUO', 'TA', 'TAI', 'TAN', 'TANG', 'TAO', 'TE', 'TENG', 'TI', 'TIAN', 'TIAO', 'TIE', 'TING', 'TONG', 'TOU', 'TU', 'TUAN', 'TUI', 'TUN', 'TUO', 'WA', 'WAI', 'WAN', 'WANG', 'WEI', 'WEN', 'WENG', 'WO', 'WU', 'XI', 'XIA', 'XIAN', 'XIANG', 'XIAO', 'XIE', 'XIN', 'XING', 'XIONG', 'XIU', 'XU', 'XUAN', 'XUE', 'XUN', 'YA', 'YAN', 'YANG', 'YAO', 'YE', 'YI', 'YIN', 'YING', 'YO', 'YONG', 'YOU', 'YU', 'YUAN', 'YUE', 'YUN', 'ZA', 'ZAI', 'ZAN', 'ZANG', 'ZAO', 'ZE', 'ZEI', 'ZEN', 'ZENG', 'ZHA', 'ZHAI', 'ZHAN', 'ZHANG', 'ZHAO', 'ZHE', 'ZHEN', 'ZHENG', 'ZHI', 'ZHONG', 'ZHOU', 'ZHU', 'ZHUA', 'ZHUAI', 'ZHUAN', 'ZHUANG', 'ZHUI', 'ZHUN', 'ZHUO', 'ZI', 'ZONG', 'ZOU', 'ZU', 'ZUAN', 'ZUI', 'ZUN', 'ZUO', ''];
  var EXCEPTIONS = {
    "\u66FE": 'ZENG',
    "\u6C88": 'SHEN',
    "\u55F2": 'DIA',
    "\u78A1": 'ZHOU',
    "\u8052": 'GUO',
    "\u7094": 'QUE',
    "\u86B5": 'KE',
    "\u7809": 'HUA',
    "\u5B24": 'MO',
    "\u5B37": 'MO',
    "\u8E52": 'PAN',
    "\u8E4A": 'XI',
    "\u4E2C": 'PAN',
    "\u9730": 'XIAN',
    "\u8398": 'XIN',
    "\u8C49": 'CHI',
    "\u9967": 'XING',
    "\u7B60": 'JUN',
    "\u957F": 'CHANG',
    "\u5E27": 'ZHEN',
    "\u5CD9": 'SHI',
    "\u90CD": 'NA',
    "\u828E": 'XIONG',
    "\u8C01": 'SHUI'
  };
  var DICT = {
    PINYINS: PINYINS,
    UNIHANS: UNIHANS,
    EXCEPTIONS: EXCEPTIONS
  };

  var FIRST_PINYIN_UNIHAN = "\u963F";
  var LAST_PINYIN_UNIHAN = "\u9FFF";
  var LATIN = 1;
  var PINYIN = 2;
  var UNKNOWN = 3;
  var supported = null;
  var COLLATOR;
  function patchDict(patchers) {
    if (!patchers) return;
    if (typeof patchers === 'function') {
      patchers = [patchers];
    }
    if (patchers.forEach) {
      patchers.forEach(function (p) {
        typeof p === 'function' && p(DICT);
      });
    }
  }
  function isSupported(force) {
    if (!force && supported !== null) {
      return supported;
    }
    if ((typeof Intl === "undefined" ? "undefined" : _typeof(Intl)) === 'object' && Intl.Collator) {
      COLLATOR = new Intl.Collator(['zh-Hans-CN', 'zh-CN']);
      supported = Intl.Collator.supportedLocalesOf(['zh-CN']).length === 1;
    } else {
      supported = false;
    }
    return supported;
  }
  function genToken(ch) {
    var UNIHANS = DICT.UNIHANS;
    var PINYINS = DICT.PINYINS;
    var EXCEPTIONS = DICT.EXCEPTIONS;
    var token = {
      source: ch
    };
    if (ch in EXCEPTIONS) {
      token.type = PINYIN;
      token.target = EXCEPTIONS[ch];
      return token;
    }
    var offset = -1;
    var cmp;
    if (ch.charCodeAt(0) < 256) {
      token.type = LATIN;
      token.target = ch;
      return token;
    } else {
      cmp = COLLATOR.compare(ch, FIRST_PINYIN_UNIHAN);
      if (cmp < 0) {
        token.type = UNKNOWN;
        token.target = ch;
        return token;
      } else if (cmp === 0) {
        token.type = PINYIN;
        offset = 0;
      } else {
        cmp = COLLATOR.compare(ch, LAST_PINYIN_UNIHAN);
        if (cmp > 0) {
          token.type = UNKNOWN;
          token.target = ch;
          return token;
        } else if (cmp === 0) {
          token.type = PINYIN;
          offset = UNIHANS.length - 1;
        }
      }
    }
    token.type = PINYIN;
    if (offset < 0) {
      var begin = 0;
      var end = UNIHANS.length - 1;
      while (begin <= end) {
        offset = ~~((begin + end) / 2);
        var unihan = UNIHANS[offset];
        cmp = COLLATOR.compare(ch, unihan);
        if (cmp === 0) {
          break;
        } else if (cmp > 0) {
          begin = offset + 1;
        } else {
          end = offset - 1;
        }
      }
    }
    if (cmp < 0) {
      offset--;
    }
    token.target = PINYINS[offset];
    if (!token.target) {
      token.type = UNKNOWN;
      token.target = token.source;
    }
    return token;
  }
  function parse(str) {
    if (typeof str !== 'string' || !isSupported()) {
      return str;
    }
    return str.split('').map(function (v) {
      return genToken(v);
    });
  }
  var pinyin = {
    isSupported: isSupported,
    parse: parse,
    patchDict: patchDict,
    genToken: genToken,
    convertToPinyin: function convertToPinyin(str, lowerCase, separator) {
      return parse(str).map(function (v) {
        if (lowerCase && v.type === PINYIN) {
          return v.target.toLowerCase();
        }
        return v.target;
      }).join(separator || '');
    }
  };

  function patcher(DICT) {
    DICT.EXCEPTIONS = {
      "\u55F2": 'DIA',
      "\u78A1": 'ZHOU',
      "\u8052": 'GUO',
      "\u7094": 'QUE',
      "\u86B5": 'KE',
      "\u7809": 'HUA',
      "\u5B37": 'MO',
      "\u8E4A": 'XI',
      "\u4E2C": 'PAN',
      "\u9730": 'XIAN',
      "\u8C49": 'CHI',
      "\u9967": 'XING',
      "\u5E27": 'ZHEN',
      "\u828E": 'XIONG',
      "\u8C01": 'SHUI',
      "\u94B6": 'KE'
    };
    DICT.UNIHANS[91] = "\u4F15";
    DICT.UNIHANS[347] = "\u4EDA";
    DICT.UNIHANS[393] = "\u8BCC";
    DICT.UNIHANS[39] = "\u5A64";
    DICT.UNIHANS[50] = "\u8160";
    DICT.UNIHANS[369] = "\u6538";
    DICT.UNIHANS[123] = "\u4E6F";
    DICT.UNIHANS[171] = "\u5215";
    DICT.UNIHANS[102] = "\u4F5D";
    DICT.UNIHANS[126] = "\u72BF";
    DICT.UNIHANS[176] = "\u5217";
    DICT.UNIHANS[178] = "\u5222";
    DICT.UNIHANS[252] = "\u5A1D";
    DICT.UNIHANS[330] = "\u5078";
  }
  function shouldPatch(toToken) {
    if (typeof toToken !== 'function') return false;
    if (toToken("\u4F15").target === 'FOU' && toToken("\u4EDA").target === 'XIA' && toToken("\u8BCC").target === 'ZHONG' && toToken("\u5A64").target === 'CHONG' && toToken("\u8160").target === 'CONG' && toToken("\u6538").target === 'YONG' && toToken("\u4E6F").target === 'HOU' && toToken("\u5215").target === 'LENG' && toToken("\u4F5D").target === 'GONG' && toToken("\u72BF").target === 'HUAI' && toToken("\u5217").target === 'LIAO' && toToken("\u5222").target === 'LIN' && toToken("\u94B6").target === 'E') {
      return true;
    }
    return false;
  }
  var patcher56L = {
    patcher: patcher,
    shouldPatch: shouldPatch
  };

  if (pinyin.isSupported() && patcher56L.shouldPatch(pinyin.genToken)) {
    pinyin.patchDict(patcher56L);
  }

  var script$J = {
    name: 'bk-virtual-scroll',
    props: {
      itemHeight: {
        type: Number,
        default: 16
      },
      showIndex: {
        type: Boolean,
        default: false
      },
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        ulHeight: 0,
        allListData: [],
        offscreenCanvas: '',
        indexList: [],
        listData: [],
        worker: {},
        mainWidth: 0,
        mainLeft: 0,
        totalHeight: 0,
        itemNumber: 0,
        totalNumber: 0,
        visHeight: 0,
        visWidth: 0,
        totalScrollHeight: 0,
        startMinMapMove: false,
        tempVal: 0,
        minMapTop: 0,
        minNavTop: 0,
        navHeight: 0,
        mapHeight: 0,
        moveRate: 0,
        bottomScrollWidth: Infinity,
        bottomScrollDis: 0,
        itemWidth: 0,
        isScrolling: false,
        isBottomMove: false,
        downPreDefault: false,
        upPreDefault: false,
        indexWidth: 0,
        observer: {}
      };
    },
    watch: {
      list: {
        handler: function handler(list) {
          this.setListData(list);
        },
        deep: true
      }
    },
    mounted: function mounted() {
      this.initStatus();
      this.initEvent();
      if (this.list.length > 0) this.setListData(this.list);
    },
    beforeDestroy: function beforeDestroy() {
      document.removeEventListener('mousemove', this.minNavMove);
      document.removeEventListener('mouseup', this.moveEnd);
      window.removeEventListener('resize', this.resize);
      if (MutationObserver) this.observer.disconnect();
      this.observer = {};
    },
    methods: {
      initStatus: function initStatus() {
        var mainEle = this.$refs.scrollHome;
        var scrollEle = this.$refs.scrollMain;
        this.visHeight = mainEle.offsetHeight || 300;
        this.visWidth = mainEle.offsetWidth || 300;
        var scrollWidth = scrollEle.scrollWidth || 0;
        this.itemWidth = scrollWidth;
        this.bottomScrollWidth = this.visWidth * this.visWidth / scrollWidth < 20 ? 20 : this.visWidth * this.visWidth / scrollWidth;
        var dpr = window.devicePixelRatio || 1;
        this.$refs.minNav.width = 8 * dpr;
        this.$refs.minNav.height = this.visHeight * dpr;
        this.$refs.minNav.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
      },
      initEvent: function initEvent() {
        document.addEventListener('mousemove', this.minNavMove);
        document.addEventListener('mouseup', this.moveEnd);
        window.addEventListener('resize', this.resize);
        if (MutationObserver) {
          this.observer = new MutationObserver(this.resize);
          this.observer.observe(this.$el, {
            attributes: true,
            attributeFilter: ['style']
          });
        }
      },
      resize: function resize(event) {
        var _this = this;
        this.slowExec(function () {
          var lastHeight = _this.visHeight;
          _this.initStatus();
          _this.setStatus();
          _this.minMapTop = _this.visHeight / lastHeight * _this.minMapTop;
          _this.minNavTop = _this.minMapTop * (_this.visHeight - _this.navHeight) / (_this.mapHeight - _this.visHeight / 8);
          _this.totalScrollHeight = _this.mapHeight === _this.canvasHeight / 8 ? 0 : _this.minMapTop / (_this.mapHeight - _this.visHeight / 8) * (_this.totalHeight - _this.visHeight);
          _this.getListData(_this.totalScrollHeight, true);
        });
      },
      handleWheel: function handleWheel(event) {
        var isVerticalScroll = event.wheelDeltaX !== undefined ? Math.abs(event.wheelDeltaY) > Math.abs(event.wheelDeltaX) : event.axis === 2;
        if (isVerticalScroll) this.handleVerticalScroll(event);else this.handleHorizontalScroll(event);
      },
      handleHorizontalScroll: function handleHorizontalScroll(event) {
        event.preventDefault();
        if (this.bottomScrollWidth >= this.mainWidth) return;
        var deltaX = -Math.max(-1, Math.min(1, event.wheelDeltaX || -event.detail));
        var bottomScrollLeft = this.bottomScrollDis + deltaX * 4;
        if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
        if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
        this.bottomScrollDis = bottomScrollLeft;
        this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
      },
      handleVerticalScroll: function handleVerticalScroll(event) {
        var deltaY = Math.max(-1, Math.min(1, event.wheelDeltaY || -event.detail));
        var shouldPreDefault = deltaY < 0 ? this.downPreDefault : this.upPreDefault;
        if (shouldPreDefault) event.preventDefault();
        if (this.isScrolling || this.itemHeight * this.totalNumber <= this.visHeight) return;
        var dis = 0;
        if (event.wheelDelta) dis = -1 / 5 * event.wheelDelta;
        if (event.detail) dis = event.detail;
        var tickGap = deltaY * -2;
        if (deltaY === 0) {
          dis = 0;
          tickGap = 0;
        }
        var scrollHeight = this.minMapTop + (dis + tickGap) * (this.mapHeight - this.visHeight / 8) / (this.totalHeight - this.itemHeight * this.itemNumber);
        var totalScrollHeight = 0;
        var minMapTop = 0;
        var minNavTop = 0;
        if (scrollHeight < 0) {
          totalScrollHeight = 0;
          minMapTop = 0;
          minNavTop = 0;
        } else if (scrollHeight >= 0 && scrollHeight <= this.mapHeight - this.visHeight / 8) {
          minMapTop = scrollHeight;
          minNavTop = this.minNavTop + (dis + tickGap) * (this.visHeight - this.navHeight) / (this.totalHeight - this.itemHeight * this.itemNumber);
          totalScrollHeight = scrollHeight * (this.totalHeight - this.itemHeight * this.itemNumber) / (this.mapHeight - this.visHeight / 8);
        } else {
          totalScrollHeight = this.totalHeight - this.visHeight;
          minMapTop = this.mapHeight - this.visHeight / 8;
          minNavTop = this.visHeight - this.navHeight;
        }
        this.minMapTop = minMapTop;
        this.minNavTop = minNavTop;
        this.isScrolling = true;
        this.getListData(totalScrollHeight);
      },
      scrollPageByIndex: function scrollPageByIndex(index) {
        var height = this.itemHeight * index;
        if (height <= 0) height = 0;else if (height >= this.totalHeight - this.visHeight) height = this.totalHeight - this.visHeight;
        if (this.totalHeight <= this.visHeight) height = 0;
        var heightDiff = this.totalHeight - this.visHeight || 1;
        this.minMapTop = height / heightDiff * (this.mapHeight - this.visHeight / 8);
        this.minNavTop = height / heightDiff * (this.visHeight - this.navHeight);
        this.getListData(height);
      },
      getListData: function getListData() {
        var totalScrollHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var isResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var postData = {
          type: 'wheelGetData',
          totalScrollHeight: totalScrollHeight,
          isResize: isResize,
          totalHeight: this.totalHeight,
          itemHeight: this.itemHeight,
          itemNumber: this.itemNumber,
          canvasHeight: this.visHeight,
          minMapTop: this.minMapTop,
          mapHeight: this.mapHeight
        };
        this.calcList(postData);
      },
      calcList: function calcList(_ref) {
        var totalScrollHeight = _ref.totalScrollHeight,
            itemHeight = _ref.itemHeight,
            itemNumber = _ref.itemNumber,
            canvasHeight = _ref.canvasHeight,
            minMapTop = _ref.minMapTop,
            totalHeight = _ref.totalHeight,
            mapHeight = _ref.mapHeight,
            isResize = _ref.isResize;
        var realHeight = mapHeight === canvasHeight / 8 ? 0 : minMapTop / (mapHeight - canvasHeight / 8) * (totalHeight - canvasHeight);
        var startIndex = Math.floor(realHeight / itemHeight);
        var endIndex = startIndex + itemNumber;
        startIndex = startIndex > 0 ? startIndex - 1 : 0;
        var listData = [];
        var indexList = [];
        var nums = Math.floor(startIndex * itemHeight / 500000);
        for (var i = startIndex; i <= endIndex; i++) {
          var top = i * itemHeight - nums * 500000;
          var value = this.allListData[i];
          if (value) {
            indexList.push({
              top: top,
              value: i + 1
            });
            listData.push({
              top: top,
              value: value
            });
          }
        }
        totalScrollHeight = totalScrollHeight - nums * 500000;
        this.indexList = indexList;
        this.listData = listData;
        this.totalScrollHeight = totalScrollHeight;
        var firstIndexObj = this.indexList[0] || {};
        var lastIndexObj = this.indexList[this.indexList.length - 1] || {};
        this.downPreDefault = lastIndexObj.value + 1 < this.totalNumber;
        this.upPreDefault = firstIndexObj.value > 1;
        this.isScrolling = false;
        this.$emit('change', listData.map(function (x) {
          return x.value;
        }));
      },
      addListData: function addListData(list) {
        this.allListData = this.allListData.concat(list);
        var number = this.totalNumber + list.length;
        var lastIndexData = this.indexList[this.indexList.length - 1] || {
          value: 0
        };
        if (this.totalNumber - lastIndexData.value <= 3) {
          this.freshDataScrollBottom(number);
        } else {
          this.freshDataNoScroll(number);
        }
        this.resize();
      },
      setListData: function setListData(list) {
        this.allListData = list;
        this.freshDataNoScroll(list.length);
        this.resize();
      },
      freshDataScrollBottom: function freshDataScrollBottom(number) {
        this.totalNumber = number;
        this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
        this.setStatus();
        this.scrollPageByIndex(this.totalNumber - this.itemNumber + 1);
      },
      freshDataNoScroll: function freshDataNoScroll(number) {
        var oldNumber = this.totalNumber;
        var oldItemNumber = this.itemNumber;
        var oldMapHeight = this.mapHeight;
        var oldVisHeight = this.visHeight;
        this.totalNumber = number;
        this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
        this.setStatus();
        this.getNumberChangeList({
          oldNumber: oldNumber,
          oldItemNumber: oldItemNumber,
          oldMapHeight: oldMapHeight,
          oldVisHeight: oldVisHeight
        });
      },
      getNumberChangeList: function getNumberChangeList(_ref2) {
        var oldNumber = _ref2.oldNumber,
            oldItemNumber = _ref2.oldItemNumber,
            oldMapHeight = _ref2.oldMapHeight,
            oldVisHeight = _ref2.oldVisHeight;
        var minMapTop = this.minMapTop * (oldNumber - oldItemNumber) / (this.totalNumber - this.itemNumber || 1) * ((this.mapHeight - this.visHeight / 8) / (oldMapHeight - oldVisHeight / 8 || 1));
        var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.totalHeight - this.visHeight);
        if (minMapTop <= 0 || this.navHeight >= this.visHeight) {
          minMapTop = 0;
          totalScrollHeight = 0;
        } else if (minMapTop > this.mapHeight - this.visHeight / 8) {
          minMapTop = this.mapHeight - this.visHeight / 8;
          totalScrollHeight = this.totalHeight - this.visHeight;
        }
        this.minMapTop = minMapTop;
        this.minNavTop = this.minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.visHeight - this.navHeight);
        this.getListData(totalScrollHeight);
      },
      setStatus: function setStatus() {
        this.totalHeight = this.totalNumber * this.itemHeight;
        this.itemNumber = this.totalHeight > this.visHeight ? Math.ceil(this.visHeight / this.itemHeight) : this.totalNumber;
        this.ulHeight = this.totalHeight > 400000 ? 1000000 : this.totalHeight;
        var heightRate = this.visHeight / this.totalHeight;
        var minNavHeight = heightRate * this.visHeight;
        this.navHeight = heightRate > 1 ? this.visHeight : minNavHeight < 20 ? 20 : minNavHeight;
        var moveMaxHeight = this.totalNumber * this.itemHeight / 8;
        this.mapHeight = moveMaxHeight < this.visHeight ? moveMaxHeight : this.visHeight;
        this.mainWidth = this.visWidth;
        if (this.$refs.scrollNav) this.mainWidth -= this.$refs.scrollNav.offsetWidth;
        if (this.showIndex) {
          this.mainWidth -= (Math.log10(this.totalNumber) + 1) * 7;
          this.mainLeft = (Math.log10(this.totalNumber) + 1) * 7;
        }
      },
      startBottomMove: function startBottomMove(event) {
        this.tempVal = event.screenX;
        this.startMinMapMove = true;
        this.isBottomMove = true;
      },
      startNavMove: function startNavMove(rate) {
        this.moveRate = rate;
        this.tempVal = event.screenY;
        this.startMinMapMove = true;
        this.$emit('virtual-scroll-scroll-bar-mouse', 'down');
        document.addEventListener('click', this.docClickHandler);
      },
      docClickHandler: function docClickHandler() {
        var _this2 = this;
        document.removeEventListener('click', this.docClickHandler);
        setTimeout(function () {
          _this2.$emit('virtual-scroll-scroll-bar-mouse', 'up');
        }, 0);
      },
      minNavMove: function minNavMove() {
        var _this3 = this;
        if (!this.startMinMapMove) return;
        if (this.isBottomMove) {
          var moveDis = event.screenX - this.tempVal;
          var bottomScrollLeft = this.bottomScrollDis + moveDis;
          if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
          if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
          this.bottomScrollDis = bottomScrollLeft;
          this.tempVal = event.screenX;
          this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
        } else {
          var _moveDis = event.screenY - this.tempVal;
          var minMapTop = this.minMapTop + _moveDis / this.moveRate * (this.mapHeight - this.visHeight / 8);
          if (minMapTop <= 0) minMapTop = 0;
          if (minMapTop >= this.mapHeight - this.visHeight / 8) minMapTop = this.mapHeight - this.visHeight / 8;
          var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8) * (this.totalHeight - this.visHeight);
          this.tempVal = event.screenY;
          this.minMapTop = minMapTop;
          this.minNavTop = minMapTop * (this.visHeight - this.navHeight) / (this.mapHeight - this.visHeight / 8);
          this.slowExec(function () {
            _this3.getListData(totalScrollHeight);
          });
        }
      },
      slowExec: function slowExec(callBack) {
        var now = +new Date();
        if (now - (this.slowExec.lastTime || 0) >= 100) {
          this.slowExec.lastTime = now;
          callBack();
        }
        window.clearTimeout(this.slowExec.timeId);
        this.slowExec.timeId = window.setTimeout(function () {
          callBack();
        }, 50);
      },
      moveEnd: function moveEnd(event) {
        event.preventDefault();
        this.startMinMapMove = false;
        this.isBottomMove = false;
      }
    }
  };

  /* script */
  var __vue_script__$J = script$J;
  /* template */

  var __vue_render__$J = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('section', {
      ref: "scrollHome",
      staticClass: "bk-scroll-home",
      class: _vm.extCls,
      on: {
        "mousewheel": _vm.handleWheel,
        "DOMMouseScroll": _vm.handleWheel
      }
    }, [_c('main', {
      staticClass: "bk-scroll-main"
    }, [_vm.showIndex ? _c('ul', {
      staticClass: "bk-scroll-index bk-scroll",
      style: {
        height: _vm.ulHeight + "px",
        top: -_vm.totalScrollHeight + "px",
        width: _vm.indexWidth + "px"
      }
    }, _vm._l(_vm.indexList, function (item, index) {
      return _c('li', {
        key: index,
        staticClass: "bk-scroll-item",
        style: {
          height: _vm.itemHeight + "px",
          top: item.top + "px"
        }
      }, [_vm._t("index", [_vm._v("\n                    " + _vm._s(item.value) + "\n                ")], {
        data: item.value
      })], 2);
    }), 0) : _vm._e(), _c('ul', {
      ref: "scrollMain",
      staticClass: "bk-scroll",
      style: {
        height: _vm.ulHeight + "px",
        top: -_vm.totalScrollHeight + "px",
        width: _vm.mainWidth + "px",
        left: _vm.mainLeft + "px"
      }
    }, _vm._l(_vm.listData, function (item) {
      return _c('li', {
        key: item.top,
        staticClass: "bk-scroll-item",
        style: {
          height: _vm.itemHeight + "px",
          top: item.top + "px",
          left: -_vm.bottomScrollDis * (_vm.itemWidth - _vm.mainWidth) / (_vm.mainWidth - _vm.bottomScrollWidth) + "px"
        }
      }, [_vm._t("default", null, {
        data: item.value
      })], 2);
    }), 0)]), _c('canvas', {
      ref: "minNav",
      staticClass: "bk-min-nav",
      style: "height: " + _vm.visHeight + "px;"
    }), _vm.navHeight < _vm.visHeight ? _c('span', {
      ref: "scrollNav",
      staticClass: "bk-min-nav-slide bk-nav-show",
      style: {
        height: _vm.navHeight + "px",
        top: _vm.minNavTop + "px"
      },
      on: {
        "mousedown": function mousedown($event) {
          _vm.startNavMove(_vm.visHeight - _vm.navHeight);
        }
      }
    }) : _vm._e(), _vm.bottomScrollWidth < _vm.mainWidth ? _c('span', {
      staticClass: "bk-min-nav-slide bk-bottom-scroll",
      style: {
        left: _vm.indexWidth + _vm.bottomScrollDis + "px",
        width: _vm.bottomScrollWidth + "px"
      },
      on: {
        "mousedown": _vm.startBottomMove
      }
    }) : _vm._e()]);
  };

  var __vue_staticRenderFns__$J = [];
  /* style */

  var __vue_inject_styles__$J = undefined;
  /* scoped */

  var __vue_scope_id__$J = undefined;
  /* module identifier */

  var __vue_module_identifier__$J = undefined;
  /* functional template */

  var __vue_is_functional_template__$J = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$J = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$J,
    staticRenderFns: __vue_staticRenderFns__$J
  }, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$J);

  var virtualOption = {
    name: 'bk-virtual-option',
    props: {
      renderFunc: Function,
      item: Object
    },
    components: {
      bkOption: __vue_component__$E
    },
    render: function render(h) {
      if (this.renderFunc) return this.renderFunc(this.item, h);else return h("bk-option", {
        "props": _objectSpread({}, this.item),
        "class": "bk-virtual-option"
      });
    }
  };

  var script$K = {
    name: 'bk-select',
    components: {
      bkPopover: __vue_component__$G,
      bkOptionAll: __vue_component__$H,
      bkSelectTag: __vue_component__$I,
      bkVirtualScroll: __vue_component__$J,
      virtualOption: virtualOption
    },
    directives: {
      bkloading: bkLoading
    },
    mixins: [emitter, locale.mixin, zIndex$1],
    props: {
      value: {
        type: [String, Number, Array],
        default: ''
      },
      isTagWidthLimit: {
        type: Boolean,
        default: true
      },
      multiple: Boolean,
      showSelectAll: Boolean,
      scrollHeight: {
        type: Number,
        default: 216
      },
      popoverMinWidth: Number,
      popoverWidth: Number,
      popoverOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      placeholder: {
        type: String,
        default: ''
      },
      clearable: {
        type: Boolean,
        default: true
      },
      disabled: Boolean,
      readonly: Boolean,
      loading: Boolean,
      searchable: Boolean,
      searchIgnoreCase: {
        type: Boolean,
        default: true
      },
      searchPlaceholder: {
        type: String,
        default: ''
      },
      size: {
        type: String,
        default: '',
        validator: function validator(val) {
          return ['', 'large', 'small'].includes(val);
        }
      },
      remoteMethod: {
        type: Function
      },
      emptyText: {
        type: String,
        default: ''
      },
      fontSize: {
        type: String,
        default: 'normal'
      },
      extCls: {
        type: String,
        default: ''
      },
      extPopoverCls: {
        type: String,
        default: ''
      },
      prefixIcon: {
        type: String,
        default: ''
      },
      displayTag: Boolean,
      collapseTag: {
        type: Boolean,
        default: true
      },
      searchWithPinyin: Boolean,
      enableVirtualScroll: {
        type: Boolean,
        default: false
      },
      virtualScrollRender: Function,
      list: Array,
      idKey: {
        type: String,
        default: 'id'
      },
      displayKey: {
        type: String,
        default: 'name'
      },
      itemHeight: {
        type: Number,
        default: 32
      },
      showEmpty: {
        type: Boolean,
        default: true
      },
      showOnInit: {
        type: Boolean,
        default: false
      },
      behavior: {
        type: String,
        default: 'normal',
        validate: function validate(v) {
          return ['simplicity', 'normal'].indexOf(v) > -1;
        }
      }
    },
    provide: function provide() {
      return {
        select: this,
        optionGroup: null
      };
    },
    data: function data() {
      var selected = this.value;
      if (this.multiple && !isArray$1(selected)) {
        selected = [];
      }
      return {
        ready: false,
        focus: false,
        selected: selected,
        options: [],
        optionsMap: {},
        selectedOptions: this.multiple ? [] : null,
        defaultWidth: 0,
        selectSize: this.size,
        searchValue: '',
        searchTimer: null,
        searchLoading: false,
        autoUpdate: false,
        renderPopoverOptions: {},
        popoverDistance: 10 + _parseInt$2(variable_1)
      };
    },
    computed: {
      selectedName: function selectedName() {
        if (this.selectedOptions) {
          if (this.multiple) {
            return this.selectedOptions.map(function (option) {
              return option.name;
            }).join(',');
          }
          return this.selectedOptions.name;
        }
        return null;
      },
      isRemoteSearch: function isRemoteSearch() {
        return typeof this.remoteMethod === 'function';
      },
      shouldUpdate: function shouldUpdate() {
        return !this.isRemoteSearch || !this.searchValue;
      },
      isUnselected: function isUnselected() {
        if (this.multiple) {
          return !this.selected.length;
        }
        return this.selected === '';
      },
      unmatchedCount: function unmatchedCount() {
        return this.options.filter(function (option) {
          return option.unmatched;
        }).length;
      },
      localPlaceholder: function localPlaceholder() {
        return this.placeholder ? this.placeholder : this.t('bk.select.pleaseselect');
      },
      dropdownActive: function dropdownActive() {
        return !(this.disabled || this.loading || this.readonly);
      },
      popoverStyle: function popoverStyle() {
        return {
          width: (this.popoverWidth ? this.popoverWidth : this.defaultWidth) + 'px',
          minWidth: (this.popoverMinWidth ? this.popoverMinWidth : this.defaultWidth) + 'px'
        };
      },
      fontSizeCls: function fontSizeCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-font';
        } else if (this.fontSize === 'large') {
          cls = 'large-font';
        }
        return cls;
      },
      wrapperCls: function wrapperCls() {
        var wrapperCls = [];
        if (this.selectSize) {
          wrapperCls.push("bk-select-".concat(this.selectSize));
        }
        return wrapperCls;
      },
      popoverCls: function popoverCls() {
        var wrapperCls = [];
        if (this.selectSize) {
          wrapperCls.push("bk-select-popover-".concat(this.selectSize));
        }
        return wrapperCls;
      },
      localSearchPlaceholder: function localSearchPlaceholder() {
        return this.searchPlaceholder ? this.searchPlaceholder : this.t('bk.select.searchPlaceholder');
      }
    },
    watch: {
      value: function value(_value) {
        if (!this.isSame(_value, this.selected)) {
          this.selected = _value;
        }
      },
      focus: function focus(_focus) {
        var _this = this;
        if (!_focus) {
          this.resetSearchValue();
          this.dispatch('bk-form-item', 'form-blur');
        }
        this.$nextTick(function () {
          _this.$emit('toggle', _focus);
          _this.dispatch('bk-form-item', 'form-focus');
          if (_focus) _this.showVirtualScroll();
        });
      },
      dropdownActive: function dropdownActive() {
        this.setDropdownState();
      },
      searchValue: function searchValue(val) {
        var _this2 = this;
        this.searchTimer && clearTimeout(this.searchTimer);
        this.searchTimer = setTimeout(function () {
          if (_this2.isRemoteSearch) {
            _this2.remoteSearch();
          } else {
            _this2.search();
          }
        }, 100);
      },
      selected: function selected(value, oldValue) {
        if (this.shouldUpdate || this.autoUpdate) {
          this.setSelectedOptions();
        }
        this.$emit('input', value);
        this.$emit('change', value, oldValue);
        this.dispatch('bk-form-item', 'form-change');
      },
      list: {
        handler: function handler(val) {
          var _this3 = this;
          if (this.enableVirtualScroll) {
            this.optionsMap = {};
            this.options = val.map(function (option) {
              return seal$1(_objectSpread({}, option, {
                id: option[_this3.idKey],
                name: option[_this3.displayKey],
                lowerName: String(option[_this3.displayKey]).toLowerCase(),
                unmatched: false
              }));
            });
            this.options.forEach(function (option) {
              _this3.optionsMap[option.id] = option;
            });
          }
        },
        immediate: true
      },
      options: function options() {
        this.updatePopoverPosition();
        this.setSelectedOptions();
        this.showVirtualScroll();
      },
      size: function size(val) {
        this.selectSize = val;
      },
      multiple: function multiple(v) {
        if (v) {
          this.selectedOptions = [];
          this.selected = [];
        }
      },
      popoverOptions: {
        handler: function handler(v) {
          this.renderPopoverOptions = _extends({}, v);
        },
        immediate: true
      }
    },
    created: function created() {
      var _this4 = this;
      this.$nextTick(function () {
        _this4.setSelectedOptions();
      });
    },
    mounted: function mounted() {
      this.setDropdownState();
      this.setDropdownCallback();
      this.showOnInit && this.show();
    },
    methods: {
      virtualScrollScrollBarMouse: function virtualScrollScrollBarMouse(idx) {
        var renderPopoverOptions = _extends({}, this.renderPopoverOptions);
        renderPopoverOptions.hideOnClick = idx !== 'down';
        this.renderPopoverOptions = _extends({}, renderPopoverOptions);
      },
      showVirtualScroll: function showVirtualScroll() {
        var list = this.options.filter(function (option) {
          return !option.unmatched;
        });
        if (this.$refs.virtualScroll && this.enableVirtualScroll) this.$refs.virtualScroll.setListData(list);
      },
      setSelectedOptions: function setSelectedOptions() {
        var _this5 = this;
        if (this.multiple) {
          var existOptions = this.selectedOptions.filter(function (option) {
            return _this5.selected.includes(option.id);
          });
          var newSelected = this.selected.filter(function (value) {
            return !existOptions.some(function (option) {
              return option.id === value;
            });
          });
          newSelected.forEach(function (value) {
            var option = _this5.optionsMap[value];
            if (option) {
              existOptions.push(option);
            }
          });
          var selectedOptions = [];
          this.selected.forEach(function (value) {
            var option = existOptions.find(function (option) {
              return option.id === value;
            });
            if (option) {
              selectedOptions.push(option);
            }
          });
          this.selectedOptions = selectedOptions;
        } else {
          this.selectedOptions = this.optionsMap[this.selected];
        }
      },
      getPopoverInstance: function getPopoverInstance() {
        return this.$refs.selectDropdown.instance;
      },
      close: function close() {
        var popover = this.getPopoverInstance();
        popover.hide();
      },
      show: function show() {
        var popover = this.getPopoverInstance();
        popover.show();
      },
      updatePopoverPosition: function updatePopoverPosition() {
        if (this.focus) {
          var popover = this.getPopoverInstance();
          popover.popperInstance.scheduleUpdate();
        }
      },
      setDropdownState: function setDropdownState() {
        var popover = this.getPopoverInstance();
        if (this.dropdownActive) {
          popover.enable();
        } else {
          popover.disable();
        }
      },
      setDropdownCallback: function setDropdownCallback() {
        var _this6 = this;
        var popover = this.getPopoverInstance();
        popover.set({
          onShown: function onShown() {
            if (_this6.searchable) {
              _this6.$refs.searchInput.focus();
            }
          }
        });
      },
      handleDropdownShow: function handleDropdownShow() {
        this.defaultWidth = this.$el.offsetWidth;
        this.focus = true;
      },
      handleDropdownHide: function handleDropdownHide() {
        this.focus = false;
      },
      registerOption: function registerOption(option) {
        if (this.enableVirtualScroll) return;
        this.options.push(option);
        this.$set(this.optionsMap, option.id, option);
      },
      removeOption: function removeOption(option) {
        if (this.enableVirtualScroll) return;
        var index = this.options.indexOf(option);
        if (index > -1) {
          this.options.splice(index, 1);
        }
      },
      selectOption: function selectOption(option) {
        var _this7 = this;
        if (this.multiple) {
          if (!this.shouldUpdate) {
            this.selectedOptions.push(option);
          }
          this.selected = [].concat(_toConsumableArray(this.selected), [option.id]);
        } else {
          if (!this.shouldUpdate) {
            this.selectedOptions = option;
          }
          this.selected = option.id;
          this.close();
        }
        this.$nextTick(function () {
          _this7.$emit('selected', _this7.selected, _this7.selectedOptions);
        });
      },
      unselectOption: function unselectOption(option) {
        var _this8 = this;
        if (this.multiple) {
          if (!this.shouldUpdate) {
            this.selectedOptions = this.selectedOptions.filter(function (selectedOption) {
              return selectedOption.id !== option.id;
            });
          }
          this.selected = this.selected.filter(function (value) {
            return value !== option.id;
          });
        } else {
          this.setSelectedOptions = null;
          this.reset();
        }
        this.$nextTick(function () {
          _this8.$emit('selected', _this8.selected, _this8.selectedOptions);
        });
      },
      reset: function reset() {
        var _this9 = this;
        this.selectedOptions = this.multiple ? [] : null;
        var prevSelected = this.multiple ? _toConsumableArray(this.selected) : this.selected;
        this.selected = this.multiple ? [] : '';
        this.$nextTick(function () {
          _this9.$emit('clear', prevSelected);
        });
      },
      selectAll: function selectAll() {
        this.selected = this.options.filter(function (option) {
          return !option.disabled;
        }).map(function (option) {
          return option.id;
        });
      },
      search: function search() {
        var _this10 = this;
        this.searchLoading = true;
        var searchValue = String(this.searchValue).trim();
        if (searchValue) {
          if (this.searchIgnoreCase) {
            searchValue = searchValue.toLowerCase();
          }
          this.options.forEach(function (option) {
            if (_this10.searchIgnoreCase) {
              option.unmatched = option.lowerName.indexOf(searchValue) < 0;
            } else {
              option.unmatched = option.name.indexOf(searchValue) < 0;
            }
            if (option.unmatched && _this10.searchWithPinyin) {
              var pinyinList = pinyin.parse(_this10.searchIgnoreCase ? option.lowerName : option.name).map(function (v) {
                if (v.type === 2) {
                  return v.target.toLowerCase();
                }
                return v.target;
              });
              var pinyinStr = pinyinList.reduce(function (res, cur) {
                return res + cur[0];
              }, '');
              option.unmatched = pinyinList.join('').indexOf(searchValue) < 0 && pinyinStr.indexOf(searchValue) < 0;
            }
          });
        } else {
          this.options.forEach(function (option) {
            option.unmatched = false;
          });
        }
        this.showVirtualScroll();
        this.searchLoading = false;
      },
      remoteSearch: function remoteSearch() {
        var _this11 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _this11.searchLoading = true;
                  _context.next = 4;
                  return _this11.remoteMethod(_this11.searchValue);
                case 4:
                  _context.next = 9;
                  break;
                case 6:
                  _context.prev = 6;
                  _context.t0 = _context["catch"](0);
                  console.error(_context.t0);
                case 9:
                  _context.prev = 9;
                  _this11.searchLoading = false;
                  return _context.finish(9);
                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 6, 9, 12]]);
        }))();
      },
      resetSearchValue: function resetSearchValue() {
        this.searchValue = '';
      },
      isSame: function isSame(source, target) {
        var isArray = isArray$1(source) && isArray$1(target);
        if (isArray) {
          if (source.length !== target.length) {
            return false;
          }
          return !source.some(function (value, index) {
            return value !== target[index];
          });
        }
        return source === target;
      },
      handleClose: function handleClose() {
        this.close();
        this.$refs.bkSelect && this.$refs.bkSelect.focus();
      },
      handleTabRemove: function handleTabRemove(options) {
        this.$emit('tab-remove', options);
      }
    }
  };

  var img$8 = new Image(); img$8.src = 'data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLXNwaW4iIHdpZHRoPSI4MHB4IiBoZWlnaHQ9IjgwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODAsNTApIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDApIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMSIgdHJhbnNmb3JtPSJzY2FsZSgxLjA3NjY3IDEuMDc2NjcpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuOTE2NjY2NjY2NjY2NjY2NnMiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC45MTY2NjY2NjY2NjY2NjY2cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzUuOTgwNzYyMTEzNTMzMTYsNjUpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDI5Ljk5OTk5OTk5OTk5OTk5NikiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjkxNjY2NjY2NjY2NjY2NjYiIHRyYW5zZm9ybT0ic2NhbGUoMS4wOTMzMyAxLjA5MzMzKSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjgzMzMzMzMzMzMzMzMzMzRzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuODMzMzMzMzMzMzMzMzMzNHMiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY1LDc1Ljk4MDc2MjExMzUzMzE2KSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSg1OS45OTk5OTk5OTk5OTk5OSkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjgzMzMzMzMzMzMzMzMzMzQiIHRyYW5zZm9ybT0ic2NhbGUoMS4xMSAxLjExKSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjc1cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjc1cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTAsODApIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDkwKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNzUiIHRyYW5zZm9ybT0ic2NhbGUoMS4xMjY2NyAxLjEyNjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjY2NjY2NjY2NjY2NjY2NjZzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuNjY2NjY2NjY2NjY2NjY2NnMiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1LjAwMDAwMDAwMDAwMDAxLDc1Ljk4MDc2MjExMzUzMzE2KSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgxMTkuOTk5OTk5OTk5OTk5OTkpIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMC42NjY2NjY2NjY2NjY2NjY2IiB0cmFuc2Zvcm09InNjYWxlKDEuMTQzMzMgMS4xNDMzMykiPgogICAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0ic2NhbGUiIGJlZ2luPSItMC41ODMzMzMzMzMzMzMzMzM0cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjU4MzMzMzMzMzMzMzMzMzRzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNC4wMTkyMzc4ODY0NjY4NCw2NSkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMTUwLjAwMDAwMDAwMDAwMDAzKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNTgzMzMzMzMzMzMzMzMzNCIgdHJhbnNmb3JtPSJzY2FsZSgxLjE2IDEuMTYpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuNXMiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC41cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAsNTAuMDAwMDAwMDAwMDAwMDEpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDE4MCkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjUiIHRyYW5zZm9ybT0ic2NhbGUoMS4xNzY2NyAxLjE3NjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjQxNjY2NjY2NjY2NjY2NjdzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuNDE2NjY2NjY2NjY2NjY2N3MiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI0LjAxOTIzNzg4NjQ2NjgzNiwzNS4wMDAwMDAwMDAwMDAwMSkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjA5Ljk5OTk5OTk5OTk5OTk3KSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNDE2NjY2NjY2NjY2NjY2NyIgdHJhbnNmb3JtPSJzY2FsZSgxLjE5MzMzIDEuMTkzMzMpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMzMzMzMzMzMzMzMzMzMzM3MiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC4zMzMzMzMzMzMzMzMzMzMzcyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQuOTk5OTk5OTk5OTk5OTg2LDI0LjAxOTIzNzg4NjQ2Njg0NykiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjM5Ljk5OTk5OTk5OTk5OTk3KSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuMzMzMzMzMzMzMzMzMzMzMyIgdHJhbnNmb3JtPSJzY2FsZSgxLjAxIDEuMDEpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMjVzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuMjVzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0OS45OTk5OTk5OTk5OTk5OSwyMCkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjcwKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuMjUiIHRyYW5zZm9ybT0ic2NhbGUoMS4wMjY2NyAxLjAyNjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjUsMjQuMDE5MjM3ODg2NDY2ODQzKSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMDAuMDAwMDAwMDAwMDAwMDYpIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMC4xNjY2NjY2NjY2NjY2NjY2NiIgdHJhbnNmb3JtPSJzY2FsZSgxLjA0MzMzIDEuMDQzMzMpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NS45ODA3NjIxMTM1MzMxNiwzNC45OTk5OTk5OTk5OTk5ODYpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDMyOS45OTk5OTk5OTk5OTk5NCkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjA4MzMzMzMzMzMzMzMzMzMzIiB0cmFuc2Zvcm09InNjYWxlKDEuMDYgMS4wNikiPgogICAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0ic2NhbGUiIGJlZ2luPSIwcyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49IjBzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KPC9zdmc+'; var __$_require_ui_images_spinner_svg__ = img$8.src;

  /* script */
  var __vue_script__$K = script$K;

  var __vue_render__$K = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "bkSelect",
      staticClass: "bk-select",
      class: [{
        'is-focus': _vm.focus,
        'is-disabled': _vm.disabled,
        'is-readonly': _vm.readonly,
        'is-loading': _vm.loading,
        'is-unselected': _vm.isUnselected,
        'is-default-trigger': !_vm.$scopedSlots.trigger,
        'has-prefix-icon': !!_vm.prefixIcon,
        'only-bottom-border': _vm.behavior === 'simplicity'
      }, _vm.wrapperCls, _vm.fontSizeCls, _vm.extCls],
      attrs: {
        "data-placeholder": _vm.localPlaceholder,
        "tabindex": "0"
      },
      on: {
        "keydown": [function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.show($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
            return null;
          }

          return _vm.close($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
            return null;
          }

          $event.stopPropagation();
          $event.preventDefault();
          return _vm.close($event);
        }]
      }
    }, [!_vm.$scopedSlots.trigger ? [_vm.loading ? [_c('img', {
      staticClass: "bk-select-loading",
      attrs: {
        "src": __$_require_ui_images_spinner_svg__
      }
    })] : [_vm.clearable && !_vm.isUnselected && !_vm.disabled && !_vm.readonly ? _c('i', {
      staticClass: "bk-select-clear bk-icon icon-close-circle-shape",
      on: {
        "click": function click($event) {
          $event.preventDefault();
          $event.stopPropagation();
          return _vm.reset($event);
        }
      }
    }) : _vm._e(), _c('i', {
      staticClass: "bk-select-angle bk-icon icon-angle-down"
    })]] : _vm._e(), _c('bk-popover', {
      ref: "selectDropdown",
      staticClass: "bk-select-dropdown",
      attrs: {
        "trigger": "click",
        "placement": "bottom-start",
        "theme": "light bk-select-dropdown",
        "animation": "slide-toggle",
        "offset": -1,
        "distance": _vm.popoverDistance,
        "z-index": _vm.zIndex,
        "on-show": _vm.handleDropdownShow,
        "on-hide": _vm.handleDropdownHide,
        "tippy-options": _vm.renderPopoverOptions
      }
    }, [_vm.prefixIcon ? _c('i', {
      class: ['bk-select-prefix-icon', _vm.prefixIcon]
    }) : _vm._e(), _vm._t("trigger", [_vm.multiple && _vm.displayTag ? _c('bk-select-tag', {
      attrs: {
        "width-limit": _vm.isTagWidthLimit
      }
    }) : _c('div', {
      staticClass: "bk-select-name",
      class: _vm.fontSizeCls,
      attrs: {
        "title": _vm.selectedName
      }
    }, [_vm._v("\n                " + _vm._s(_vm.selectedName) + "\n            ")])], null, _vm.$props), _c('div', {
      staticClass: "bk-select-dropdown-content",
      class: [_vm.popoverCls, _vm.extPopoverCls],
      style: _vm.popoverStyle,
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [_vm.searchable ? _c('div', {
      staticClass: "bk-select-search-wrapper"
    }, [_c('i', {
      staticClass: "left-icon bk-icon icon-search"
    }), _c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: _vm.searchValue,
        expression: "searchValue"
      }],
      ref: "searchInput",
      staticClass: "bk-select-search-input",
      class: _vm.fontSizeCls,
      attrs: {
        "type": "text",
        "placeholder": _vm.localSearchPlaceholder
      },
      domProps: {
        "value": _vm.searchValue
      },
      on: {
        "keydown": [function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
            return null;
          }

          return _vm.handleClose($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
            return null;
          }

          $event.stopPropagation();
          $event.preventDefault();
          return _vm.handleClose($event);
        }],
        "input": function input($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.searchValue = $event.target.value;
        }
      }
    })]) : _vm._e(), _c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: _vm.searchLoading
        },
        expression: "{ isLoading: searchLoading }"
      }],
      staticClass: "bk-options-wrapper",
      style: {
        maxHeight: _vm.scrollHeight + 'px'
      }
    }, [_c('ul', {
      ref: "optionList",
      staticClass: "bk-options",
      class: {
        'bk-options-single': !_vm.multiple
      },
      style: {
        maxHeight: _vm.scrollHeight + 'px'
      }
    }, [_vm.multiple && _vm.showSelectAll && !_vm.searchValue ? _c('bk-option-all', {
      ref: "selectAllOption"
    }) : _vm._e(), _vm.enableVirtualScroll ? _c('bk-virtual-scroll', {
      ref: "virtualScroll",
      staticClass: "bk-virtual-select",
      style: {
        height: _vm.scrollHeight + 'px',
        width: '100%'
      },
      attrs: {
        "item-height": _vm.itemHeight
      },
      on: {
        "virtual-scroll-scroll-bar-mouse": _vm.virtualScrollScrollBarMouse
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(item) {
          return [_c('virtual-option', {
            attrs: {
              "item": item.data,
              "render-func": _vm.virtualScrollRender
            }
          })];
        }
      }])
    }) : _vm._t("default")], 2)]), _vm.showEmpty ? [!_vm.options.length ? _c('div', {
      staticClass: "bk-select-empty",
      class: _vm.fontSizeCls
    }, [_vm._v("\n                    " + _vm._s(_vm.emptyText || _vm.t('bk.select.dataEmpty')) + "\n                ")]) : _vm.searchable && _vm.unmatchedCount === _vm.options.length ? _c('div', {
      staticClass: "bk-select-empty",
      class: _vm.fontSizeCls
    }, [_vm._v("\n                    " + _vm._s(_vm.emptyText || _vm.t('bk.select.searchEmpty')) + "\n                ")]) : _vm._e()] : _vm._e(), _vm.$slots.extension ? _c('div', {
      staticClass: "bk-select-extension",
      class: _vm.fontSizeCls
    }, [_vm._t("extension")], 2) : _vm._e()], 2)], 2)], 2);
  };

  var __vue_staticRenderFns__$K = [];
  /* style */

  var __vue_inject_styles__$K = undefined;
  /* scoped */

  var __vue_scope_id__$K = undefined;
  /* module identifier */

  var __vue_module_identifier__$K = undefined;
  /* functional template */

  var __vue_is_functional_template__$K = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$K = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$K,
    staticRenderFns: __vue_staticRenderFns__$K
  }, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, false, undefined, undefined, undefined);

  /* script */

  /* template */
  var __vue_render__$L = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-page-selection-count', "bk-page-selection-count-" + _vm.$parent.realityLocation]
    }, [_vm.$parent.curLang === 'cn' ? [_vm._v("\n        已选择"), _c('span', {
      staticClass: "count"
    }, [_vm._v(_vm._s(_vm.$parent.selectionCount))]), _vm._v("条\n    ")] : [_c('span', {
      staticClass: "count"
    }, [_vm._v(_vm._s(_vm.$parent.selectionCount))]), _vm._v(" item(s) selected\n    ")]], 2);
  };

  var __vue_staticRenderFns__$L = [];
  /* style */

  var __vue_inject_styles__$L = undefined;
  /* scoped */

  var __vue_scope_id__$L = undefined;
  /* module identifier */

  var __vue_module_identifier__$L = undefined;
  /* functional template */

  var __vue_is_functional_template__$L = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$L = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$L,
    staticRenderFns: __vue_staticRenderFns__$L
  }, __vue_inject_styles__$L, {}, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, false, undefined, undefined, undefined);

  /* script */

  /* template */
  var __vue_render__$M = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.$parent.showTotalCount ? _c('div', {
      class: ['bk-page-total-count', "bk-page-total-count-" + _vm.$parent.realityLocation, {
        'bk-page-total-small': _vm.$parent.small
      }]
    }, [_vm.$parent.curLang === 'cn' ? [_vm._v("\n        共计"), _c('span', {
      staticClass: "stress"
    }, [_vm._v(_vm._s(_vm.$parent.count))]), _vm._v("条\n    ")] : [_vm._v("\n        Total: "), _c('span', {
      staticClass: "stress"
    }, [_vm._v(_vm._s(_vm.$parent.count))]), _vm._v(" items\n    ")]], 2) : _vm._e();
  };

  var __vue_staticRenderFns__$M = [];
  /* style */

  var __vue_inject_styles__$M = undefined;
  /* scoped */

  var __vue_scope_id__$M = undefined;
  /* module identifier */

  var __vue_module_identifier__$M = undefined;
  /* functional template */

  var __vue_is_functional_template__$M = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$M = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$M,
    staticRenderFns: __vue_staticRenderFns__$M
  }, __vue_inject_styles__$M, {}, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, false, undefined, undefined, undefined);

  var script$L = {
    name: 'small-jump',
    components: {
      bkPopover: __vue_component__$G
    },
    props: {
      current: {
        type: Number,
        default: ''
      },
      total: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        focus: false,
        currentPage: this.current
      };
    },
    watch: {
      current: function current(value) {
        this.currentPage = value;
      }
    },
    methods: {
      handleInputChange: function handleInputChange(event) {
        var $target = event.target;
        var value = Number($target.textContent);
        if (!value || value < 1 || value > this.total || value === this.current) return;
        this.currentPage = value;
        this.setSelection();
      },
      handleBlur: function handleBlur() {
        if (this.currentPage !== this.current) {
          this.$emit('on-change', this.currentPage);
        }
        this.focus = false;
        this.$refs.jumpInput && (this.$refs.jumpInput.textContent = this.currentPage);
      },
      handleStep: function handleStep(step) {
        var nextStep = this.current + step;
        if (nextStep > this.total) {
          return;
        }
        if (nextStep < 1) {
          return;
        }
        this.currentPage = nextStep;
        this.$emit('on-change', this.currentPage);
      },
      handleChangePage: function handleChangePage(value) {
        if (value === this.current) return this.hidePopover();
        this.currentPage = value;
        if (!this.focus) {
          this.handleBlur();
        }
        this.hidePopover();
      },
      getPopoverInstance: function getPopoverInstance() {
        return this.$refs.smallJumpPopover && this.$refs.smallJumpPopover.instance;
      },
      hidePopover: function hidePopover() {
        var instance = this.getPopoverInstance();
        instance && instance.hide();
      },
      showPopover: function showPopover() {
        var instance = this.getPopoverInstance();
        instance && instance.show();
      },
      setSelection: function setSelection() {
        var _this = this;
        this.$nextTick(function () {
          var $input = _this.$refs.jumpInput;
          $input.focus();
          var range = window.getSelection();
          range.selectAllChildren($input);
          range.collapseToEnd();
        });
      },
      handleKeyDown: function handleKeyDown(e) {
        if (['Enter', 'NumpadEnter'].includes(e.code)) {
          this.handleBlur();
          this.setSelection();
          this.focus = true;
          this.hidePopover();
          e.preventDefault();
          return false;
        }
      }
    }
  };

  /* script */
  var __vue_script__$L = script$L;
  /* template */

  var __vue_render__$N = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-page-small-jump"
    }, [_c('div', {
      staticClass: "btn-pre",
      class: {
        disable: _vm.current === 1
      },
      on: {
        "click": function click($event) {
          _vm.handleStep(-1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-left-shape"
    })]), _c('bk-popover', {
      ref: "smallJumpPopover",
      attrs: {
        "trigger": "manual",
        "placement": "bottom-start",
        "theme": "light bk-select-dropdown",
        "animation": "slide-toggle",
        "offset": -1,
        "distance": 12
      }
    }, [_c('div', {
      class: ['jump-input-wrapper', {
        'focus': _vm.focus
      }],
      on: {
        "click": function click($event) {
          $event.preventDefault();
          return _vm.showPopover($event);
        }
      }
    }, [_c('span', {
      ref: "jumpInput",
      staticClass: "jump-input",
      attrs: {
        "contenteditable": ""
      },
      domProps: {
        "textContent": _vm._s(_vm.current)
      },
      on: {
        "input": _vm.handleInputChange,
        "blur": _vm.handleBlur,
        "focus": function focus() {
          return _vm.focus = true;
        },
        "keydown": _vm.handleKeyDown
      }
    }), _c('span', {
      class: ['page-total', {
        'focus': _vm.focus
      }]
    }, [_vm._v("/ " + _vm._s(_vm.total))])]), _c('div', {
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [_c('ul', {
      staticClass: "small-jump-options"
    }, _vm._l(_vm.total, function (index) {
      return _c('li', {
        key: index,
        class: ['small-jump-option', {
          'is-selected': _vm.current === index
        }],
        on: {
          "mousedown": function mousedown($event) {
            _vm.handleChangePage(index);
          }
        }
      }, [_vm._v("\n                    " + _vm._s(index) + "\n                ")]);
    }), 0)])]), _c('div', {
      staticClass: "btn-next",
      class: {
        disable: _vm.current === _vm.total
      },
      on: {
        "click": function click($event) {
          _vm.handleStep(1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-right-shape"
    })])], 1);
  };

  var __vue_staticRenderFns__$N = [];
  /* style */

  var __vue_inject_styles__$N = undefined;
  /* scoped */

  var __vue_scope_id__$N = undefined;
  /* module identifier */

  var __vue_module_identifier__$N = undefined;
  /* functional template */

  var __vue_is_functional_template__$N = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$N = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$N,
    staticRenderFns: __vue_staticRenderFns__$N
  }, __vue_inject_styles__$N, __vue_script__$L, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, false, undefined, undefined, undefined);

  var script$M = {
    name: 'bk-pagination',
    components: {
      bkSelect: __vue_component__$K,
      bkOption: __vue_component__$E,
      paginationSelectionCount: __vue_component__$L,
      paginationTotalCount: __vue_component__$M,
      SmallJump: __vue_component__$N
    },
    mixins: [locale.mixin],
    props: {
      type: {
        type: String,
        default: 'default',
        validator: function validator(value) {
          return ['default', 'compact'].indexOf(value) > -1;
        }
      },
      small: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        default: 'default',
        validator: function validator(value) {
          return ['default', 'small'].indexOf(value) > -1;
        }
      },
      current: {
        type: Number,
        default: 1,
        required: true,
        validator: function validator(val) {
          var positiveInteger = /^[1-9]+[0-9]*]*$/;
          return positiveInteger.test(val);
        }
      },
      limit: {
        type: Number,
        required: true
      },
      count: {
        type: Number,
        default: 0,
        required: true
      },
      align: {
        type: String,
        default: 'left',
        validator: function validator(val) {
          return ['left', 'center', 'right'].includes(val);
        }
      },
      limitList: {
        type: Array,
        default: function _default() {
          return [10, 20, 50, 100];
        }
      },
      showLimit: {
        type: Boolean,
        default: true
      },
      location: {
        type: String,
        default: 'right',
        validator: function validator(val) {
          return ['left', 'right'].includes(val);
        }
      },
      showSelectionCount: Boolean,
      selectionCount: {
        type: Number,
        default: 0
      },
      showTotalCount: Boolean,
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        pageSize: 5,
        renderList: [],
        curGroup: 1,
        limitListTmp: [],
        realityLimit: this.limit || 10,
        toggle: false
      };
    },
    computed: {
      curLang: function curLang() {
        var l = locale.getCurLang().bk.lang;
        if (['zh', 'cn', 'zh-CN', 'zh-cn', 'zhCN', 'zhcn', 'zh-TW', 'zh-tw', 'zhTW', 'zhtw'].indexOf(l) > -1) {
          return 'cn';
        }
        return 'en';
      },
      total: function total() {
        return Math.ceil(this.count / this.realityLimit);
      },
      realityLocation: function realityLocation() {
        if (this.align === 'left') {
          return 'right';
        }
        if (this.align === 'right') {
          return 'left';
        }
        return this.location;
      }
    },
    watch: {
      realityLimit: function realityLimit(val, oldVal) {
        this.$emit('update:limit', val);
        this.$emit('limit-change', val, oldVal);
      },
      current: function current(newVal) {
        this.calcPageList(newVal);
      },
      total: function total(newVal) {
        this.calcPageList(this.current);
      },
      limit: function limit(newVal) {
        if (this.limitList.includes(newVal)) {
          this.realityLimit = newVal;
        } else {
          this.realityLimit = this.limitList[0];
        }
      },
      paginationIndex: function paginationIndex(newVal) {
        this.realityLimit = newVal;
      }
    },
    created: function created() {
      this.limitListTmp = this.limitList.map(function (page) {
        return {
          id: page,
          count: page
        };
      });
      if (this.limitList.includes(this.limit)) {
        this.realityLimit = this.limit;
      } else {
        this.realityLimit = this.limitList[0];
      }
      this.calcPageList(this.current);
    },
    methods: {
      _array: function _array(size) {
        return Array.apply(null, {
          length: size
        });
      },
      calcPageList: function calcPageList(current) {
        var total = this.total;
        var pageSize = this.pageSize;
        var size = pageSize > total ? total : pageSize;
        if (current >= size - 1) {
          if (total - current > Math.floor(size / 2)) {
            this.renderList = this._array(size).map(function (v, i) {
              return i + current - Math.ceil(size / 2) + 1;
            });
          } else {
            this.renderList = this._array(size).map(function (v, i) {
              return total - i;
            }).reverse();
          }
        } else {
          this.renderList = this._array(size).map(function (v, i) {
            return i + 1;
          });
        }
      },
      prevGroup: function prevGroup() {
        var pageSize = this.pageSize;
        var middlePage = this.renderList[Math.ceil(this.renderList.length / 2)];
        if (middlePage - pageSize < 1) {
          this.calcPageList(1);
        } else {
          this.calcPageList(middlePage - pageSize);
        }
        this.jumpToPage(this.renderList[Math.floor(this.renderList.length / 2)]);
      },
      nextGroup: function nextGroup() {
        var pageSize = this.pageSize;
        var total = this.total;
        var middlePage = this.renderList[Math.ceil(this.renderList.length / 2)];
        if (middlePage + pageSize > total) {
          this.calcPageList(total);
        } else {
          this.calcPageList(middlePage + pageSize);
        }
        this.jumpToPage(this.renderList[Math.floor(this.renderList.length / 2)]);
      },
      prevPage: function prevPage() {
        if (this.current !== 1) {
          this.jumpToPage(this.current - 1);
        }
      },
      nextPage: function nextPage() {
        if (this.current !== this.total) {
          this.jumpToPage(this.current + 1);
        }
      },
      jumpToPage: function jumpToPage(page) {
        this.$emit('update:current', page);
        this.$emit('change', page);
      }
    }
  };

  /* script */
  var __vue_script__$M = script$M;
  /* template */

  var __vue_render__$O = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.total > 0 ? _c('div', {
      class: ['bk-page', "bk-page-align-" + _vm.align, {
        'bk-page-compact': _vm.type === 'compact',
        'bk-page-small': _vm.size === 'small'
      }, _vm.extCls]
    }, [_vm.showTotalCount ? _c('pagination-total-count') : _vm._e(), _vm.showLimit ? _c('div', {
      class: ['bk-page-count', "bk-page-count-" + _vm.realityLocation, _vm.small && 'bk-page-count-small']
    }, [_vm.curLang === 'cn' ? [_c('span', [_vm._v("每页")]), _c('bk-select', {
      class: {
        'page-select-small': _vm.small && !_vm.toggle
      },
      attrs: {
        "placeholder": "页数",
        "clearable": false,
        "size": _vm.small ? 'small' : ''
      },
      on: {
        "toggle": function toggle(value) {
          return _vm.toggle = value;
        }
      },
      model: {
        value: _vm.realityLimit,
        callback: function callback($$v) {
          _vm.realityLimit = $$v;
        },
        expression: "realityLimit"
      }
    }, _vm._l(_vm.limitListTmp, function (p, index) {
      return _c('bk-option', {
        key: index,
        attrs: {
          "id": p.id,
          "name": p.count
        }
      });
    }), 1), _c('span', [_vm._v("条")])] : [_c('bk-select', {
      attrs: {
        "placeholder": "page",
        "clearable": false
      },
      model: {
        value: _vm.realityLimit,
        callback: function callback($$v) {
          _vm.realityLimit = $$v;
        },
        expression: "realityLimit"
      }
    }, _vm._l(_vm.limitListTmp, function (p, index) {
      return _c('bk-option', {
        key: index,
        attrs: {
          "id": p.id,
          "name": p.count + "/page"
        }
      });
    }), 1)]], 2) : _vm._e(), _vm.showSelectionCount ? _c('pagination-selection-count') : _vm._e(), !_vm.small ? _c('ul', {
      staticClass: "bk-page-list"
    }, [_c('li', {
      staticClass: "page-item",
      class: {
        disabled: _vm.current === 1
      },
      on: {
        "click": _vm.prevPage
      }
    }, [_vm._m(0)]), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.renderList[0] > 1,
        expression: "renderList[0] > 1"
      }],
      staticClass: "page-item",
      on: {
        "click": function click($event) {
          _vm.jumpToPage(1);
        }
      }
    }, [_c('a', {
      staticClass: "page-button",
      attrs: {
        "href": "javascript:void(0);"
      }
    }, [_vm._v("1")])]), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.renderList[0] > 2 && _vm.current > 3,
        expression: "renderList[0] > 2 && current > 3"
      }],
      class: ['page-item', {
        'page-omit': _vm.type !== 'compact'
      }],
      on: {
        "click": _vm.prevGroup
      }
    }, [_c('span', {
      staticClass: "page-button"
    }, [_vm._v("...")])]), _vm._l(_vm.renderList, function (item, index) {
      return _c('li', {
        key: index,
        staticClass: "page-item",
        class: {
          'cur-page': item === _vm.current
        },
        on: {
          "click": function click($event) {
            _vm.jumpToPage(item);
          }
        }
      }, [_c('a', {
        staticClass: "page-button",
        attrs: {
          "href": "javascript:void(0);"
        }
      }, [_vm._v(_vm._s(item))])]);
    }), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.renderList[_vm.renderList.length - 1] < _vm.total - 1,
        expression: "renderList[renderList.length - 1] < total - 1"
      }],
      class: ['page-item', {
        'page-omit': _vm.type !== 'compact'
      }],
      on: {
        "click": _vm.nextGroup
      }
    }, [_c('span', {
      staticClass: "page-button"
    }, [_vm._v("...")])]), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.renderList[_vm.renderList.length - 1] !== _vm.total,
        expression: "renderList[renderList.length - 1] !== total"
      }],
      staticClass: "page-item",
      class: {
        'cur-page': _vm.current === _vm.total
      },
      on: {
        "click": function click($event) {
          _vm.jumpToPage(_vm.total);
        }
      }
    }, [_c('a', {
      staticClass: "page-button",
      attrs: {
        "href": "javascript:void(0);"
      }
    }, [_vm._v(_vm._s(_vm.total))])]), _c('li', {
      staticClass: "page-item",
      class: {
        disabled: _vm.current === _vm.total
      },
      on: {
        "click": _vm.nextPage
      }
    }, [_vm._m(1)])], 2) : _c('small-jump', {
      attrs: {
        "current": _vm.current,
        "total": _vm.total
      },
      on: {
        "on-change": _vm.jumpToPage
      }
    })], 1) : _vm._e();
  };

  var __vue_staticRenderFns__$O = [function () {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('a', {
      staticClass: "page-button",
      attrs: {
        "href": "javascript:void(0);"
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-left"
    })]);
  }, function () {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('a', {
      staticClass: "page-button",
      attrs: {
        "href": "javascript:void(0);"
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-right"
    })]);
  }];
  /* style */

  var __vue_inject_styles__$O = undefined;
  /* scoped */

  var __vue_scope_id__$O = undefined;
  /* module identifier */

  var __vue_module_identifier__$O = undefined;
  /* functional template */

  var __vue_is_functional_template__$O = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$O = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$O,
    staticRenderFns: __vue_staticRenderFns__$O
  }, __vue_inject_styles__$O, __vue_script__$M, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$O);

  var script$N = {
    name: 'bk-popconfirm',
    components: {
      bkPopover: __vue_component__$G
    },
    mixins: [locale.mixin],
    props: {
      tirgger: {
        type: String,
        default: 'mouseenter focus'
      },
      title: {
        type: String
      },
      content: {
        type: String
      },
      theme: {
        type: String,
        default: 'light-border'
      },
      confirmText: {
        type: String
      },
      cancelText: {
        type: String
      },
      confirmButtonIsText: {
        type: Boolean,
        default: false
      },
      cancelButtonIsText: {
        type: Boolean,
        default: false
      },
      extPopoverCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {};
    },
    computed: {
      localeOkText: function localeOkText() {
        if (this.confirmText === undefined) {
          return this.t('bk.dialog.ok');
        }
        return this.confirmText;
      },
      localeCancelText: function localeCancelText() {
        if (this.cancelText === undefined) {
          return this.t('bk.dialog.cancel');
        }
        return this.cancelText;
      },
      isTiny: function isTiny() {
        return !this.$slots['content'] && !this.title && !this.content;
      },
      isSimple: function isSimple() {
        return !this.$slots['content'] && !this.title;
      },
      confirmButtonType: function confirmButtonType() {
        return this.isTiny || this.confirmButtonIsText ? 'text' : 'button';
      },
      cancelButtonType: function cancelButtonType() {
        return this.isTiny || this.cancelButtonIsText ? 'text' : 'button';
      }
    },
    methods: {
      confirm: function confirm() {
        this.$refs['popover'].hideHandler();
        this.$emit('confirm');
      },
      cancel: function cancel() {
        this.$refs['popover'].hideHandler();
        this.$emit('cancel');
      }
    }
  };

  /* script */
  var __vue_script__$N = script$N;
  /* template */

  var __vue_render__$P = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('bk-popover', _vm._b({
      ref: "popover",
      attrs: {
        "size": "regular",
        "theme": _vm.theme
      }
    }, 'bk-popover', _vm.$attrs, false), [_c('div', {
      staticClass: "bk-popconfirm-content",
      class: [_vm.extPopoverCls, {
        'popconfirm-more': !_vm.isTiny
      }],
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [!_vm.isTiny ? _c('div', {
      staticClass: "popconfirm-content"
    }, [_vm._t("content", [_vm.title ? _c('div', {
      staticClass: "title"
    }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm.content ? _c('div', {
      staticClass: "content",
      class: {
        'is-simple': _vm.isSimple
      }
    }, [_vm._v(_vm._s(_vm.content))]) : _vm._e()])], 2) : _vm._e(), _c('div', {
      staticClass: "popconfirm-operate"
    }, [_vm.localeOkText ? _c('button', {
      staticClass: "default-operate-button primary",
      attrs: {
        "type": _vm.confirmButtonType
      },
      on: {
        "click": _vm.confirm
      }
    }, [_vm._v(_vm._s(_vm.localeOkText))]) : _vm._e(), _vm.isTiny ? _c('span', {
      staticClass: "popconfirm-split"
    }) : _vm._e(), _vm.localeCancelText ? _c('button', {
      staticClass: "default-operate-button",
      attrs: {
        "type": _vm.cancelButtonType
      },
      on: {
        "click": _vm.cancel
      }
    }, [_vm._v(_vm._s(_vm.localeCancelText))]) : _vm._e()])]), _vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$P = [];
  /* style */

  var __vue_inject_styles__$P = undefined;
  /* scoped */

  var __vue_scope_id__$P = undefined;
  /* module identifier */

  var __vue_module_identifier__$P = undefined;
  /* functional template */

  var __vue_is_functional_template__$P = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$P = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$P,
    staticRenderFns: __vue_staticRenderFns__$P
  }, __vue_inject_styles__$P, __vue_script__$N, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$P);

  var script$O = {
    name: 'bk-process',
    props: {
      list: {
        type: Array,
        required: true
      },
      controllable: {
        type: Boolean,
        default: false
      },
      showSteps: {
        type: Boolean,
        default: false
      },
      curProcess: {
        type: Number,
        default: 0
      },
      displayKey: {
        type: String,
        required: true
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        toggleFlag: false,
        showFlag: this.showSteps,
        dataList: this.list,
        controllables: this.controllable,
        paddingBottom: 0,
        maxBottom: 0,
        stepsClientHeight: 32
      };
    },
    watch: {
      list: {
        handler: function handler(value) {
          this.initToggleFlag(value);
          this.dataList = _toConsumableArray(value);
          this.calculateMaxBottom(value);
        },
        deep: true
      },
      curProcess: function curProcess(newValue, oldValue) {
        if (newValue > this.list.length + 1) {
          return;
        }
        this.setParentProcessLoad(this.list);
      }
    },
    created: function created() {
      this.setParentProcessLoad(this.list);
    },
    mounted: function mounted() {
      this.initToggleFlag(this.list);
      this.calculateMaxBottom(this.list);
      if (this.showFlag) {
        this.paddingBottom = this.maxBottom;
      } else {
        this.paddingBottom = 0;
      }
    },
    methods: {
      initToggleFlag: function initToggleFlag(list) {
        if (!list.length) {
          this.toggleFlag = false;
        } else {
          for (var i = 0; i < list.length; i++) {
            if (list[i].steps && list[i].steps.length) {
              this.toggleFlag = true;
              break;
            }
          }
        }
      },
      setParentProcessLoad: function setParentProcessLoad(list) {
        var _this$list;
        var dataList = _toConsumableArray(list);
        var curProcess = this.curProcess - 1 || 0;
        if (!dataList.length) {
          return;
        }
        if (curProcess === dataList.length) {
          this.$set(dataList[curProcess - 1], 'isLoading', false);
        } else {
          for (var i = 0; i < dataList.length; i++) {
            var loadFlag = false;
            if (dataList[curProcess].steps && dataList[curProcess].steps.length) {
              var steps = dataList[curProcess].steps;
              for (var j = 0; j < steps.length; j++) {
                if (steps[j]['isLoading']) {
                  loadFlag = true;
                }
              }
              if (loadFlag) {
                if (curProcess > 0) {
                  this.$set(dataList[curProcess - 1], 'isLoading', false);
                }
                this.$set(dataList[curProcess], 'isLoading', true);
              }
            }
          }
        }
        (_this$list = this.list).splice.apply(_this$list, [0, this.list.length].concat(_toConsumableArray(dataList)));
      },
      toggleProcess: function toggleProcess() {
        this.showFlag = !this.showFlag;
        if (this.showFlag) {
          this.paddingBottom = this.maxBottom;
        } else {
          this.paddingBottom = 0;
        }
      },
      calculateMaxBottom: function calculateMaxBottom(list) {
        var processList = _toConsumableArray(list);
        var stepsLengthList = [];
        if (!processList.length) {
          this.maxBottom = 0;
          return;
        }
        processList.forEach(function (item) {
          if (item.steps) {
            stepsLengthList.push(item.steps.length);
          }
        });
        this.maxBottom = Math.max.apply(null, stepsLengthList) * this.stepsClientHeight;
      },
      toggle: function toggle(item, index) {
        if (!this.controllables) {
          return;
        }
        this.$emit('update:curProcess', index + 1);
        this.$emit('process-changed', index + 1, item);
      }
    }
  };

  /* script */
  var __vue_script__$O = script$O;
  /* template */

  var __vue_render__$Q = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-process",
      class: _vm.extCls
    }, [_c('ul', {
      style: {
        paddingBottom: _vm.paddingBottom + 'px'
      }
    }, _vm._l(_vm.dataList, function (item, index) {
      return _c('li', {
        key: index,
        class: {
          success: _vm.curProcess >= index + 1,
          current: item.isLoading && index === _vm.curProcess - 1
        },
        style: {
          cursor: _vm.controllables ? 'pointer' : ''
        },
        on: {
          "click": function click($event) {
            _vm.toggle(item, index);
          }
        }
      }, [_vm._v("\n            " + _vm._s(item[_vm.displayKey]) + "\n            "), item.isLoading && index === _vm.curProcess - 1 ? _c('div', {
        staticClass: "bk-spin-loading bk-spin-loading-mini bk-spin-loading-white"
      }, [_c('div', {
        staticClass: "rotate rotate1"
      }), _c('div', {
        staticClass: "rotate rotate2"
      }), _c('div', {
        staticClass: "rotate rotate3"
      }), _c('div', {
        staticClass: "rotate rotate4"
      }), _c('div', {
        staticClass: "rotate rotate5"
      }), _c('div', {
        staticClass: "rotate rotate6"
      }), _c('div', {
        staticClass: "rotate rotate7"
      }), _c('div', {
        staticClass: "rotate rotate8"
      })]) : _c('i', {
        staticClass: "bk-icon icon-check-1"
      }), _c('dl', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: item.steps && item.steps.length && _vm.showFlag,
          expression: "item.steps && item.steps.length && showFlag"
        }],
        ref: "stepsDom",
        refInFor: true,
        staticClass: "bk-process-step"
      }, _vm._l(item.steps, function (step, stepIndex) {
        return _c('dd', {
          key: stepIndex
        }, [_vm._v("\n                    " + _vm._s(step[_vm.displayKey]) + "\n                    "), step.isLoading && index === _vm.curProcess - 1 ? _c('div', {
          staticClass: "bk-spin-loading bk-spin-loading-mini bk-spin-loading-primary steps-loading"
        }, [_c('div', {
          staticClass: "rotate rotate1"
        }), _c('div', {
          staticClass: "rotate rotate2"
        }), _c('div', {
          staticClass: "rotate rotate3"
        }), _c('div', {
          staticClass: "rotate rotate4"
        }), _c('div', {
          staticClass: "rotate rotate5"
        }), _c('div', {
          staticClass: "rotate rotate6"
        }), _c('div', {
          staticClass: "rotate rotate7"
        }), _c('div', {
          staticClass: "rotate rotate8"
        })]) : _c('i', {
          staticClass: "bk-icon icon-check-1"
        })]);
      }), 0)]);
    }), 0), _vm.toggleFlag ? _c('a', {
      staticClass: "bk-process-toggle",
      attrs: {
        "href": "javascript:;"
      },
      on: {
        "click": _vm.toggleProcess
      }
    }, [_c('i', {
      staticClass: "bk-icon",
      class: _vm.showFlag ? 'icon-angle-up' : 'icon-angle-down'
    })]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$Q = [];
  /* style */

  var __vue_inject_styles__$Q = undefined;
  /* scoped */

  var __vue_scope_id__$Q = undefined;
  /* module identifier */

  var __vue_module_identifier__$Q = undefined;
  /* functional template */

  var __vue_is_functional_template__$Q = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$Q = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$Q,
    staticRenderFns: __vue_staticRenderFns__$Q
  }, __vue_inject_styles__$Q, __vue_script__$O, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$Q);

  var script$P = {
    name: 'bk-progress',
    props: {
      theme: {
        type: String,
        default: 'primary',
        validator: function validator(value) {
          if (['primary', 'warning', 'success', 'danger'].indexOf(value) < 0) {
            console.error("theme property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      percent: {
        type: Number,
        default: 0,
        validator: function validator(val) {
          return val >= 0 && val <= 1;
        }
      },
      size: {
        type: String,
        default: 'normal',
        validator: function validator(value) {
          if (['small', 'normal', 'large'].indexOf(value) < 0) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      strokeWidth: {
        type: Number
      },
      textInside: {
        type: Boolean,
        default: false
      },
      color: {
        type: String,
        default: ''
      },
      showText: {
        type: Boolean,
        default: true
      },
      titleStyle: {
        type: Object,
        default: function _default() {
          return {
            fontSize: '16px',
            verticalAlign: 'middle'
          };
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      fixed: {
        type: Number,
        default: 0,
        validator: function validator(val) {
          return val >= 0 && val <= 20;
        }
      }
    },
    data: function data() {
      return {
        percentStyle: {
          lineHeight: this.strokeWidth + "px",
          height: this.strokeWidth + 'px'
        }
      };
    },
    computed: {
      themeType: function themeType() {
        if (this.text) {
          return 'primary';
        }
        return this.theme;
      },
      barStyle: function barStyle() {
        var style = {};
        style.width = this.percentFixed + '%';
        style.backgroundColor = this.color;
        return style;
      },
      percentFixed: function percentFixed() {
        return Number(this.percent * 100).toFixed(this.fixed);
      },
      progressTextSize: function progressTextSize() {
        return 12 + this.strokeWidth * 0.4;
      }
    }
  };

  /* script */
  var __vue_script__$P = script$P;
  /* template */

  var __vue_render__$R = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-progress",
      class: _vm.extCls
    }, [_c('div', {
      staticClass: "progress-bar",
      class: "bk-progress-" + _vm.size,
      style: _vm.percentStyle
    }, [_c('div', {
      staticClass: "progress-inner",
      class: "bk-" + _vm.themeType,
      style: _vm.barStyle
    }, [_vm.showText && _vm.textInside && _vm.percentFixed !== 0 ? _c('div', {
      staticClass: "inner-text",
      style: _vm.titleStyle
    }, [_vm._v(_vm._s(_vm.percentFixed) + "%")]) : _vm._e()]), _vm.showText && _vm.textInside && _vm.percentFixed === 0 ? [_vm._v(_vm._s(_vm.percentFixed) + "%")] : _vm._e()], 2), _vm.showText && !_vm.textInside ? _c('div', {
      staticClass: "progress-text",
      style: _vm.titleStyle
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.percentFixed) + "%")])], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__$R = [];
  /* style */

  var __vue_inject_styles__$R = undefined;
  /* scoped */

  var __vue_scope_id__$R = undefined;
  /* module identifier */

  var __vue_module_identifier__$R = undefined;
  /* functional template */

  var __vue_is_functional_template__$R = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$R = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$R,
    staticRenderFns: __vue_staticRenderFns__$R
  }, __vue_inject_styles__$R, __vue_script__$P, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$R);

  var mixin$2 = {
    mixins: [emitter],
    data: function data() {
      return {
        current: '',
        group: false,
        groupName: this.name,
        parent: this.findComponentUpward(this, 'bk-radio-group')
      };
    },
    computed: {
      selected: function selected() {
        return this.current === this.localTrueValue;
      },
      localTrueValue: function localTrueValue() {
        var localValue;
        if (this.parent) {
          if (this.value === undefined && this.label === undefined) {
            localValue = this.trueValue;
          } else if (this.value !== undefined) {
            localValue = this.value;
          } else {
            localValue = this.label;
          }
        } else {
          localValue = this.trueValue;
        }
        return localValue;
      }
    },
    mounted: function mounted() {
      if (this.parent) {
        this.groupName = this.parent.name;
      }
      this.updateValue();
    },
    methods: {
      findComponentUpward: function findComponentUpward(context, componentName, componentNames) {
        if (typeof componentName === 'string') {
          componentNames = [componentName];
        } else {
          componentNames = componentName;
        }
        var parent = context.$parent;
        var name = parent.$options.name;
        while (parent && (!name || componentNames.indexOf(name) < 0)) {
          parent = parent.$parent;
          if (parent) name = parent.$options.name;
        }
        return parent;
      },
      getKeyDownSelected: function getKeyDownSelected(target) {
        var ele = Array.prototype.find.call(target.children, function (node) {
          return node.nodeName === 'INPUT' && node.type === 'radio';
        });
        return !ele.checked;
      },
      handlerChange: function handlerChange(event) {
        if (this.disabled) {
          return false;
        }
        var selected = event.type === 'change' ? event.target.checked : this.getKeyDownSelected(event.target);
        var value = selected ? this.localTrueValue : this.falseValue;
        this.$emit('input', value);
        this.$emit('change', value);
        this.dispatch('bk-form-item', 'form-change');
        if (this.parent) {
          this.parent.change({
            value: value
          });
        }
      }
    }
  };

  var script$Q = {
    name: 'bk-radio',
    mixins: [mixin$2],
    props: {
      name: {
        type: [String]
      },
      value: {
        type: [String, Number, Boolean],
        default: undefined
      },
      trueValue: {
        type: [String, Number, Boolean],
        default: true
      },
      falseValue: {
        type: [String, Number, Boolean],
        default: false
      },
      label: {
        type: [String, Number]
      },
      checked: {
        type: Boolean,
        default: undefined
      },
      disabled: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    watch: {
      checked: function checked() {
        this.updateValue();
      },
      value: function value(val) {
        if (val === this.localTrueValue || val === this.falseValue) {
          this.updateValue();
        }
      }
    },
    methods: {
      updateValue: function updateValue() {
        if (this.parent) {
          this.current = this.parent.value;
        } else {
          if (this.checked !== undefined) {
            this.current = this.checked ? this.localTrueValue : this.falseValue;
            this.$emit('input', this.current);
            this.$emit('change', this.current);
            this.dispatch('bk-form-item', 'form-change');
          } else {
            this.current = this.value;
          }
        }
      }
    }
  };

  /* script */
  var __vue_script__$Q = script$Q;
  /* template */

  var __vue_render__$S = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('label', {
      staticClass: "bk-form-radio",
      class: _vm.extCls,
      attrs: {
        "tabindex": _vm.disabled ? false : 0
      },
      on: {
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.handlerChange($event);
        }
      }
    }, [_c('input', {
      key: _vm.current,
      class: {
        'is-checked': _vm.checked || _vm.selected
      },
      attrs: {
        "type": "radio",
        "name": _vm.groupName,
        "disabled": _vm.disabled,
        "tabindex": "-1"
      },
      domProps: {
        "checked": _vm.selected
      },
      on: {
        "change": _vm.handlerChange
      }
    }), _c('div', {
      staticClass: "bk-radio-text"
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  };

  var __vue_staticRenderFns__$S = [];
  /* style */

  var __vue_inject_styles__$S = undefined;
  /* scoped */

  var __vue_scope_id__$S = undefined;
  /* module identifier */

  var __vue_module_identifier__$S = undefined;
  /* functional template */

  var __vue_is_functional_template__$S = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$S = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$S,
    staticRenderFns: __vue_staticRenderFns__$S
  }, __vue_inject_styles__$S, __vue_script__$Q, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$S);

  var script$R = {
    name: 'bk-radio-button',
    mixins: [mixin$2],
    props: {
      name: {
        type: [String]
      },
      value: {
        type: [String, Number, Boolean],
        default: undefined
      },
      trueValue: {
        type: [String, Number, Boolean],
        default: true
      },
      falseValue: {
        type: [String, Number, Boolean],
        default: false
      },
      label: {
        type: [String, Number]
      },
      disabled: {
        type: Boolean,
        default: false
      }
    },
    watch: {
      value: function value(val) {
        if (val === this.localTrueValue || val === this.falseValue) {
          this.updateValue();
        }
      }
    },
    methods: {
      updateValue: function updateValue() {
        if (this.parent) {
          this.current = this.parent.value;
        } else {
          this.current = this.value;
        }
      }
    }
  };

  /* script */
  var __vue_script__$R = script$R;
  /* template */

  var __vue_render__$T = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('label', {
      staticClass: "bk-form-radio-button",
      class: {
        'disabled': _vm.disabled
      },
      attrs: {
        "tabindex": _vm.disabled ? false : 0
      },
      on: {
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.handlerChange($event);
        }
      }
    }, [_c('input', {
      key: _vm.current,
      staticClass: "bk-radio-button-input",
      class: {
        'is-checked': _vm.selected
      },
      attrs: {
        "type": "radio",
        "name": _vm.groupName,
        "disabled": _vm.disabled,
        "tabindex": -1
      },
      domProps: {
        "checked": _vm.selected
      },
      on: {
        "change": _vm.handlerChange
      }
    }), _c('div', {
      staticClass: "bk-radio-button-text"
    }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
  };

  var __vue_staticRenderFns__$T = [];
  /* style */

  var __vue_inject_styles__$T = undefined;
  /* scoped */

  var __vue_scope_id__$T = undefined;
  /* module identifier */

  var __vue_module_identifier__$T = undefined;
  /* functional template */

  var __vue_is_functional_template__$T = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$T = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$T,
    staticRenderFns: __vue_staticRenderFns__$T
  }, __vue_inject_styles__$T, __vue_script__$R, __vue_scope_id__$T, __vue_is_functional_template__$T, __vue_module_identifier__$T, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$T);

  var script$S = {
    name: 'bk-radio-group',
    mixins: [emitter],
    props: {
      value: {
        type: [String, Number, Boolean],
        default: ''
      },
      name: {
        type: [String, Number],
        default: function _default() {
          var seed = 0;
          var now = now$1();
          return "bk_radio_".concat(now, "_").concat(seed++);
        }
      }
    },
    data: function data() {
      return {
        curValue: this.value,
        radios: []
      };
    },
    watch: {
      value: function value() {
        var _this = this;
        if (this.curValue !== this.value) {
          this.curValue = this.value;
          this.$nextTick(function () {
            _this.updateValue();
          });
        }
      }
    },
    mounted: function mounted() {
      this.updateValue();
    },
    methods: {
      findComponentsDownward: function findComponentsDownward(context, componentName) {
        var _this2 = this;
        return context.$children.reduce(function (components, child) {
          if (child.$options.name === componentName) components.push(child);
          var foundChilds = _this2.findComponentsDownward(child, componentName);
          return components.concat(foundChilds);
        }, []);
      },
      updateValue: function updateValue() {
        var _this3 = this;
        this.radios = this.findComponentsDownward(this, 'bk-radio').concat(this.findComponentsDownward(this, 'bk-radio-button'));
        if (this.radios) {
          this.radios.forEach(function (child) {
            child.current = _this3.curValue;
          });
        }
      },
      change: function change(data) {
        this.curValue = data.value;
        this.updateValue();
        this.$emit('input', data.value);
        this.$emit('change', data.value);
        this.dispatch('bk-form-item', 'form-change');
      }
    }
  };

  /* script */
  var __vue_script__$S = script$S;
  /* template */

  var __vue_render__$U = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-form-control",
      attrs: {
        "name": _vm.name
      }
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$U = [];
  /* style */

  var __vue_inject_styles__$U = undefined;
  /* scoped */

  var __vue_scope_id__$U = undefined;
  /* module identifier */

  var __vue_module_identifier__$U = undefined;
  /* functional template */

  var __vue_is_functional_template__$U = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$U = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$U,
    staticRenderFns: __vue_staticRenderFns__$U
  }, __vue_inject_styles__$U, __vue_script__$S, __vue_scope_id__$U, __vue_is_functional_template__$U, __vue_module_identifier__$U, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$U);

  var script$T = {
    name: 'bk-round-progress',
    props: {
      config: {
        type: Object,
        default: function _default() {
          return {
            strokeWidth: 5,
            bgColor: 'gray',
            activeColor: 'green',
            index: 0
          };
        }
      },
      percent: {
        type: Number,
        default: 0
      },
      title: {
        type: String
      },
      content: {
        type: [String, Number],
        default: ''
      },
      titleStyle: {
        type: Object,
        default: function _default() {
          return {
            fontSize: '16px'
          };
        }
      },
      numShow: {
        type: Boolean,
        default: true
      },
      numUnit: {
        type: String,
        default: '%'
      },
      numStyle: {
        type: Object,
        default: function _default() {
          return {
            fontSize: '16px'
          };
        }
      },
      radius: {
        type: String,
        default: '100px'
      },
      width: {
        type: String,
        default: ''
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        dashArray: Math.PI * 100
      };
    },
    computed: {
      dashOffset: function dashOffset() {
        return this.percentFixed > 1 ? false : (1 - this.percentFixed) * this.dashArray;
      },
      percentFixed: function percentFixed() {
        return Number(this.percent.toFixed(2));
      },
      diameter: function diameter() {
        return this.width || this.radius;
      }
    }
  };

  /* script */
  var __vue_script__$T = script$T;
  /* template */

  var __vue_render__$V = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-round-progress",
      class: _vm.extCls
    }, [_c('svg', {
      attrs: {
        "width": _vm.diameter,
        "height": _vm.diameter,
        "viewBox": "0 0 100 100",
        "version": "1.1"
      }
    }, [_c('circle', {
      staticClass: "progress-background",
      attrs: {
        "cx": "50",
        "cy": "50",
        "r": "50",
        "fill": "transparent",
        "stroke-width": _vm.config.strokeWidth,
        "stroke": _vm.config.bgColor
      }
    }), _c('circle', {
      staticClass: "progress-bar",
      class: 'circle' + _vm.config.index,
      attrs: {
        "cx": "50",
        "cy": "50",
        "r": "50",
        "fill": "transparent",
        "stroke-width": _vm.config.strokeWidth,
        "stroke": _vm.config.activeColor,
        "stroke-dasharray": _vm.dashArray,
        "stroke-dashoffset": _vm.dashOffset
      }
    })]), _vm.numShow ? _c('div', {
      staticClass: "num",
      style: _vm.numStyle
    }, [!_vm.content ? [_vm._v("\n            " + _vm._s(Math.round(_vm.percentFixed * 100))), _vm.numUnit ? _c('span', [_vm._v(_vm._s(_vm.numUnit))]) : _vm._e()] : [_vm._v(_vm._s(_vm.content))]], 2) : _vm._e(), _vm.title ? _c('div', {
      staticClass: "title",
      style: _vm.titleStyle
    }, [_vm._v("\n        " + _vm._s(_vm.title) + "\n    ")]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$V = [];
  /* style */

  var __vue_inject_styles__$V = undefined;
  /* scoped */

  var __vue_scope_id__$V = undefined;
  /* module identifier */

  var __vue_module_identifier__$V = undefined;
  /* functional template */

  var __vue_is_functional_template__$V = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$V = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$V,
    staticRenderFns: __vue_staticRenderFns__$V
  }, __vue_inject_styles__$V, __vue_script__$T, __vue_scope_id__$V, __vue_is_functional_template__$V, __vue_module_identifier__$V, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$V);

  setInstaller(__vue_component__$K, function (Vue, options) {
    Vue.prototype.$bkToPinyin = function (str, lowerCase, separator) {
      return pinyin.convertToPinyin(str, lowerCase, separator);
    };
  });

  var requestFrame = function () {
    var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
      return window.setTimeout(fn, 20);
    };
    return function (fn) {
      return raf(fn);
    };
  }();
  var cancelFrame = function () {
    var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
    return function (id) {
      return cancel(id);
    };
  }();
  var resetTrigger = function resetTrigger(element) {
    var trigger = element.__resizeTrigger__;
    var expand = trigger.firstElementChild;
    var contract = trigger.lastElementChild;
    var expandChild = expand.firstElementChild;
    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + 'px';
    expandChild.style.height = expand.offsetHeight + 1 + 'px';
    expand.scrollLeft = expand.scrollWidth;
    expand.scrollTop = expand.scrollHeight;
  };
  var checkTriggers = function checkTriggers(element) {
    return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
  };
  var scrollListener = function scrollListener(event) {
    var _this = this;
    resetTrigger(this);
    if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
    this.__resizeRAF__ = requestFrame(function () {
      if (checkTriggers(_this)) {
        _this.__resizeLast__.width = _this.offsetWidth;
        _this.__resizeLast__.height = _this.offsetHeight;
        _this.__resizeListeners__.forEach(function (fn) {
          fn.call(_this, event);
        });
      }
    });
  };
  var attachEvent = document.attachEvent;
  var DOM_PREFIXES = 'Webkit Moz O ms'.split(' ');
  var START_EVENTS = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' ');
  var RESIZE_ANIMATION_NAME = 'resizeanim';
  var animation = false;
  var keyFramePrefix = '';
  var animationStartEvent = 'animationstart';
  if (!attachEvent) {
    var testElement = document.createElement('fakeelement');
    if (testElement.style.animationName !== undefined) {
      animation = true;
    }
    if (animation === false) {
      var prefix = '';
      for (var i$3 = 0; i$3 < DOM_PREFIXES.length; i$3++) {
        if (testElement.style[DOM_PREFIXES[i$3] + 'AnimationName'] !== undefined) {
          prefix = DOM_PREFIXES[i$3];
          keyFramePrefix = '-' + prefix.toLowerCase() + '-';
          animationStartEvent = START_EVENTS[i$3];
          animation = true;
          break;
        }
      }
    }
  }
  var stylesCreated = false;
  var createStyles = function createStyles() {
    if (!stylesCreated) {
      var animationKeyframes = "@".concat(keyFramePrefix, "keyframes ").concat(RESIZE_ANIMATION_NAME, " { from { opacity: 0; } to { opacity: 0; } } ");
      var animationStyle = "".concat(keyFramePrefix, "animation: 1ms ").concat(RESIZE_ANIMATION_NAME, ";");
      var css = "".concat(animationKeyframes, "\n      .resize-triggers { ").concat(animationStyle, " visibility: hidden; opacity: 0; }\n      .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1 }\n      .resize-triggers > div { background: #eee; overflow: auto; }\n      .contract-trigger:before { width: 200%; height: 200%; }");
      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';
      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
      head.appendChild(style);
      stylesCreated = true;
    }
  };
  var addResizeListener = function addResizeListener(element, fn) {
    if (attachEvent) {
      element.attachEvent('onresize', fn);
    } else {
      if (!element.__resizeTrigger__) {
        if (getComputedStyle(element).position === 'static') {
          element.style.position = 'relative';
        }
        createStyles();
        element.__resizeLast__ = {};
        element.__resizeListeners__ = [];
        var resizeTrigger = element.__resizeTrigger__ = document.createElement('div');
        resizeTrigger.className = 'resize-triggers';
        resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
        element.appendChild(resizeTrigger);
        resetTrigger(element);
        element.addEventListener('scroll', scrollListener, true);
        if (animationStartEvent) {
          resizeTrigger.addEventListener(animationStartEvent, function (event) {
            if (event.animationName === RESIZE_ANIMATION_NAME) {
              resetTrigger(element);
            }
          });
        }
      }
      element.__resizeListeners__.push(fn);
    }
  };
  var removeResizeListener = function removeResizeListener(element, fn) {
    if (!element || !element.__resizeListeners__) return;
    if (attachEvent) {
      element.detachEvent('onresize', fn);
    } else {
      element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
      if (!element.__resizeListeners__.length) {
        element.removeEventListener('scroll', scrollListener);
        element.__resizeTrigger__ = !element.removeChild(element.__resizeTrigger__);
      }
    }
  };

  var script$U = {
    name: 'bk-sideslider',
    directives: {
      transferDom: transferDom
    },
    mixins: [locale.mixin],
    props: {
      isShow: {
        type: Boolean,
        default: false
      },
      title: {
        type: String,
        default: ''
      },
      quickClose: {
        type: Boolean,
        default: false
      },
      showMask: {
        type: Boolean,
        default: true
      },
      width: {
        type: Number,
        default: 400
      },
      beforeClose: {
        type: Function,
        default: function _default(res) {
          return true;
        }
      },
      direction: {
        type: String,
        default: 'right',
        validator: function validator(value) {
          return ['left', 'right'].indexOf(value) > -1;
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      zIndex: {
        type: [Number, String],
        default: 'default'
      },
      multiInstance: {
        type: Boolean,
        default: true
      },
      transfer: {
        type: Boolean,
        default: false
      },
      appendToBody: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        needBorder: false,
        localZIndex: zIndexManager.nextTickIndex(2),
        popUid: ''
      };
    },
    computed: {
      calcDirection: function calcDirection() {
        return this.direction === 'left' ? 'right' : 'left';
      }
    },
    watch: {
      isShow: function isShow(val) {
        var _this = this;
        var root = document.documentElement;
        if (val) {
          this.localZIndex = zIndexManager.nextTickIndex(2);
          addClass$1(root, 'bk-sideslider-show');
          if (this.isScrollY()) {
            addClass$1(root, 'has-sideslider-padding');
          }
          if (this.showMask) {
            this.generatePopUid();
          }
          setTimeout(function () {
            _this.$emit('shown');
          }, 200);
        } else {
          removeClass$1(root, 'bk-sideslider-show has-sideslider-padding');
          if (this.popUid) {
            popManager.hide(this.popUid);
            this.popUid = '';
          }
          setTimeout(function () {
            _this.$emit('hidden');
          }, 200);
        }
      }
    },
    mounted: function mounted() {
      if (this.$refs.content && this.showMask) {
        this.generatePopUid();
        addResizeListener(this.$refs.content, this.handleContentResize);
      }
    },
    destroyed: function destroyed() {
      var root = document.querySelector('html');
      removeClass$1(root, 'bk-sideslider-show');
      removeResizeListener(this.$refs.content, this.handleContentResize);
    },
    beforeDestroy: function beforeDestroy() {
      this.isShow && this.popUid && popManager.hide(this.popUid);
    },
    methods: {
      generatePopUid: function generatePopUid() {
        this.popUid = popManager.show('bk-sideslider', this.$el, {
          zIndex: this.localZIndex - 1,
          tplAction: this.multiInstance && 'keepAll' || 'onlyone',
          appendToBody: this.transfer
        });
      },
      isScrollY: function isScrollY() {
        return document.documentElement.offsetHeight > document.documentElement.clientHeight;
      },
      show: function show() {
        var root = document.documentElement;
        addClass$1(root, 'bk-sideslider-show');
        this.isShow = true;
      },
      hide: function hide() {
        var root = document.querySelector('html');
        removeClass$1(root, 'bk-sideslider-show');
        this.isShow = false;
      },
      handleClose: function handleClose() {
        var _this2 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var shouldClose;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  shouldClose = true;
                  if (!(typeof _this2.beforeClose === 'function')) {
                    _context.next = 5;
                    break;
                  }
                  _context.next = 4;
                  return _this2.beforeClose();
                case 4:
                  shouldClose = _context.sent;
                case 5:
                  if (shouldClose) {
                    _this2.$emit('update:isShow', false);
                    setTimeout(function () {
                      _this2.$emit('animation-end');
                    }, 250);
                  }
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      handleQuickClose: function handleQuickClose() {
        if (this.quickClose) {
          this.handleClose();
        }
      },
      handleContentResize: function handleContentResize() {
        var ref = this.$refs.content;
        this.needBorder = ref.scrollHeight > ref.clientHeight;
      }
    }
  };

  /* script */
  var __vue_script__$U = script$U;
  /* template */

  var __vue_render__$W = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "slide"
      }
    }, [_vm.isShow ? _c('article', {
      directives: [{
        name: "transfer-dom",
        rawName: "v-transfer-dom"
      }],
      staticClass: "bk-sideslider",
      class: _vm.extCls,
      style: {
        zIndex: _vm.localZIndex
      },
      attrs: {
        "data-transfer": _vm.transfer
      },
      on: {
        "mousedown": function mousedown($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          return _vm.handleQuickClose($event);
        }
      }
    }, [_c('section', {
      staticClass: "bk-sideslider-wrapper",
      class: [{
        left: _vm.direction === 'left',
        right: _vm.direction === 'right'
      }],
      style: {
        width: _vm.width + 'px'
      }
    }, [_c('div', {
      staticClass: "bk-sideslider-header"
    }, [_c('div', {
      staticClass: "bk-sideslider-closer",
      style: {
        float: _vm.calcDirection
      },
      on: {
        "click": _vm.handleClose
      }
    }, [_c('i', {
      staticClass: "bk-icon",
      class: 'icon-angle-' + _vm.direction
    })]), _c('div', {
      staticClass: "bk-sideslider-title",
      style: {
        padding: _vm.calcDirection === 'left' ? '0 0 0 50px' : '0 0 0 30px'
      }
    }, [_vm._t("header", [_vm._v("\n                        " + _vm._s(_vm.title || _vm.t('bk.sideslider.title')) + "\n                    ")])], 2)]), _c('div', {
      ref: "content",
      staticClass: "bk-sideslider-content",
      style: {
        maxHeight: _vm.$slots.footer ? 'calc(100vh - 114px)' : 'calc(100vh - 60px)'
      }
    }, [_vm._t("content")], 2), _vm.$slots.footer ? _c('div', {
      staticClass: "bk-sideslider-footer",
      style: {
        borderTopColor: !_vm.needBorder ? 'transparent' : '#dcdee5',
        backgroundColor: !_vm.needBorder ? '#fafbfd' : '#ffffff'
      }
    }, [_vm._t("footer")], 2) : _vm._e()])]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$W = [];
  /* style */

  var __vue_inject_styles__$W = undefined;
  /* scoped */

  var __vue_scope_id__$W = undefined;
  /* module identifier */

  var __vue_module_identifier__$W = undefined;
  /* functional template */

  var __vue_is_functional_template__$W = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$W = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$W,
    staticRenderFns: __vue_staticRenderFns__$W
  }, __vue_inject_styles__$W, __vue_script__$U, __vue_scope_id__$W, __vue_is_functional_template__$W, __vue_module_identifier__$W, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$W);

  Vue.use(bkTooltips);
  var script$V = {
    name: 'bk-slider-button',
    props: {
      vertical: {
        type: Boolean,
        default: false
      },
      value: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        dragging: false,
        isClick: false,
        startY: 0,
        startX: 0,
        startPosition: 0,
        newPosition: null,
        oldValue: this.value
      };
    },
    computed: {
      showTip: function showTip() {
        return this.$parent.showTip;
      },
      tip: function tip() {
        var tip = '';
        if (this.customContent && this.customContent[this.value]) {
          var customContent = this.customContent[this.value];
          tip = customContent.tip || customContent.label || '';
        }
        return {
          content: this.showCustomTip ? tip : this.showTip ? this.value ? "".concat(this.value) : "".concat(0) : '',
          placement: this.vertical ? 'right' : 'top'
        };
      },
      disable: function disable() {
        return this.$parent.disable;
      },
      maxValue: function maxValue() {
        return this.$parent.maxValue;
      },
      minValue: function minValue() {
        return this.$parent.minValue;
      },
      step: function step() {
        return this.$parent.step;
      },
      precision: function precision() {
        return this.$parent.precision;
      },
      currentPosition: function currentPosition() {
        return "".concat((this.value - this.minValue) / (this.maxValue - this.minValue) * 100, "%");
      },
      wrapperStyle: function wrapperStyle() {
        return this.vertical ? {
          bottom: this.currentPosition
        } : {
          left: this.currentPosition
        };
      },
      showButtonLabel: function showButtonLabel() {
        return this.$parent.showButtonLabel;
      },
      buttonLabel: function buttonLabel() {
        var unit = this.$parent.buttonLabelUnit;
        return this.value ? "".concat(this.value).concat(unit) : "".concat(0, unit);
      },
      showIntervalLabel: function showIntervalLabel() {
        return this.$parent.showIntervalLabel;
      },
      customContent: function customContent() {
        return this.$parent.customContent;
      },
      showCustomTip: function showCustomTip() {
        return this.$parent.showCustomTip;
      }
    },
    methods: {
      onButtonDown: function onButtonDown(event) {
        if (this.disable) return;
        event.preventDefault();
        this.onDragStart(event);
        this.$parent.on(window, 'mousemove', this.onDragging);
        this.$parent.on(window, 'touchmove', this.onDragging);
        this.$parent.on(window, 'mouseup', this.onDragEnd);
        this.$parent.on(window, 'touchend', this.onDragEnd);
      },
      onDragStart: function onDragStart(event) {
        this.dragging = true;
        this.isClick = true;
        if (event.type === 'touchstart') {
          event.clientY = event.touches[0].clientY;
          event.clientX = event.touches[0].clientX;
        }
        if (this.vertical) {
          this.startY = event.clientY;
        } else {
          this.startX = event.clientX;
        }
        this.startPosition = _parseFloat$2(this.currentPosition);
        this.newPosition = this.startPosition;
      },
      onDragging: function onDragging(event) {
        if (this.dragging) {
          this.isClick = false;
          this.$parent.resetSize();
          var diff = 0;
          if (event.type === 'touchmove') {
            event.clientY = event.touches[0].clientY;
            event.clientX = event.touches[0].clientX;
          }
          if (this.vertical) {
            this.currentY = event.clientY;
            diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
          } else {
            this.currentX = event.clientX;
            diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
          }
          this.newPosition = this.startPosition + diff;
          this.setPosition(this.newPosition);
        }
      },
      setPosition: function setPosition(newPosition) {
        if (newPosition === null || isNaN(newPosition)) return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        var lengthPerStep = 100 / ((this.maxValue - this.minValue) / this.step);
        var steps = Math.round(newPosition / lengthPerStep);
        var value = steps * lengthPerStep * (this.maxValue - this.minValue) * 0.01 + this.minValue;
        value = _parseFloat$2(value.toFixed(this.precision));
        this.$emit('input', value);
        if (!this.dragging && this.value !== this.oldValue) {
          this.oldValue = this.value;
        }
      },
      onDragEnd: function onDragEnd() {
        var _this = this;
        this.isMove = false;
        if (this.dragging) {
          setTimeout(function () {
            _this.dragging = false;
            if (!_this.isClick) {
              _this.setPosition(_this.newPosition);
              _this.$parent.emitChange();
            }
          }, 0);
          this.$parent.off(window, 'mousemove', this.onDragging);
          this.$parent.off(window, 'touchmove', this.onDragging);
          this.$parent.off(window, 'mouseup', this.onDragEnd);
          this.$parent.off(window, 'touchend', this.onDragEnd);
        }
      }
    }
  };

  /* script */
  var __vue_script__$V = script$V;
  /* template */

  var __vue_render__$X = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips",
        value: _vm.tip,
        expression: "tip"
      }],
      ref: "button",
      class: ['bk-slider-button', _vm.vertical ? 'vertical' : 'horizontal', {
        'grabbing': _vm.dragging
      }],
      style: _vm.wrapperStyle,
      attrs: {
        "tabindex": "0"
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
        },
        "mousedown": _vm.onButtonDown,
        "touchstart": _vm.onButtonDown
      }
    }, [_c('div', {
      class: ['slider-button', {
        'slider-button-disable': _vm.disable
      }]
    }), _vm.showButtonLabel && !_vm.showIntervalLabel ? _c('div', {
      class: ['slider-button-label', _vm.vertical ? 'vertical' : 'horizontal']
    }, [_vm._v("\n        " + _vm._s(_vm.buttonLabel) + "\n    ")]) : _vm._e()]);
  };

  var __vue_staticRenderFns__$X = [];
  /* style */

  var __vue_inject_styles__$X = undefined;
  /* scoped */

  var __vue_scope_id__$X = undefined;
  /* module identifier */

  var __vue_module_identifier__$X = undefined;
  /* functional template */

  var __vue_is_functional_template__$X = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$X = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$X,
    staticRenderFns: __vue_staticRenderFns__$X
  }, __vue_inject_styles__$X, __vue_script__$V, __vue_scope_id__$X, __vue_is_functional_template__$X, __vue_module_identifier__$X, false, undefined, undefined, undefined);

  var script$W = {
    name: 'bk-slider',
    components: {
      sliderButton: __vue_component__$X,
      bkInput: __vue_component__$A
    },
    props: {
      value: {
        type: [Number, Array],
        default: 0
      },
      vertical: {
        type: Boolean,
        default: false
      },
      showTip: {
        type: Boolean,
        default: true
      },
      disable: {
        type: Boolean,
        default: false
      },
      maxValue: {
        type: [Number],
        default: 100
      },
      minValue: {
        type: [Number],
        default: 0
      },
      step: {
        type: [Number],
        default: 1
      },
      range: {
        type: Boolean,
        default: false
      },
      showInterval: {
        type: Boolean,
        default: false
      },
      showIntervalLabel: {
        type: Boolean,
        default: false
      },
      intervalLabelUnit: {
        type: String,
        default: ''
      },
      height: {
        type: String,
        default: '200px'
      },
      showButtonLabel: {
        type: Boolean,
        default: false
      },
      buttonLabelUnit: {
        type: String,
        default: ''
      },
      showBetweenLabel: {
        type: Boolean,
        default: false
      },
      showInput: {
        type: Boolean,
        default: false
      },
      customContent: {
        type: Object
      },
      showCustomLabel: {
        type: Boolean,
        default: false
      },
      showCustomTip: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        sliderSize: 1,
        firstValue: null,
        secondValue: null,
        oldValue: null,
        stepWidth: 0,
        inputValue: 0,
        firstInput: 0,
        secondInput: 0
      };
    },
    computed: {
      precision: function precision() {
        var precisions = [this.minValue, this.maxValue, this.step].map(function (item) {
          var decimal = ('' + item).split('.')[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      },
      rangeMinValue: function rangeMinValue() {
        return Math.min(this.firstValue, this.secondValue);
      },
      rangeMaxValue: function rangeMaxValue() {
        return Math.max(this.firstValue, this.secondValue);
      },
      barSize: function barSize() {
        return this.range ? "".concat(100 * (this.rangeMaxValue - this.rangeMinValue) / (this.maxValue - this.minValue), "%") : "".concat(100 * (this.firstValue - this.minValue) / (this.maxValue - this.minValue), "%");
      },
      barStart: function barStart() {
        return this.range ? "".concat(100 * (this.rangeMinValue - this.minValue) / (this.maxValue - this.minValue), "%") : '0%';
      },
      barStyle: function barStyle() {
        return this.vertical ? {
          height: this.barSize,
          bottom: this.barStart
        } : {
          width: this.barSize,
          left: this.barStart
        };
      },
      intervals: function intervals() {
        var _this = this;
        if (!this.showInterval || this.minValue > this.maxValue) return [];
        if (this.step === 0) {
          console.warn('WARNNING:step should not be 0');
          return [];
        }
        var stopCount = (this.maxValue - this.minValue) / this.step;
        var stepWidth = 100 * this.step / (this.maxValue - this.minValue);
        var result = [];
        for (var i = 1; i < stopCount; i++) {
          result.push(i * stepWidth);
        }
        if (this.range) {
          return result.filter(function (step) {
            return step < 100 * (_this.rangeMinValue - _this.minValue) / (_this.maxValue - _this.minValue) || step > 100 * (_this.rangeMaxValue - _this.minValue) / (_this.maxValue - _this.minValue);
          });
        } else {
          return result.filter(function (step) {
            return step > 100 * (_this.firstValue - _this.minValue) / (_this.maxValue - _this.minValue);
          });
        }
      },
      runwayStyle: function runwayStyle() {
        return this.vertical ? {
          height: this.height,
          width: '4px'
        } : {};
      },
      intervalLabels: function intervalLabels() {
        if (!this.showIntervalLabel) return [];
        if (this.step === 0) {
          console.warn('WARNNING:step should not be 0');
          return [];
        }
        var stepCount = (this.maxValue - this.minValue) / this.step;
        var stepWidth = 100 * this.step / (this.maxValue - this.minValue);
        var result = [];
        for (var i = 0; i <= stepCount; i++) {
          var item = {
            stepWidth: i * stepWidth,
            stepLabel: "".concat(i * this.step).concat(this.intervalLabelUnit)
          };
          result.push(item);
        }
        return result;
      },
      showSecondInput: function showSecondInput() {
        return isArray$1(this.value);
      },
      customList: function customList() {
        var _this2 = this;
        if (!this.customContent) {
          return [];
        }
        return keys$1(this.customContent).sort(function (a, b) {
          return a - b;
        }).filter(function (value) {
          return value >= _this2.minValue && value <= _this2.maxValue;
        }).map(function (item) {
          var tip = _this2.customContent[item].tip;
          var label = _this2.customContent[item].label;
          return {
            tip: tip || label || '',
            label: label || '',
            percent: (item - _this2.minValue) / (_this2.maxValue - _this2.minValue) * 100
          };
        });
      }
    },
    watch: {
      value: function value() {
        this.setValues();
      },
      firstValue: function firstValue(val) {
        if (this.range) {
          this.$emit('input', [this.rangeMinValue, this.rangeMaxValue]);
        } else {
          this.$emit('input', val);
        }
        this.firstInput = val;
      },
      secondValue: function secondValue(val) {
        this.$emit('input', [this.rangeMinValue, this.rangeMaxValue]);
        this.secondInput = val;
      }
    },
    mounted: function mounted() {
      if (this.range) {
        if (isArray$1(this.value)) {
          this.firstValue = Math.max(this.minValue, this.value[0]);
          this.secondValue = Math.min(this.maxValue, this.value[1]);
        } else {
          this.firstValue = this.minValue;
          this.secondValue = this.maxValue;
        }
        this.oldValue = [this.firstValue, this.secondValue];
      } else {
        if (typeof this.value !== 'number' || isNaN(this.value)) {
          this.firstValue = this.minValue;
        } else {
          this.firstValue = Math.min(this.maxValue, Math.max(this.minValue, this.value));
        }
        this.oldValue = this.firstValue;
      }
      this.stepWidth = 100 * this.step / (this.maxValue - this.minValue);
      this.resetSize();
      this.on(window, 'resize', this.resetSize);
    },
    methods: {
      valueChanged: function valueChanged() {
        var _this3 = this;
        if (this.range) {
          return ![this.rangeMinValue, this.rangeMaxValue].every(function (item, index) {
            return item === _this3.oldValue[index];
          });
        } else {
          return this.value !== this.oldValue;
        }
      },
      setValues: function setValues() {
        if (this.minValue > this.maxValue) {
          console.error('min should not be greater than max.');
          return;
        }
        var val = this.value;
        if (this.range && isArray$1(val)) {
          if (val[1] < this.minValue) {
            this.$emit('input', [this.minValue, this.minValue]);
          } else if (val[0] > this.maxValue) {
            this.$emit('input', [this.maxValue, this.maxValue]);
          } else if (val[0] < this.minValue) {
            this.$emit('input', [this.minValue, val[1]]);
          } else if (val[1] > this.maxValue) {
            this.$emit('input', [val[0], this.maxValue]);
          } else {
            this.firstValue = val[0];
            this.secondValue = val[1];
            if (this.valueChanged()) {
              this.oldValue = val.slice();
            }
          }
        } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
          if (val < this.minValue) {
            this.$emit('input', this.minValue);
          } else if (val > this.maxValue) {
            this.$emit('input', this.maxValue);
          } else {
            this.firstValue = val;
            if (this.valueChanged()) {
              this.oldValue = val;
            }
          }
        }
      },
      resetSize: function resetSize() {
        if (this.$refs.slider) {
          this.sliderSize = this.$refs.slider["client".concat(this.vertical ? 'Height' : 'Width')];
        }
      },
      emitChange: function emitChange() {
        var _this4 = this;
        this.$nextTick(function () {
          _this4.$emit('change', _this4.range ? [_this4.rangeMinValue, _this4.rangeMaxValue] : _this4.value);
        });
      },
      getIntervalStyle: function getIntervalStyle(position) {
        return this.vertical ? {
          'bottom': position + '%'
        } : {
          'left': position + '%'
        };
      },
      setPosition: function setPosition(percent) {
        if (!this.range) {
          this.$refs.firstbutton.setPosition(percent);
          return;
        }
        var targetValue = this.minValue + percent * (this.maxValue - this.minValue) / 100;
        var curButtonRef = '';
        if (Math.abs(this.rangeMinValue - targetValue) < Math.abs(this.rangeMaxValue - targetValue)) {
          curButtonRef = this.firstValue < this.secondValue ? 'firstbutton' : 'secondbutton';
        } else {
          curButtonRef = this.firstValue > this.secondValue ? 'firstbutton' : 'secondbutton';
        }
        this.$refs[curButtonRef].setPosition(percent);
      },
      setButtonPos: function setButtonPos(event) {
        if (this.disable) return;
        this.resetSize();
        if (this.vertical) {
          var offsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
          this.setPosition((offsetBottom - event.clientY) / this.sliderSize * 100);
        } else {
          var offsetLeft = this.$refs.slider.getBoundingClientRect().left;
          this.setPosition((event.clientX - offsetLeft) / this.sliderSize * 100);
        }
        this.emitChange();
      },
      firstInputChange: function firstInputChange(v) {
        if (v === '') {
          return;
        }
        var val = _parseFloat$2(v);
        if (val < this.minValue) {
          this.firstInput = this.minValue;
          this.firstValue = this.minValue;
        } else if (val > this.maxValue) {
          this.firstInput = this.maxValue;
          this.firstValue = this.maxValue;
        } else {
          this.firstValue = val;
        }
      },
      secondInputChange: function secondInputChange(v) {
        if (v === '') {
          return;
        }
        var val = _parseFloat$2(v);
        if (val < this.minValue) {
          this.secondInput = this.minValue;
          this.secondValue = this.minValue;
        } else if (val > this.maxValue) {
          this.secondInput = this.maxValue;
          this.secondValue = this.maxValue;
        } else {
          this.secondValue = val;
        }
      },
      on: function on(element, event, handler) {
        if (element && event && handler) {
          element.addEventListener(event, handler, false);
        }
      },
      off: function off(element, event, handler) {
        if (element && event) {
          element.removeEventListener(event, handler, false);
        }
      },
      getInputWidth: function getInputWidth(num) {
        var len = "".concat(num).length;
        return len > 2 ? "".concat(56 + (len - 2) * 6, "px") : '56px';
      }
    }
  };

  /* script */
  var __vue_script__$W = script$W;
  /* template */

  var __vue_render__$Y = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-slider', _vm.extCls]
    }, [_vm._t("start"), _c('div', {
      ref: "slider",
      staticClass: "bk-slider-runway",
      style: _vm.runwayStyle,
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.setButtonPos($event);
        }
      }
    }, [_c('div', {
      class: ['bk-slider-bar', _vm.vertical ? 'vertical' : 'horizontal', {
        'disable': _vm.disable
      }],
      style: _vm.barStyle
    }), _vm.showInterval ? _vm._l(_vm.intervals, function (item, index) {
      return _c('div', {
        key: index,
        class: ['bk-slider-interval', {
          'vertical': _vm.vertical
        }],
        style: _vm.getIntervalStyle(item)
      });
    }) : _vm._e(), _vm.customContent ? _vm._l(_vm.customList, function (item, index) {
      return _c('div', {
        key: index,
        class: ['bk-slider-interval', {
          'vertical': _vm.vertical
        }],
        style: _vm.getIntervalStyle(item.percent)
      });
    }) : _vm._e(), _vm.showBetweenLabel || _vm.showIntervalLabel || _vm.showCustomLabel ? [_c('div', {
      class: ['bk-slider-labels', _vm.vertical ? 'vertical' : 'horizontal']
    }, [_vm.showBetweenLabel ? [_c('div', {
      staticClass: "label-start",
      style: [{
        opacity: _vm.showButtonLabel ? [_vm.firstValue, _vm.secondValue].includes(_vm.vertical ? _vm.maxValue : _vm.minValue) ? '0' : '1' : '1'
      }]
    }, [_vm._v("\n                        " + _vm._s(_vm.minValue) + _vm._s(_vm.intervalLabelUnit) + "\n                    ")]), _c('div', {
      staticClass: "label-end",
      style: [{
        opacity: _vm.showButtonLabel ? [_vm.firstValue, _vm.secondValue].includes(_vm.vertical ? _vm.minValue : _vm.maxValue) ? '0' : '1' : '1'
      }]
    }, [_vm._v("\n                        " + _vm._s(_vm.maxValue) + _vm._s(_vm.intervalLabelUnit) + "\n                    ")])] : _vm.showIntervalLabel ? _vm._l(_vm.intervalLabels, function (item, index) {
      return _c('div', {
        key: index,
        class: ['bk-slider-label', _vm.vertical ? 'vertical' : 'horizontal'],
        style: _vm.getIntervalStyle(item.stepWidth)
      }, [_vm._v("\n                        " + _vm._s(item.stepLabel) + "\n                    ")]);
    }) : _vm.showCustomLabel ? _vm._l(_vm.customList, function (item, index) {
      return _c('div', {
        key: index,
        class: ['bk-slider-label', _vm.vertical ? 'vertical' : 'horizontal'],
        style: _vm.getIntervalStyle(item.percent)
      }, [_vm._v("\n                        " + _vm._s(item.label) + "\n                    ")]);
    }) : _vm._e()], 2)] : _vm._e(), _c('slider-button', {
      ref: "firstbutton",
      attrs: {
        "vertical": _vm.vertical
      },
      model: {
        value: _vm.firstValue,
        callback: function callback($$v) {
          _vm.firstValue = $$v;
        },
        expression: "firstValue"
      }
    }), _vm.range ? _c('slider-button', {
      ref: "secondbutton",
      attrs: {
        "vertical": _vm.vertical
      },
      model: {
        value: _vm.secondValue,
        callback: function callback($$v) {
          _vm.secondValue = $$v;
        },
        expression: "secondValue"
      }
    }) : _vm._e()], 2), _vm.showInput && !_vm.vertical ? _c('div', {
      staticClass: "bk-slider-input"
    }, [_c('div', {
      staticClass: "input-item",
      style: {
        width: _vm.getInputWidth(_vm.firstInput)
      }
    }, [_c('bk-input', {
      attrs: {
        "type": "number",
        "max": _vm.maxValue,
        "min": _vm.minValue
      },
      on: {
        "change": _vm.firstInputChange,
        "enter": _vm.firstInputChange,
        "blur": _vm.firstInputChange
      },
      model: {
        value: _vm.firstInput,
        callback: function callback($$v) {
          _vm.firstInput = $$v;
        },
        expression: "firstInput"
      }
    })], 1), _vm.showSecondInput && _vm.secondValue ? [_c('div', {
      staticClass: "input-center"
    }, [_vm._v("～")]), _c('div', {
      staticClass: "input-item",
      style: {
        width: _vm.getInputWidth(_vm.secondInput)
      }
    }, [_c('bk-input', {
      attrs: {
        "type": "number",
        "max": _vm.maxValue,
        "min": _vm.minValue
      },
      on: {
        "change": _vm.secondInputChange,
        "enter": _vm.secondInputChange,
        "blur": _vm.secondInputChange
      },
      model: {
        value: _vm.secondInput,
        callback: function callback($$v) {
          _vm.secondInput = $$v;
        },
        expression: "secondInput"
      }
    })], 1)] : _vm._e()], 2) : _vm._e(), _vm._t("end")], 2);
  };

  var __vue_staticRenderFns__$Y = [];
  /* style */

  var __vue_inject_styles__$Y = undefined;
  /* scoped */

  var __vue_scope_id__$Y = undefined;
  /* module identifier */

  var __vue_module_identifier__$Y = undefined;
  /* functional template */

  var __vue_is_functional_template__$Y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$Y = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$Y,
    staticRenderFns: __vue_staticRenderFns__$Y
  }, __vue_inject_styles__$Y, __vue_script__$W, __vue_scope_id__$Y, __vue_is_functional_template__$Y, __vue_module_identifier__$Y, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$Y);

  var script$X = {
    name: 'bk-steps',
    mixins: [locale.mixin],
    props: {
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      curStep: {
        type: Number,
        default: 1
      },
      controllable: {
        type: Boolean,
        default: false
      },
      direction: {
        type: String,
        default: 'horizontal',
        validator: function validator(val) {
          return ['horizontal', 'vertical'].includes(val);
        }
      },
      status: {
        type: String,
        default: '',
        validator: function validator(val) {
          return ['', 'error', 'loading'].includes(val);
        }
      },
      lineType: {
        type: String,
        default: 'dashed',
        validator: function validator(val) {
          return ['dashed', 'solid'].includes(val);
        }
      },
      size: {
        type: String,
        default: '',
        validator: function validator(val) {
          return ['', 'small'].includes(val);
        }
      },
      theme: {
        type: String,
        default: 'primary'
      },
      extCls: {
        type: String,
        default: ''
      },
      beforeChange: {
        type: Function,
        default: null
      }
    },
    data: function data() {
      return {
        defaultSteps: [],
        currentStatus: this.status
      };
    },
    computed: {
      wrapperCls: function wrapperCls() {
        var wrapperCls = ['bk-steps', "bk-steps-".concat(this.direction), "bk-steps-".concat(this.lineType), "bk-steps-".concat(this.theme)];
        if (this.size) {
          wrapperCls.push("bk-steps-".concat(this.size));
        }
        return wrapperCls;
      }
    },
    watch: {
      status: function status(val) {
        this.currentStatus = val;
      },
      steps: {
        handler: function handler(val) {
          this.updateSteps(val);
        },
        deep: true
      }
    },
    created: function created() {
      var _this$defaultSteps;
      (_this$defaultSteps = this.defaultSteps).splice.apply(_this$defaultSteps, [0, this.defaultSteps.length].concat([{
        title: this.t('bk.steps.step1'),
        icon: 1
      }, {
        title: this.t('bk.steps.step2'),
        icon: 2
      }, {
        title: this.t('bk.steps.step3'),
        icon: 3
      }]));
      if (this.steps && this.steps.length) {
        this.updateSteps(this.steps);
      }
    },
    methods: {
      updateSteps: function updateSteps(steps) {
        var _this$defaultSteps2;
        var defaultSteps = [];
        steps.forEach(function (step) {
          if (typeof step === 'string') {
            defaultSteps.push(step);
          } else {
            defaultSteps.push({
              title: step.title,
              icon: step.icon,
              description: step.description,
              status: step.status
            });
          }
        });
        (_this$defaultSteps2 = this.defaultSteps).splice.apply(_this$defaultSteps2, [0, this.defaultSteps.length].concat(defaultSteps));
      },
      iconType: function iconType(step) {
        var icon = step.icon;
        if (icon) {
          return typeof icon === 'string';
        }
        return typeof step === 'string';
      },
      isIcon: function isIcon(step) {
        return step.icon ? step.icon : step;
      },
      isCurrent: function isCurrent(index) {
        return this.curStep === index + 1;
      },
      isDone: function isDone(index) {
        return this.curStep > index + 1 || this.defaultSteps[index].status === 'done';
      },
      isLoadingStatus: function isLoadingStatus(step) {
        return step.status === 'loading';
      },
      isErrorStatus: function isErrorStatus(step) {
        return step.status === 'error';
      },
      jumpTo: function jumpTo(index) {
        var _this = this;
        return _asyncToGenerator( regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  if (!(_this.controllable && index !== _this.curStep)) {
                    _context2.next = 7;
                    break;
                  }
                  if (!(typeof _this.beforeChange === 'function')) {
                    _context2.next = 5;
                    break;
                  }
                  _context2.next = 5;
                  return new promise$1( function () {
                    var _ref = _asyncToGenerator( regenerator.mark(function _callee(resolve, reject) {
                      var confirmed;
                      return regenerator.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return _this.beforeChange(index);
                            case 2:
                              confirmed = _context.sent;
                              confirmed ? resolve(confirmed) : reject(confirmed);
                            case 4:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));
                    return function (_x, _x2) {
                      return _ref.apply(this, arguments);
                    };
                  }());
                case 5:
                  _this.$emit('update:curStep', index);
                  _this.$emit('step-changed', index);
                case 7:
                  _context2.next = 12;
                  break;
                case 9:
                  _context2.prev = 9;
                  _context2.t0 = _context2["catch"](0);
                  console.warn(_context2.t0);
                case 12:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 9]]);
        }))();
      }
    }
  };

  /* script */
  var __vue_script__$X = script$X;
  /* template */

  var __vue_render__$Z = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: [_vm.wrapperCls, _vm.extCls]
    }, _vm._l(_vm.defaultSteps, function (step, index) {
      var _obj;

      return _c('div', {
        key: index,
        staticClass: "bk-step",
        class: (_obj = {
          'bk-step-no-content': !step.title,
          done: _vm.isDone(index),
          current: _vm.isCurrent(index)
        }, _obj["bk-step-" + _vm.currentStatus] = _vm.currentStatus && _vm.isCurrent(index), _obj)
      }, [_c('span', {
        staticClass: "bk-step-indicator",
        class: 'bk-step-' + (_vm.iconType(step) ? 'icon' : 'number'),
        style: {
          cursor: _vm.controllable ? 'pointer' : ''
        },
        on: {
          "click": function click($event) {
            _vm.jumpTo(index + 1);
          }
        }
      }, [_vm.isCurrent(index) && _vm.currentStatus === 'loading' || _vm.isLoadingStatus(step) ? _c('i', {
        staticClass: "bk-icon icon-circle-4-1 icon-loading"
      }) : _vm.iconType(step) ? _c('i', {
        staticClass: "bk-icon",
        class: 'icon-' + _vm.isIcon(step)
      }) : _vm.isCurrent(index) && _vm.currentStatus === 'error' || _vm.isErrorStatus(step) ? _c('i', {
        staticClass: "bk-icon icon-close icon-error"
      }) : _vm.isDone(index) ? _c('i', {
        staticClass: "bk-icon icon-check-1 icon-finish"
      }) : _c('span', {
        staticClass: "number"
      }, [_vm._v("\n                " + _vm._s(_vm.isIcon(step)) + "\n            ")])]), step.title ? _c('div', {
        staticClass: "bk-step-content"
      }, [_c('div', {
        staticClass: "bk-step-title",
        style: {
          cursor: _vm.controllable ? 'pointer' : ''
        },
        on: {
          "click": function click($event) {
            _vm.jumpTo(index + 1);
          }
        }
      }, [_vm._v("\n                " + _vm._s(step.title) + "\n            ")]), step.description ? _c('div', {
        staticClass: "bk-step-description",
        attrs: {
          "title": step.description
        }
      }, [_vm._v("\n                " + _vm._s(step.description) + "\n            ")]) : _vm._e()]) : _vm._e()]);
    }), 0);
  };

  var __vue_staticRenderFns__$Z = [];
  /* style */

  var __vue_inject_styles__$Z = undefined;
  /* scoped */

  var __vue_scope_id__$Z = undefined;
  /* module identifier */

  var __vue_module_identifier__$Z = undefined;
  /* functional template */

  var __vue_is_functional_template__$Z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$Z = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$Z,
    staticRenderFns: __vue_staticRenderFns__$Z
  }, __vue_inject_styles__$Z, __vue_script__$X, __vue_scope_id__$Z, __vue_is_functional_template__$Z, __vue_module_identifier__$Z, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$Z);

  var script$Y = {
    name: 'bk-switcher',
    model: {
      prop: 'value',
      event: 'update'
    },
    props: {
      value: {
        type: [String, Number, Boolean],
        default: false
      },
      trueValue: {
        type: [String, Number, Boolean],
        default: true
      },
      falseValue: {
        type: [String, Number, Boolean],
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      showText: {
        type: Boolean,
        default: false
      },
      onText: {
        type: String,
        default: 'ON'
      },
      offText: {
        type: String,
        default: 'OFF'
      },
      isOutline: {
        type: Boolean,
        default: false
      },
      theme: {
        type: String,
        default: 'success'
      },
      isSquare: {
        type: Boolean,
        default: false
      },
      size: {
        type: String,
        default: '',
        validator: function validator(value) {
          if (['', 'large', 'small'].indexOf(value) < 0) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      preCheck: {
        type: Function
      }
    },
    data: function data() {
      return {
        isLoading: false,
        localValue: this.value
      };
    },
    computed: {
      isChecked: function isChecked() {
        return this.localValue === this.trueValue;
      },
      classObject: function classObject() {
        var cls = {
          'bk-switcher': true,
          'bk-switcher-outline': this.isOutline,
          'bk-switcher-square': this.isSquare,
          'show-label': this.showText,
          'is-disabled': this.disabled,
          'is-checked': this.isChecked,
          'is-unchecked': !this.isChecked,
          'is-loading': this.isLoading,
          'primary': this.theme === 'primary'
        };
        if (this.size && !this.showText) {
          var sizeStr = 'bk-switcher-' + this.size;
          cls[sizeStr] = true;
        }
        return cls;
      }
    },
    watch: {
      value: function value(newValue) {
        this.localValue = newValue;
      }
    },
    methods: {
      change: function change() {
        var _this = this;
        if (this.disabled || this.isLoading) {
          return;
        }
        var lastValue = this.isChecked ? this.falseValue : this.trueValue;
        var lastChecked = !this.isChecked;
        var trigger = function trigger() {
          _this.localValue = lastValue;
          _this.$emit('update', lastValue);
          _this.$emit('change', lastChecked);
        };
        var goodJob = true;
        if (typeof this.preCheck === 'function') {
          goodJob = this.preCheck(lastValue);
          if (typeof goodJob.then === 'function') {
            this.isLoading = true;
            return goodJob.then(function () {
              trigger();
            }).finally(function () {
              _this.isLoading = false;
            });
          }
        }
        if (goodJob) {
          trigger();
        }
      }
    }
  };

  /* script */
  var __vue_script__$Y = script$Y;

  var __vue_render__$_ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: _vm.classObject,
      attrs: {
        "tabindex": "0"
      },
      on: {
        "click": _vm.change,
        "keydown": function keydown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.change($event);
        }
      }
    }, [_c('input', {
      attrs: {
        "type": "checkbox",
        "disabled": _vm.disabled,
        "tabindex": "-1"
      }
    }), _c('label', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showText,
        expression: "showText"
      }],
      staticClass: "switcher-label"
    }, [_c('span', {
      staticClass: "switcher-text on-text"
    }, [_vm._v(_vm._s(_vm.onText))]), _c('span', {
      staticClass: "switcher-text off-text"
    }, [_vm._v(_vm._s(_vm.offText))])]), _vm.isLoading ? [_c('img', {
      staticClass: "bk-switcher-loading",
      attrs: {
        "src": __$_require_ui_images_spinner_svg__
      }
    })] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$_ = [];
  /* style */

  var __vue_inject_styles__$_ = undefined;
  /* scoped */

  var __vue_scope_id__$_ = undefined;
  /* module identifier */

  var __vue_module_identifier__$_ = undefined;
  /* functional template */

  var __vue_is_functional_template__$_ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$_ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$_,
    staticRenderFns: __vue_staticRenderFns__$_
  }, __vue_inject_styles__$_, __vue_script__$Y, __vue_scope_id__$_, __vue_is_functional_template__$_, __vue_module_identifier__$_, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$_);

  var bkTabLabel = {
    name: 'bk-tab-label',
    props: ['panel', 'index', 'closable', 'isSidePosition'],
    render: function render(h) {
      var _this = this;
      var _this$panel = this.panel,
          renderLabel = _this$panel.renderLabel,
          $slots = _this$panel.$slots,
          label = _this$panel.label,
          name = _this$panel.name;
      var labelContent = renderLabel && renderLabel(h, name) || $slots.label || label;
      return h("li", {
        "on": {
          "click": function click() {
            return _this.$parent.togglePanel(_this.panel);
          }
        },
        "class": this.showClose && !this.isSidePosition ? 'has-close' : ''
      }, [h("div", {
        "class": "bk-tab-label"
      }, [labelContent]), this.showClose ? h("i", {
        "class": "bk-tab-close-controller",
        "on": {
          "click": function click($event) {
            return _this.handleClosePanel($event);
          }
        }
      }) : '']);
    },
    computed: {
      showClose: function showClose() {
        if (this.panel.disabled) {
          return false;
        }
        if (this.panel.closable !== undefined) {
          return this.panel.closable;
        }
        return this.closable;
      }
    },
    methods: {
      handleClosePanel: function handleClosePanel(event) {
        event.stopPropagation();
        this.$parent.handleClosePanel(this.index, this.panel);
      }
    }
  };

  var script$Z = {
    name: 'bk-tab',
    components: {
      bkTabLabel: bkTabLabel
    },
    props: {
      active: {
        type: [String, Number],
        default: ''
      },
      sortable: {
        type: Boolean,
        default: false
      },
      sortType: {
        type: String,
        default: 'replace'
      },
      type: {
        type: String,
        default: 'border-card',
        validator: function validator(val) {
          return ['card', 'border-card', 'unborder-card', 'vertical-card'].includes(val);
        }
      },
      tabPosition: {
        type: String,
        default: 'top',
        validator: function validator(val) {
          return ['left', 'right', 'top'].includes(val);
        }
      },
      scrollStep: {
        type: Number,
        default: 200
      },
      validateActive: {
        type: Boolean,
        default: true
      },
      closable: Boolean,
      addable: Boolean,
      beforeToggle: Function,
      extCls: {
        type: String,
        default: ''
      },
      showHeader: {
        type: Boolean,
        default: true
      },
      changeOnHover: Boolean,
      changeOnHoverDelay: {
        type: Number,
        default: 1000
      },
      labelHeight: {
        type: Number,
        default: 50,
        validator: function validator(val) {
          if (val < 42) {
            console.error('选项卡 label 的高度，最小值为 42');
            return false;
          }
          return true;
        }
      },
      activeBar: {
        type: Object,
        default: function _default() {
          return {
            position: 'bottom',
            height: '2px'
          };
        }
      },
      addShowNextRight: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        isTab: true,
        localActive: this.active,
        scrollState: {
          show: false,
          position: 'left',
          offset: 0,
          basicStep: this.scrollStep,
          wrapperRect: null,
          listRect: null
        },
        panelInstance: [],
        dragenterIndex: -1,
        dragStartIndex: -1,
        draggingEle: null,
        guid: Math.random().toString(16).substr(4) + Math.random().toString(16).substr(4),
        resizeHandler: null,
        promise: {
          toggle: {
            previousPanel: null,
            rejector: null
          }
        },
        hoverTimer: null,
        activeBarStyle: {
          left: 0,
          width: 0,
          height: 0,
          transform: '',
          top: '',
          bottom: ''
        },
        addCustomRect: {
          width: 0
        }
      };
    },
    computed: {
      panelNames: function panelNames() {
        return this.panelInstance.map(function (panel) {
          return panel.name;
        });
      },
      activePanel: function activePanel() {
        var _this = this;
        return this.panelInstance.find(function (panel) {
          return panel.name === _this.localActive;
        });
      },
      visiblePanels: function visiblePanels() {
        return this.panelInstance.filter(function (panel) {
          return panel.visible;
        });
      },
      tabStyle: function tabStyle() {
        if (this.isSidePosition) {
          var paddingValue = 21;
          return {
            minHeight: "".concat(this.labelHeight * 4 + paddingValue, "px")
          };
        }
        return {};
      },
      headerStyle: function headerStyle() {
        if (this.tabPosition === 'top') {
          var diffValue = this.type === 'border-card' ? 2 : 1;
          return {
            height: "".concat(this.labelHeight, "px"),
            backgroundImage: "linear-gradient(transparent ".concat(this.labelHeight - diffValue, "px, #dcdee5 1px)")
          };
        }
        return {};
      },
      isSidePosition: function isSidePosition() {
        return ['left', 'right'].includes(this.tabPosition);
      },
      isEmpty: function isEmpty() {
        return this.panelInstance.length < 1;
      },
      hasActiveBar: function hasActiveBar() {
        return (this.type === 'unborder-card' || this.isSidePosition) && !this.isEmpty;
      },
      tabLabelListStyle: function tabLabelListStyle() {
        if (this.isEmpty) {
          return {};
        }
        if (this.hasActiveBar) {
          return {
            transform: "translateX(".concat(this.scrollState.offset, "px)"),
            height: "".concat(this.labelHeight, "px"),
            '--activeBarTop': this.activeBarStyle.top,
            '--activeBarBottom': this.activeBarStyle.bottom,
            '--activeBarLeft': this.activeBarStyle.left,
            '--activeBarWidth': this.activeBarStyle.width,
            '--activeBarHeight': this.activeBarStyle.height,
            '--activeBarTransform': this.activeBarStyle.transform
          };
        }
        return {
          transform: "translateX(".concat(this.scrollState.offset, "px)"),
          height: "".concat(this.labelHeight, "px")
        };
      },
      hasAddBtnSlot: function hasAddBtnSlot() {
        return !!this.$slots && !!this.$slots.add;
      }
    },
    watch: {
      panelNames: function panelNames(names) {
        this.checkActiveName();
      },
      active: function active(_active) {
        this.updateActiveBarPosition(_active);
        if (this.localActive !== _active) {
          this.localActive = _active;
          if (this.promise.toggle.rejector) {
            this.promise.toggle.rejector(false);
            this.clearToggleStatus();
          }
        }
      },
      localActive: function localActive(_localActive) {
        if (_localActive !== this.active) {
          this.$emit('update:active', _localActive);
          this.$emit('tab-change', _localActive, this.activePanel);
          this.updateActivePosition(_localActive);
        }
      },
      showHeader: function showHeader(value) {
        if (value) {
          this.resizeHandler();
        }
      },
      tabPosition: function tabPosition() {
        this.updateActiveBarPosition(this.localActive);
      },
      'scrollState.show': function scrollStateShow(isShow) {
        this.$emit('scroll-show-change', isShow);
      }
    },
    created: function created() {
      this.resizeHandler = debounce(100, this.calculateScroller);
    },
    mounted: function mounted() {
      this.updateActiveBarPosition(this.localActive);
      addResizeListener(this.$refs.labelList, this.resizeHandler);
      addResizeListener(this.$refs.labelWrapper, this.resizeHandler);
      this.caluclateVerticalPadding();
    },
    beforeDestroy: function beforeDestroy() {
      removeResizeListener(this.$refs.labelList, this.resizeHandler);
      removeResizeListener(this.$refs.labelWrapper, this.resizeHandler);
    },
    methods: {
      caluclateVerticalPadding: function caluclateVerticalPadding() {
        var _this2 = this;
        if (this.type !== 'vertical-card') return;
        this.$nextTick(function () {
          var width = _this2.$refs.tabHeader.offsetWidth;
          _this2.$refs.tabSection.style["padding-".concat(_this2.verticalPosition)] = "".concat(width + 20, "px");
        });
      },
      registerPanel: function registerPanel(panel) {
        this.panelInstance.push(panel);
      },
      deletePanel: function deletePanel(panel) {
        var index = this.panelInstance.indexOf(panel);
        if (index !== -1) {
          this.panelInstance.splice(index, 1);
        }
      },
      togglePanel: function togglePanel(panel) {
        var _this3 = this;
        return _asyncToGenerator( regenerator.mark(function _callee2() {
          var toggleStatus, shouldToggle;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!panel.disabled) {
                    _context2.next = 2;
                    break;
                  }
                  return _context2.abrupt("return", false);
                case 2:
                  _this3.handleClearHoverTimer();
                  toggleStatus = _this3.promise.toggle;
                  if (!(panel.name === _this3.localActive)) {
                    _context2.next = 7;
                    break;
                  }
                  if (toggleStatus.rejector) {
                    toggleStatus.rejector(false);
                  }
                  return _context2.abrupt("return", false);
                case 7:
                  if (!(typeof _this3.beforeToggle === 'function')) {
                    _context2.next = 29;
                    break;
                  }
                  if (!toggleStatus.previousPanel) {
                    _context2.next = 14;
                    break;
                  }
                  if (!(toggleStatus.previousPanel === panel)) {
                    _context2.next = 13;
                    break;
                  }
                  return _context2.abrupt("return", false);
                case 13:
                  toggleStatus.rejector(false);
                case 14:
                  _context2.prev = 14;
                  _context2.next = 17;
                  return new promise$1( function () {
                    var _ref = _asyncToGenerator( regenerator.mark(function _callee(resolve, reject) {
                      var confirmed;
                      return regenerator.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              toggleStatus.previousPanel = panel;
                              toggleStatus.rejector = reject;
                              _context.next = 4;
                              return _this3.beforeToggle(panel.name, panel);
                            case 4:
                              confirmed = _context.sent;
                              confirmed ? resolve(confirmed) : reject(confirmed);
                            case 6:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));
                    return function (_x, _x2) {
                      return _ref.apply(this, arguments);
                    };
                  }());
                case 17:
                  shouldToggle = _context2.sent;
                  if (shouldToggle) {
                    _this3.localActive = panel.name;
                  }
                  _context2.next = 24;
                  break;
                case 21:
                  _context2.prev = 21;
                  _context2.t0 = _context2["catch"](14);
                  console.log('Previous tab toggle canceled');
                case 24:
                  _context2.prev = 24;
                  _this3.clearToggleStatus();
                  return _context2.finish(24);
                case 27:
                  _context2.next = 30;
                  break;
                case 29:
                  _this3.localActive = panel.name;
                case 30:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[14, 21, 24, 27]]);
        }))();
      },
      clearToggleStatus: function clearToggleStatus() {
        this.promise.toggle = {
          previousPanel: null,
          rejector: null
        };
      },
      checkActiveName: function checkActiveName() {
        if (this.validateActive && !this.panelNames.includes(this.localActive)) {
          var newActivePanel = this.panelInstance.length ? this.panelInstance[0] : null;
          this.localActive = newActivePanel ? newActivePanel.name : '';
        }
      },
      calculateScroller: function calculateScroller() {
        var _this4 = this;
        if (!this.showHeader) {
          return false;
        }
        this.$nextTick(function () {
          var _this4$$refs = _this4.$refs,
              labelWrapper = _this4$$refs.labelWrapper,
              labelList = _this4$$refs.labelList,
              addController = _this4$$refs.addController;
          var labelWrapperRect = labelWrapper.getBoundingClientRect();
          var labelListRect = labelList.getBoundingClientRect();
          var addControllerRect = addController ? addController.getBoundingClientRect() : {
            width: 0
          };
          _this4.addCustomRect = _this4.hasAddBtnSlot ? _this4.$refs.addCustom.getBoundingClientRect() : {
            width: 0
          };
          _this4.scrollState.show = labelListRect.width + addControllerRect.width + _this4.addCustomRect.width > labelWrapperRect.width;
          if (!_this4.scrollState.show) {
            _this4.scrollState.offset = 0;
            _this4.scrollState.position = 'left';
          } else {
            _this4.compensateOffset(labelWrapperRect, labelListRect);
          }
          _this4.scrollState.wrapperRect = labelWrapperRect;
          _this4.scrollState.listRect = labelListRect;
          _this4.updateActivePosition(_this4.localActive);
        });
      },
      compensateOffset: function compensateOffset(newWrapperRect, newListRect) {
        var oldWrapperRect = this.scrollState.wrapperRect;
        if (!oldWrapperRect) {
          return false;
        }
        var overplusWidth = newWrapperRect.width - this.scrollState.offset - newListRect.width;
        if (overplusWidth > 0) {
          this.scrollState.offset = newWrapperRect.width - newListRect.width - this.getControllerWidth();
          this.scrollState.position = 'right';
        } else {
          this.scrollState.position = this.scrollState.position === 'left' ? 'left' : 'middle';
        }
      },
      getControllerWidth: function getControllerWidth() {
        return this.getLeftControllerWidth() + this.getRightControllerWidth();
      },
      getLeftControllerWidth: function getLeftControllerWidth() {
        var prevController = this.$refs.prevController;
        var controllers = [prevController];
        var width = 0;
        controllers.forEach(function (controller) {
          width += controller ? controller.offsetWidth : 0;
        });
        return width;
      },
      getRightControllerWidth: function getRightControllerWidth() {
        var _this$$refs = this.$refs,
            nextController = _this$$refs.nextController,
            addController = _this$$refs.addController;
        var controllers = [nextController, addController];
        var width = 0;
        controllers.forEach(function (controller) {
          width += controller ? controller.offsetWidth : 0;
        });
        if (this.hasAddBtnSlot) {
          this.addCustomRect = this.hasAddBtnSlot ? this.$refs.addCustom.getBoundingClientRect() : {
            width: 0
          };
          width += this.addCustomRect.width;
        }
        return width;
      },
      updateActiveBarPosition: function updateActiveBarPosition(active) {
        var _this5 = this;
        if (!this.showHeader) {
          return false;
        }
        this.$nextTick(function () {
          var panel = _this5.$refs.tabLabel.find(function (item) {
            if (item && item.$el) {
              var newActive = Object.prototype.toString.call(active) === '[object Number]' ? active + '' : active;
              return item.$el.dataset.name === newActive;
            }
          });
          if (panel) {
            var tabLabel = panel.$el;
            var tabLabelRect = tabLabel.getBoundingClientRect();
            if (!_this5.isSidePosition) {
              if (tabLabelRect.width === 0 && tabLabelRect.height === 0) {
                tabLabel.classList.add('simulate-border-bottom');
              } else {
                tabLabel.classList.remove('simulate-border-bottom');
              }
              _this5.activeBarStyle.width = "".concat(tabLabelRect.width - 24, "px");
              _this5.activeBarStyle.height = _this5.activeBar.height;
              _this5.activeBarStyle.transform = "translateX(".concat(tabLabel.offsetLeft + 12, "px)");
              _this5.activeBarStyle.left = 0;
              if (_this5.activeBar.position === 'top') {
                _this5.activeBarStyle.top = '0px';
                _this5.activeBarStyle.bottom = 'auto';
              } else {
                _this5.activeBarStyle.top = 'auto';
                _this5.activeBarStyle.bottom = '0px';
              }
            } else {
              if (tabLabelRect.width === 0 && tabLabelRect.height === 0) {
                tabLabel.classList.add('simulate-border-right');
              } else {
                tabLabel.classList.remove('simulate-border-right');
              }
              _this5.activeBarStyle.width = _this5.activeBar.height;
              _this5.activeBarStyle.height = "".concat(tabLabelRect.height || 50, "px");
              _this5.activeBarStyle.transform = "translateY(".concat(tabLabel.offsetTop, "px)");
              if (_this5.tabPosition === 'right') {
                _this5.activeBarStyle.left = 0;
              } else {
                _this5.activeBarStyle.left = "".concat(tabLabelRect.width - 2, "px");
              }
            }
          }
        });
      },
      updateActivePosition: function updateActivePosition(active) {
        var _this6 = this;
        if (!this.scrollState.show || !this.showHeader) {
          return false;
        }
        this.$nextTick(function () {
          var index = _this6.panelNames.indexOf(active);
          if (index !== -1) {
            var _this6$scrollState = _this6.scrollState,
                wrapperRect = _this6$scrollState.wrapperRect,
                listRect = _this6$scrollState.listRect;
            var tabLabel = _this6.$refs.tabLabel[index].$el;
            var tabLabelRect = tabLabel.getBoundingClientRect();
            var labelWrapperWidth = wrapperRect.width - _this6.getControllerWidth();
            var leftThreshold = tabLabel.offsetLeft;
            var rightThreshold = Math.abs(tabLabel.offsetLeft - labelWrapperWidth + tabLabelRect.width);
            var isLeftOutside = tabLabelRect.left < wrapperRect.left + _this6.getLeftControllerWidth();
            var isRightOutside = tabLabelRect.right > wrapperRect.right - _this6.getRightControllerWidth();
            if (isLeftOutside) {
              _this6.scrollState.offset = -1 * leftThreshold;
              _this6.scrollState.position = leftThreshold ? 'middle' : 'left';
            } else if (isRightOutside) {
              _this6.scrollState.offset = -1 * rightThreshold;
              _this6.scrollState.position = listRect.width - rightThreshold === labelWrapperWidth ? 'right' : 'middle';
            }
          }
        });
      },
      stepToPrev: function stepToPrev() {
        var _this$scrollState = this.scrollState,
            position = _this$scrollState.position,
            basicStep = _this$scrollState.basicStep,
            offset = _this$scrollState.offset;
        if (position === 'left') {
          return false;
        }
        var newOffset = offset + basicStep;
        if (newOffset > 0) {
          newOffset = 0;
          this.scrollState.position = 'left';
        } else {
          this.scrollState.position = 'middle';
        }
        this.scrollState.offset = newOffset;
      },
      stepToNext: function stepToNext() {
        var _this$scrollState2 = this.scrollState,
            position = _this$scrollState2.position,
            basicStep = _this$scrollState2.basicStep,
            wrapperRect = _this$scrollState2.wrapperRect,
            listRect = _this$scrollState2.listRect,
            offset = _this$scrollState2.offset;
        if (position === 'right') {
          return false;
        }
        var controllerWidth = this.getControllerWidth();
        var newOffset = offset - basicStep;
        if (wrapperRect.width - controllerWidth - newOffset > listRect.width) {
          newOffset = wrapperRect.width - listRect.width - controllerWidth;
          this.scrollState.position = 'right';
        } else {
          this.scrollState.position = 'middle';
        }
        this.scrollState.offset = newOffset;
      },
      handleAddPanel: function handleAddPanel() {
        this.$emit('add-panel');
      },
      handleClosePanel: function handleClosePanel(index, panel) {
        this.$emit('close-panel', index, panel);
      },
      handleLabelHover: function handleLabelHover(panel) {
        var _this7 = this;
        if (!this.changeOnHover || panel.disabled || panel.name === this.localActive) {
          return false;
        }
        this.handleClearHoverTimer();
        this.hoverTimer = setTimeout(function () {
          _this7.togglePanel(panel);
        }, this.changeOnHoverDelay);
      },
      handleClearHoverTimer: function handleClearHoverTimer() {
        this.hoverTimer && clearTimeout(this.hoverTimer);
        this.hoverTimer = null;
      },
      dragStart: function dragStart(index, $event) {
        this.dragStartIndex = index;
        this.draggingEle = this.guid;
        $event.dataTransfer.effectAllowed = 'move';
        this.$emit('on-drag-tab', index, $event);
      },
      dragenter: function dragenter(index) {
        if (this.distinctRoots(this.draggingEle, this.guid)) {
          this.dragenterIndex = index;
        }
      },
      dragend: function dragend() {
        this.dragenterIndex = -1;
        this.dragStartIndex = -1;
        this.draggingEle = null;
      },
      drop: function drop(index, $event) {
        var _this8 = this;
        if (!this.visiblePanels[index].sortable) {
          return false;
        }
        if (!this.distinctRoots(this.draggingEle, this.guid)) {
          return false;
        }
        if (this.sortType === 'insert') {
          if (this.dragStartIndex < index) {
            this.visiblePanels.splice(index + 1, 0, this.visiblePanels[this.dragStartIndex]);
            this.visiblePanels.splice(this.dragStartIndex, 1);
          } else if (this.dragStartIndex > index) {
            this.visiblePanels.splice(index, 0, this.visiblePanels[this.dragStartIndex]);
            this.visiblePanels.splice(this.dragStartIndex + 1, 1);
          } else {
            return false;
          }
        } else {
          this.swapArr(this.visiblePanels, this.dragStartIndex, index);
        }
        this.$emit('sort-change', this.dragStartIndex, index);
        var timer = setTimeout(function () {
          _this8.updateActiveBarPosition(_this8.localActive);
          clearTimeout(timer);
          timer = null;
        }, 200);
      },
      swapArr: function swapArr(arr, a, b) {
        var swap = arr[a];
        arr[a] = arr[b];
        arr[b] = swap;
      },
      distinctRoots: function distinctRoots(el1, el2) {
        return el1 === el2;
      }
    }
  };

  /* script */
  var __vue_script__$Z = script$Z;
  /* template */

  var __vue_render__$$ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-tab', _vm.tabPosition === 'top' ? "bk-tab-" + _vm.type : "position-" + _vm.tabPosition, _vm.extCls],
      style: _vm.tabStyle
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showHeader,
        expression: "showHeader"
      }],
      ref: "tabHeader",
      staticClass: "bk-tab-header",
      style: _vm.headerStyle
    }, [_c('div', {
      staticClass: "bk-tab-header-setting",
      class: {
        'has-setting': _vm.$slots.setting
      },
      style: {
        height: _vm.labelHeight + "px",
        lineHeight: _vm.labelHeight + "px"
      }
    }, [_vm._t("setting")], 2), _c('div', {
      ref: "labelWrapper",
      staticClass: "bk-tab-label-wrapper",
      class: {
        'has-scroller': _vm.scrollState.show && !_vm.isSidePosition,
        'has-add': (_vm.addable || _vm.hasAddBtnSlot) && !_vm.isSidePosition
      },
      style: {
        padding: _vm.scrollState.show && !_vm.isSidePosition ? "0 " + (_vm.addCustomRect.width + 24) + "px 0 24px" : undefined
      }
    }, [_c('ul', {
      ref: "labelList",
      class: ['bk-tab-label-list', {
        'bk-tab-label-list-has-bar': _vm.hasActiveBar
      }],
      style: _vm.tabLabelListStyle
    }, _vm._l(_vm.visiblePanels, function (panel, index) {
      return _c("bk-tab-label", {
        key: panel.name + index,
        ref: "tabLabel",
        refInFor: true,
        tag: "li",
        staticClass: "bk-tab-label-item",
        class: {
          active: panel.name === _vm.localActive,
          'is-first': index === 0,
          'is-last': index === _vm.visiblePanels.length - 1,
          'is-disabled': panel.disabled,
          'is-dragging': _vm.dragStartIndex === index,
          'is-dragenter': _vm.dragenterIndex === index && index !== _vm.dragStartIndex && panel.sortable,
          'is-unsortable': _vm.dragenterIndex === index && !panel.sortable
        },
        style: {
          lineHeight: _vm.labelHeight + "px"
        },
        attrs: {
          "data-name": panel.name,
          "draggable": _vm.sortable && panel.sortable,
          "panel": panel,
          "index": index,
          "closable": _vm.closable,
          "is-side-position": _vm.isSidePosition
        },
        nativeOn: {
          "dragstart": function dragstart($event) {
            _vm.dragStart(index, $event);
          },
          "dragenter": function dragenter($event) {
            $event.preventDefault();

            _vm.dragenter(index, $event);
          },
          "dragleave": function dragleave($event) {
            $event.preventDefault();
          },
          "dragover": function dragover($event) {
            $event.preventDefault();
          },
          "dragend": function dragend($event) {
            $event.preventDefault();

            _vm.dragend(index, $event);
          },
          "drop": function drop($event) {
            $event.preventDefault();

            _vm.drop(index, $event);
          },
          "&mouseenter": function mouseenter($event) {
            _vm.handleLabelHover(panel);
          },
          "&mouseleave": function mouseleave($event) {
            _vm.handleClearHoverTimer(panel);
          }
        }
      });
    }), 1), _vm.addable && !_vm.isSidePosition && !_vm.hasAddBtnSlot ? _c('i', {
      ref: "addController",
      staticClass: "bk-tab-add-controller bk-icon icon-plus",
      class: {
        'left-border': !_vm.visiblePanels.length,
        'next-right': _vm.addShowNextRight
      },
      style: {
        height: _vm.labelHeight + "px",
        lineHeight: _vm.labelHeight + "px"
      },
      on: {
        "click": _vm.handleAddPanel
      }
    }) : _vm._e(), _vm.hasAddBtnSlot ? _c('div', {
      ref: "addCustom",
      staticClass: "bk-tab-add-custom",
      class: {
        'next-right': _vm.addShowNextRight
      },
      style: {
        height: (_vm.scrollState.show && !_vm.isSidePosition ? _vm.labelHeight - 1 : _vm.labelHeight - 2) + "px",
        lineHeight: _vm.labelHeight + "px"
      }
    }, [_vm._t("add")], 2) : _vm._e(), _vm.scrollState.show ? [_c('i', {
      ref: "prevController",
      staticClass: "bk-tab-scroll-controller prev bk-icon icon-angle-left",
      class: {
        'disabled': _vm.scrollState.position === 'left'
      },
      style: {
        height: _vm.labelHeight - 1 + "px",
        lineHeight: _vm.labelHeight + "px"
      },
      on: {
        "click": _vm.stepToPrev
      }
    }), _c('i', {
      ref: "nextController",
      staticClass: "bk-tab-scroll-controller next bk-icon icon-angle-right",
      class: {
        'disabled': _vm.scrollState.position === 'right'
      },
      style: {
        height: _vm.labelHeight - 1 + "px",
        lineHeight: _vm.labelHeight + "px",
        right: _vm.hasAddBtnSlot || _vm.addable ? (_vm.addShowNextRight ? 0 : _vm.addCustomRect.width || 40) + "px" : undefined
      },
      on: {
        "click": _vm.stepToNext
      }
    })] : _vm._e()], 2)]), _c('div', {
      ref: "tabSection",
      staticClass: "bk-tab-section"
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$$ = [];
  /* style */

  var __vue_inject_styles__$$ = undefined;
  /* scoped */

  var __vue_scope_id__$$ = undefined;
  /* module identifier */

  var __vue_module_identifier__$$ = undefined;
  /* functional template */

  var __vue_is_functional_template__$$ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$$ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$$,
    staticRenderFns: __vue_staticRenderFns__$$
  }, __vue_inject_styles__$$, __vue_script__$Z, __vue_scope_id__$$, __vue_is_functional_template__$$, __vue_module_identifier__$$, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$$);

  var script$_ = {
    name: 'bk-tab-panel',
    props: {
      name: {
        type: [String, Number],
        required: true
      },
      label: {
        type: String,
        required: false
      },
      closable: {
        type: Boolean,
        default: undefined
      },
      visible: {
        type: Boolean,
        default: true
      },
      disabled: Boolean,
      sortable: {
        type: Boolean,
        default: true
      },
      renderDirective: {
        type: String,
        default: 'show',
        validator: function validator(val) {
          return ['if', 'show'].includes(val);
        }
      },
      renderLabel: Function
    },
    computed: {
      tabInstance: function tabInstance() {
        var parent = this.$parent;
        while (parent && !parent.isTab) {
          parent = parent.$parent;
        }
        return parent;
      },
      shouldRender: function shouldRender() {
        var directive = this.renderDirective;
        return directive === 'show' || this.active && directive === 'if';
      },
      active: function active() {
        return this.tabInstance.localActive === this.name;
      }
    },
    created: function created() {
      if (this.tabInstance.isTab) {
        this.tabInstance.registerPanel(this);
      } else {
        console.error('"bk-tab-panel"\'s parent element must be "bk-tab"');
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.tabInstance.isTab) {
        this.tabInstance.deletePanel(this);
      }
    }
  };

  /* script */
  var __vue_script__$_ = script$_;
  /* template */

  var __vue_render__$10 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.shouldRender ? _c('section', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.active,
        expression: "active"
      }],
      staticClass: "bk-tab-content"
    }, [_vm._t("default")], 2) : _vm._e();
  };

  var __vue_staticRenderFns__$10 = [];
  /* style */

  var __vue_inject_styles__$10 = undefined;
  /* scoped */

  var __vue_scope_id__$10 = undefined;
  /* module identifier */

  var __vue_module_identifier__$10 = undefined;
  /* functional template */

  var __vue_is_functional_template__$10 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$10 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$10,
    staticRenderFns: __vue_staticRenderFns__$10
  }, __vue_inject_styles__$10, __vue_script__$_, __vue_scope_id__$10, __vue_is_functional_template__$10, __vue_module_identifier__$10, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$10);

  var _populated = false;
  var _ie, _firefox, _opera, _webkit, _chrome;
  var _ie_real_version;
  var _osx, _windows, _linux, _android;
  var _win64;
  var _iphone, _ipad, _native;
  var _mobile;
  function _populate() {
    if (_populated) {
      return;
    }
    _populated = true;
    var uas = navigator.userAgent;
    var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
    var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
    _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
    _ipad = /\b(iP[ao]d)/.exec(uas);
    _android = /Android/i.exec(uas);
    _native = /FBAN\/\w+;/i.exec(uas);
    _mobile = /Mobile/i.exec(uas);
    _win64 = !!(/Win64/.exec(uas));
    if (agent) {
      _ie = agent[1] ? parseFloat(agent[1]) : (
            agent[5] ? parseFloat(agent[5]) : NaN);
      if (_ie && document && document.documentMode) {
        _ie = document.documentMode;
      }
      var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
      _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
      _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
      _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
      _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
      if (_webkit) {
        agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
        _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
      } else {
        _chrome = NaN;
      }
    } else {
      _ie = _firefox = _opera = _chrome = _webkit = NaN;
    }
    if (os) {
      if (os[1]) {
        var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
        _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
      } else {
        _osx = false;
      }
      _windows = !!os[2];
      _linux   = !!os[3];
    } else {
      _osx = _windows = _linux = false;
    }
  }
  var UserAgent_DEPRECATED = {
    ie: function() {
      return _populate() || _ie;
    },
    ieCompatibilityMode: function() {
      return _populate() || (_ie_real_version > _ie);
    },
    ie64: function() {
      return UserAgent_DEPRECATED.ie() && _win64;
    },
    firefox: function() {
      return _populate() || _firefox;
    },
    opera: function() {
      return _populate() || _opera;
    },
    webkit: function() {
      return _populate() || _webkit;
    },
    safari: function() {
      return UserAgent_DEPRECATED.webkit();
    },
    chrome : function() {
      return _populate() || _chrome;
    },
    windows: function() {
      return _populate() || _windows;
    },
    osx: function() {
      return _populate() || _osx;
    },
    linux: function() {
      return _populate() || _linux;
    },
    iphone: function() {
      return _populate() || _iphone;
    },
    mobile: function() {
      return _populate() || (_iphone || _ipad || _android || _mobile);
    },
    nativeApp: function() {
      return _populate() || _native;
    },
    android: function() {
      return _populate() || _android;
    },
    ipad: function() {
      return _populate() || _ipad;
    }
  };
  var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

  var canUseDOM = !!(
    typeof window !== 'undefined' &&
    window.document &&
    window.document.createElement
  );
  var ExecutionEnvironment = {
    canUseDOM: canUseDOM,
    canUseWorkers: typeof Worker !== 'undefined',
    canUseEventListeners:
      canUseDOM && !!(window.addEventListener || window.attachEvent),
    canUseViewport: canUseDOM && !!window.screen,
    isInWorker: !canUseDOM
  };
  var ExecutionEnvironment_1 = ExecutionEnvironment;

  var useHasFeature;
  if (ExecutionEnvironment_1.canUseDOM) {
    useHasFeature =
      document.implementation &&
      document.implementation.hasFeature &&
      document.implementation.hasFeature('', '') !== true;
  }
  function isEventSupported(eventNameSuffix, capture) {
    if (!ExecutionEnvironment_1.canUseDOM ||
        capture && !('addEventListener' in document)) {
      return false;
    }
    var eventName = 'on' + eventNameSuffix;
    var isSupported = eventName in document;
    if (!isSupported) {
      var element = document.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }
    if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
      isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
    }
    return isSupported;
  }
  var isEventSupported_1 = isEventSupported;

  var PIXEL_STEP  = 10;
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;
  function normalizeWheel( event)  {
    var sX = 0, sY = 0,
        pX = 0, pY = 0;
    if ('detail'      in event) { sY = event.detail; }
    if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
    if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
    if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }
    if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in event) { pY = event.deltaY; }
    if ('deltaX' in event) { pX = event.deltaX; }
    if ((pX || pY) && event.deltaMode) {
      if (event.deltaMode == 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }
    return { spinX  : sX,
             spinY  : sY,
             pixelX : pX,
             pixelY : pY };
  }
  normalizeWheel.getEventType = function()  {
    return (UserAgent_DEPRECATED_1.firefox())
             ? 'DOMMouseScroll'
             : (isEventSupported_1('wheel'))
                 ? 'wheel'
                 : 'mousewheel';
  };
  var normalizeWheel_1 = normalizeWheel;

  var normalizeWheel$1 = normalizeWheel_1;

  var isFirefox$2 = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  var mousewheel = function mousewheel(element, callback) {
    if (element && element.addEventListener) {
      element.addEventListener(isFirefox$2 ? 'DOMMouseScroll' : 'mousewheel', function (event) {
        var normalized = normalizeWheel$1(event);
        callback && callback.apply(this, [event, normalized]);
      });
    }
  };
  var Mousewheel = {
    bind: function bind(el, binding) {
      mousewheel(el, binding.value);
    }
  };

  var getValueByPath = function getValueByPath(object, prop) {
    prop = prop || '';
    var paths = prop.split('.');
    var current = object;
    var result = null;
    for (var i = 0, j = paths.length; i < j; i++) {
      var path = paths[i];
      if (!current) break;
      if (i === j - 1) {
        result = current[path];
        break;
      }
      current = current[path];
    }
    return result;
  };
  function getPropByPath(obj, path, strict) {
    var tempObj = obj;
    path = path.replace(/\[(\w+)\]/g, '.$1');
    path = path.replace(/^\./, '');
    var keyArr = path.split('.');
    var i = 0;
    for (var len = keyArr.length; i < len - 1; ++i) {
      if (!tempObj && !strict) break;
      var key = keyArr[i];
      if (key in tempObj) {
        tempObj = tempObj[key];
      } else {
        if (strict) {
          throw new Error('please transfer a valid prop path to form item!');
        }
        break;
      }
    }
    return {
      o: tempObj,
      k: keyArr[i],
      v: tempObj ? tempObj[keyArr[i]] : null
    };
  }
  var getCell = function getCell(event) {
    var cell = event.target;
    while (cell && cell.tagName.toUpperCase() !== 'HTML') {
      if (cell.tagName.toUpperCase() === 'TD') {
        return cell;
      }
      cell = cell.parentNode;
    }
    return null;
  };
  var isObject = function isObject(obj) {
    return obj !== null && _typeof(obj) === 'object';
  };
  var orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
    if (!sortKey && !sortMethod && (!sortBy || isArray$1(sortBy) && !sortBy.length)) {
      return array;
    }
    if (typeof reverse === 'string') {
      reverse = reverse === 'descending' ? -1 : 1;
    } else {
      reverse = reverse && reverse < 0 ? -1 : 1;
    }
    var getKey = sortMethod ? null : function (value, index) {
      if (sortBy) {
        if (!isArray$1(sortBy)) {
          sortBy = [sortBy];
        }
        return sortBy.map(function (by) {
          if (typeof by === 'string') {
            return getValueByPath(value, by);
          } else {
            return by(value, index, array);
          }
        });
      }
      if (sortKey !== '$key') {
        if (isObject(value) && '$value' in value) value = value.$value;
      }
      return [isObject(value) ? getValueByPath(value, sortKey) : value];
    };
    var compare = function compare(a, b) {
      if (sortMethod) {
        return sortMethod(a.value, b.value);
      }
      for (var i = 0, len = a.key.length; i < len; i++) {
        if (a.key[i] < b.key[i]) {
          return -1;
        }
        if (a.key[i] > b.key[i]) {
          return 1;
        }
      }
      return 0;
    };
    return array.map(function (value, index) {
      return {
        value: value,
        index: index,
        key: getKey ? getKey(value, index) : null
      };
    }).sort(function (a, b) {
      var order = compare(a, b);
      if (!order) {
        order = a.index - b.index;
      }
      return order * reverse;
    }).map(function (item) {
      return item.value;
    });
  };
  var getColumnById = function getColumnById(table, columnId) {
    var column = null;
    table.columns.forEach(function (item) {
      if (item.id === columnId) {
        column = item;
      }
    });
    return column;
  };
  var getColumnByCell = function getColumnByCell(table, cell) {
    var matches = (cell.className || '').match(/bk-table-[^\s]+/gm);
    if (matches) {
      return getColumnById(table, matches[0]);
    }
    return null;
  };
  var getRowIdentity = function getRowIdentity(row, rowKey) {
    if (!row) throw new Error('row is required when get row identity');
    if (typeof rowKey === 'string') {
      if (rowKey.indexOf('.') < 0) {
        return row[rowKey];
      }
      var key = rowKey.split('.');
      var current = row;
      for (var i = 0; i < key.length; i++) {
        current = current[key[i]];
      }
      return current;
    } else if (typeof rowKey === 'function') {
      return rowKey(row);
    }
  };
  var isShallowEqual = function isShallowEqual() {
    var current = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var currentKeys = keys$1(current);
    var previousKeys = keys$1(previous);
    if (currentKeys.length !== previousKeys.length) {
      return false;
    }
    return !currentKeys.some(function (key) {
      return current[key] !== previous[key];
    });
  };
  var createFuncWrapper = function createFuncWrapper(handler) {
    if (typeof handler !== 'function') return function () {};
    var promise;
    return function () {
      var _arguments = arguments;
      if (promise) return promise;
      promise = new promise$1(function (resolve) {
        setTimeout( _asyncToGenerator( regenerator.mark(function _callee() {
          var result;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  promise = null;
                  _context.next = 3;
                  return handler.apply(void 0, _toConsumableArray(_arguments));
                case 3:
                  result = _context.sent;
                  resolve(result);
                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })), 0);
      });
      return promise;
    };
  };

  var sortData = function sortData(data, states) {
    var sortingColumn = states.sortingColumn;
    if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
      return data;
    }
    return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
  };
  var getKeysMap = function getKeysMap() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var rowKey = arguments.length > 1 ? arguments[1] : undefined;
    var arrayMap = {};
    array.forEach(function (row, index) {
      arrayMap[getRowIdentity(row, rowKey)] = {
        row: row,
        index: index
      };
    });
    return arrayMap;
  };
  var _toggleRowSelection = function toggleRowSelection(states, row, selected) {
    var changed = false;
    var selection = states.selection;
    var index = selection.indexOf(row);
    if (typeof selected === 'undefined') {
      if (index === -1) {
        selection.push(row);
        changed = true;
      } else {
        selection.splice(index, 1);
        changed = true;
      }
    } else {
      if (selected && index === -1) {
        selection.push(row);
        changed = true;
      } else if (!selected && index > -1) {
        selection.splice(index, 1);
        changed = true;
      }
    }
    return changed;
  };
  var _toggleRowExpansion = function toggleRowExpansion(states, row, expanded) {
    var changed = false;
    var expandRows = states.expandRows;
    if (typeof expanded !== 'undefined') {
      var index = expandRows.indexOf(row);
      if (expanded) {
        if (index === -1) {
          expandRows.push(row);
          changed = true;
        }
      } else {
        if (index !== -1) {
          expandRows.splice(index, 1);
          changed = true;
        }
      }
    } else {
      var _index = expandRows.indexOf(row);
      if (_index === -1) {
        expandRows.push(row);
        changed = true;
      } else {
        expandRows.splice(_index, 1);
        changed = true;
      }
    }
    return changed;
  };
  var doFlattenColumns = function doFlattenColumns(columns) {
    var result = [];
    columns.forEach(function (column) {
      if (column.children) {
        result.push.apply(result, doFlattenColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };
  var TableStore = function () {
    function TableStore(table) {
      var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, TableStore);
      if (!table) {
        throw new Error('Table is required.');
      }
      this.table = table;
      this.isDraging = false;
      this.states = {
        rowKey: null,
        _columns: [],
        originColumns: [],
        columns: [],
        fixedColumns: [],
        rightFixedColumns: [],
        leafColumns: [],
        fixedLeafColumns: [],
        rightFixedLeafColumns: [],
        leafColumnsLength: 0,
        fixedLeafColumnsLength: 0,
        rightFixedLeafColumnsLength: 0,
        isComplex: false,
        filteredData: null,
        data: null,
        sortingColumn: null,
        sortProp: null,
        sortOrder: null,
        isAllSelected: false,
        selection: [],
        reserveSelection: false,
        selectable: null,
        currentRow: null,
        hoverRow: null,
        filters: {},
        expandRows: [],
        defaultExpandAll: false,
        selectOnIndeterminate: false
      };
      for (var prop in initialState) {
        if (initialState.hasOwnProperty(prop) && this.states.hasOwnProperty(prop)) {
          this.states[prop] = initialState[prop];
        }
      }
    }
    _createClass(TableStore, [{
      key: "mutations",
      get: function get() {
        return {
          setData: function setData(states, data) {
            var _this = this;
            var dataInstanceChanged = states._data !== data;
            states._data = data;
            keys$1(states.filters).forEach(function (columnId) {
              var values = states.filters[columnId];
              if (!values || values.length === 0) return;
              var column = getColumnById(_this.states, columnId);
              if (column && column.filterMethod) {
                data = data.filter(function (row) {
                  return values.some(function (value) {
                    return column.filterMethod.call(null, value, row, column);
                  });
                });
              }
            });
            states.filteredData = data;
            states.data = sortData(data || [], states);
            this.updateCurrentRow();
            var rowKey = states.rowKey;
            if (!states.reserveSelection) {
              if (dataInstanceChanged) {
                this.clearSelection();
              } else {
                this.cleanSelection();
              }
              this.updateAllSelected();
            } else {
              if (rowKey) {
                var selection = states.selection;
                var selectedMap = getKeysMap(selection, rowKey);
                states.data.forEach(function (row) {
                  var rowId = getRowIdentity(row, rowKey);
                  var rowInfo = selectedMap[rowId];
                  if (rowInfo) {
                    selection[rowInfo.index] = row;
                  }
                });
                this.updateAllSelected();
              } else {
                console.warn('WARN: rowKey is required when reserve-selection is enabled.');
              }
            }
            var defaultExpandAll = states.defaultExpandAll;
            if (defaultExpandAll) {
              this.states.expandRows = (states.data || []).slice(0);
            } else if (rowKey) {
              var ids = getKeysMap(this.states.expandRows, rowKey);
              var expandRows = [];
              var _iterator = _createForOfIteratorHelper(states.data),
                  _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var row = _step.value;
                  var rowId = getRowIdentity(row, rowKey);
                  if (ids[rowId]) {
                    expandRows.push(row);
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              this.states.expandRows = expandRows;
            } else {
              this.states.expandRows = [];
            }
            Vue.nextTick(function () {
              return _this.table.updateScrollY();
            });
          },
          changeSortCondition: function changeSortCondition(states, options) {
            var _this2 = this;
            states.data = sortData(states.filteredData || states._data || [], states);
            var _this$table = this.table,
                $el = _this$table.$el,
                highlightCurrentRow = _this$table.highlightCurrentRow;
            if ($el && highlightCurrentRow) {
              var data = states.data;
              var tr = $el.querySelector('tbody').children;
              var rows = [].filter.call(tr, function (row) {
                return hasClass(row, 'bk-table-row');
              });
              var row = rows[data.indexOf(states.currentRow)];
              Array.prototype.forEach.call(rows, function (row) {
                return removeClass(row, 'current-row');
              });
              addClass(row, 'current-row');
            }
            if (!options || !options.silent) {
              this.table.$emit('sort-change', {
                column: this.states.sortingColumn,
                prop: this.states.sortProp,
                order: this.states.sortOrder
              });
            }
            Vue.nextTick(function () {
              return _this2.table.updateScrollY();
            });
          },
          sort: function sort(states, options) {
            var _this3 = this;
            var prop = options.prop,
                order = options.order;
            if (prop) {
              states.sortProp = prop;
              states.sortOrder = order || 'ascending';
              Vue.nextTick(function () {
                for (var i = 0, length = states.columns.length; i < length; i++) {
                  var column = states.columns[i];
                  if (column.property === states.sortProp) {
                    column.order = states.sortOrder;
                    states.sortingColumn = column;
                    break;
                  }
                }
                if (states.sortingColumn) {
                  _this3.commit('changeSortCondition');
                }
              });
            }
          },
          filterChange: function filterChange(states, options) {
            var _this4 = this;
            var values = options.values;
            var column = options.column,
                silent = options.silent;
            if (values && !isArray$1(values)) {
              values = [values];
            }
            var prop = column.property;
            var filters = {};
            if (prop) {
              states.filters[column.id] = values;
              filters[column.columnKey || column.id] = values;
            }
            var data = states._data;
            keys$1(states.filters).forEach(function (columnId) {
              var values = states.filters[columnId];
              if (!values || values.length === 0) return;
              var column = getColumnById(_this4.states, columnId);
              if (column && column.filterMethod) {
                data = data.filter(function (row) {
                  return values.some(function (value) {
                    return column.filterMethod.call(null, value, row, column);
                  });
                });
              }
            });
            states.filteredData = data;
            states.data = sortData(data, states);
            if (!silent) {
              this.table.$emit('filter-change', filters, states.filters);
            }
            Vue.nextTick(function () {
              return _this4.table.updateScrollY();
            });
          },
          insertColumn: function insertColumn(states, column, index, parent) {
            var array = states._columns;
            if (parent) {
              array = parent.children;
              if (!array) array = parent.children = [];
            }
            if (typeof index !== 'undefined') {
              array.splice(index, 0, column);
            } else {
              array.push(column);
            }
            if (column.type === 'selection') {
              states.selectable = column.selectable;
              states.reserveSelection = column.reserveSelection;
            }
            if (this.table.$ready) {
              this.updateColumns();
              this.scheduleLayout();
            }
          },
          removeColumn: function removeColumn(states, column, parent) {
            var array = states._columns;
            if (parent) {
              array = parent.children;
              if (!array) array = parent.children = [];
            }
            if (array) {
              array.splice(array.indexOf(column), 1);
            }
            if (this.table.$ready) {
              this.updateColumns();
              this.scheduleLayout();
            }
          },
          setHoverRow: function setHoverRow(states, row) {
            states.hoverRow = row;
          },
          setCurrentRow: function setCurrentRow(states, row) {
            var oldCurrentRow = states.currentRow;
            states.currentRow = row;
            if (oldCurrentRow !== row) {
              this.table.$emit('current-change', row, oldCurrentRow);
            }
          },
          rowSelectedChanged: function rowSelectedChanged(states, row) {
            var changed = _toggleRowSelection(states, row);
            var selection = states.selection;
            if (changed) {
              var table = this.table;
              table.$emit('selection-change', selection ? selection.slice() : []);
              table.$emit('select', selection, row);
            }
            this.updateAllSelected();
          },
          toggleAllSelection: debounce(10, function (states) {
            if (this.isAllSelectionDisabled) return;
            var data = states.data;
            var selection = this.states.selection;
            var value = states.selectOnIndeterminate ? !states.isAllSelected : !(states.isAllSelected || selection.length);
            var selectionChanged = false;
            data.forEach(function (item, index) {
              if (states.selectable) {
                if (states.selectable.call(null, item, index) && _toggleRowSelection(states, item, value)) {
                  selectionChanged = true;
                }
              } else {
                if (_toggleRowSelection(states, item, value)) {
                  selectionChanged = true;
                }
              }
            });
            var table = this.table;
            if (selectionChanged) {
              table.$emit('selection-change', selection ? selection.slice() : []);
            }
            table.$emit('select-all', selection);
            states.isAllSelected = value;
          })
        };
      }
    }, {
      key: "updateColumns",
      value: function updateColumns() {
        var states = this.states;
        var _columns = states._columns || [];
        states.fixedColumns = _columns.filter(function (column) {
          return column.fixed === true || column.fixed === 'left';
        });
        states.rightFixedColumns = _columns.filter(function (column) {
          return column.fixed === 'right';
        });
        if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
          _columns[0].fixed = true;
          states.fixedColumns.unshift(_columns[0]);
        }
        var notFixedColumns = _columns.filter(function (column) {
          return !column.fixed;
        });
        states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);
        var leafColumns = doFlattenColumns(notFixedColumns);
        var fixedLeafColumns = doFlattenColumns(states.fixedColumns);
        var rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);
        states.leafColumnsLength = leafColumns.length;
        states.fixedLeafColumnsLength = fixedLeafColumns.length;
        states.rightFixedLeafColumnsLength = rightFixedLeafColumns.length;
        states.columns = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
        states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
      }
    }, {
      key: "isSelected",
      value: function isSelected(row) {
        return (this.states.selection || []).indexOf(row) > -1;
      }
    }, {
      key: "isAllSelectionDisabled",
      get: function get() {
        var _this5 = this;
        if (!this.states.selectable) {
          return false;
        }
        var isEmpty = this.states.data && this.states.data.length === 0;
        var isDisabled = this.states.data.every(function (row, index) {
          return !_this5.states.selectable(row, index);
        });
        return isEmpty || isDisabled;
      }
    }, {
      key: "clearSelection",
      value: function clearSelection() {
        var states = this.states;
        states.isAllSelected = false;
        var oldSelection = states.selection;
        if (states.selection.length) {
          states.selection = [];
        }
        if (oldSelection.length > 0) {
          this.table.$emit('selection-change', states.selection ? states.selection.slice() : []);
        }
      }
    }, {
      key: "setExpandRowKeys",
      value: function setExpandRowKeys(rowKeys) {
        var expandRows = [];
        var data = this.states.data;
        var rowKey = this.states.rowKey;
        if (!rowKey) throw new Error('[Table] prop row-key should not be empty.');
        var keysMap = getKeysMap(data, rowKey);
        rowKeys.forEach(function (key) {
          var info = keysMap[key];
          if (info) {
            expandRows.push(info.row);
          }
        });
        this.states.expandRows = expandRows;
      }
    }, {
      key: "toggleRowSelection",
      value: function toggleRowSelection(row, selected) {
        var changed = _toggleRowSelection(this.states, row, selected);
        if (changed) {
          this.table.$emit('selection-change', this.states.selection ? this.states.selection.slice() : []);
        }
      }
    }, {
      key: "toggleRowExpansion",
      value: function toggleRowExpansion(row, expanded) {
        var changed = _toggleRowExpansion(this.states, row, expanded);
        if (changed) {
          this.table.$emit('expand-change', row, this.states.expandRows);
          this.scheduleLayout();
        }
      }
    }, {
      key: "isRowExpanded",
      value: function isRowExpanded(row) {
        var _this$states = this.states,
            _this$states$expandRo = _this$states.expandRows,
            expandRows = _this$states$expandRo === void 0 ? [] : _this$states$expandRo,
            rowKey = _this$states.rowKey;
        if (rowKey) {
          var expandMap = getKeysMap(expandRows, rowKey);
          return !!expandMap[getRowIdentity(row, rowKey)];
        }
        return expandRows.indexOf(row) !== -1;
      }
    }, {
      key: "cleanSelection",
      value: function cleanSelection() {
        var selection = this.states.selection || [];
        var data = this.states.data;
        var rowKey = this.states.rowKey;
        var deleted;
        if (rowKey) {
          deleted = [];
          var selectedMap = getKeysMap(selection, rowKey);
          var dataMap = getKeysMap(data, rowKey);
          for (var key in selectedMap) {
            if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
              deleted.push(selectedMap[key].row);
            }
          }
        } else {
          deleted = selection.filter(function (item) {
            return data.indexOf(item) === -1;
          });
        }
        deleted.forEach(function (deletedItem) {
          selection.splice(selection.indexOf(deletedItem), 1);
        });
        if (deleted.length) {
          this.table.$emit('selection-change', selection ? selection.slice() : []);
        }
      }
    }, {
      key: "clearFilter",
      value: function clearFilter() {
        var states = this.states;
        var _this$table$$refs = this.table.$refs,
            tableHeader = _this$table$$refs.tableHeader,
            fixedTableHeader = _this$table$$refs.fixedTableHeader,
            rightFixedTableHeader = _this$table$$refs.rightFixedTableHeader;
        var panels = {};
        if (tableHeader) panels = deepmerge(panels, tableHeader.filterPanels);
        if (fixedTableHeader) panels = deepmerge(panels, fixedTableHeader.filterPanels);
        if (rightFixedTableHeader) panels = deepmerge(panels, rightFixedTableHeader.filterPanels);
        var keys = keys$1(panels);
        if (!keys.length) return;
        keys.forEach(function (key) {
          panels[key].filteredValue = [];
        });
        states.filters = {};
        this.commit('filterChange', {
          column: {},
          values: [],
          silent: true
        });
      }
    }, {
      key: "clearSort",
      value: function clearSort() {
        var states = this.states;
        if (!states.sortingColumn) return;
        states.sortingColumn.order = null;
        states.sortProp = null;
        states.sortOrder = null;
        this.commit('changeSortCondition', {
          silent: true
        });
      }
    }, {
      key: "updateAllSelected",
      value: function updateAllSelected() {
        var states = this.states;
        var selection = states.selection,
            rowKey = states.rowKey,
            selectable = states.selectable,
            data = states.data;
        if (!data || data.length === 0) {
          states.isAllSelected = false;
          return;
        }
        var selectedMap;
        if (rowKey) {
          selectedMap = getKeysMap(states.selection, rowKey);
        }
        var isSelected = function isSelected(row) {
          if (selectedMap) {
            return !!selectedMap[getRowIdentity(row, rowKey)];
          } else {
            return selection.indexOf(row) !== -1;
          }
        };
        var isAllSelected = true;
        var selectedCount = 0;
        for (var i = 0, j = data.length; i < j; i++) {
          var item = data[i];
          var isRowSelectable = selectable && selectable(item, i);
          if (!isSelected(item)) {
            if (!selectable || isRowSelectable) {
              isAllSelected = false;
              break;
            }
          } else {
            selectedCount++;
          }
        }
        if (selectedCount === 0) isAllSelected = false;
        states.isAllSelected = isAllSelected;
      }
    }, {
      key: "scheduleLayout",
      value: function scheduleLayout(updateColumns) {
        if (updateColumns) {
          this.updateColumns();
        }
        this.table.debouncedUpdateLayout();
      }
    }, {
      key: "setCurrentRowKey",
      value: function setCurrentRowKey(key) {
        var states = this.states;
        var rowKey = states.rowKey;
        if (!rowKey) throw new Error('[Table] row-key should not be empty.');
        var data = states.data || [];
        var keysMap = getKeysMap(data, rowKey);
        var info = keysMap[key];
        states.currentRow = info ? info.row : null;
      }
    }, {
      key: "updateCurrentRow",
      value: function updateCurrentRow() {
        var states = this.states;
        var table = this.table;
        var data = states.data || [];
        var oldCurrentRow = states.currentRow;
        if (data.indexOf(oldCurrentRow) === -1) {
          states.currentRow = null;
          if (states.currentRow !== oldCurrentRow) {
            table.$emit('current-change', null, oldCurrentRow);
          }
        }
      }
    }, {
      key: "commit",
      value: function commit(name) {
        var mutations = this.mutations;
        if (mutations[name]) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          mutations[name].apply(this, [this.states].concat(args));
        } else {
          throw new Error("Action not found: ".concat(name));
        }
      }
    }]);
    return TableStore;
  }();

  var scrollBarWidth;
  function scrollbarWidth () {
    if (scrollBarWidth !== undefined) return scrollBarWidth;
    var outer = document.createElement('div');
    outer.className = 'bk-scrollbar-wrap';
    outer.style.visibility = 'hidden';
    outer.style.width = '100px';
    outer.style.position = 'absolute';
    outer.style.top = '-9999px';
    document.body.appendChild(outer);
    var widthNoScroll = outer.offsetWidth;
    outer.style.overflow = 'scroll';
    var inner = document.createElement('div');
    inner.style.width = '100%';
    outer.appendChild(inner);
    var widthWithScroll = inner.offsetWidth;
    outer.parentNode.removeChild(outer);
    scrollBarWidth = widthNoScroll - widthWithScroll;
    return scrollBarWidth;
  }

  var TableLayout = function () {
    function TableLayout(options) {
      _classCallCheck(this, TableLayout);
      this.observers = [];
      this.table = null;
      this.store = null;
      this.columns = null;
      this.fit = true;
      this.showHeader = true;
      this.height = null;
      this.scrollX = false;
      this.scrollY = false;
      this.bodyWidth = null;
      this.fixedWidth = null;
      this.rightFixedWidth = null;
      this.tableHeight = null;
      this.headerHeight = 44;
      this.appendHeight = 0;
      this.footerHeight = 44;
      this.paginationHeight = 0;
      this.viewportHeight = null;
      this.bodyHeight = null;
      this.fixedBodyHeight = null;
      this.gutterWidth = options.table.virtualRender ? 0 : scrollbarWidth();
      this.rowsHeight = {};
      this.debouncedSyncRowHeight = debounce(1000 / 60, this.syncRowHeight);
      for (var name in options) {
        if (options.hasOwnProperty(name)) {
          this[name] = options[name];
        }
      }
      if (!this.table) {
        throw new Error('table is required for Table Layout');
      }
      if (!this.store) {
        throw new Error('store is required for Table Layout');
      }
    }
    _createClass(TableLayout, [{
      key: "updateScrollY",
      value: function updateScrollY() {
        if (!this.bodyHeight) return;
        var bodyWrapper = this.table.bodyWrapper;
        if (this.table.$el && bodyWrapper) {
          if (this.table.isVirtualRender) {
            var body = bodyWrapper.querySelector('.bk-virtual-section');
            this.scrollY = body.offsetHeight > this.bodyHeight;
          } else {
            var _body = bodyWrapper.querySelector('.bk-table-body');
            this.scrollY = _body.offsetHeight > this.bodyHeight;
          }
        }
      }
    }, {
      key: "setHeight",
      value: function setHeight(value) {
        var _this = this;
        var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';
        var el = this.table.$el;
        if (typeof value === 'string' && /^\d+$/.test(value)) {
          value = Number(value);
        }
        this.height = value;
        if (!el) return Vue.nextTick(function () {
          return _this.setHeight(value, prop);
        });
        if (typeof value === 'number') {
          el.style[prop] = value + 'px';
          this.updateElsHeight();
        } else if (typeof value === 'string') {
          el.style[prop] = value;
          this.updateElsHeight();
        }
      }
    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(value) {
        return this.setHeight(value, 'max-height');
      }
    }, {
      key: "updateElsHeight",
      value: function updateElsHeight() {
        var _this2 = this;
        if (this.table.$destroyed) return;
        if (!this.table.$ready) return Vue.nextTick(function () {
          return _this2.updateElsHeight();
        });
        var _this$table$$refs = this.table.$refs,
            headerWrapper = _this$table$$refs.headerWrapper,
            appendWrapper = _this$table$$refs.appendWrapper,
            footerWrapper = _this$table$$refs.footerWrapper,
            paginationWrapper = _this$table$$refs.paginationWrapper;
        if (this.table.showPagination && !paginationWrapper) return Vue.nextTick(function () {
          return _this2.updateElsHeight();
        });
        this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;
        this.paginationHeight = paginationWrapper ? paginationWrapper.offsetHeight : 0;
        if (this.showHeader && !headerWrapper) return;
        var headerHeight = this.headerHeight = !this.showHeader ? 0 : headerWrapper.offsetHeight;
        if (this.showHeader && headerWrapper.offsetWidth > 0 && (this.table.columns || []).length > 0 && headerHeight < 2) {
          return Vue.nextTick(function () {
            return _this2.updateElsHeight();
          });
        }
        var tableHeight = this.tableHeight = this.table.$el.offsetHeight - this.paginationHeight;
        var footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
        this.bodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
        this.fixedBodyHeight = this.scrollX ? this.bodyHeight - this.gutterWidth : this.bodyHeight;
        var noData = !this.table.data || this.table.data.length === 0;
        this.viewportHeight = this.scrollX ? tableHeight - (noData ? 0 : this.gutterWidth) : tableHeight;
        this.updateScrollY();
        this.notifyObservers('scrollable');
      }
    }, {
      key: "getFlattenColumns",
      value: function getFlattenColumns() {
        var flattenColumns = [];
        var columns = this.table.columns;
        columns.forEach(function (column) {
          if (column.isColumnGroup) {
            flattenColumns.push.apply(flattenColumns, column.columns);
          } else {
            flattenColumns.push(column);
          }
        });
        return flattenColumns;
      }
    }, {
      key: "updateColumnsWidth",
      value: function updateColumnsWidth() {
        if (this.table.$destroyed) return;
        var fit = this.fit;
        var bodyWidth = this.table.$el.clientWidth;
        var bodyMinWidth = 0;
        var flattenColumns = this.getFlattenColumns();
        if (flattenColumns.length < 1) {
          return;
        }
        var flexColumns = flattenColumns.filter(function (column) {
          return typeof column.width !== 'number';
        });
        if (!this.store.isDraging) {
          flattenColumns.forEach(function (column) {
            if (typeof column.width === 'number') {
              column.realWidth = column.width;
            }
          });
        }
        if (!this.store.isDraging && flexColumns.length > 0 && fit) {
          flattenColumns.forEach(function (column) {
            bodyMinWidth += column.width || column.minWidth;
          });
          var scrollYWidth = this.scrollY ? this.gutterWidth : 0;
          if (bodyMinWidth <= bodyWidth - scrollYWidth) {
            this.scrollX = false;
            var virtualScrollWidth = this.table.isVirtualRender && this.scrollY ? 10 : 0;
            var totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth - virtualScrollWidth;
            if (flexColumns.length === 1) {
              flexColumns[0].realWidth = flexColumns[0].minWidth + totalFlexWidth;
            } else {
              var flexWidthPerPixel = Math.floor(totalFlexWidth / flexColumns.length);
              var firstWidth = totalFlexWidth;
              flexColumns.forEach(function (column, index) {
                if (index === 0) return;
                var flexWidth = column.minWidth + flexWidthPerPixel;
                if (column.maxWidth && column.maxWidth < flexWidth) {
                  flexWidth = column.maxWidth;
                  firstWidth -= column.maxWidth - column.minWidth;
                } else {
                  firstWidth -= flexWidthPerPixel;
                }
                column.realWidth = flexWidth;
              });
              flexColumns[0].realWidth = flexColumns[0].minWidth + firstWidth;
            }
          } else {
            this.scrollX = true;
            flexColumns.forEach(function (column) {
              column.realWidth = column.minWidth;
            });
          }
          this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
          this.table.resizeState.width = this.bodyWidth;
        } else {
          flattenColumns.forEach(function (column) {
            bodyMinWidth += column.realWidth;
          });
          this.scrollX = bodyMinWidth > bodyWidth;
          var findLastColumnWithNotSetting = function findLastColumnWithNotSetting(columnList) {
            var i = columnList.length;
            while (--i) {
              if (columnList[i].type !== 'setting') {
                return columnList[i];
              }
            }
            return null;
          };
          var lastColumn = findLastColumnWithNotSetting(flattenColumns);
          if (lastColumn) {
            if (!this.scrollX && flattenColumns.length) {
              var deltaWidth = bodyWidth - bodyMinWidth;
              console.log('from print table last column < ', lastColumn);
              lastColumn.realWidth = lastColumn.realWidth + deltaWidth;
              this.bodyWidth = bodyWidth;
            } else {
              console.log('from print table last column > ', lastColumn);
              if (lastColumn) {
                var lastRealWidth = typeof lastColumn.width !== 'number' ? lastColumn.minWidth : lastColumn.width;
                var preLastColumnBodyMinWidth = bodyMinWidth - lastColumn.realWidth;
                if (preLastColumnBodyMinWidth + lastRealWidth > bodyWidth) {
                  lastColumn.realWidth = lastRealWidth;
                  bodyMinWidth = preLastColumnBodyMinWidth + lastRealWidth;
                } else {
                  lastColumn.realWidth = bodyWidth - preLastColumnBodyMinWidth;
                  bodyMinWidth = preLastColumnBodyMinWidth + lastColumn.realWidth;
                }
              }
              this.scrollX = bodyMinWidth > bodyWidth;
              this.bodyWidth = bodyMinWidth;
            }
          }
        }
        var fixedColumns = this.store.states.fixedColumns;
        if (fixedColumns.length > 0) {
          var fixedWidth = 0;
          fixedColumns.forEach(function (column) {
            fixedWidth += column.realWidth || column.width;
          });
          this.fixedWidth = fixedWidth;
        }
        var rightFixedColumns = this.store.states.rightFixedColumns;
        if (rightFixedColumns.length > 0) {
          var rightFixedWidth = 0;
          rightFixedColumns.forEach(function (column) {
            rightFixedWidth += column.realWidth || column.width;
          });
          this.rightFixedWidth = rightFixedWidth;
        }
        this.store.isDraging = false;
        this.notifyObservers('columns');
      }
    }, {
      key: "syncRowHeight",
      value: function syncRowHeight() {
        if (this.table.$destroyed) return;
        if (!this.table.$ready) return Vue.nextTick(this.syncRowHeight);
        var rows = this.table.$refs.tableBody.$refs.row || [];
        var rowsHeight = rows.reduce(function (accumulator, row) {
          var key = row.getAttribute('data-table-row');
          accumulator[key] = row.offsetHeight;
          return accumulator;
        }, {});
        if (isShallowEqual(rowsHeight, this.rowsHeight)) return;
        this.rowsHeight = rowsHeight;
      }
    }, {
      key: "addObserver",
      value: function addObserver(observer) {
        this.observers.push(observer);
      }
    }, {
      key: "removeObserver",
      value: function removeObserver(observer) {
        var index = this.observers.indexOf(observer);
        if (index !== -1) {
          this.observers.splice(index, 1);
        }
      }
    }, {
      key: "notifyObservers",
      value: function notifyObservers(event) {
        var _this3 = this;
        var observers = this.observers;
        observers.forEach(function (observer) {
          switch (event) {
            case 'columns':
              observer.onColumnsChange(_this3);
              break;
            case 'scrollable':
              observer.onScrollableChange(_this3);
              break;
            default:
              throw new Error("Table Layout don't have event ".concat(event, "."));
          }
        });
      }
    }]);
    return TableLayout;
  }();

  function _extends$4(){return _extends$4=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$4.apply(this,arguments)}var normalMerge=["attrs","props","domProps"],toArrayMerge=["class","style","directives"],functionalMerge=["on","nativeOn"],mergeJsxProps=function(a){return a.reduce(function(c,a){for(var b in a)if(!c[b])c[b]=a[b];else if(-1!==normalMerge.indexOf(b))c[b]=_extends$4({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e);}else if(-1!==functionalMerge.indexOf(b)){for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h);}else c[b][f]=a[b][f];}else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];return c},{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments);}};var helper=mergeJsxProps;

  function beforeShow(instance) {
    var reference = instance.reference;
    var props = reference._bk_overflow_tips_.props;
    var isOverflow = checkOverflow(reference);
    if (isOverflow) {
      instance.setContent(props.content ? props.content : props.allowHTML ? reference.innerHTML : reference.textContent);
      return true;
    }
    return false;
  }
  function setupOnShow(props, customProps) {
    props.onShow = function (instance) {
      if (typeof customProps.onShow === 'function') {
        var result = customProps.onShow(instance);
        if (!result) return false;
      }
      return beforeShow(instance);
    };
  }
  function setupTheme(props, customProps) {
    var theme = ['bk-overflow-tips'];
    if (customProps.theme) {
      theme.push(customProps.theme);
    }
    props.theme = theme.join(' ');
  }
  var defaultProps$1 = {
    arrow: true,
    interactive: true,
    delay: 150,
    allowHTML: false,
    maxWidth: 400,
    boundary: 'window',
    placement: 'top'
  };
  var overflowTips = {
    inserted: function inserted(el) {
      var binding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
      var props = _extends(_objectSpread({}, defaultProps$1), customProps);
      setupOnShow(props, customProps);
      setupTheme(props, customProps);
      el._bk_overflow_tips_ = {
        props: props,
        instance: tippy(el, props)
      };
    },
    update: function update(el, binding) {
      var _el$_bk_overflow_tips = el._bk_overflow_tips_,
          props = _el$_bk_overflow_tips.props,
          instance = _el$_bk_overflow_tips.instance;
      var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
      _extends(props, customProps);
      setupOnShow(props, customProps);
      instance.set(props);
    },
    unbind: function unbind(el) {
      el._tippy && el._tippy.destroy();
      delete el._bk_overflow_tips_;
    },
    setDefaultProps: function setDefaultProps(props) {
      _extends(defaultProps$1, props);
    }
  };
  overflowTips.install = function (Vue) {
    Vue.directive('bk-overflow-tips', overflowTips);
  };

  var LayoutObserver = {
    created: function created() {
      this.tableLayout.addObserver(this);
    },
    destroyed: function destroyed() {
      this.tableLayout.removeObserver(this);
    },
    computed: {
      tableLayout: function tableLayout() {
        var layout = this.layout;
        if (!layout && this.table) {
          layout = this.table.layout;
        }
        if (!layout) {
          throw new Error('Can not find table layout.');
        }
        return layout;
      }
    },
    mounted: function mounted() {
      this.onColumnsChange(this.tableLayout);
      this.onScrollableChange(this.tableLayout);
    },
    updated: function updated() {
      if (this.__updated__) {
        return;
      }
      this.onColumnsChange(this.tableLayout);
      this.onScrollableChange(this.tableLayout);
      this.__updated__ = true;
    },
    methods: {
      onColumnsChange: function onColumnsChange() {
        var cols = this.$el.querySelectorAll('colgroup > col');
        if (!cols.length) {
          return;
        }
        var flattenColumns = this.tableLayout.getFlattenColumns();
        var columnsMap = {};
        flattenColumns.forEach(function (column) {
          columnsMap[column.id] = column;
        });
        for (var i = 0, j = cols.length; i < j; i++) {
          var col = cols[i];
          var name = col.getAttribute('name');
          var column = columnsMap[name];
          if (column) {
            col.setAttribute('width', column.realWidth || column.width);
          }
        }
      },
      onScrollableChange: function onScrollableChange(layout) {
        var cols = this.$el.querySelectorAll('colgroup > col[name=gutter]');
        for (var i = 0, j = cols.length; i < j; i++) {
          var col = cols[i];
          col.setAttribute('width', layout.scrollY ? layout.gutterWidth : '0');
        }
        var ths = this.$el.querySelectorAll('th.gutter');
        for (var _i = 0, _j = ths.length; _i < _j; _i++) {
          var th = ths[_i];
          th.style.width = layout.scrollY ? layout.gutterWidth + 'px' : '0';
          th.style.display = layout.scrollY ? '' : 'none';
        }
      }
    }
  };

  function visibleRender(e, wrapper, binding) {
    var _binding$value = binding.value,
        _binding$value$lineHe = _binding$value.lineHeight,
        lineHeight = _binding$value$lineHe === void 0 ? 30 : _binding$value$lineHe,
        callback = _binding$value.callback;
    var scrollTop = wrapper.scrollTop,
        offsetHeight = wrapper.offsetHeight,
        startIndex = wrapper.startIndex,
        endIndex = wrapper.endIndex;
    var targetStartIndex = Math.floor(scrollTop / lineHeight);
    var targetEndIndex = Math.ceil(offsetHeight / lineHeight) + targetStartIndex;
    if (startIndex !== targetStartIndex || endIndex !== targetEndIndex) {
      typeof callback === 'function' && callback(e, targetStartIndex, targetEndIndex, scrollTop);
    }
  }
  var throttledRender = throttle(60, function (e, wrapper, binding) {
    return visibleRender(e, wrapper, binding);
  });
  var virtualRender = {
    inserted: function inserted(el, binding) {
      var wrapper = el.parentNode;
      wrapper.addEventListener('scroll', function (e) {
        return throttledRender(e, wrapper, binding);
      });
    },
    componentUpdated: function componentUpdated(el, binding) {
      var wrapper = el.parentNode;
      throttledRender(null, wrapper, binding);
    },
    unbind: function unbind(el) {
      if (el) {
        var wrapper = el.parentNode;
        wrapper && wrapper.removeEventListener('scroll', throttledRender);
      }
    }
  };

  var Component = {
    name: 'bk-virtual-render',
    directives: {
      virtualRender: virtualRender
    },
    props: {
      className: {
        type: String,
        default: ''
      },
      scrollXName: {
        type: String,
        default: 'bk-scroll-x'
      },
      scrollYName: {
        type: String,
        default: 'bk-scroll-y'
      },
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      lineHeight: {
        type: Number,
        default: 30
      },
      minHeight: {
        type: Number,
        default: 30
      },
      height: {
        type: [Number, String],
        default: '100%'
      },
      width: {
        type: [Number, String],
        default: '100%'
      },
      groupItemCount: {
        type: Number,
        default: 1
      },
      preloadItemCount: {
        type: Number,
        default: 1
      },
      renderAs: {
        type: String,
        default: 'div'
      },
      contentAs: {
        type: String,
        default: 'div'
      },
      scrollPosition: {
        type: String,
        default: 'content'
      },
      abosuteHeight: {
        type: [Number, String],
        default: 'auto'
      }
    },
    data: function data() {
      return {
        startIndex: 0,
        endIndex: 0,
        scrollTop: 1,
        translateY: 0
      };
    },
    computed: {
      listLength: function listLength() {
        return Math.ceil((this.localList || []).length / this.groupItemCount);
      },
      calcList: function calcList() {
        return this.localList.slice(this.startIndex * this.groupItemCount, (this.endIndex + this.preloadItemCount) * this.groupItemCount);
      },
      wrapperStyle: function wrapperStyle() {
        return {
          height: typeof this.height === 'number' ? "".concat(this.height, "px") : this.height,
          width: typeof this.width === 'number' ? "".concat(this.width, "px") : this.width,
          display: 'inline-block'
        };
      },
      innerHeight: function innerHeight() {
        return this.abosuteHeight === 'auto' ? this.lineHeight * this.listLength : "".concat(this.abosuteHeight, "px");
      },
      innerContentStyle: function innerContentStyle() {
        return {
          top: "".concat(this.scrollTop, "px"),
          transform: "translateY(-".concat(this.translateY, "px)")
        };
      },
      innerStyle: function innerStyle() {
        return {
          height: "".concat(this.innerHeight < this.minHeight ? this.minHeight : this.innerHeight, "px"),
          display: this.abosuteHeight === 0 ? 'none' : 'block'
        };
      },
      localList: function localList() {
        return (this.list || []).map(function (item, index) {
          return _extends(item, {
            $index: index
          });
        });
      }
    },
    watch: {
      list: function list(val) {
        var _this = this;
        this.$nextTick(function () {
          return _this.scrollToIndex(0);
        });
      }
    },
    methods: {
      handleScrollCallback: function handleScrollCallback(event, startIndex, endIndex, scrollTop) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.scrollTop = scrollTop;
        this.$emit('content-scroll', event);
        this.translateY = scrollTop % this.lineHeight;
      },
      scrollToIndex: function scrollToIndex(index) {
        if (index >= 0) {
          var scrollTop = this.lineHeight * index;
          this.$el && this.$el.scrollTo({
            top: scrollTop,
            behavior: 'smooth'
          });
        }
      }
    },
    render: function render(h) {
      return h(this.renderAs || 'div', {
        class: ['bk-virtual-render', this.scrollXName, this.scrollYName, this.className, this.scrollPosition === 'container' ? 'bk-virtual-content' : ''],
        style: _objectSpread({}, this.wrapperStyle, this.scrollPosition === 'container' ? this.innerContentStyle : {})
      }, [this.$slots.beforeContent, h(this.contentAs || 'div', {
        class: [this.scrollPosition === 'content' ? 'bk-virtual-content' : ''],
        style: this.scrollPosition === 'content' ? this.innerContentStyle : {},
        directives: [{
          name: 'virtual-render',
          value: {
            callback: this.handleScrollCallback,
            listLength: this.listLength,
            lineHeight: this.lineHeight,
            startIndex: this.startIndex,
            endIndex: this.endIndex
          }
        }]
      }, [this.$scopedSlots.default({
        data: this.calcList
      })]), this.$slots.afterContent, h('div', {
        class: ['bk-virtual-section'],
        style: this.innerStyle
      })]);
    }
  };

  setInstaller(Component);

  var TableBody = {
    name: 'bk-table-body',
    mixins: [LayoutObserver],
    components: {
      bkCheckbox: __vue_component__$8,
      bkVirtualRender: Component
    },
    directives: {
      bkOverflowTips: overflowTips
    },
    props: {
      store: {
        required: true
      },
      stripe: Boolean,
      context: {},
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      fixed: String,
      highlight: Boolean
    },
    render: function render(h) {
      var _this = this;
      var columnsHidden = this.columns.map(function (column, index) {
        return _this.isColumnHidden(index);
      });
      var renderRows = function renderRows(row, $index) {
        return [h("tr", helper([{
          "ref": "row",
          "refInFor": true,
          "style": _this.getRowStyle(row, $index),
          "key": _this.table.rowKey ? _this.getKeyOfRow(row, $index) : $index,
          "on": {
            "dblclick": function dblclick($event) {
              return _this.handleDoubleClick($event, row);
            },
            "click": function click($event) {
              return _this.handleClick($event, row);
            },
            "contextmenu": function contextmenu($event) {
              return _this.handleContextMenu($event, row);
            },
            "mouseenter": function mouseenter($event) {
              return _this.handleMouseEnter($index, $event, row);
            },
            "mouseleave": function mouseleave($event) {
              return _this.handleMouseLeave($index, $event, row);
            }
          },
          "class": [_this.getRowClass(row, $index)]
        }, {
          "attrs": _this.getRowAttributes(row, $index)
        }]), [_this._l(_this.columns, function (column, cellIndex) {
          var _this$getSpan = _this.getSpan(row, column, $index, cellIndex),
              rowspan = _this$getSpan.rowspan,
              colspan = _this$getSpan.colspan;
          if (!rowspan || !colspan || column.type === 'setting') {
            return '';
          } else {
            return h("td", helper([{
              "style": _this.getCellStyle($index, cellIndex, row, column),
              "class": _this.getCellClass($index, cellIndex, row, column),
              "attrs": {
                "rowspan": rowspan,
                "colspan": colspan
              },
              "on": {
                "mouseenter": function mouseenter($event) {
                  return _this.handleCellMouseEnter($event, row);
                },
                "mouseleave": _this.handleCellMouseLeave
              }
            }, {
              "domProps": _this.getCellAttributes($index, cellIndex, row, column)
            }]), [_this.isColumnInvisible(cellIndex) ? '' : column.renderCell.call(_this._renderProxy, h, {
              row: row,
              column: column,
              $index: $index,
              store: _this.store,
              _self: _this.context || _this.table.$vnode.context
            }, columnsHidden[cellIndex])]);
          }
        })]), _this.store.isRowExpanded(row) ? h("tr", helper([{
          "ref": "row",
          "refInFor": true
        }, {
          "attrs": _this.getExpandedRowAttributes(row, $index)
        }, {
          "style": _this.getExpandedRowStyle(row, $index),
          "class": _this.getExpandedRowClass(row, $index)
        }]), [h("td", {
          "attrs": {
            "colspan": _this.columns.length
          },
          "class": "bk-table-expanded-cell"
        }, [!_this.fixed && _this.table.renderExpanded ? _this.table.renderExpanded(h, {
          row: row,
          $index: $index,
          store: _this.store
        }) : ''])]) : ''];
      };
      var tableStyle = {
        width: "".concat(this.tableLayout.bodyWidth - (this.tableLayout.scrollY ? 10 : 0), "px")
      };
      return this.virtualRender ? h("bk-virtual-render", helper([{
        "attrs": {
          "list": this.data,
          "width": this.virtualRenderOpt.width,
          "height": this.virtualRenderOpt.height,
          "lineHeight": this.virtualRenderOpt.lineHeight
        }
      }, {
        scopedSlots: {
          default: function _default(slot) {
            return h("table", {
              "class": "bk-table-body",
              "attrs": {
                "cellspacing": "0",
                "cellpadding": "0",
                "border": "0"
              },
              "style": tableStyle
            }, [h("colgroup", [_this._l(_this.columns, function (column) {
              return h("col", {
                "attrs": {
                  "name": column.id
                }
              });
            })]), h("tbody", [_this._l(slot.data, renderRows)])]);
          }
        }
      }])) : h("table", {
        "class": "bk-table-body",
        "attrs": {
          "cellspacing": "0",
          "cellpadding": "0",
          "border": "0"
        }
      }, [h("colgroup", [this._l(this.columns, function (column) {
        return h("col", {
          "attrs": {
            "name": column.id
          }
        });
      })]), h("tbody", [this._l(this.data, renderRows)])]);
    },
    watch: {
      'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
        var el = this.$el;
        if (!el) {
          return;
        }
        var tr = el.querySelector('tbody').children;
        var rows = [].filter.call(tr, function (row) {
          return hasClass(row, 'bk-table-row');
        });
        var oldRow = rows[oldVal];
        var newRow = rows[newVal];
        if (oldRow) {
          removeClass(oldRow, 'hover-row');
        }
        if (newRow) {
          addClass(newRow, 'hover-row');
        }
      },
      'store.states.currentRow': function storeStatesCurrentRow(newVal, oldVal) {
        if (!this.highlight) {
          return;
        }
        var el = this.$el;
        if (!el) {
          return;
        }
        var data = this.store.states.data;
        var tr = el.querySelector('tbody').children;
        var rows = [].filter.call(tr, function (row) {
          return hasClass(row, 'bk-table-row');
        });
        var oldRow = rows[data.indexOf(oldVal)];
        var newRow = rows[data.indexOf(newVal)];
        if (oldRow) {
          removeClass(oldRow, 'current-row');
        } else {
          [].forEach.call(rows, function (row) {
            return removeClass(row, 'current-row');
          });
        }
        if (newRow) {
          addClass(newRow, 'current-row');
        }
      }
    },
    computed: {
      table: function table() {
        return this.$parent;
      },
      data: function data() {
        return this.store.states.data;
      },
      columnsCount: function columnsCount() {
        return this.store.states.columns.length;
      },
      leftFixedLeafCount: function leftFixedLeafCount() {
        return this.store.states.fixedLeafColumnsLength;
      },
      rightFixedLeafCount: function rightFixedLeafCount() {
        return this.store.states.rightFixedLeafColumnsLength;
      },
      leftFixedCount: function leftFixedCount() {
        return this.store.states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount() {
        return this.store.states.rightFixedColumns.length;
      },
      columns: function columns() {
        return this.store.states.columns;
      },
      virtualRender: function virtualRender() {
        return this.table.isVirtualRender;
      },
      virtualRenderOpt: function virtualRenderOpt() {
        var _this2 = this;
        if (this.virtualRender) {
          var virtualCfg = keys$1(this.table.virtualRender).filter(function (key) {
            return ['height', 'width', 'lineHeight'].includes(key);
          }).reduce(function (pre, curr) {
            return _objectSpread({}, pre, _defineProperty({}, curr, _this2.table.virtualRender[curr]));
          }, {});
          return _objectSpread({
            height: this.tableLayout.bodyHeight - 4,
            width: '100%',
            lineHeight: 42
          }, virtualCfg || {});
        }
        return {};
      }
    },
    data: function data() {
      return {
        tooltipContent: ''
      };
    },
    created: function created() {
      this.activateTooltip = debounce(50, function (tooltip) {
        return tooltip.handleShowPopper();
      });
    },
    updated: function updated() {
      this.syncFixedRowHeight();
    },
    methods: {
      getKeyOfRow: function getKeyOfRow(row, index) {
        var rowKey = this.table.rowKey;
        if (rowKey) {
          return getRowIdentity(row, rowKey);
        }
        return index;
      },
      isColumnInvisible: function isColumnInvisible(index) {
        if (!this.fixed) {
          return false;
        }
        return this.isColumnHidden(index);
      },
      isColumnHidden: function isColumnHidden(index) {
        if (this.fixed === true || this.fixed === 'left') {
          return index >= this.leftFixedLeafCount;
        } else if (this.fixed === 'right') {
          return index < this.columnsCount - this.rightFixedLeafCount;
        } else {
          return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
        }
      },
      getSpan: function getSpan(row, column, rowIndex, columnIndex) {
        var rowspan = 1;
        var colspan = 1;
        var fn = this.table.spanMethod;
        if (typeof fn === 'function') {
          var result = fn({
            row: row,
            column: column,
            rowIndex: rowIndex,
            columnIndex: columnIndex
          });
          if (isArray$1(result)) {
            rowspan = result[0];
            colspan = result[1];
          } else if (_typeof(result) === 'object') {
            rowspan = result.rowspan;
            colspan = result.colspan;
          }
        }
        var nextColumn = this.columns[columnIndex + 1];
        colspan = nextColumn && nextColumn.type === 'setting' ? colspan + 1 : colspan;
        return {
          rowspan: rowspan,
          colspan: colspan
        };
      },
      getRowStyle: function getRowStyle(row, rowIndex) {
        var rowStyle = this.table.rowStyle || {};
        if (typeof rowStyle === 'function') {
          rowStyle = rowStyle({
            row: row,
            rowIndex: rowIndex
          });
        }
        var height = this.tableLayout.rowsHeight["row-".concat(rowIndex)];
        if (this.fixed && height) {
          rowStyle.height = height + 'px';
        }
        return rowStyle;
      },
      getRowClass: function getRowClass(row, rowIndex) {
        var classes = ['bk-table-row'];
        if (rowIndex === this.data.length - 1) {
          classes.push('bk-table-row-last');
        }
        if (this.table.highlightCurrentRow && row === this.store.states.currentRow) {
          classes.push('current-row');
        }
        if (this.stripe && rowIndex % 2 === 1) {
          classes.push('bk-table-row-striped');
        }
        var rowClassName = this.table.rowClassName;
        if (typeof rowClassName === 'string') {
          classes.push(rowClassName);
        } else if (typeof rowClassName === 'function') {
          classes.push(rowClassName({
            row: row,
            rowIndex: rowIndex
          }));
        }
        if (this.store.states.expandRows.indexOf(row) > -1) {
          classes.push('expanded');
        }
        return classes.join(' ');
      },
      getRowAttributes: function getRowAttributes(row, rowIndex) {
        return {
          'data-table-row': "row-".concat(rowIndex)
        };
      },
      getCellStyle: function getCellStyle(rowIndex, columnIndex, row, column) {
        var cellStyle = this.table.cellStyle;
        if (typeof cellStyle === 'function') {
          return cellStyle({
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          });
        }
        return cellStyle;
      },
      getCellClass: function getCellClass(rowIndex, columnIndex, row, column) {
        var classes = [column.id, column.align, column.className];
        if (this.isColumnHidden(columnIndex)) {
          classes.push('is-hidden');
        }
        if (columnIndex === 0) {
          classes.push('is-first');
        }
        if (columnIndex === this.columns.length - 1) {
          classes.push('is-last');
        }
        var cellClassName = this.table.cellClassName;
        if (typeof cellClassName === 'string') {
          classes.push(cellClassName);
        } else if (typeof cellClassName === 'function') {
          classes.push(cellClassName({
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          }));
        }
        return classes.join(' ');
      },
      getCellAttributes: function getCellAttributes(rowIndex, cellIndex, row, column) {
        if (typeof this.table.cellAttributes === 'function') {
          var attributes = this.table.cellAttributes({
            rowIndex: rowIndex,
            cellIndex: cellIndex,
            row: row,
            column: column
          });
          return _typeof(attributes) === 'object' ? attributes : {};
        } else if (_typeof(this.table.cellAttributes) === 'object') {
          return this.table.cellAttributes;
        }
        return {};
      },
      getExpandedRowAttributes: function getExpandedRowAttributes(row, rowIndex) {
        return {
          'data-table-row': "expanded-row-".concat(rowIndex)
        };
      },
      getExpandedRowStyle: function getExpandedRowStyle(row, rowIndex) {
        var style = {};
        var height = this.tableLayout.rowsHeight["expanded-row-".concat(rowIndex)];
        if (this.fixed && height) {
          style.height = height + 'px';
        }
        return style;
      },
      getExpandedRowClass: function getExpandedRowClass(row, rowIndex) {
        var classes = ['is-expanded-row'];
        return classes.join(' ');
      },
      handleCellMouseEnter: function handleCellMouseEnter(event, row) {
        var table = this.table;
        var cell = getCell(event);
        if (cell) {
          var column = getColumnByCell(table, cell);
          var hoverState = table.hoverState = {
            cell: cell,
            column: column,
            row: row
          };
          table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
        }
      },
      handleCellMouseLeave: function handleCellMouseLeave(event) {
        var cell = getCell(event);
        if (!cell) return;
        var oldHoverState = this.table.hoverState || {};
        this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
      },
      handleMouseEnter: function handleMouseEnter(index, event, row) {
        this.store.commit('setHoverRow', index);
        this.table.$emit('row-mouse-enter', index, event, row);
      },
      handleMouseLeave: function handleMouseLeave(index, event, row) {
        this.store.commit('setHoverRow', null);
        this.table.$emit('row-mouse-leave', index, event, row);
      },
      handleContextMenu: function handleContextMenu(event, row) {
        this.handleEvent(event, row, 'contextmenu');
      },
      handleDoubleClick: function handleDoubleClick(event, row) {
        this.handleEvent(event, row, 'dblclick');
      },
      handleClick: function handleClick(event, row) {
        this.store.commit('setCurrentRow', row);
        this.handleEvent(event, row, 'click');
      },
      handleEvent: function handleEvent(event, row, name) {
        var table = this.table;
        var cell = getCell(event);
        var rowIndex = this.data.indexOf(row);
        var column;
        var columnIndex;
        if (cell) {
          column = getColumnByCell(table, cell);
          if (column) {
            columnIndex = this.columns.indexOf(column);
            table.$emit("cell-".concat(name), row, column, cell, event, rowIndex, columnIndex);
          }
        }
        table.$emit("row-".concat(name), row, event, column, rowIndex, columnIndex);
      },
      handleExpandClick: function handleExpandClick(data) {
        var _this3 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var row, event, column, result;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  row = data.row, event = data.event, column = data.column;
                  event.stopPropagation();
                  if (!(typeof column.beforeExpandChange === 'function')) {
                    _context.next = 8;
                    break;
                  }
                  _context.next = 5;
                  return column.beforeExpandChange(data);
                case 5:
                  result = _context.sent;
                  if (result) {
                    _context.next = 8;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 8:
                  _this3.store.toggleRowExpansion(row);
                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      syncFixedRowHeight: function syncFixedRowHeight() {
        if (!this.fixed && (this.leftFixedCount || this.rightFixedCount)) {
          this.tableLayout.debouncedSyncRowHeight();
        }
      },
      renderBodyRows: function renderBodyRows() {}
    }
  };

  var bkTableSetting = {
    name: 'bk-table-setting',
    components: {
      bkPopover: __vue_component__$G
    },
    props: {
      column: Object
    },
    render: function render(h) {
      var popoverContent = this.column.settingContent ? this.column.settingContent(h) : '';
      return h("bk-popover", {
        "attrs": {
          "trigger": "click",
          "placement": "bottom-end",
          "theme": "light bk-table-setting-popover-content",
          "distance": -2
        }
      }, [h("i", {
        "class": 'bk-table-setting-icon ' + this.column.icon
      }), h("template", {
        "slot": "content"
      }, [popoverContent])]);
    }
  };

  var script$$ = {
    name: 'bk-link',
    props: {
      disabled: Boolean,
      underline: Boolean,
      href: {
        type: String,
        default: null
      },
      icon: String,
      iconPlacement: {
        type: String,
        default: 'left'
      },
      theme: {
        type: String,
        default: 'default',
        validator: function validator(val) {
          return ['default', 'primary', 'success', 'warning', 'danger'].includes(val);
        }
      }
    },
    methods: {
      handleClick: function handleClick(event) {
        if (this.disabled) {
          event.preventDefault();
          return false;
        }
        this.$emit('click', event);
      }
    }
  };

  /* script */
  var __vue_script__$$ = script$$;
  /* template */

  var __vue_render__$11 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('a', _vm._b({
      class: ['bk-link', "is-" + _vm.theme, _vm.disabled && 'is-disabled', _vm.underline && !_vm.disabled && 'has-underline'],
      attrs: {
        "href": _vm.href
      },
      on: {
        "click": _vm.handleClick
      }
    }, 'a', _vm.$attrs, false), [_vm.icon && _vm.iconPlacement === 'left' ? _c('i', {
      class: ['bk-link-icon is-left', _vm.icon]
    }) : _vm._e(), _vm.$slots.default ? _c('span', {
      staticClass: "bk-link-text"
    }, [_vm._t("default")], 2) : _vm._e(), _vm.icon && _vm.iconPlacement === 'right' ? _c('i', {
      class: ['bk-link-icon is-right', _vm.icon]
    }) : _vm._e()]);
  };

  var __vue_staticRenderFns__$11 = [];
  /* style */

  var __vue_inject_styles__$11 = undefined;
  /* scoped */

  var __vue_scope_id__$11 = undefined;
  /* module identifier */

  var __vue_module_identifier__$11 = undefined;
  /* functional template */

  var __vue_is_functional_template__$11 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$11 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$11,
    staticRenderFns: __vue_staticRenderFns__$11
  }, __vue_inject_styles__$11, __vue_script__$$, __vue_scope_id__$11, __vue_is_functional_template__$11, __vue_module_identifier__$11, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$11);

  var script$10 = {
    name: 'bk-table-filter-panel',
    components: {
      bkCheckboxGroup: __vue_component__$9,
      bkCheckbox: __vue_component__$8,
      bkLink: __vue_component__$11
    },
    mixins: [locale.mixin],
    data: function data() {
      return {
        instance: null,
        reference: null,
        filters: [],
        multiple: false,
        placement: 'bottom-start',
        method: null,
        selected: [],
        column: null,
        table: null,
        searchable: false,
        keyword: '',
        matchedFilters: []
      };
    },
    computed: {
      searchEmpty: function searchEmpty() {
        return this.keyword.length && !this.matchedFilters.length;
      }
    },
    watch: {
      keyword: function keyword() {
        this.setMatchedFilters();
      }
    },
    mounted: function mounted() {
      var _this = this;
      this.instance = tippy(this.reference, {
        theme: 'light bk-table-filter-panel',
        trigger: 'click',
        interactive: true,
        placement: this.placement,
        content: this.$el,
        onShow: function onShow() {
          _this.column.filterOpened = true;
        },
        onHide: function onHide() {
          _this.column.filterOpened = false;
        },
        onHidden: function onHidden() {
          _this.keyword = '';
        }
      });
    },
    methods: {
      setMatchedFilters: function setMatchedFilters() {
        var keyword = this.keyword.toLowerCase();
        this.matchedFilters = this.filters.filter(function (filter) {
          var index = filter.text.toString().toLowerCase().indexOf(keyword);
          return index > -1;
        });
      },
      isMatched: function isMatched(filter) {
        if (!this.keyword.length) {
          return true;
        }
        return this.matchedFilters.includes(filter);
      },
      handleConfirm: function handleConfirm() {
        this.confirmFilter(this.selected);
        this.instance.hide();
      },
      handleReset: function handleReset() {
        this.selected = [];
        this.handleConfirm();
      },
      handleSelect: function handleSelect(filter) {
        if (filter.disabled) {
          return;
        }
        if (this.selected.includes(filter.value)) {
          this.instance.hide();
          return;
        }
        this.selected = [filter.value];
        this.handleConfirm();
      },
      confirmFilter: function confirmFilter() {
        this.column.filteredValue = this.selected;
        this.table.store.commit('filterChange', {
          column: this.column,
          values: this.selected
        });
        this.table.store.updateAllSelected();
      }
    }
  };

  /* script */
  var __vue_script__$10 = script$10;
  /* template */

  var __vue_render__$12 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-table-filter-panel",
      class: {
        multiple: _vm.multiple
      }
    }, [_vm.searchable ? _c('div', {
      staticClass: "panel-search"
    }, [_c('i', {
      staticClass: "panel-search-icon bk-icon icon-search"
    }), _c('input', {
      directives: [{
        name: "model",
        rawName: "v-model.trim",
        value: _vm.keyword,
        expression: "keyword",
        modifiers: {
          "trim": true
        }
      }],
      staticClass: "panel-search-input",
      attrs: {
        "type": "text",
        "placeholder": _vm.t('bk.table.filter.placeholder')
      },
      domProps: {
        "value": _vm.keyword
      },
      on: {
        "input": function input($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.keyword = $event.target.value.trim();
        },
        "blur": function blur($event) {
          _vm.$forceUpdate();
        }
      }
    })]) : _vm._e(), _vm.multiple ? [_c('bk-checkbox-group', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.searchEmpty,
        expression: "!searchEmpty"
      }],
      staticClass: "panel-checkbox-group",
      model: {
        value: _vm.selected,
        callback: function callback($$v) {
          _vm.selected = $$v;
        },
        expression: "selected"
      }
    }, _vm._l(_vm.filters, function (filter) {
      return _c('bk-checkbox', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: _vm.isMatched(filter),
          expression: "isMatched(filter)"
        }],
        key: filter.value,
        staticClass: "panel-checkbox",
        attrs: {
          "value": filter.value,
          "disabled": !!filter.disabled
        }
      }, [_vm._v("\n                " + _vm._s(filter.text) + "\n            ")]);
    }), 1), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.searchEmpty,
        expression: "!searchEmpty"
      }],
      staticClass: "panel-options"
    }, [_c('bk-link', {
      staticClass: "panel-options-link",
      attrs: {
        "theme": "primary"
      },
      on: {
        "click": _vm.handleConfirm
      }
    }, [_vm._v(_vm._s(_vm.t('bk.table.confirm')))]), _c('bk-link', {
      staticClass: "panel-options-link",
      attrs: {
        "theme": "primary"
      },
      on: {
        "click": _vm.handleReset
      }
    }, [_vm._v(_vm._s(_vm.t('bk.table.reset')))])], 1)] : [_c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.searchEmpty,
        expression: "!searchEmpty"
      }],
      staticClass: "panel-list"
    }, [_c('li', {
      staticClass: "panel-item",
      class: {
        'is-selected': _vm.selected.length === 0,
        'is-hidden': !!_vm.keyword.length
      },
      on: {
        "click": _vm.handleReset
      }
    }, [_vm._v("\n                " + _vm._s(_vm.t('bk.table.all')) + "\n            ")]), _vm._l(_vm.filters, function (filter) {
      return _c('li', {
        key: filter.value,
        staticClass: "panel-item",
        class: {
          'is-selected': _vm.selected.includes(filter.value),
          'is-disabled': !!filter.disabled,
          'is-hidden': !_vm.isMatched(filter)
        },
        on: {
          "click": function click($event) {
            _vm.handleSelect(filter);
          }
        }
      }, [_vm._v("\n                " + _vm._s(filter.text) + "\n            ")]);
    })], 2)], _vm.searchEmpty ? _c('p', {
      staticClass: "panel-empty"
    }, [_vm._v(_vm._s(_vm.t('bk.table.filter.empty')))]) : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$12 = [];
  /* style */

  var __vue_inject_styles__$12 = undefined;
  /* scoped */

  var __vue_scope_id__$12 = undefined;
  /* module identifier */

  var __vue_module_identifier__$12 = undefined;
  /* functional template */

  var __vue_is_functional_template__$12 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$12 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$12,
    staticRenderFns: __vue_staticRenderFns__$12
  }, __vue_inject_styles__$12, __vue_script__$10, __vue_scope_id__$12, __vue_is_functional_template__$12, __vue_module_identifier__$12, false, undefined, undefined, undefined);

  var getAllColumns = function getAllColumns(columns) {
    var result = [];
    columns.forEach(function (column) {
      if (column.children) {
        result.push(column);
        result.push.apply(result, getAllColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };
  var convertToRows = function convertToRows(originColumns) {
    var maxLevel = 1;
    var traverse = function traverse(column, parent) {
      if (parent) {
        column.level = parent.level + 1;
        if (maxLevel < column.level) {
          maxLevel = column.level;
        }
      }
      if (column.children) {
        var colSpan = 0;
        column.children.forEach(function (subColumn) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        });
        column.colSpan = colSpan;
      } else {
        column.colSpan = 1;
      }
    };
    originColumns.forEach(function (column) {
      column.level = 1;
      traverse(column);
    });
    var rows = [];
    for (var i = 0; i < maxLevel; i++) {
      rows.push([]);
    }
    var allColumns = getAllColumns(originColumns);
    allColumns.forEach(function (column) {
      if (!column.children) {
        column.rowSpan = maxLevel - column.level + 1;
      } else {
        column.rowSpan = 1;
      }
      rows[column.level - 1].push(column);
    });
    return rows;
  };
  var TableHeader = {
    name: 'bk-table-header',
    mixins: [LayoutObserver],
    render: function render(h) {
      var _this = this;
      var originColumns = this.store.states.originColumns;
      var columnRows = convertToRows(originColumns, this.columns);
      var isGroup = columnRows.length > 1;
      if (isGroup) this.$parent.isGroup = true;
      return h("table", {
        "class": "bk-table-header",
        "attrs": {
          "cellspacing": "0",
          "cellpadding": "0",
          "border": "0"
        }
      }, [h("colgroup", [this._l(this.columns, function (column) {
        return h("col", {
          "attrs": {
            "name": column.id
          }
        });
      }), this.hasGutter ? h("col", {
        "attrs": {
          "name": "gutter"
        }
      }) : '']), h("thead", {
        "class": [{
          'is-group': isGroup,
          'has-gutter': this.hasGutter
        }]
      }, [this._l(columnRows, function (columns, rowIndex) {
        return h("tr", {
          "style": _this.getHeaderRowStyle(rowIndex),
          "class": _this.getHeaderRowClass(rowIndex)
        }, [_this._l(columns, function (column, cellIndex) {
          return h("th", helper([{
            "attrs": {
              "colspan": column.colSpan,
              "rowspan": column.rowSpan
            },
            "on": {
              "mousemove": function mousemove($event) {
                return _this.handleMouseMove($event, column);
              },
              "mouseout": _this.handleMouseOut,
              "mousedown": function mousedown($event) {
                return _this.handleMouseDown($event, column);
              },
              "click": function click($event) {
                return _this.handleHeaderClick($event, column);
              },
              "contextmenu": function contextmenu($event) {
                return _this.handleHeaderContextMenu($event, column);
              }
            },
            "style": _this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
            "class": _this.getHeaderCellClass(rowIndex, cellIndex, columns, column),
            "key": column.id
          }, {
            "domProps": _this.getHeaderCellAttributes(rowIndex, cellIndex, columns, column)
          }]), [_this.isCellHidden(cellIndex, columns) ? '' : h("div", {
            "class": "cell"
          }, [h("div", {
            "class": ['bk-table-header-label', column.labelClassName]
          }, [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, {
            column: column,
            $index: cellIndex,
            store: _this.store,
            _self: _this.$parent.$vnode.context,
            fixed: _this.fixed
          }) : column.label]), column.sortable ? h("span", {
            "class": "bk-table-caret-wrapper",
            "on": {
              "click": function click($event) {
                return _this.handleSortClick($event, column);
              }
            }
          }, [h("i", {
            "class": "bk-table-sort-caret ascending",
            "on": {
              "click": function click($event) {
                return _this.handleSortClick($event, column, 'ascending');
              }
            }
          }), h("i", {
            "class": "bk-table-sort-caret descending",
            "on": {
              "click": function click($event) {
                return _this.handleSortClick($event, column, 'descending');
              }
            }
          })]) : '', column.filterable ? h("span", {
            "class": ['bk-table-column-filter-trigger', 'bk-icon icon-funnel', column.filterOpened ? 'is-open' : '', column.filteredValue && column.filteredValue.length > 0 ? 'is-filtered' : ''],
            "on": {
              "click": function click($event) {
                return _this.handleFilterClick($event, column);
              }
            }
          }) : ''])]);
        }), _this.hasGutter ? h("th", {
          "class": "gutter"
        }) : '']);
      }), this.$slots.prepend ? h("tr", {
        "class": "bk-table-header-append"
      }, [h("th", {
        "attrs": {
          "colSpan": this.colSpanNum
        },
        "class": "is-prepend"
      }, [this.$slots.prepend])]) : ''])]);
    },
    props: {
      fixed: String,
      store: {
        required: true
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default: function _default() {
          return {
            prop: '',
            order: ''
          };
        }
      }
    },
    components: {
      bkCheckbox: __vue_component__$8,
      bkTableSetting: bkTableSetting
    },
    computed: {
      table: function table() {
        return this.$parent;
      },
      isAllSelected: function isAllSelected() {
        return this.store.states.isAllSelected;
      },
      columnsCount: function columnsCount() {
        return this.store.states.columns.length;
      },
      leftFixedCount: function leftFixedCount() {
        return this.store.states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount() {
        return this.store.states.rightFixedColumns.length;
      },
      leftFixedLeafCount: function leftFixedLeafCount() {
        return this.store.states.fixedLeafColumnsLength;
      },
      rightFixedLeafCount: function rightFixedLeafCount() {
        return this.store.states.rightFixedLeafColumnsLength;
      },
      columns: function columns() {
        return this.store.states.columns;
      },
      hasGutter: function hasGutter() {
        return !this.fixed && this.tableLayout.gutterWidth;
      },
      colSpanNum: function colSpanNum() {
        var originColSpan = this.store.states.originColumns.length ? this.store.states.originColumns.map(function (col) {
          return col.colSpan;
        }).reduce(function (pre, next) {
          return pre + next;
        }) : 0;
        return this.hasGutter ? originColSpan + 1 : originColSpan;
      }
    },
    created: function created() {
      this.filterPanels = {};
    },
    mounted: function mounted() {
      var _this$defaultSort = this.defaultSort,
          prop = _this$defaultSort.prop,
          order = _this$defaultSort.order;
      this.store.commit('sort', {
        prop: prop,
        order: order
      });
    },
    beforeDestroy: function beforeDestroy() {
      var panels = this.filterPanels;
      for (var prop in panels) {
        if (panels.hasOwnProperty(prop) && panels[prop]) {
          panels[prop].$destroy(true);
        }
      }
    },
    methods: {
      isCellHidden: function isCellHidden(index, columns) {
        var start = 0;
        for (var i = 0; i < index; i++) {
          start += columns[i].colSpan;
        }
        var after = start + columns[index].colSpan - 1;
        if (this.fixed === true || this.fixed === 'left') {
          return after >= this.leftFixedLeafCount;
        } else if (this.fixed === 'right') {
          return start < this.columnsCount - this.rightFixedLeafCount;
        } else {
          return after < this.leftFixedLeafCount || start >= this.columnsCount - this.rightFixedLeafCount;
        }
      },
      getHeaderRowStyle: function getHeaderRowStyle(rowIndex) {
        var headerRowStyle = this.table.headerRowStyle;
        if (typeof headerRowStyle === 'function') {
          return headerRowStyle({
            rowIndex: rowIndex
          });
        }
        return headerRowStyle;
      },
      getHeaderRowClass: function getHeaderRowClass(rowIndex) {
        var classes = [];
        var headerRowClassName = this.table.headerRowClassName;
        if (typeof headerRowClassName === 'string') {
          classes.push(headerRowClassName);
        } else if (typeof headerRowClassName === 'function') {
          classes.push(headerRowClassName({
            rowIndex: rowIndex
          }));
        }
        return classes.join(' ');
      },
      getHeaderCellStyle: function getHeaderCellStyle(rowIndex, columnIndex, row, column) {
        var headerCellStyle = this.table.headerCellStyle;
        if (typeof headerCellStyle === 'function') {
          return headerCellStyle({
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          });
        }
        return headerCellStyle;
      },
      getHeaderCellClass: function getHeaderCellClass(rowIndex, columnIndex, row, column) {
        var classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];
        if (this.border) {
          classes.push('has-border');
        }
        if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
          classes.push('is-hidden');
        }
        if (!column.children) {
          classes.push('is-leaf');
        }
        if (column.sortable) {
          classes.push('is-sortable');
        }
        if (column.filterable) {
          classes.push('is-filterable');
        }
        if (columnIndex === 0) {
          classes.push('is-first');
        }
        if (columnIndex === row.length - 1) {
          classes.push('is-last');
        }
        var headerCellClassName = this.table.headerCellClassName;
        if (typeof headerCellClassName === 'string') {
          classes.push(headerCellClassName);
        } else if (typeof headerCellClassName === 'function') {
          classes.push(headerCellClassName({
            rowIndex: rowIndex,
            columnIndex: columnIndex,
            row: row,
            column: column
          }));
        }
        return classes.join(' ');
      },
      getHeaderCellAttributes: function getHeaderCellAttributes(rowIndex, cellIndex, columns, column) {
        if (typeof this.table.headerCellAttributes === 'function') {
          var attributes = this.table.headerCellAttributes({
            rowIndex: rowIndex,
            cellIndex: cellIndex,
            columns: columns,
            column: column
          });
          return _typeof(attributes) === 'object' ? attributes : {};
        } else if (_typeof(this.table.headerCellAttributes) === 'object') {
          return this.table.headerCellAttributes;
        }
        return {};
      },
      toggleAllSelection: function toggleAllSelection() {
        this.store.commit('toggleAllSelection');
      },
      handleFilterClick: function handleFilterClick(event, column) {
        event.stopPropagation();
        var target = event.target;
        while (target && target.tagName !== 'TH') {
          target = target.parentNode;
        }
        var filterReference = target.querySelector('.bk-table-column-filter-trigger');
        var table = this.$parent;
        var filterPanel = this.filterPanels[column.id];
        if (filterPanel && column.filterOpened) {
          filterPanel.instance.hide();
          return;
        }
        if (!filterPanel) {
          filterPanel = new Vue(__vue_component__$12);
          this.filterPanels[column.id] = filterPanel;
          filterPanel.table = table;
          filterPanel.column = column;
          filterPanel.multiple = column.filterMultiple;
          filterPanel.placement = column.filterPlacement || 'bottom-start';
          filterPanel.reference = filterReference;
          filterPanel.filters = column.filters;
          filterPanel.selected = column.filteredValue;
          filterPanel.searchable = column.filterSearchable;
          filterPanel.$mount();
        }
        setTimeout(function () {
          filterPanel.instance.show();
        }, 1000 / 60);
      },
      handleHeaderClick: function handleHeaderClick(event, column) {
        if (!column.filters && column.sortable) {
          this.handleSortClick(event, column);
        } else if (column.filterable && !column.sortable) {
          this.handleFilterClick(event, column);
        }
        this.$parent.$emit('header-click', column, event);
      },
      handleHeaderContextMenu: function handleHeaderContextMenu(event, column) {
        this.$parent.$emit('header-contextmenu', column, event);
      },
      handleMouseDown: function handleMouseDown(event, column) {
        var _this2 = this;
        if (column.children && column.children.length > 0) return;
        if (this.draggingColumn) {
          this.dragging = true;
          this.$parent.resizeProxyVisible = true;
          var table = this.$parent;
          var tableEl = table.$el;
          var tableLeft = tableEl.getBoundingClientRect().left;
          var columnEl = this.$el.querySelector("th.".concat(column.id));
          var columnRect = columnEl.getBoundingClientRect();
          var minLeft = columnRect.left - tableLeft + 80;
          addClass(columnEl, 'noclick');
          this.dragState = {
            startMouseLeft: event.clientX,
            startLeft: columnRect.right - tableLeft,
            startColumnLeft: columnRect.left - tableLeft,
            tableLeft: tableLeft
          };
          var resizeProxy = table.$refs.resizeProxy;
          resizeProxy.style.left = this.dragState.startLeft + 'px';
          document.onselectstart = function () {
            return false;
          };
          document.ondragstart = function () {
            return false;
          };
          var handleMouseMove = function handleMouseMove(event) {
            var deltaLeft = event.clientX - _this2.dragState.startMouseLeft;
            var proxyLeft = _this2.dragState.startLeft + deltaLeft;
            resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
          };
          var handleMouseUp = function handleMouseUp() {
            if (_this2.dragging) {
              var _this2$dragState = _this2.dragState,
                  startColumnLeft = _this2$dragState.startColumnLeft,
                  startLeft = _this2$dragState.startLeft;
              var finalLeft = _parseInt$2(resizeProxy.style.left, 10);
              var columnWidth = finalLeft - startColumnLeft;
              column.width = column.realWidth = columnWidth;
              table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);
              _this2.store.isDraging = true;
              _this2.store.scheduleLayout();
              document.body.style.cursor = '';
              _this2.dragging = false;
              _this2.draggingColumn = null;
              _this2.dragState = {};
              table.resizeProxyVisible = false;
            }
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            document.onselectstart = null;
            document.ondragstart = null;
            setTimeout(function () {
              removeClass(columnEl, 'noclick');
            }, 0);
          };
          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', handleMouseUp);
        }
      },
      handleMouseMove: function handleMouseMove(event, column) {
        if (column.children && column.children.length > 0) return;
        var target = event.target;
        while (target && target.tagName !== 'TH') {
          target = target.parentNode;
        }
        if (!column || !column.resizable) return;
        if (!this.dragging) {
          var rect = target.getBoundingClientRect();
          var bodyStyle = document.body.style;
          if (rect.width > 12 && rect.right - event.pageX < 8) {
            bodyStyle.cursor = 'col-resize';
            if (hasClass(target, 'is-sortable')) {
              target.style.cursor = 'col-resize';
            }
            this.draggingColumn = column;
          } else if (!this.dragging) {
            bodyStyle.cursor = '';
            if (hasClass(target, 'is-sortable')) {
              target.style.cursor = 'pointer';
            }
            this.draggingColumn = null;
          }
        }
      },
      handleMouseOut: function handleMouseOut() {
        document.body.style.cursor = '';
      },
      toggleOrder: function toggleOrder(_ref) {
        var order = _ref.order,
            sortOrders = _ref.sortOrders;
        if (order === '') return sortOrders[0];
        var index = sortOrders.indexOf(order || null);
        return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
      },
      handleSortClick: function handleSortClick(event, column, givenOrder) {
        event.stopPropagation();
        var order = givenOrder || this.toggleOrder(column);
        var target = event.target;
        while (target && target.tagName !== 'TH') {
          target = target.parentNode;
        }
        if (target && target.tagName === 'TH') {
          if (hasClass(target, 'noclick')) {
            removeClass(target, 'noclick');
            return;
          }
        }
        if (!column.sortable) return;
        var states = this.store.states;
        var sortProp = states.sortProp;
        var sortOrder;
        var sortingColumn = states.sortingColumn;
        if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
          if (sortingColumn) {
            sortingColumn.order = null;
          }
          states.sortingColumn = column;
          sortProp = column.property;
        }
        if (!order) {
          sortOrder = column.order = null;
          states.sortingColumn = null;
          sortProp = null;
        } else {
          sortOrder = column.order = order;
        }
        states.sortProp = sortProp;
        states.sortOrder = sortOrder;
        this.store.commit('changeSortCondition');
      }
    },
    data: function data() {
      return {
        draggingColumn: null,
        dragging: false,
        dragState: {}
      };
    }
  };

  var TableFooter = {
    name: 'bk-table-footer',
    mixins: [LayoutObserver],
    render: function render(h) {
      var _this = this;
      var sums = [];
      if (this.summaryMethod) {
        sums = this.summaryMethod({
          columns: this.columns,
          data: this.store.states.data
        });
      } else {
        this.columns.forEach(function (column, index) {
          if (index === 0) {
            sums[index] = _this.sumText;
            return;
          }
          var values = _this.store.states.data.map(function (item) {
            return Number(item[column.property]);
          });
          var precisions = [];
          var notNumber = true;
          values.forEach(function (value) {
            if (!isNaN(value)) {
              notNumber = false;
              var decimal = ('' + value).split('.')[1];
              precisions.push(decimal ? decimal.length : 0);
            }
          });
          var precision = Math.max.apply(null, precisions);
          if (!notNumber) {
            sums[index] = values.reduce(function (prev, curr) {
              var value = Number(curr);
              if (!isNaN(value)) {
                return _parseFloat$2((prev + curr).toFixed(Math.min(precision, 20)));
              } else {
                return prev;
              }
            }, 0);
          } else {
            sums[index] = '';
          }
        });
      }
      return h("table", {
        "class": "bk-table-footer",
        "attrs": {
          "cellspacing": "0",
          "cellpadding": "0",
          "border": "0"
        }
      }, [h("colgroup", [this._l(this.columns, function (column) {
        return h("col", {
          "attrs": {
            "name": column.id
          }
        });
      }), this.hasGutter ? h("col", {
        "attrs": {
          "name": "gutter"
        }
      }) : '']), h("tbody", {
        "class": [{
          'has-gutter': this.hasGutter
        }]
      }, [h("tr", [this._l(this.columns, function (column, cellIndex) {
        return h("td", {
          "attrs": {
            "colspan": column.colSpan,
            "rowspan": column.rowSpan
          },
          "class": [column.id, column.headerAlign, column.className || '', _this.isCellHidden(cellIndex, _this.columns) ? 'is-hidden' : '', !column.children ? 'is-leaf' : '', column.labelClassName]
        }, [h("div", {
          "class": ['cell', column.labelClassName]
        }, [sums[cellIndex]])]);
      }), this.hasGutter ? h("th", {
        "class": "gutter"
      }) : ''])])]);
    },
    props: {
      fixed: String,
      store: {
        required: true
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default: function _default() {
          return {
            prop: '',
            order: ''
          };
        }
      }
    },
    computed: {
      table: function table() {
        return this.$parent;
      },
      isAllSelected: function isAllSelected() {
        return this.store.states.isAllSelected;
      },
      columnsCount: function columnsCount() {
        return this.store.states.columns.length;
      },
      leftFixedCount: function leftFixedCount() {
        return this.store.states.fixedColumns.length;
      },
      rightFixedCount: function rightFixedCount() {
        return this.store.states.rightFixedColumns.length;
      },
      columns: function columns() {
        return this.store.states.columns;
      },
      hasGutter: function hasGutter() {
        return !this.fixed && this.tableLayout.gutterWidth;
      }
    },
    methods: {
      isCellHidden: function isCellHidden(index, columns) {
        if (this.fixed === true || this.fixed === 'left') {
          return index >= this.leftFixedCount;
        } else if (this.fixed === 'right') {
          var before = 0;
          for (var i = 0; i < index; i++) {
            before += columns[i].colSpan;
          }
          return before < this.columnsCount - this.rightFixedCount;
        } else {
          return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
        }
      }
    }
  };

  var tableIdSeed = 1;
  var script$11 = {
    name: 'bk-table',
    components: {
      TableHeader: TableHeader,
      TableFooter: TableFooter,
      TableBody: TableBody,
      BkPagination: __vue_component__$O
    },
    directives: {
      Mousewheel: Mousewheel,
      Bkloading: bkLoading
    },
    mixins: [locale.mixin],
    props: {
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      size: {
        type: String,
        default: 'small',
        validator: function validator(val) {
          return ['small', 'medium', 'large'].includes(val);
        }
      },
      height: [String, Number],
      maxHeight: [String, Number],
      fit: {
        type: Boolean,
        default: true
      },
      stripe: Boolean,
      border: Boolean,
      outerBorder: {
        type: Boolean,
        default: true
      },
      rowBorder: {
        type: Boolean,
        default: true
      },
      colBorder: Boolean,
      rowKey: [String, Function],
      context: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      showHeader: {
        type: Boolean,
        default: true
      },
      showSummary: Boolean,
      sumText: String,
      summaryMethod: Function,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      cellClassName: [String, Function],
      cellStyle: [Object, Function],
      headerBorder: {
        type: Boolean,
        default: false
      },
      headerRowClassName: [String, Function],
      headerRowStyle: [Object, Function],
      headerCellClassName: [String, Function],
      headerCellStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      currentRowKey: [String, Number],
      emptyText: String,
      emptyBlockClassName: String,
      expandRowKeys: Array,
      defaultExpandAll: Boolean,
      defaultSort: Object,
      spanMethod: Function,
      selectOnIndeterminate: {
        type: Boolean,
        default: true
      },
      pagination: Object,
      showPaginationInfo: {
        type: Boolean,
        default: true
      },
      autoScrollToTop: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      },
      setting: {
        type: Object,
        default: function _default() {
          return {
            columns: []
          };
        },
        validator: function validator(setting) {
          return isArray$1(setting.columns);
        }
      },
      cellAttributes: [Function, Object],
      headerCellAttributes: [Function, Object],
      virtualRender: {
        type: [Object, Boolean],
        default: false
      },
      scrollLoading: {
        type: Object,
        default: function _default() {
          return {
            size: 'mini',
            isLoading: false
          };
        }
      }
    },
    data: function data() {
      var store = new TableStore(this, {
        rowKey: this.rowKey,
        defaultExpandAll: this.defaultExpandAll,
        selectOnIndeterminate: this.selectOnIndeterminate
      });
      var layout = new TableLayout({
        store: store,
        table: this,
        fit: this.fit,
        showHeader: this.showHeader
      });
      return {
        layout: layout,
        store: store,
        isHidden: false,
        renderExpanded: null,
        resizeProxyVisible: false,
        resizeState: {
          width: null,
          height: null
        },
        isGroup: false,
        scrollPosition: 'left',
        scrollThrottle: false
      };
    },
    computed: {
      curLang: function curLang() {
        var l = locale.getCurLang().bk.lang;
        if (['zh', 'cn', 'zh-CN', 'zh-cn', 'zhCN', 'zhcn', 'zh-TW', 'zh-tw', 'zhTW', 'zhtw'].indexOf(l) > -1) {
          return 'cn';
        }
        return 'en';
      },
      tableSize: function tableSize() {
        return this.size;
      },
      tableBorder: function tableBorder() {
        return this.border || this.rowBorder && this.colBorder;
      },
      tableRowBorder: function tableRowBorder() {
        return this.border || this.rowBorder;
      },
      tableColBorder: function tableColBorder() {
        return this.border || this.colBorder;
      },
      bodyWrapper: function bodyWrapper() {
        return this.$refs.bodyWrapper;
      },
      shouldUpdateHeight: function shouldUpdateHeight() {
        return this.height || this.maxHeight || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
      },
      selection: function selection() {
        return this.store.states.selection;
      },
      columns: function columns() {
        return this.store.states.columns;
      },
      tableData: function tableData() {
        return this.store.states.data;
      },
      fixedColumns: function fixedColumns() {
        return this.store.states.fixedColumns;
      },
      rightFixedColumns: function rightFixedColumns() {
        return this.store.states.rightFixedColumns;
      },
      notOnlySetting: function notOnlySetting() {
        return this.rightFixedColumns.some(function (column) {
          return column.type !== 'setting';
        });
      },
      bodyWidth: function bodyWidth() {
        var _this$layout = this.layout,
            bodyWidth = _this$layout.bodyWidth,
            scrollY = _this$layout.scrollY,
            gutterWidth = _this$layout.gutterWidth;
        return bodyWidth ? bodyWidth - (scrollY ? gutterWidth : 0) + 'px' : '';
      },
      bodyHeight: function bodyHeight() {
        if (this.height) {
          return {
            height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
          };
        } else if (this.maxHeight) {
          return {
            'max-height': (this.showHeader ? this.maxHeight - this.layout.headerHeight - this.layout.footerHeight - this.layout.paginationHeight : this.maxHeight - this.layout.footerHeight - this.layout.paginationHeight) + 'px'
          };
        }
        return {};
      },
      fixedBodyHeight: function fixedBodyHeight() {
        if (this.height) {
          return {
            height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
          };
        } else if (this.maxHeight) {
          var maxHeight = this.layout.scrollX ? this.maxHeight - this.layout.gutterWidth : this.maxHeight;
          if (this.showHeader) {
            maxHeight -= this.layout.headerHeight;
          }
          maxHeight -= this.layout.footerHeight;
          maxHeight -= this.layout.paginationHeight;
          return {
            'max-height': maxHeight + 'px'
          };
        }
        return {};
      },
      fixedHeight: function fixedHeight() {
        if (this.maxHeight) {
          if (this.showSummary) {
            return {
              bottom: this.layout.paginationHeight + 'px'
            };
          }
          return {
            bottom: (this.layout.scrollX && this.data.length ? this.layout.gutterWidth + this.layout.paginationHeight : this.layout.paginationHeight) + 'px'
          };
        } else {
          if (this.showSummary) {
            return {
              height: this.layout.tableHeight ? this.layout.tableHeight + 'px' : ''
            };
          }
          return {
            height: this.layout.viewportHeight ? this.layout.viewportHeight + 'px' : ''
          };
        }
      },
      rightFixedHeight: function rightFixedHeight() {
        if (this.notOnlySetting) {
          return this.fixedHeight;
        }
        return {
          height: this.layout.headerHeight + 'px'
        };
      },
      showPagination: function showPagination() {
        return this.data.length && this.pagination && this.pagination.count > 0;
      },
      showSelectionCount: function showSelectionCount() {
        return this.store.states._columns.some(function (column) {
          return column.type === 'selection';
        });
      },
      isVirtualRender: function isVirtualRender() {
        var prop = this.virtualRender;
        return typeof prop === 'boolean' ? prop : _typeof(prop) === 'object' ? !prop.disabled : false;
      }
    },
    watch: {
      height: {
        immediate: true,
        handler: function handler(value) {
          this.layout.setHeight(value);
        }
      },
      maxHeight: {
        immediate: true,
        handler: function handler(value) {
          this.layout.setMaxHeight(value);
        }
      },
      currentRowKey: function currentRowKey(newVal) {
        this.store.setCurrentRowKey(newVal);
      },
      data: {
        immediate: true,
        handler: function handler(value) {
          var _this = this;
          this.store.commit('setData', value);
          if (this.$ready) {
            this.$nextTick(function () {
              _this.doLayout();
            });
          }
        }
      },
      expandRowKeys: {
        immediate: true,
        handler: function handler(newVal) {
          if (newVal) {
            this.store.setExpandRowKeys(newVal);
          }
        }
      }
    },
    created: function created() {
      var _this2 = this;
      this.tableId = 'bk-table-' + tableIdSeed++;
      this.debouncedUpdateLayout = debounce(50, function () {
        return _this2.doLayout();
      });
    },
    mounted: function mounted() {
      var _this3 = this;
      this.bindEvents();
      this.store.updateColumns();
      this.doLayout();
      this.resizeState = {
        width: this.$el.offsetWidth,
        height: this.$el.offsetHeight
      };
      this.store.states.columns.forEach(function (column) {
        if (column.filteredValue && column.filteredValue.length) {
          _this3.store.commit('filterChange', {
            column: column,
            values: column.filteredValue,
            silent: true
          });
        }
      });
      this.$ready = true;
    },
    beforeDestroy: function beforeDestroy() {
      this.$destroyed = true;
      if (this.resizeListener) removeResizeListener(this.$el, this.resizeListener);
    },
    methods: {
      setCurrentRow: function setCurrentRow(row) {
        this.store.commit('setCurrentRow', row);
      },
      toggleRowSelection: function toggleRowSelection(row, selected) {
        this.store.toggleRowSelection(row, selected);
        this.store.updateAllSelected();
      },
      toggleRowExpansion: function toggleRowExpansion(row, expanded) {
        this.store.toggleRowExpansion(row, expanded);
      },
      clearSelection: function clearSelection() {
        this.store.clearSelection();
      },
      clearFilter: function clearFilter() {
        this.store.clearFilter();
      },
      clearSort: function clearSort() {
        this.store.clearSort();
      },
      handleMouseLeave: function handleMouseLeave() {
        this.store.commit('setHoverRow', null);
        if (this.hoverState) this.hoverState = null;
      },
      updateScrollY: function updateScrollY() {
        this.layout.updateScrollY();
        this.layout.updateColumnsWidth();
      },
      handleFixedMousewheel: function handleFixedMousewheel(event, data) {
        var bodyWrapper = this.bodyWrapper;
        if (Math.abs(data.spinY) > 0) {
          var currentScrollTop = bodyWrapper.scrollTop;
          if (data.pixelY < 0 && currentScrollTop !== 0) {
            event.preventDefault();
          }
          if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
            event.preventDefault();
          }
          bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
        } else {
          bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
        }
      },
      handleHeaderFooterMousewheel: function handleHeaderFooterMousewheel(event, data) {
        var pixelX = data.pixelX,
            pixelY = data.pixelY;
        if (Math.abs(pixelX) >= Math.abs(pixelY)) {
          event.preventDefault();
          this.bodyWrapper.scrollLeft += data.pixelX / 5;
        }
      },
      handlePageChange: function handlePageChange(page) {
        this.autoScrollToTop && this.scrollToTop();
        this.$emit('page-change', page);
      },
      handlePageLimitChange: function handlePageLimitChange(currentLimit, prevLimit) {
        this.autoScrollToTop && this.scrollToTop();
        this.$emit('page-limit-change', currentLimit, prevLimit);
      },
      scrollToTop: function scrollToTop() {
        this.$refs.bodyWrapper.scrollTo({
          top: 0
        });
      },
      bindEvents: function bindEvents() {
        var _this$$refs = this.$refs,
            headerWrapper = _this$$refs.headerWrapper,
            footerWrapper = _this$$refs.footerWrapper,
            tableHeader = _this$$refs.tableHeader,
            bodyWrapper = _this$$refs.bodyWrapper;
        var refs = this.$refs;
        var self = this;
        this.bodyWrapper.addEventListener('scroll', function () {
          var _this4 = this;
          if (headerWrapper) {
            headerWrapper.scrollLeft = this.scrollLeft;
            values$1(tableHeader.filterPanels).forEach(function (filterPanel) {
              filterPanel.instance && filterPanel.instance.hide(0);
            });
          }
          if (footerWrapper) footerWrapper.scrollLeft = this.scrollLeft;
          if (refs.fixedBodyWrapper) refs.fixedBodyWrapper.scrollTop = this.scrollTop;
          if (refs.rightFixedBodyWrapper) refs.rightFixedBodyWrapper.scrollTop = this.scrollTop;
          var maxScrollLeftPosition = this.scrollWidth - this.offsetWidth - 1;
          var scrollLeft = this.scrollLeft;
          if (scrollLeft >= maxScrollLeftPosition) {
            self.scrollPosition = 'right';
          } else if (scrollLeft === 0) {
            self.scrollPosition = 'left';
          } else {
            self.scrollPosition = 'middle';
          }
          if (self.scrollLoading.isLoading) return;
          if (this.scrollThrottle) return;
          this.scrollThrottle = true;
          setTimeout(function () {
            _this4.scrollThrottle = false;
            if (bodyWrapper.scrollHeight - bodyWrapper.offsetHeight - bodyWrapper.scrollTop < 40) {
              self.$emit('scroll-end');
            }
          }, 500);
        });
        if (this.fit) {
          addResizeListener(this.$el, this.resizeListener);
        }
      },
      resizeListener: function resizeListener() {
        if (!this.$ready) return;
        var shouldUpdateLayout = false;
        var el = this.$el;
        var _this$resizeState = this.resizeState,
            oldWidth = _this$resizeState.width,
            oldHeight = _this$resizeState.height;
        var width = el.offsetWidth;
        if (oldWidth !== width) {
          shouldUpdateLayout = true;
        }
        var height = el.offsetHeight;
        if ((this.height || this.shouldUpdateHeight) && oldHeight !== height) {
          shouldUpdateLayout = true;
        }
        if (shouldUpdateLayout) {
          this.resizeState.width = width;
          this.resizeState.height = height;
          this.doLayout();
        }
      },
      doLayout: function doLayout() {
        if (this.$destroyed) return;
        if (this.shouldUpdateHeight) {
          this.layout.updateElsHeight();
        }
        this.layout.updateColumnsWidth();
      },
      sort: function sort(prop, order) {
        this.store.commit('sort', {
          prop: prop,
          order: order
        });
      },
      toggleAllSelection: function toggleAllSelection() {
        this.store.commit('toggleAllSelection');
      }
    }
  };

  /* script */
  var __vue_script__$11 = script$11;
  /* template */

  var __vue_render__$13 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-table",
      class: [{
        'bk-table-fit': _vm.fit,
        'bk-table-striped': _vm.stripe,
        'bk-table-border': _vm.tableBorder || _vm.isGroup,
        'bk-table-outer-border': _vm.outerBorder,
        'bk-table-linear': !(_vm.tableBorder || _vm.outerBorder || _vm.isGroup),
        'bk-table-row-border': _vm.tableRowBorder,
        'bk-table-col-border': _vm.tableColBorder,
        'bk-table-hidden': _vm.isHidden,
        'bk-table-group': _vm.isGroup,
        'bk-table-fluid-height': _vm.maxHeight,
        'bk-table-scrollable-x': _vm.layout.scrollX,
        'bk-table-scrollable-y': _vm.layout.scrollY,
        'bk-table-enable-row-transition': (_vm.store.states.data || []).length !== 0 && (_vm.store.states.data || []).length < 100
      }, _vm.tableSize ? "bk-table-" + _vm.tableSize : '', _vm.extCls],
      on: {
        "mouseleave": function mouseleave($event) {
          _vm.handleMouseLeave($event);
        }
      }
    }, [_c('div', {
      ref: "hiddenColumns",
      staticClass: "hidden-columns"
    }, [_vm._t("default")], 2), _vm.showHeader ? _c('div', {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleHeaderFooterMousewheel,
        expression: "handleHeaderFooterMousewheel"
      }],
      ref: "headerWrapper",
      staticClass: "bk-table-header-wrapper"
    }, [_c('table-header', {
      ref: "tableHeader",
      style: {
        width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
      },
      attrs: {
        "store": _vm.store,
        "border": _vm.headerBorder,
        "default-sort": _vm.defaultSort
      }
    }, [_c('template', {
      slot: "prepend"
    }, [_vm._t("prepend")], 2)], 2)], 1) : _vm._e(), _c('div', {
      ref: "bodyWrapper",
      staticClass: "bk-table-body-wrapper",
      class: [_vm.layout.scrollX ? "is-scrolling-" + _vm.scrollPosition : 'is-scrolling-none'],
      style: [_vm.bodyHeight]
    }, [_c('table-body', {
      ref: "tableBody",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "context": _vm.context,
        "store": _vm.store,
        "stripe": _vm.stripe,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle,
        "highlight": _vm.highlightCurrentRow
      }
    }), !_vm.data || _vm.data.length === 0 || _vm.store.states.data.length === 0 ? _c('div', {
      ref: "emptyBlock",
      class: ['bk-table-empty-block', _vm.emptyBlockClassName],
      style: {
        width: _vm.bodyWidth
      }
    }, [_c('span', {
      staticClass: "bk-table-empty-text"
    }, [_vm._t("empty", [_c('i', {
      staticClass: "bk-table-empty-icon bk-icon icon-empty"
    }), _c('div', [_vm._v(_vm._s(_vm.emptyText || _vm.t('bk.table.emptyText')))])])], 2)]) : _vm._e(), _vm.$slots.append ? _c('div', {
      ref: "appendWrapper",
      staticClass: "bk-table-append-wrapper"
    }, [_vm._t("append")], 2) : _vm._e()], 1), _vm.showSummary ? _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }, {
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleHeaderFooterMousewheel,
        expression: "handleHeaderFooterMousewheel"
      }],
      ref: "footerWrapper",
      staticClass: "bk-table-footer-wrapper"
    }, [_c('table-footer', {
      style: {
        width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
      },
      attrs: {
        "store": _vm.store,
        "border": _vm.tableBorder,
        "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
        "summary-method": _vm.summaryMethod,
        "default-sort": _vm.defaultSort
      }
    })], 1) : _vm._e(), _vm.fixedColumns.length > 0 ? _c('div', {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleFixedMousewheel,
        expression: "handleFixedMousewheel"
      }],
      ref: "fixedWrapper",
      staticClass: "bk-table-fixed",
      style: [{
        width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
      }, _vm.fixedHeight]
    }, [_vm.showHeader ? _c('div', {
      ref: "fixedHeaderWrapper",
      staticClass: "bk-table-fixed-header-wrapper"
    }, [_c('table-header', {
      ref: "fixedTableHeader",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "left",
        "border": _vm.headerBorder,
        "store": _vm.store
      }
    }, [_c('template', {
      slot: "prepend"
    }, [_vm._t("prepend")], 2)], 2)], 1) : _vm._e(), _c('div', {
      ref: "fixedBodyWrapper",
      staticClass: "bk-table-fixed-body-wrapper",
      style: [{
        top: _vm.layout.headerHeight + 'px'
      }, _vm.fixedBodyHeight]
    }, [_c('table-body', {
      ref: "leftTableBody",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "left",
        "store": _vm.store,
        "stripe": _vm.stripe,
        "highlight": _vm.highlightCurrentRow,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle
      }
    }), _vm.$slots.append ? _c('div', {
      staticClass: "bk-table-append-gutter",
      style: {
        height: _vm.layout.appendHeight + 'px'
      }
    }) : _vm._e()], 1), _vm.showSummary ? _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }],
      ref: "fixedFooterWrapper",
      staticClass: "bk-table-fixed-footer-wrapper"
    }, [_c('table-footer', {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "left",
        "border": _vm.tableBorder,
        "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
        "summary-method": _vm.summaryMethod,
        "store": _vm.store
      }
    })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c('div', {
      directives: [{
        name: "mousewheel",
        rawName: "v-mousewheel",
        value: _vm.handleFixedMousewheel,
        expression: "handleFixedMousewheel"
      }],
      ref: "rightFixedWrapper",
      staticClass: "bk-table-fixed-right",
      style: [{
        width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '',
        right: _vm.layout.scrollY ? (_vm.tableBorder ? _vm.layout.gutterWidth : _vm.layout.gutterWidth || 0) + 'px' : ''
      }, _vm.rightFixedHeight]
    }, [_vm.showHeader ? _c('div', {
      ref: "rightFixedHeaderWrapper",
      staticClass: "bk-table-fixed-header-wrapper"
    }, [_c('table-header', {
      ref: "rightFixedTableHeader",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "right",
        "border": _vm.headerBorder,
        "store": _vm.store
      }
    })], 1) : _vm._e(), _vm.notOnlySetting ? _c('div', {
      ref: "rightFixedBodyWrapper",
      staticClass: "bk-table-fixed-body-wrapper",
      style: [{
        top: _vm.layout.headerHeight + 'px'
      }, _vm.fixedBodyHeight]
    }, [_c('table-body', {
      ref: "rightTableBody",
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "right",
        "store": _vm.store,
        "stripe": _vm.stripe,
        "row-class-name": _vm.rowClassName,
        "row-style": _vm.rowStyle,
        "highlight": _vm.highlightCurrentRow
      }
    })], 1) : _vm._e(), _vm.showSummary ? _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.data && _vm.data.length > 0,
        expression: "data && data.length > 0"
      }],
      ref: "rightFixedFooterWrapper",
      staticClass: "bk-table-fixed-footer-wrapper"
    }, [_c('table-footer', {
      style: {
        width: _vm.bodyWidth
      },
      attrs: {
        "fixed": "right",
        "border": _vm.tableBorder,
        "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
        "summary-method": _vm.summaryMethod,
        "store": _vm.store
      }
    })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c('div', {
      ref: "rightFixedPatch",
      staticClass: "bk-table-fixed-right-patch",
      style: {
        width: _vm.layout.scrollY ? _vm.layout.gutterWidth + 'px' : '0',
        height: _vm.layout.headerHeight + 'px'
      }
    }) : _vm._e(), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.resizeProxyVisible,
        expression: "resizeProxyVisible"
      }],
      ref: "resizeProxy",
      staticClass: "bk-table-column-resize-proxy"
    }), _vm.showPagination ? _c('div', {
      ref: "paginationWrapper",
      staticClass: "bk-table-pagination-wrapper"
    }, [_vm.pagination ? _c('bk-pagination', _vm._b({
      staticClass: "bk-table-pagination",
      attrs: {
        "size": "small",
        "align": "right",
        "show-total-count": _vm.showPaginationInfo,
        "show-selection-count": _vm.showSelectionCount,
        "selection-count": _vm.store.states.selection.length
      },
      on: {
        "change": _vm.handlePageChange,
        "limit-change": _vm.handlePageLimitChange
      }
    }, 'bk-pagination', _vm.pagination, false)) : _vm._e()], 1) : _vm._e(), _vm.scrollLoading.isLoading ? _c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: _vm.scrollLoading,
        expression: "scrollLoading"
      }],
      staticClass: "bk-table-bottom-loading"
    }) : _vm._e()]);
  };

  var __vue_staticRenderFns__$13 = [];
  /* style */

  var __vue_inject_styles__$13 = undefined;
  /* scoped */

  var __vue_scope_id__$13 = undefined;
  /* module identifier */

  var __vue_module_identifier__$13 = undefined;
  /* functional template */

  var __vue_is_functional_template__$13 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$13 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$13,
    staticRenderFns: __vue_staticRenderFns__$13
  }, __vue_inject_styles__$13, __vue_script__$11, __vue_scope_id__$13, __vue_is_functional_template__$13, __vue_module_identifier__$13, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$13);

  var columnIdSeed = 1;
  var defaults = {
    default: {
      order: ''
    },
    selection: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      align: 'is-center',
      headerAlign: 'is-center',
      order: '',
      className: 'bk-table-column-selection'
    },
    expand: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      align: 'is-center',
      headerAlign: 'is-center',
      order: '',
      className: 'bk-table-column-expand'
    },
    index: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      align: 'is-center',
      headerAlign: 'is-center',
      order: '',
      className: 'bk-table-column-index'
    },
    setting: {
      width: 42,
      maxWidth: 42,
      minWidth: 42,
      realWidth: 42,
      headerAlign: 'is-center',
      order: '',
      className: 'bk-table-column-setting',
      icon: 'bk-icon icon-cog-shape'
    }
  };
  var forced = {
    selection: {
      renderHeader: function renderHeader(h, _ref) {
        var _this = this;
        var store = _ref.store,
            column = _ref.column;
        return h("bk-checkbox", {
          "attrs": {
            "disabled": store.isAllSelectionDisabled,
            "indeterminate": store.states.selection.length > 0 && !this.isAllSelected,
            "before-change": function beforeChange() {
              return column.beforeSelectAllChange(_this.isAllSelected, {
                column: column,
                store: store
              });
            },
            "checked": this.isAllSelected
          },
          "nativeOn": {
            "click": function () {
              var _click = _asyncToGenerator( regenerator.mark(function _callee() {
                var result;
                return regenerator.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return column.beforeSelectAllChange(_this.isAllSelected, {
                          column: column,
                          store: store
                        });
                      case 2:
                        result = _context.sent;
                        if (!(result === false)) {
                          _context.next = 5;
                          break;
                        }
                        return _context.abrupt("return");
                      case 5:
                        _this.toggleAllSelection();
                      case 6:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));
              function click() {
                return _click.apply(this, arguments);
              }
              return click;
            }()
          }
        });
      },
      renderCell: function renderCell(h, _ref2) {
        var row = _ref2.row,
            column = _ref2.column,
            store = _ref2.store,
            $index = _ref2.$index;
        var disabled = column.selectable ? !column.selectable.call(null, row, $index) : false;
        return h("bk-checkbox", {
          "attrs": {
            "checked": store.isSelected(row),
            "disabled": disabled,
            "before-change": function beforeChange() {
              return column.beforeSelectChange(store.isSelected(row), {
                row: row,
                column: column,
                store: store,
                $index: $index
              });
            }
          },
          "nativeOn": {
            "click": function () {
              var _click2 = _asyncToGenerator( regenerator.mark(function _callee2(event) {
                var result;
                return regenerator.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        event.stopPropagation();
                        if (!disabled) {
                          _context2.next = 3;
                          break;
                        }
                        return _context2.abrupt("return");
                      case 3:
                        _context2.next = 5;
                        return column.beforeSelectChange(store.isSelected(row), {
                          row: row,
                          column: column,
                          store: store,
                          $index: $index
                        });
                      case 5:
                        result = _context2.sent;
                        result !== false && store.commit('rowSelectedChanged', row);
                      case 7:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              function click(_x) {
                return _click2.apply(this, arguments);
              }
              return click;
            }()
          }
        });
      },
      sortable: false,
      resizable: false
    },
    index: {
      renderHeader: function renderHeader(h, _ref3) {
        var column = _ref3.column;
        return column.label || '#';
      },
      renderCell: function renderCell(h, _ref4) {
        var $index = _ref4.$index,
            column = _ref4.column;
        var i = $index + 1;
        var index = column.index;
        if (typeof index === 'number') {
          i = $index + index;
        } else if (typeof index === 'function') {
          i = index($index);
        }
        return h("div", [i]);
      },
      sortable: false
    },
    expand: {
      renderHeader: function renderHeader(h, _ref5) {
        var column = _ref5.column;
        return column.label || '';
      },
      renderCell: function renderCell(h, data, proxy) {
        var row = data.row,
            store = data.store;
        var expanded = store.states.expandRows.indexOf(row) > -1;
        return h("div", {
          "class": 'bk-table-expand-icon ' + (expanded ? 'bk-table-expand-icon-expanded' : ''),
          "on": {
            "click": function click(event) {
              return proxy.handleExpandClick(_objectSpread({}, data, {
                event: event
              }));
            }
          }
        }, [h("i", {
          "class": 'bk-icon icon-play-shape'
        })]);
      },
      sortable: false,
      resizable: false,
      className: 'bk-table-expand-column'
    },
    setting: {
      renderHeader: function renderHeader(h, _ref6) {
        var column = _ref6.column,
            fixed = _ref6.fixed;
        if (fixed === 'right') {
          return h("bk-table-setting", {
            "attrs": {
              "column": column
            }
          });
        }
        return '';
      },
      renderCell: function renderCell(h, _ref7, proxy) {
        var row = _ref7.row,
            store = _ref7.store;
        return '';
      },
      sortable: false,
      resizable: false,
      fixed: 'right',
      align: 'center'
    }
  };
  var getDefaultColumn = function getDefaultColumn(type, options) {
    var column = _objectSpread({}, defaults[type || 'default']);
    for (var name in options) {
      if (options.hasOwnProperty(name)) {
        var value = options[name];
        if (typeof value !== 'undefined') {
          column[name] = value;
        }
      }
    }
    if (!column.minWidth) {
      column.minWidth = 80;
    }
    column.realWidth = typeof column.width !== 'number' ? column.minWidth : column.width;
    return column;
  };
  var DEFAULT_RENDER_CELL = function DEFAULT_RENDER_CELL(h, _ref8) {
    var row = _ref8.row,
        column = _ref8.column,
        $index = _ref8.$index;
    var property = column.property;
    var value = property && getPropByPath(row, property).v;
    if (column && column.formatter) {
      return column.formatter(row, column, value, $index);
    }
    return value;
  };
  var parseWidth = function parseWidth(width) {
    if (width !== undefined) {
      width = _parseInt$2(width, 10);
      if (isNaN(width)) {
        width = null;
      }
    }
    return width;
  };
  var TableColumn = {
    name: 'bk-table-column',
    props: {
      type: {
        type: String,
        default: 'default'
      },
      label: String,
      className: String,
      labelClassName: String,
      property: String,
      prop: String,
      width: {},
      minWidth: {},
      maxWidth: {},
      renderHeader: Function,
      sortable: {
        type: [String, Boolean],
        default: false
      },
      sortMethod: Function,
      sortBy: [String, Function, Array],
      resizable: {
        type: Boolean,
        default: true
      },
      context: {},
      columnKey: String,
      align: String,
      headerAlign: String,
      showOverflowTooltip: [Boolean, Object],
      fixed: [Boolean, String],
      formatter: Function,
      selectable: Function,
      reserveSelection: Boolean,
      filterMethod: Function,
      filteredValue: Array,
      filters: Array,
      filterPlacement: String,
      filterMultiple: {
        type: Boolean,
        default: true
      },
      filterSearchable: Boolean,
      index: [Number, Function],
      sortOrders: {
        type: Array,
        default: function _default() {
          return ['ascending', 'descending', null];
        },
        validator: function validator(val) {
          return val.every(function (order) {
            return ['ascending', 'descending', null].indexOf(order) > -1;
          });
        }
      },
      beforeExpandChange: Function,
      beforeSelectChange: Function,
      beforeSelectAllChange: Function
    },
    data: function data() {
      return {
        isSubColumn: false,
        columns: []
      };
    },
    beforeCreate: function beforeCreate() {
      this.row = {};
      this.column = {};
      this.$index = 0;
    },
    computed: {
      owner: function owner() {
        var parent = this.$parent;
        while (parent && !parent.tableId) {
          parent = parent.$parent;
        }
        return parent;
      },
      columnOrTableParent: function columnOrTableParent() {
        var parent = this.$parent;
        while (parent && !parent.tableId && !parent.columnId) {
          parent = parent.$parent;
        }
        return parent;
      }
    },
    created: function created() {
      var _this2 = this;
      var h = this.$createElement;
      this.customRender = this.$options.render;
      if (this.type !== 'setting') {
        this.$options.render = function (h) {
          return h('div', _this2.$slots.default);
        };
      } else {
        this.$options.render = function (h) {
          _this2.columnConfig.settingContent = function (h) {
            return _this2.$slots.default;
          };
          return h('div');
        };
      }
      var parent = this.columnOrTableParent;
      var owner = this.owner;
      this.isSubColumn = owner !== parent;
      this.columnId = (parent.tableId || parent.columnId) + '-column-' + columnIdSeed++;
      var type = this.type;
      var width = parseWidth(this.width);
      var minWidth = parseWidth(this.minWidth);
      var maxWidth = parseWidth(this.maxWidth);
      var isColumnGroup = false;
      var column = getDefaultColumn(type, {
        id: this.columnId,
        columnKey: this.columnKey,
        label: this.label,
        className: this.className,
        labelClassName: this.labelClassName,
        property: this.prop || this.property,
        type: type,
        renderCell: null,
        renderHeader: this.renderHeader,
        width: width,
        minWidth: minWidth,
        maxWidth: maxWidth,
        isColumnGroup: isColumnGroup,
        context: this.context,
        align: this.align ? 'is-' + this.align : undefined,
        headerAlign: this.headerAlign ? 'is-' + this.headerAlign : this.align ? 'is-' + this.align : undefined,
        sortable: this.sortable === '' ? true : this.sortable,
        sortMethod: this.sortMethod,
        sortBy: this.sortBy,
        resizable: this.resizable,
        showOverflowTooltip: this.showOverflowTooltip,
        formatter: this.formatter,
        selectable: this.selectable,
        reserveSelection: this.reserveSelection,
        fixed: this.fixed === '' ? true : this.fixed,
        filterMethod: this.filterMethod,
        filters: this.filters,
        filterable: this.filters,
        filterMultiple: this.filterMultiple,
        filterOpened: false,
        filteredValue: this.filteredValue || [],
        filterPlacement: this.filterPlacement || '',
        filterSearchable: this.filterSearchable,
        index: this.index,
        sortOrders: this.sortOrders,
        order: null,
        beforeExpandChange: this.beforeExpandChange,
        beforeSelectChange: createFuncWrapper(this.beforeSelectChange),
        beforeSelectAllChange: createFuncWrapper(this.beforeSelectAllChange)
      });
      var source = forced[type] || {};
      keys$1(source).forEach(function (prop) {
        var value = source[prop];
        if (value !== undefined) {
          if (prop === 'renderHeader') {
            if (type === 'selection' && column[prop]) {
              console.warn('[Magic Warn][TableColumn]Selection column doesn\'t allow to set render-header function.');
            } else {
              value = column[prop] || value;
            }
          }
          column[prop] = prop === 'className' ? "".concat(column[prop], " ").concat(value) : value;
        }
      });
      this.columnConfig = column;
      var renderCell = column.renderCell;
      var _self = this;
      if (type === 'expand') {
        owner.renderExpanded = function (h, data) {
          return _self.$scopedSlots.default ? _self.$scopedSlots.default(data) : _self.$slots.default;
        };
        column.renderCell = function (h, data) {
          return h("div", {
            "class": "cell"
          }, [renderCell(h, data, this._renderProxy)]);
        };
        return;
      }
      if (type === 'setting') {
        column.settingContent = function (h) {
          return _self.$slots.default;
        };
      }
      column.renderCell = function (h, data) {
        if (_self.$scopedSlots.default) {
          renderCell = function renderCell() {
            return _self.$scopedSlots.default(data);
          };
        }
        if (!renderCell) {
          renderCell = DEFAULT_RENDER_CELL;
        }
        if (_self.showOverflowTooltip) {
          var config = _typeof(_self.showOverflowTooltip) === 'object' ? _self.showOverflowTooltip : {
            interactive: false
          };
          return h("div", {
            "class": "cell",
            "directives": [{
              name: "bk-overflow-tips",
              value: config
            }]
          }, [renderCell(h, data)]);
        }
        return h("div", {
          "class": "cell"
        }, [renderCell(h, data)]);
      };
    },
    destroyed: function destroyed() {
      if (!this.$parent) return;
      var parent = this.$parent;
      this.owner.store.commit('removeColumn', this.columnConfig, this.isSubColumn ? parent.columnConfig : null);
    },
    watch: {
      label: function label(newVal) {
        if (this.columnConfig) {
          this.columnConfig.label = newVal;
        }
      },
      prop: function prop(newVal) {
        if (this.columnConfig) {
          this.columnConfig.property = newVal;
        }
      },
      property: function property(newVal) {
        if (this.columnConfig) {
          this.columnConfig.property = newVal;
        }
      },
      filters: function filters(newVal) {
        if (this.columnConfig) {
          this.columnConfig.filters = newVal;
        }
      },
      filterMultiple: function filterMultiple(newVal) {
        if (this.columnConfig) {
          this.columnConfig.filterMultiple = newVal;
        }
      },
      align: function align(newVal) {
        if (this.columnConfig) {
          this.columnConfig.align = newVal ? 'is-' + newVal : null;
          if (!this.headerAlign) {
            this.columnConfig.headerAlign = newVal ? 'is-' + newVal : null;
          }
        }
      },
      headerAlign: function headerAlign(newVal) {
        if (this.columnConfig) {
          this.columnConfig.headerAlign = 'is-' + (newVal || this.align);
        }
      },
      width: function width(newVal) {
        if (this.columnConfig) {
          this.columnConfig.width = parseWidth(newVal);
          this.owner.store.scheduleLayout();
        }
      },
      minWidth: function minWidth(newVal) {
        if (this.columnConfig) {
          this.columnConfig.minWidth = parseWidth(newVal);
          this.owner.store.scheduleLayout();
        }
      },
      fixed: function fixed(newVal) {
        if (this.columnConfig) {
          this.columnConfig.fixed = newVal;
          this.owner.store.scheduleLayout(true);
        }
      },
      sortable: function sortable(newVal) {
        if (this.columnConfig) {
          this.columnConfig.sortable = newVal;
        }
      },
      index: function index(newVal) {
        if (this.columnConfig) {
          this.columnConfig.index = newVal;
        }
      },
      formatter: function formatter(newVal) {
        if (this.columnConfig) {
          this.columnConfig.formatter = newVal;
        }
      },
      className: function className(newVal) {
        if (this.columnConfig) {
          this.columnConfig.className = newVal;
        }
      },
      labelClassName: function labelClassName(newVal) {
        if (this.columnConfig) {
          this.columnConfig.labelClassName = newVal;
        }
      }
    },
    mounted: function mounted() {
      var owner = this.owner;
      var parent = this.columnOrTableParent;
      var columnIndex;
      if (!this.isSubColumn) {
        columnIndex = [].indexOf.call(parent.$refs.hiddenColumns.children, this.$el);
      } else {
        columnIndex = [].indexOf.call(parent.$el.children, this.$el);
      }
      owner.store.commit('insertColumn', this.columnConfig, columnIndex, this.isSubColumn ? parent.columnConfig : null);
    }
  };

  setInstaller(TableColumn);

  var script$12 = {
    name: 'bk-table-setting-content',
    components: {
      bkCheckboxGroup: __vue_component__$9,
      bkCheckbox: __vue_component__$8,
      bkButton: __vue_component__$7
    },
    mixins: [locale.mixin],
    props: {
      fields: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      selected: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      valueKey: {
        type: String,
        default: 'id'
      },
      labelKey: {
        type: String,
        default: 'label'
      },
      size: {
        type: String,
        default: 'small'
      },
      limit: Number
    },
    data: function data() {
      return {
        localSelected: [],
        currentSize: 'small'
      };
    },
    computed: {
      fieldsState: function fieldsState() {
        var _this = this;
        var disabled = [];
        var available = [];
        var fixed = [];
        this.fields.forEach(function (field) {
          if (field.disabled) {
            disabled.push(field);
            if (_this.localSelected.includes(field[_this.valueKey])) {
              fixed.push(field);
            }
          } else {
            available.push(field);
          }
        });
        return {
          disabled: disabled,
          available: available,
          fixed: fixed
        };
      },
      disabledFields: function disabledFields() {
        return this.fieldsState.disabled;
      },
      availableFields: function availableFields() {
        return this.fieldsState.available;
      },
      fixedFields: function fixedFields() {
        return this.fieldsState.fixed;
      },
      allSelected: function allSelected() {
        var _this2 = this;
        return this.availableFields.every(function (field) {
          return _this2.localSelected.includes(field[_this2.valueKey]);
        });
      },
      reachLimit: function reachLimit() {
        return this.limit && this.localSelected.length > this.limit;
      },
      popoverInstance: function popoverInstance() {
        return this.$parent.instance;
      }
    },
    watch: {
      selected: {
        immediate: true,
        handler: function handler(value) {
          this.setSelected();
        }
      },
      size: {
        immediate: true,
        handler: function handler(size) {
          this.setSize(size);
        }
      },
      popoverInstance: function popoverInstance() {
        this.initCallback();
      }
    },
    methods: {
      initCallback: function initCallback() {
        var _this3 = this;
        this.popoverInstance.set({
          onHidden: function onHidden() {
            if (_this3.isConfirm) {
              _this3.$emit('setting-change', {
                fields: _this3.fields.filter(function (field) {
                  return _this3.localSelected.includes(field[_this3.valueKey]);
                }),
                size: _this3.currentSize
              });
            } else {
              _this3.$emit('cancel');
            }
            _this3.isConfirm = false;
            _this3.$nextTick(function () {
              _this3.setSelected();
              _this3.setSize(_this3.size);
            });
          }
        });
      },
      setSelected: function setSelected() {
        var _this4 = this;
        this.localSelected = this.selected.map(function (field) {
          return field[_this4.valueKey];
        });
      },
      setSize: function setSize(size) {
        this.currentSize = size;
      },
      handleSelectAll: function handleSelectAll() {
        var _this5 = this;
        if (!this.allSelected) {
          this.localSelected = this.fields.filter(function (field) {
            return _this5.fixedFields.includes(field) || !field.disabled;
          }).map(function (field) {
            return field[_this5.valueKey];
          });
        } else {
          this.localSelected = this.fixedFields.map(function (field) {
            return field[_this5.valueKey];
          });
        }
      },
      handleConfirm: function handleConfirm() {
        this.isConfirm = true;
        this.popoverInstance.hide();
      },
      handleCancel: function handleCancel() {
        this.isConfirm = false;
        this.popoverInstance.hide();
      }
    }
  };

  /* script */
  var __vue_script__$12 = script$12;
  /* template */

  var __vue_render__$14 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-table-setting-content"
    }, [_c('h2', {
      staticClass: "content-title"
    }, [_vm._v(_vm._s(_vm.t('bk.table.setting.title')))]), _c('div', {
      staticClass: "content-scroller"
    }, [_c('div', {
      staticClass: "content-fields clearfix"
    }, [_c('p', {
      staticClass: "setting-title"
    }, [_vm._v("\n                " + _vm._s(_vm.t('bk.table.setting.fields.title')) + "\n                "), _vm.limit ? _c('span', {
      staticClass: "setting-subtitle",
      class: {
        'is-limit': _vm.reachLimit
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.t('bk.table.setting.fields.subtitle', {
      max: _vm.limit
    })) + "\n                ")]) : _c('bk-checkbox', {
      staticClass: "fr setting-checkbox",
      attrs: {
        "checked": _vm.allSelected
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.handleSelectAll($event);
        }
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.t('bk.table.setting.fields.selectAll')) + "\n                ")])], 1), _c('bk-checkbox-group', {
      staticClass: "fields-group",
      model: {
        value: _vm.localSelected,
        callback: function callback($$v) {
          _vm.localSelected = $$v;
        },
        expression: "localSelected"
      }
    }, [_vm._l(_vm.fields, function (field) {
      return [_c('span', {
        key: field[_vm.valueKey],
        staticClass: "fields-checkbox-wrapper"
      }, [_c('bk-checkbox', {
        staticClass: "fields-checkbox",
        attrs: {
          "disabled": field.hasOwnProperty('disabled') ? !!field.disabled : false,
          "value": field[_vm.valueKey],
          "title": field[_vm.labelKey]
        }
      }, [_vm._v("\n                            " + _vm._s(field[_vm.labelKey]) + "\n                        ")])], 1)];
    })], 2)], 1), _c('div', {
      staticClass: "content-line-height"
    }, [_c('p', {
      staticClass: "setting-title"
    }, [_vm._v("\n                " + _vm._s(_vm.t('bk.table.setting.lineHeight.title')) + "\n            ")]), _c('div', {
      staticClass: "bk-button-group link-button-group"
    }, [_c('bk-button', {
      class: ['link-button', {
        'is-selected': _vm.currentSize === 'small'
      }],
      attrs: {
        "size": "small"
      },
      on: {
        "click": function click($event) {
          _vm.setSize('small');
        }
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.t('bk.table.setting.lineHeight.small')) + "\n                ")]), _c('bk-button', {
      class: ['link-button', {
        'is-selected': _vm.currentSize === 'medium'
      }],
      attrs: {
        "size": "small"
      },
      on: {
        "click": function click($event) {
          _vm.setSize('medium');
        }
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.t('bk.table.setting.lineHeight.medium')) + "\n                ")]), _c('bk-button', {
      class: ['link-button', {
        'is-selected': _vm.currentSize === 'large'
      }],
      attrs: {
        "size": "small"
      },
      on: {
        "click": function click($event) {
          _vm.setSize('large');
        }
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.t('bk.table.setting.lineHeight.large')) + "\n                ")])], 1)])]), _c('div', {
      staticClass: "content-options"
    }, [_c('bk-button', {
      staticClass: "mr10",
      attrs: {
        "theme": "primary",
        "disabled": _vm.reachLimit
      },
      on: {
        "click": _vm.handleConfirm
      }
    }, [_vm._v("\n            " + _vm._s(_vm.t('bk.table.setting.options.ok')) + "\n        ")]), _c('bk-button', {
      attrs: {
        "theme": "default"
      },
      on: {
        "click": _vm.handleCancel
      }
    }, [_vm._v(_vm._s(_vm.t('bk.table.setting.options.cancel')))])], 1)]);
  };

  var __vue_staticRenderFns__$14 = [];
  /* style */

  var __vue_inject_styles__$14 = undefined;
  /* scoped */

  var __vue_scope_id__$14 = undefined;
  /* module identifier */

  var __vue_module_identifier__$14 = undefined;
  /* functional template */

  var __vue_is_functional_template__$14 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$14 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$14,
    staticRenderFns: __vue_staticRenderFns__$14
  }, __vue_inject_styles__$14, __vue_script__$12, __vue_scope_id__$14, __vue_is_functional_template__$14, __vue_module_identifier__$14, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$14);

  var _validateCollection = function (it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$2 = _objectDp.f;
  var fastKey = _meta.fastKey;
  var SIZE = _descriptors ? '_s' : 'size';
  var getEntry = function (that, key) {
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  var _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME;
        that._i = _objectCreate(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function (key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        forEach: function forEach(callbackfn ) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$2(C.prototype, 'size', {
        get: function () {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index !== 'F') that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME);
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return _iterStep(1);
        }
        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      _setSpecies(NAME);
    }
  };

  var SPECIES$2 = _wks('species');
  var _arraySpeciesConstructor = function (original) {
    var C;
    if (_isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
      if (_isObject(C)) {
        C = C[SPECIES$2];
        if (C === null) C = undefined;
      }
    } return C === undefined ? Array : C;
  };

  var _arraySpeciesCreate = function (original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  var _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;
          else if (res) switch (TYPE) {
            case 3: return true;
            case 5: return val;
            case 6: return index;
            case 2: result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var dP$3 = _objectDp.f;
  var each = _arrayMethods(0);
  var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    if (!_descriptors || typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME, '_c');
        target._c = new Base();
        if (iterable != undefined) _forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) _hide(C.prototype, KEY, function (a, b) {
          _anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !_isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP$3(C.prototype, 'size', {
        get: function () {
          return this._c.size;
        }
      });
    }
    _setToStringTag(C, NAME);
    O[NAME] = C;
    _export(_export.G + _export.W + _export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };

  var SET = 'Set';
  var es6_set = _collection(SET, function (get) {
    return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    add: function add(value) {
      return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
    }
  }, _collectionStrong);

  var _arrayFromIterable = function (iter, ITERATOR) {
    var result = [];
    _forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };

  var _collectionToJson = function (NAME) {
    return function toJSON() {
      if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return _arrayFromIterable(this);
    };
  };

  _export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });

  var _setCollectionOf = function (COLLECTION) {
    _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = new Array(length);
      while (length--) A[length] = arguments[length];
      return new this(A);
    } });
  };

  _setCollectionOf('Set');

  var _setCollectionFrom = function (COLLECTION) {
    _export(_export.S, COLLECTION, { from: function from(source ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
  };

  _setCollectionFrom('Set');

  var set = _core.Set;

  var set$1 = set;

  Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,value:function r(){var t=isNaN(arguments[0])?1:Number(arguments[0]);return t?Array.prototype.reduce.call(this,function(a,e){return Array.isArray(e)?a.push.apply(a,r.call(e,t-1)):a.push(e),a},[]):Array.prototype.slice.call(this)},writable:!0}),Array.prototype.flatMap||Object.defineProperty(Array.prototype,"flatMap",{configurable:!0,value:function(r){return Array.prototype.map.apply(this,arguments).flat()},writable:!0});

  var listRender = {
    name: 'render',
    functional: true,
    props: {
      node: Object,
      displayKey: String,
      searchKey: [String, Array],
      searchKeyword: String,
      tpl: Function
    },
    render: function render(h, ct) {
      var parentClass = 'bk-selector-node';
      var textClass = 'text';
      var _ct$props = ct.props,
          node = _ct$props.node,
          displayKey = _ct$props.displayKey,
          searchKeyword = _ct$props.searchKeyword,
          tpl = _ct$props.tpl;
      function highlightKeyword(value) {
        if (searchKeyword) {
          var keywordReg = new RegExp("(".concat(searchKeyword, ")"), 'i');
          return value.replace(keywordReg, '<strong class="highlight-text">$1</strong>');
        } else {
          return value;
        }
      }
      if (tpl) {
        var innerHtml = tpl(node, ct, highlightKeyword, h);
        return innerHtml;
      } else {
        return h("div", {
          "class": parentClass
        }, [h("span", {
          "domProps": {
            "innerHTML": highlightKeyword(node[displayKey])
          },
          "class": textClass
        })]);
      }
    }
  };

  var tagRender = {
    name: 'tag-render',
    functional: true,
    props: {
      node: Object,
      displayKey: String,
      tpl: Function
    },
    render: function render(h, ct) {
      var parentClass = 'tag';
      var textClass = 'text';
      if (ct.props.tpl) {
        return ct.props.tpl(ct.props.node, ct, h);
      }
      return h("div", {
        "class": parentClass
      }, [h("span", {
        "class": textClass
      }, [ct.props.node[ct.props.displayKey]])]);
    }
  };

  var script$13 = {
    name: 'bk-tag-input',
    components: {
      listRender: listRender,
      tagRender: tagRender,
      bkPopover: __vue_component__$G
    },
    directives: {
      bkloading: bkLoading,
      bkTooltips: bkTooltips
    },
    mixins: [locale.mixin, emitter],
    props: {
      showClearOnlyHover: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: ''
      },
      value: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      leftSpace: {
        type: Number,
        default: 0
      },
      disabled: {
        type: Boolean,
        default: false
      },
      hasDeleteIcon: {
        type: Boolean,
        default: false
      },
      separator: {
        type: String,
        default: ''
      },
      maxData: {
        type: Number,
        default: -1
      },
      maxResult: {
        type: Number,
        default: 10
      },
      isBlurTrigger: {
        type: Boolean,
        default: true
      },
      saveKey: {
        type: String,
        default: 'id'
      },
      displayKey: {
        type: String,
        default: 'name'
      },
      tooltipKey: {
        type: String,
        default: ''
      },
      searchKey: {
        type: [String, Array],
        default: 'name'
      },
      useGroup: {
        type: Boolean,
        default: false
      },
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      contentWidth: {
        type: Number,
        default: 190
      },
      contentMaxHeight: {
        type: Number,
        default: 300
      },
      allowCreate: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: true
      },
      tpl: Function,
      tagTpl: Function,
      pasteFn: Function,
      filterCallback: {
        type: Function,
        default: null
      },
      popoverOptions: {
        type: Object,
        default: function _default() {
          return {
            distance: 0
          };
        }
      },
      trigger: {
        type: String,
        default: 'search',
        validator: function validator(value) {
          if (['focus', 'search'].indexOf(value) < 0) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      allowNextFocus: {
        type: Boolean,
        default: true
      },
      allowAutoMatch: {
        type: Boolean,
        default: false
      },
      createTagValidator: {
        type: Function,
        default: null
      }
    },
    data: function data() {
      return {
        curInputValue: '',
        cacheVal: '',
        timer: 0,
        focusItemIndex: this.allowCreate ? -1 : 0,
        isEdit: false,
        showList: false,
        isCanRemoveTag: false,
        tagList: [],
        localTagList: [],
        tagListCache: [],
        localTagListCache: [],
        renderList: [],
        renderListShadow: [],
        renderListPaged: [],
        renderListAll: [],
        initData: [],
        curPage: 1,
        totalSize: 0,
        totalPage: 0,
        pageSize: 0,
        showScrollLoading: false,
        isBeforeDestroy: false,
        bkTagSelector: null,
        popoverInstance: null,
        isSingleSelect: false,
        INPUT_MIN_WIDTH: 12,
        popoverWidth: 190,
        hover: false
      };
    },
    computed: {
      isShowClear: function isShowClear() {
        return this.clearable && !this.disabled && this.localTagList.length !== 0 && (this.showClearOnlyHover ? this.hover : true);
      },
      resultList: function resultList() {
        if (this.useGroup) {
          var result = {};
          this.renderList.forEach(function (item, index) {
            item.index = index;
            if (!result[item.group.groupId]) {
              result[item.group.groupId] = {
                id: item.group.groupId,
                name: item.group.groupName,
                children: []
              };
            }
            result[item.group.groupId].children.push(item);
          });
          return result;
        } else {
          return this.renderList;
        }
      },
      defaultPlaceholder: function defaultPlaceholder() {
        return this.placeholder || this.t('bk.tagInput.placeholder');
      }
    },
    watch: {
      curInputValue: function curInputValue(newVal, oldVal) {
        var _this = this;
        if (newVal !== '' && this.renderList.length) {
          this.showList = true;
        } else if (this.trigger !== 'focus') {
          setTimeout(function () {
            _this.showList = false;
          }, 100);
        }
      },
      showList: function showList(val) {
        var _this2 = this;
        if (val) {
          this.$nextTick(function () {
            _this2.showPopover();
          });
        }
      },
      list: function list(val) {
        if (val) {
          this.getData();
        }
      },
      value: function value() {
        this.getData();
      },
      maxData: function maxData(val) {
        this.isSingleSelect = val === 1;
      }
    },
    created: function created() {
      this.isSingleSelect = this.maxData === 1;
      this.pageSize = this.maxResult;
      this.getData();
    },
    mounted: function mounted() {
      this.bkTagSelector = this.$refs.bkTagSelector;
      this.popoverInstance = this.$refs['tagInputDropdown'];
    },
    beforeDestroy: function beforeDestroy() {
      this.isBeforeDestroy = true;
      var selectorList = this.$refs.selectorList;
      selectorList && selectorList.removeEventListener('scroll', this.scrollHandler);
      clearTimeout(this.timer);
    },
    methods: {
      mouseEnterHandler: function mouseEnterHandler() {
        this.hover = true;
      },
      handlerClear: function handlerClear() {
        this.tagList = [];
        this.localTagList = [];
        this.handlerChange('removeAll');
      },
      showPopover: function showPopover() {
        var inputLeft = this.isSingleSelect ? 0 : this.$refs.staffInput.offsetLeft;
        this.popoverInstance.instance.set({
          offset: "".concat(inputLeft, ", 0")
        });
        if (this.popoverInstance.instance.popperInstance) {
          this.popoverInstance.instance.popperInstance.update();
        }
        var selectorList = this.$refs.selectorList;
        if (selectorList) {
          selectorList.scrollTop = 0;
          selectorList.removeEventListener('scroll', this.scrollHandler);
          selectorList.addEventListener('scroll', this.scrollHandler);
        }
        this.popoverInstance.instance.show();
      },
      getCharLength: function getCharLength(str) {
        var len = str.length;
        var bitLen = 0;
        for (var i = 0; i < len; i++) {
          if ((str.charCodeAt(i) & 0xff00) !== 0) {
            bitLen++;
          }
          bitLen++;
        }
        return bitLen;
      },
      filterData: function filterData() {
        var _this3 = this;
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        val = val.toLowerCase();
        var filterData;
        if (typeof this.filterCallback === 'function') {
          filterData = this.filterCallback(val, this.searchKey, this.initData) || [];
        } else {
          if (isArray$1(this.searchKey)) {
            var filterDataList = this.searchKey.map(function (searchKey) {
              return _this3.initData.filter(function (item) {
                return item[searchKey].toLowerCase().indexOf(val) !== -1;
              });
            });
            filterData = from_1$1(new set$1(filterDataList.flat()));
          } else {
            filterData = this.initData.filter(function (item) {
              return item[_this3.searchKey].toLowerCase().indexOf(val) !== -1;
            });
          }
        }
        this.renderListAll = filterData.slice(0);
        this.renderListShadow = filterData.slice(0);
        this.initPageConf(this.renderListAll.length);
      },
      initPageConf: function initPageConf(count) {
        var _this$renderList;
        this.curPage = 1;
        this.totalSize = count;
        this.totalPage = Math.ceil(this.totalSize / this.pageSize) || 1;
        var list = [];
        for (var i = 0; i < this.totalSize; i += this.pageSize) {
          list.push(this.renderListShadow.slice(i, i + this.pageSize));
        }
        this.renderListPaged = list;
        (_this$renderList = this.renderList).splice.apply(_this$renderList, [0, this.renderList.length].concat(_toConsumableArray(this.renderListPaged[this.curPage - 1] || [])));
      },
      pageChange: function pageChange(page) {
        var _this$renderList2;
        this.curPage = page;
        (_this$renderList2 = this.renderList).splice.apply(_this$renderList2, [this.renderList.length, 0].concat(_toConsumableArray(this.renderListPaged[this.curPage - 1])));
        this.showScrollLoading = false;
      },
      scrollHandler: function scrollHandler(e) {
        var _this4 = this;
        if (this.showScrollLoading || this.isBeforeDestroy) {
          return;
        }
        var scrollContainer = this.$refs.selectorList;
        if (scrollContainer.scrollTop === 0) {
          return;
        }
        if (scrollContainer.scrollTop + scrollContainer.offsetHeight >= scrollContainer.scrollHeight) {
          var curPage = ++this.curPage;
          if (curPage <= this.totalPage) {
            this.showScrollLoading = true;
            setTimeout( _asyncToGenerator( regenerator.mark(function _callee() {
              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return _this4.pageChange(curPage);
                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })), 500);
          }
        }
      },
      transitionAfterLeave: function transitionAfterLeave() {
        var _this$renderList3;
        (_this$renderList3 = this.renderList).splice.apply(_this$renderList3, [0, this.renderList.length].concat([]));
      },
      activeClass: function activeClass(data, i) {
        var style = {
          'bk-selector-actived': false,
          'bk-selector-selected': this.localTagList.includes(data[this.saveKey])
        };
        if (this.useGroup) {
          style['bk-selector-actived'] = data.index === this.focusItemIndex;
        } else {
          style['bk-selector-actived'] = i === this.focusItemIndex;
        }
        return style;
      },
      getSiteInfo: function getSiteInfo() {
        var res = {
          index: 0,
          temp: []
        };
        var nodes = this.$refs.tagList.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (!(node.nodeType === 3 && !/\S/.test(node.nodeValue))) {
            res.temp.push(node);
          }
        }
        if (this.isSingleSelect) {
          res.index = 0;
        } else {
          keys$1(res.temp).forEach(function (key) {
            if (res.temp[key].id === 'staffInput') {
              res.index = key;
            }
          });
        }
        return res;
      },
      getInputIndex: function getInputIndex() {
        var nodes = this.$refs.tagList.childNodes;
        var index = -1;
        for (var i = 0; i < nodes.length; i++) {
          var currentNode = nodes[i];
          if (currentNode.getAttribute && currentNode.getAttribute('role') === 'input') {
            index = i;
          }
        }
        return index;
      },
      formatGroupList: function formatGroupList() {
        var _this5 = this;
        var allList = [];
        this.list.forEach(function (item) {
          if (item.children) {
            item.children.forEach(function (child) {
              var params = _objectSpread({}, child);
              params.group = {
                groupId: item[_this5.saveKey],
                groupName: item[_this5.displayKey]
              };
              allList.push(params);
            });
          }
        });
        return allList;
      },
      getData: function getData() {
        var _this6 = this;
        this.tagList = [];
        this.localTagList = [];
        this.initData = [];
        if (this.useGroup) {
          this.allList = this.formatGroupList();
          this.allList.forEach(function (item) {
            _this6.initData.push(item);
          });
        } else {
          this.list.forEach(function (item) {
            _this6.initData.push(item);
          });
        }
        if (this.value.length) {
          this.value.forEach(function (tag) {
            var val = _this6.initData.find(function (val) {
              return tag === val[_this6.saveKey];
            });
            if (val !== undefined) {
              _this6.localTagList.push(val);
              _this6.tagList.push(val[_this6.saveKey]);
            } else if (_this6.allowCreate && !_this6.tagList.includes(tag)) {
              var _temp;
              var temp = (_temp = {}, _defineProperty(_temp, _this6.saveKey, tag), _defineProperty(_temp, _this6.displayKey, tag), _temp);
              _this6.localTagList.splice(_this6.localTagList.length, 0, temp);
              _this6.tagList.splice(_this6.tagList.length, 0, tag);
            }
          });
          if (!this.isSingleSelect) {
            this.initData = this.initData.filter(function (val) {
              return !_this6.value.includes(val[_this6.saveKey]);
            });
          }
        }
        if (this.trigger === 'focus') {
          this.filterData();
        }
      },
      selectTag: function selectTag(event, tag) {
        if (this.disabled) {
          return;
        }
        this.insertAfter(this.$refs.staffInput, event.currentTarget);
        this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
      },
      handleInput: function handleInput(event) {
        if (this.maxData === -1 || this.maxData > this.tagList.length) {
          var value = event.target.value;
          var charLen = this.getCharLength(value);
          this.cacheVal = value;
          if (charLen) {
            this.isCanRemoveTag = false;
            this.filterData(value);
            this.$refs.input.style.width = charLen * this.INPUT_MIN_WIDTH + 'px';
          } else {
            this.isCanRemoveTag = true;
            if (this.trigger === 'focus') {
              this.filterData();
            }
          }
        } else {
          this.handleBlur();
          this.curInputValue = '';
          this.showList = false;
        }
        this.isEdit = true;
        this.focusItemIndex = this.allowCreate ? -1 : 0;
      },
      handleFocus: function handleFocus(event) {
        this.isCanRemoveTag = true;
        this.dispatch('bk-form-item', 'form-focus');
        this.popoverWidth = this.isSingleSelect ? this.bkTagSelector.clientWidth : this.contentWidth;
        event.currentTarget.select();
      },
      handlePaste: function handlePaste(event) {
        var _this7 = this;
        if (this.isSingleSelect) {
          return false;
        }
        event.preventDefault();
        var value = event.clipboardData.getData('text');
        var valArr = this.pasteFn ? this.pasteFn(value) : this.defaultPasteFn(value);
        var tags = [];
        valArr.map(function (val) {
          return tags.push(val[_this7.saveKey]);
        });
        if (tags.length) {
          var nodes = this.$refs.tagList.childNodes;
          var result = this.getSiteInfo();
          var localTags = [];
          var localInitDara = [];
          this.initData.map(function (data) {
            localInitDara.push(data[_this7.saveKey]);
          });
          tags = tags.filter(function (tag) {
            return tag && tag.trim() && !_this7.tagList.includes(tag) && localInitDara.includes(tag);
          });
          if (this.maxData !== -1) {
            if (this.tagList.length < this.maxData) {
              var differ = this.maxData - this.tagList.length;
              if (tags.length > differ) {
                tags = _toConsumableArray(tags.slice(0, differ));
              }
            } else {
              tags = [];
            }
          }
          tags.map(function (tag) {
            var temp = {};
            temp[_this7.saveKey] = tag;
            temp[_this7.displayKey] = tag;
            localTags.push(temp);
          });
          if (tags.length) {
            var _this$tagList, _this$localTagList;
            (_this$tagList = this.tagList).splice.apply(_this$tagList, [result.index, 0].concat(_toConsumableArray(tags)));
            (_this$localTagList = this.localTagList).splice.apply(_this$localTagList, [result.index, 0].concat(localTags));
            var site = nodes[_parseInt$2(result.index)];
            this.insertAfter(this.$refs.staffInput, site);
            this.focusInputer();
            this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
            this.initData = this.initData.filter(function (val) {
              return !tags.includes(val[_this7.saveKey]);
            });
            this.handlerChange('select');
          }
        }
      },
      defaultPasteFn: function defaultPasteFn(val) {
        var _this8 = this;
        var target = [];
        var textArr = val.split(';');
        textArr.map(function (item) {
          if (item.match(/^[a-zA-Z][a-zA-Z_]+/g)) {
            var finalItem = item.match(/^[a-zA-Z][a-zA-Z_]+/g).join('');
            var temp = {};
            temp[_this8.saveKey] = finalItem;
            temp[_this8.displayKey] = finalItem;
            target.push(temp);
          }
        });
        return target;
      },
      updateScrollTop: function updateScrollTop() {
        var _this9 = this;
        var panelObj = this.$refs.selectorList;
        var panelInfo = {
          height: panelObj.clientHeight,
          yAxis: panelObj.getBoundingClientRect().y
        };
        this.$nextTick(function () {
          var activeObj = _this9.$refs.selectorList.querySelector('.bk-selector-actived');
          if (!activeObj) {
            return;
          }
          var activeInfo = {
            height: activeObj.clientHeight,
            yAxis: activeObj.getBoundingClientRect().y
          };
          if (activeInfo.yAxis < panelInfo.yAxis) {
            var currentScTop = panelObj.scrollTop;
            panelObj.scrollTop = currentScTop - (panelInfo.yAxis - activeInfo.yAxis);
          }
          var distanceToBottom = activeInfo.yAxis + activeInfo.height - panelInfo.yAxis;
          if (distanceToBottom > panelInfo.height) {
            var _currentScTop = panelObj.scrollTop;
            panelObj.scrollTop = _currentScTop + distanceToBottom - panelInfo.height;
          }
        });
      },
      handleKeydown: function handleKeydown(event) {
        if (this.showScrollLoading) {
          return;
        }
        var target;
        var val = event.target.value;
        var valLen = this.getCharLength(val);
        var result = this.getSiteInfo();
        var inputIndex = this.getInputIndex();
        var nodes = this.$refs.tagList.childNodes;
        switch (event.code) {
          case 'ArrowUp':
            event.preventDefault();
            if (!this.showList) {
              return;
            }
            this.focusItemIndex--;
            this.focusItemIndex = this.focusItemIndex < 0 ? -1 : this.focusItemIndex;
            if (this.focusItemIndex === -1) {
              this.focusItemIndex = this.renderList.length - 1;
            }
            this.updateScrollTop();
            break;
          case 'ArrowDown':
            event.preventDefault();
            if (!this.showList) {
              return;
            }
            this.focusItemIndex++;
            this.focusItemIndex = this.focusItemIndex > this.renderList.length - 1 ? this.renderList.length : this.focusItemIndex;
            if (this.focusItemIndex === this.renderList.length) {
              this.focusItemIndex = 0;
            }
            this.updateScrollTop();
            break;
          case 'ArrowLeft':
            this.isEdit = true;
            if (!valLen) {
              if (inputIndex < 1) {
                return;
              }
              this.$refs.tagList.insertBefore(this.$refs.staffInput, nodes[inputIndex - 1]);
              this.$refs.input.value = '';
              this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
              this.focusInputer();
            }
            break;
          case 'ArrowRight':
            this.isEdit = true;
            if (!valLen) {
              if (inputIndex === nodes.length - 1) {
                return;
              }
              this.insertAfter(this.$refs.staffInput, nodes[inputIndex + 1]);
              this.focusInputer();
            }
            break;
          case 'Enter':
          case 'NumpadEnter':
            if (!this.allowCreate && this.showList || this.allowCreate && this.focusItemIndex >= 0 && this.showList) {
              this.handlerResultSelect(this.renderList[this.focusItemIndex], 'select');
              this.showList = false;
            } else if (this.allowCreate) {
              event.preventDefault();
              var tag = this.curInputValue;
              this.handlerResultSelect(tag, 'custom');
            }
            this.cacheVal = '';
            event.preventDefault();
            break;
          case 'Backspace':
            if (_parseInt$2(result.index, 10) !== 0 && !this.curInputValue.length) {
              target = this.localTagList[result.index - 1];
              this.backspaceHandler(result.index, target);
            }
            break;
          default:
            break;
        }
      },
      handlerResultSelect: function handlerResultSelect(item, type) {
        if (!item || item.disabled) {
          return;
        }
        if (this.isSingleSelect) {
          this.clearSingleCache();
        }
        this.addTag(item, type);
        this.handlerChange('select');
        this.clearInput();
        this.showList = false;
      },
      backspaceHandler: function backspaceHandler(index, target) {
        var _this10 = this;
        if (!this.curInputValue) {
          if (this.isCanRemoveTag) {
            this.tagList.splice(index - 1, 1);
            this.localTagList.splice(index - 1, 1);
            var nodes = this.$refs.tagList.childNodes;
            var result = this.getSiteInfo();
            var key = _parseInt$2(result.index, 10) === 1 ? 1 : _parseInt$2(result.index, 10) - 2;
            var site = nodes[key];
            this.insertAfter(this.$refs.staffInput, site);
            this.focusInputer();
            var localList = this.useGroup ? this.allList : this.list;
            var isExistInit = localList.some(function (item) {
              return item === target[_this10.saveKey];
            });
            if ((this.allowCreate && isExistInit || !this.allowCreate) && !this.isSingleSelect) {
              this.initData.push(target);
            }
            this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
            this.handlerChange('remove');
          }
          this.isCanRemoveTag = true;
        }
      },
      handlerTagRemove: function handlerTagRemove(data, index) {
        this.removeTag(data, index);
        this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
        this.resetInput();
        this.handlerChange('remove');
      },
      removeTag: function removeTag(data, index) {
        var _this11 = this;
        this.tagList.splice(index, 1);
        this.localTagList.splice(index, 1);
        var localList = this.useGroup ? this.allList : this.list;
        var isExistInit = localList.some(function (item) {
          return item === data[_this11.saveKey];
        });
        if ((this.allowCreate && isExistInit || !this.allowCreate) && !this.isSingleSelect) {
          this.initData.push(data);
        }
      },
      addTag: function addTag(item, type) {
        var _this12 = this;
        var nodes = this.$refs.tagList.childNodes;
        var result = this.getSiteInfo();
        var isSelected = false;
        var tags = [];
        var newVal;
        if (type === 'custom') {
          if (this.separator) {
            var localTags = [];
            tags = item.split(this.separator);
            tags = tags.filter(function (tag) {
              var validate = typeof _this12.createTagValidator === 'function' ? _this12.createTagValidator(tag) : true;
              return tag && tag.trim() && !_this12.tagList.includes(tag) && validate;
            });
            tags.forEach(function (tag) {
              var temp = {};
              temp[_this12.saveKey] = tag;
              temp[_this12.displayKey] = tag;
              localTags.push(temp);
            });
            if (tags.length) {
              var _this$tagList2, _this$localTagList2;
              (_this$tagList2 = this.tagList).splice.apply(_this$tagList2, [result.index, 0].concat(_toConsumableArray(tags)));
              (_this$localTagList2 = this.localTagList).splice.apply(_this$localTagList2, [result.index, 0].concat(localTags));
              isSelected = true;
            }
          } else {
            if (_typeof(item) === 'object') {
              newVal = item[this.saveKey];
              var validate = typeof this.createTagValidator === 'function' ? this.createTagValidator(newVal) : true;
              if (newVal && !this.tagList.includes(newVal) && validate) {
                newVal = newVal.replace(/\s+/g, '');
                if (newVal !== undefined) {
                  this.tagList.splice(result.index, 0, newVal);
                  this.localTagList.splice(result.index, 0, item);
                  isSelected = true;
                }
              }
            } else {
              var localItem = {};
              newVal = item.trim();
              localItem[this.saveKey] = newVal;
              localItem[this.displayKey] = newVal;
              var _validate = typeof this.createTagValidator === 'function' ? this.createTagValidator(newVal) : true;
              if (newVal !== undefined && !this.tagList.includes(newVal) && _validate) {
                this.tagList.splice(result.index, 0, newVal);
                this.localTagList.splice(result.index, 0, localItem);
                isSelected = true;
              }
            }
          }
        } else if (item) {
          newVal = item[this.saveKey];
          if (newVal !== undefined && !this.tagList.includes(newVal)) {
            this.tagList.splice(result.index, 0, newVal);
            this.localTagList.splice(result.index, 0, item);
            isSelected = true;
          }
        }
        if (isSelected) {
          this.$nextTick(function () {
            var site = nodes[_parseInt$2(result.index, 10) + 1];
            _this12.insertAfter(_this12.$refs.staffInput, site);
            _this12.$refs.input.style.width = _this12.INPUT_MIN_WIDTH + 'px';
            if (!_this12.isSingleSelect && _this12.allowNextFocus) {
              _this12.focusInputer();
            }
            if (!_this12.isSingleSelect) {
              _this12.initData = _this12.initData.filter(function (val) {
                return !_this12.tagList.includes(val[_this12.saveKey]);
              });
            }
          });
        }
      },
      handlerChange: function handlerChange(type) {
        this.$emit('input', this.tagList);
        this.$emit('change', this.tagList);
        this.dispatch('bk-form-item', 'form-change');
        this.$emit(type);
        this.$emit('update:tags', this.tagList);
      },
      clearInput: function clearInput() {
        this.curInputValue = '';
        this.cacheVal = '';
      },
      handleBlur: function handleBlur(inputValue) {
        var _this13 = this;
        this.timer = setTimeout(function () {
          var inputValue = _this13.curInputValue;
          _this13.clearInput();
          _this13.dispatch('bk-form-item', 'form-blur');
          _this13.isEdit = false;
          if (_this13.isSingleSelect) {
            var _this13$tagListCache = _slicedToArray(_this13.tagListCache, 1),
                oldVal = _this13$tagListCache[0];
            if (inputValue && inputValue === oldVal && _this13.localTagListCache.length) {
              _this13.addTag(_this13.localTagListCache[0], 'select');
            } else {
              _this13.handlerChange('remove');
            }
          } else if (_this13.allowAutoMatch && inputValue) {
            var matchItem = _this13.renderList.find(function (item) {
              return item[_this13.searchKey] === inputValue;
            });
            if (matchItem) {
              _this13.handlerResultSelect(matchItem, 'select');
            } else if (_this13.allowCreate) {
              _this13.handlerResultSelect(inputValue, 'custom');
            }
          }
          _this13.$emit('blur', inputValue, _this13.tagList);
        }, 200);
      },
      focusInputer: function focusInputer(event) {
        var _this14 = this;
        if (this.disabled) {
          return;
        }
        if (event && event.target) {
          var className = event.target.className;
          if (className.indexOf('bk-tag-input') > -1 || className.indexOf('tag-list') > -1) {
            this.curInputValue = this.cacheVal;
            this.$refs.tagList.appendChild(this.$refs.staffInput);
          }
        }
        clearTimeout(this.timer);
        if (this.isSingleSelect && this.tagList.length) {
          this.tagListCache = _toConsumableArray(this.tagList);
          this.localTagListCache = _toConsumableArray(this.localTagList);
          this.curInputValue = this.localTagListCache[0][this.saveKey];
          this.removeTag(this.localTagList[0], 0);
          this.handleInput({
            target: {
              value: this.curInputValue
            }
          });
        }
        this.isEdit = true;
        this.$nextTick(function () {
          _this14.$refs.input.focus();
          if (_this14.trigger === 'focus') {
            _this14.showList = true;
            _this14.filterData();
            _this14.showPopover();
          }
        });
      },
      clearSingleCache: function clearSingleCache() {
        this.tagListCache = [];
        this.localTagListCache = [];
        this.tagList = [];
        this.localTagList = [];
      },
      insertAfter: function insertAfter(newElement, targetElement) {
        if (newElement.nextSibling === newElement) {
          return false;
        }
        targetElement.parentNode.insertBefore(newElement, targetElement ? targetElement.nextSibling : null);
      },
      resetInput: function resetInput() {
        var nodes = this.$refs.tagList.childNodes;
        var result = this.getSiteInfo();
        if (result.index !== result.temp.length) {
          this.clearInput();
          var site = nodes[nodes.length - 1];
          this.insertAfter(this.$refs.staffInput, site);
        }
      }
    }
  };

  var __vue_script__$13 = script$13;
  /* template */

  var __vue_render__$15 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "bkTagSelector",
      staticClass: "bk-tag-selector",
      class: _vm.extCls,
      on: {
        "click": function click($event) {
          _vm.focusInputer($event);
        },
        "mouseenter": _vm.mouseEnterHandler,
        "mouseleave": function mouseleave($event) {
          _vm.hover = false;
        }
      }
    }, [_c('div', {
      class: ['bk-tag-input', {
        'active': _vm.isEdit,
        'disabled': _vm.disabled
      }]
    }, [_c('ul', {
      ref: "tagList",
      staticClass: "tag-list",
      class: !_vm.localTagList.length ? 'no-item' : '',
      style: {
        'margin-left': _vm.leftSpace + "px"
      }
    }, [_vm._l(_vm.localTagList, function (tag, index) {
      return _c('li', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips.light",
          value: {
            boundary: 'window',
            content: tag[_vm.tooltipKey],
            disabled: !_vm.tooltipKey
          },
          expression: "{ boundary: 'window', content: tag[tooltipKey], disabled: !tooltipKey }",
          modifiers: {
            "light": true
          }
        }],
        key: tag[_vm.saveKey] !== undefined ? tag[_vm.saveKey] : index,
        staticClass: "key-node",
        on: {
          "click": function click($event) {
            _vm.selectTag($event, tag);
          }
        }
      }, [_c('tag-render', {
        attrs: {
          "node": tag,
          "display-key": _vm.displayKey,
          "tpl": _vm.tagTpl
        }
      }), !_vm.disabled && _vm.hasDeleteIcon ? _c('i', {
        staticClass: "bk-icon icon-close remove-key",
        on: {
          "click": function click($event) {
            $event.stopPropagation();

            _vm.handlerTagRemove(tag, index);
          }
        }
      }) : _vm._e()], 1);
    }), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isEdit,
        expression: "isEdit"
      }],
      ref: "staffInput",
      staticClass: "staff-input",
      attrs: {
        "id": "staffInput",
        "role": "input"
      }
    }, [!_vm.disabled ? _c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: _vm.curInputValue,
        expression: "curInputValue"
      }],
      ref: "input",
      staticClass: "input",
      attrs: {
        "type": "text"
      },
      domProps: {
        "value": _vm.curInputValue
      },
      on: {
        "input": [function ($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.curInputValue = $event.target.value;
        }, _vm.handleInput],
        "focus": _vm.handleFocus,
        "paste": _vm.handlePaste,
        "blur": function blur($event) {
          _vm.handleBlur(_vm.curInputValue);
        },
        "keydown": _vm.handleKeydown
      }
    }) : _vm._e()])], 2), _c('p', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.isEdit && !_vm.localTagList.length && !_vm.curInputValue.length,
        expression: "!isEdit && !localTagList.length && !curInputValue.length"
      }],
      staticClass: "placeholder"
    }, [_vm._v(_vm._s(_vm.defaultPlaceholder))]), _vm.isShowClear ? _c('i', {
      staticClass: "bk-icon icon-close-circle-shape clear-icon",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.handlerClear($event);
        }
      }
    }) : _vm._e()]), _c('bk-popover', {
      ref: "tagInputDropdown",
      staticClass: "bk-select-dropdown",
      attrs: {
        "placement": "bottom-start",
        "trigger": "manual",
        "theme": "light bk-select-dropdown"
      }
    }, [_c('div', {
      staticClass: "bk-tag-popover-trigger"
    }), _c('div', {
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [_vm.showList ? _c('div', {
      staticClass: "bk-selector-list",
      style: {
        'width': _vm.popoverWidth + "px"
      }
    }, [_vm.useGroup ? [_c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: keys$1(_vm.resultList).length,
        expression: "Object.keys(resultList).length"
      }],
      ref: "selectorList",
      staticClass: "outside-ul",
      style: {
        'max-height': _vm.contentMaxHeight + "px"
      }
    }, [_vm._l(_vm.resultList, function (group, key) {
      return _c('li', {
        key: key,
        staticClass: "bk-selector-group-item"
      }, [_c('span', {
        staticClass: "group-name"
      }, [_vm._v(_vm._s(group.name) + " (" + _vm._s(group.children.length) + ")")]), _c('ul', {
        staticClass: "bk-selector-group-list-item"
      }, _vm._l(group.children, function (data, index) {
        return _c('li', {
          key: index,
          class: ['bk-selector-list-item', {
            disabled: data.disabled
          }, _vm.activeClass(data, index)],
          on: {
            "mousedown": function mousedown($event) {
              _vm.handlerResultSelect(data, 'select');
            }
          }
        }, [_c('list-render', {
          attrs: {
            "node": data,
            "display-key": _vm.displayKey,
            "tpl": _vm.tpl,
            "search-key": _vm.searchKey,
            "search-keyword": _vm.curInputValue
          }
        })], 1);
      }), 0)]);
    }), _vm.showScrollLoading ? _c('li', {
      staticClass: "bk-selector-list-item"
    }, [_c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: true,
          size: 'mini',
          theme: 'black'
        },
        expression: "{ isLoading: true, size: 'mini', theme: 'black' }"
      }],
      staticClass: "loading"
    })]) : _vm._e()], 2)] : [_c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.resultList.length,
        expression: "resultList.length"
      }],
      ref: "selectorList",
      staticClass: "outside-ul",
      style: {
        'max-height': _vm.contentMaxHeight + "px"
      }
    }, [_vm._l(_vm.resultList, function (data, index) {
      return _c('li', {
        key: index,
        class: ['bk-selector-list-item', {
          disabled: data.disabled
        }, _vm.activeClass(data, index)],
        on: {
          "click": function click($event) {
            _vm.handlerResultSelect(data, 'select');
          }
        }
      }, [_c('list-render', {
        attrs: {
          "node": data,
          "display-key": _vm.displayKey,
          "tpl": _vm.tpl,
          "search-key": _vm.searchKey,
          "search-keyword": _vm.curInputValue
        }
      })], 1);
    }), _vm.showScrollLoading ? _c('li', {
      staticClass: "bk-selector-list-item"
    }, [_c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: true,
          size: 'mini',
          theme: 'black'
        },
        expression: "{ isLoading: true, size: 'mini', theme: 'black' }"
      }],
      staticClass: "loading"
    })]) : _vm._e()], 2)]], 2) : _vm._e()])])], 1);
  };

  var __vue_staticRenderFns__$15 = [];
  /* style */

  var __vue_inject_styles__$15 = undefined;
  /* scoped */

  var __vue_scope_id__$15 = undefined;
  /* module identifier */

  var __vue_module_identifier__$15 = undefined;
  /* functional template */

  var __vue_is_functional_template__$15 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$15 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$15,
    staticRenderFns: __vue_staticRenderFns__$15
  }, __vue_inject_styles__$15, __vue_script__$13, __vue_scope_id__$15, __vue_is_functional_template__$15, __vue_module_identifier__$15, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$15);

  var bkTimePicker = {
    name: 'bk-time-picker',
    mixins: [__vue_component__$j, timeMixins],
    components: {
      TimePickerPanel: __vue_component__$p,
      RangeTimePickerPanel: __vue_component__$s
    },
    props: {
      type: {
        type: String,
        default: 'time',
        validator: function validator(value) {
          if (['time', 'timerange'].indexOf(value) < 0) {
            console.error("type property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      panel: function panel() {
        var isRange = this.type === 'timerange';
        return isRange ? 'RangeTimePickerPanel' : 'TimePickerPanel';
      },
      ownPickerProps: function ownPickerProps() {
        return {
          disabledHours: this.disabledHours,
          disabledMinutes: this.disabledMinutes,
          disabledSeconds: this.disabledSeconds,
          hideDisabledOptions: this.hideDisabledOptions
        };
      }
    },
    watch: {
      visible: function visible(_visible) {
        var _this = this;
        if (_visible) {
          this.$nextTick(function () {
            var spinners = findChildComponents(_this, 'TimeSpinner');
            spinners.forEach(function (instance) {
              return instance.updateScroll();
            });
          });
        }
      }
    }
  };

  setInstaller(bkTimePicker);

  var script$14 = {
    name: 'bk-timeline',
    components: {
      vnodeIcon: {
        functional: true,
        render: function render(h, ctx) {
          return ctx.props.icon;
        }
      }
    },
    props: {
      list: {
        type: Array,
        required: true
      },
      titleAble: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        colorReg: /default|primary|warning|success|danger/
      };
    },
    methods: {
      toggle: function toggle(item) {
        this.$emit('select', item);
      },
      makeClass: function makeClass(item) {
        var _ref;
        var classPrefix = 'bk-timeline-item-';
        var classNames = [(_ref = {}, _defineProperty(_ref, "".concat(classPrefix, "filled"), item.filled), _defineProperty(_ref, "".concat(classPrefix, "custom-icon"), this.isCustomIcon(item.icon)), _ref)];
        var dotColors = ['blue', 'red', 'green', 'yellow', 'gray'];
        if (item.size) {
          classNames.push("".concat(classPrefix).concat(item.size));
        }
        if (dotColors.includes(item.color)) {
          classNames.push("".concat(classPrefix).concat(item.color));
        }
        if (item.type && this.colorReg.test(item.type)) {
          classNames.push("".concat(classPrefix).concat(item.type));
        }
        return classNames;
      },
      isNode: function isNode(data) {
        if (isVNode(data.content)) {
          return true;
        } else {
          return false;
        }
      },
      nodeContent: function nodeContent(data, index) {
        this.$slots["nodeContent".concat(index)] = [data.content];
      },
      isBuiltinIcon: function isBuiltinIcon(icon) {
        return typeof icon === 'string';
      },
      isVNodeIcon: function isVNodeIcon(icon) {
        return isVNode(icon);
      },
      isCustomIcon: function isCustomIcon(icon) {
        return this.isBuiltinIcon(icon) || this.isVNodeIcon(icon);
      },
      computedTitle: function computedTitle(str) {
        return this.titleAble ? str.replace(/<[^>]+>/g, '') : '';
      }
    }
  };

  /* script */
  var __vue_script__$14 = script$14;
  /* template */

  var __vue_render__$16 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('ul', {
      staticClass: "bk-timeline",
      class: _vm.extCls
    }, _vm._l(_vm.list, function (item, index) {
      return _c('li', {
        key: index,
        staticClass: "bk-timeline-dot",
        class: _vm.makeClass(item)
      }, [_vm.isCustomIcon(item.icon) ? _c('div', {
        staticClass: "bk-timeline-icon"
      }, [_c('span', {
        staticClass: "bk-timeline-icon-inner"
      }, [_vm.isBuiltinIcon(item.icon) ? _c('i', {
        class: ['bk-icon', "icon-" + item.icon]
      }) : _vm.isVNodeIcon(item.icon) ? _c('vnode-icon', {
        attrs: {
          "icon": item.icon
        }
      }) : _vm._e()], 1)]) : _vm._e(), _c('div', {
        staticClass: "bk-timeline-section"
      }, [_vm._t("title" + index, [item.tag !== '' ? _c('div', {
        class: ['bk-timeline-title', {
          'has-event': !!_vm.$listeners['select']
        }],
        domProps: {
          "innerHTML": _vm._s(item.tag)
        },
        on: {
          "click": function click($event) {
            _vm.toggle(item);
          }
        }
      }) : _vm._e()], null, item), item.content ? _c('div', {
        staticClass: "bk-timeline-content"
      }, [_vm.isNode(item) ? [_vm._t('nodeContent' + index, [_vm._v(_vm._s(_vm.nodeContent(item, index)))])] : [_c('div', {
        attrs: {
          "title": _vm.computedTitle(item.content)
        },
        domProps: {
          "innerHTML": _vm._s(item.content)
        }
      })]], 2) : _vm._e()], 2)]);
    }), 0);
  };

  var __vue_staticRenderFns__$16 = [];
  /* style */

  var __vue_inject_styles__$16 = undefined;
  /* scoped */

  var __vue_scope_id__$16 = undefined;
  /* module identifier */

  var __vue_module_identifier__$16 = undefined;
  /* functional template */

  var __vue_is_functional_template__$16 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$16 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$16,
    staticRenderFns: __vue_staticRenderFns__$16
  }, __vue_inject_styles__$16, __vue_script__$14, __vue_scope_id__$16, __vue_is_functional_template__$16, __vue_module_identifier__$16, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$16);

  var script$15 = {
    name: 'bk-transfer',
    components: {
      bkInput: __vue_component__$A
    },
    directives: {
      bkOverflowTips: overflowTips
    },
    mixins: [locale.mixin],
    props: {
      title: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      emptyContent: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      displayKey: {
        type: String,
        default: 'value'
      },
      settingKey: {
        type: String,
        default: 'id'
      },
      sortKey: {
        type: String,
        default: ''
      },
      sourceList: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      targetList: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      hasHeader: {
        type: Boolean,
        default: false
      },
      sortable: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      },
      searchPlaceholder: {
        type: String,
        default: ''
      },
      searchable: {
        type: Boolean,
        default: false
      },
      showOverflowTips: Boolean
    },
    data: function data() {
      return {
        dataList: [],
        hasSelectedList: [],
        sortList: [],
        leftHoverIndex: -1,
        rightHoverIndex: -1,
        slot: {},
        sortCode: this.sortKey,
        isSortFlag: this.sortable,
        keyword: ''
      };
    },
    computed: {
      typeFlag: function typeFlag() {
        if (!this.sourceList || !isArray$1(this.sourceList)) {
          return 'empty';
        }
        var str = this.sourceList.toString();
        if (str.indexOf('[object Object]') !== -1) {
          return true;
        }
        return false;
      },
      displayDataList: function displayDataList() {
        var _this = this;
        if (this.keyword) {
          var displayCode = this.displayCode;
          return this.dataList.filter(function (item) {
            return !isEmpty(item[displayCode]) && String(item[displayCode]).indexOf(_this.keyword) > -1;
          });
        }
        return this.dataList;
      },
      displayCode: function displayCode() {
        if (!this.typeFlag) {
          return 'value';
        }
        return this.displayKey;
      },
      settingCode: function settingCode() {
        if (!this.typeFlag) {
          return 'index';
        }
        return this.settingKey;
      }
    },
    watch: {
      sourceList: {
        handler: function handler(value) {
          if (this.typeFlag !== 'empty') {
            this.initData();
            this.initSort();
          }
        },
        deep: true
      },
      targetList: {
        handler: function handler(value) {
          this.initData();
          this.initSort();
        },
        deep: true
      },
      displayCode: function displayCode(value) {
        this.initData();
      },
      settingCode: function settingCode(value) {
        this.initData();
      },
      sortKey: function sortKey(value) {
        this.sortCode = value;
        this.initSort();
      },
      sortable: function sortable(value) {
        this.isSortFlag = value;
        this.initSort();
      }
    },
    created: function created() {
      if (this.typeFlag !== 'empty') {
        if (!this.typeFlag) {
          this.generalInit();
        } else {
          this.init();
        }
        this.initSort();
      }
      this.slot = _extends({}, this.$slots);
    },
    methods: {
      initData: function initData() {
        if (this.typeFlag !== 'empty') {
          if (!this.typeFlag) {
            this.generalInit();
          } else {
            this.init();
          }
        }
      },
      generalInit: function generalInit() {
        if (!this.targetList.length || this.targetList.length > this.sourceList.length) {
          var _this$hasSelectedList;
          var list = [];
          for (var i = 0; i < this.sourceList.length; i++) {
            list.push({
              index: i,
              value: this.sourceList[i]
            });
          }
          this.dataList = [].concat(list);
          (_this$hasSelectedList = this.hasSelectedList).splice.apply(_this$hasSelectedList, [0, this.hasSelectedList.length].concat([]));
          this.$emit('change', this.dataList, [], []);
        } else {
          var _list = [];
          var valueList = [];
          for (var _i = 0; _i < this.sourceList.length; _i++) {
            _list.push({
              index: _i,
              value: this.sourceList[_i]
            });
          }
          for (var j = 0; j < _list.length; j++) {
            for (var k = 0; k < this.targetList.length; k++) {
              if (_list[j].value === this.targetList[k]) {
                valueList.push(_list[j]);
              }
            }
          }
          this.hasSelectedList = [].concat(valueList);
          var result = _list.filter(function (item1) {
            return valueList.every(function (item2) {
              return item2['index'] !== item1['index'];
            });
          });
          this.dataList = _toConsumableArray(result);
          this.$emit('change', this.dataList, _toConsumableArray(this.generalListHandler(this.hasSelectedList)), []);
        }
      },
      init: function init() {
        var _this2 = this;
        if (!this.targetList.length || this.targetList.length > this.sourceList.length) {
          this.dataList = _toConsumableArray(this.sourceList);
          this.hasSelectedList = [];
          this.$emit('change', this.dataList, [], []);
        } else {
          var result = this.sourceList.filter(function (item1) {
            return _this2.targetList.every(function (item2) {
              return item2 !== item1[_this2.settingCode];
            });
          });
          var hasTempList = [];
          this.sourceList.forEach(function (item1) {
            _this2.targetList.forEach(function (item2) {
              if (item1[_this2.settingCode] === item2) {
                hasTempList.push(item1);
              }
            });
          });
          this.hasSelectedList = [].concat(hasTempList);
          this.dataList = _toConsumableArray(result);
          var list = _toConsumableArray(this.sourceListHandler(this.hasSelectedList));
          this.$emit('change', this.dataList, this.hasSelectedList, list);
        }
      },
      generalListHandler: function generalListHandler(list) {
        var templateList = [];
        if (!list.length) {
          return [];
        } else {
          var dataList = _toConsumableArray(list);
          dataList.forEach(function (item) {
            templateList.push(item.value);
          });
          return templateList;
        }
      },
      sourceListHandler: function sourceListHandler(list) {
        var _this3 = this;
        var templateList = [];
        if (!list.length) {
          return [];
        } else {
          var dataList = _toConsumableArray(list);
          dataList.forEach(function (item) {
            for (var key in item) {
              if (key === _this3.settingCode) {
                templateList.push(item[key]);
              }
            }
          });
          return templateList;
        }
      },
      initSort: function initSort() {
        var _this4 = this;
        var templateList = [];
        if (!this.typeFlag) {
          if (this.isSortFlag) {
            this.sortCode = 'index';
          } else {
            this.sortCode = '';
          }
          for (var k = 0; k < this.sourceList.length; k++) {
            templateList.push({
              index: k,
              value: this.sourceList[k]
            });
          }
        } else {
          if (!this.isSortFlag) {
            this.sortCode = '';
          }
          templateList = _toConsumableArray(this.sourceList);
        }
        if (this.sortCode) {
          var arr = [];
          templateList.forEach(function (item) {
            arr.push(item[_this4.sortCode]);
          });
          this.sortList = [].concat(arr);
          if (this.sortList.length === this.sourceList.length) {
            var list = _toConsumableArray(this.dataList);
            this.dataList = _toConsumableArray(this.sortDataList(list, this.sortCode, this.sortList));
          }
        }
      },
      sortDataList: function sortDataList(list, key, sortList) {
        var arr = sortList;
        return list.sort(function (a, b) {
          return arr.indexOf(a[key]) - arr.indexOf(b[key]) >= 0;
        });
      },
      removeFromDataList: function removeFromDataList(removeItem) {
        var _this5 = this;
        this.dataList = this.dataList.filter(function (item) {
          return item[_this5.settingCode] !== removeItem[_this5.settingCode];
        });
      },
      allToRight: function allToRight() {
        var _this6 = this;
        this.leftHoverIndex = -1;
        var displayDataList = this.displayDataList;
        var hasSelectedList = this.hasSelectedList;
        displayDataList.forEach(function (transferItem) {
          hasSelectedList.push(transferItem);
          _this6.removeFromDataList(transferItem);
        });
        if (this.sortList.length === this.sourceList.length) {
          this.hasSelectedList = _toConsumableArray(this.sortDataList(hasSelectedList, this.sortCode, this.sortList));
        } else {
          this.hasSelectedList = _toConsumableArray(hasSelectedList);
        }
        if (!this.typeFlag) {
          this.$emit('change', this.dataList, _toConsumableArray(this.generalListHandler(this.hasSelectedList)), []);
        } else {
          var list = _toConsumableArray(this.sourceListHandler(this.hasSelectedList));
          this.$emit('change', this.dataList, this.hasSelectedList, list);
        }
      },
      allToLeft: function allToLeft() {
        this.rightHoverIndex = -1;
        var hasSelectedList = this.hasSelectedList;
        var dataList = this.dataList;
        while (hasSelectedList.length) {
          var transferItem = hasSelectedList.shift();
          dataList.push(transferItem);
          if (this.sortList.length === this.sourceList.length) {
            this.dataList = _toConsumableArray(this.sortDataList(dataList, this.sortCode, this.sortList));
          } else {
            this.dataList = _toConsumableArray(dataList);
          }
        }
        if (!this.typeFlag) {
          this.$emit('change', this.dataList, _toConsumableArray(this.generalListHandler(this.hasSelectedList)), []);
        } else {
          var list = _toConsumableArray(this.sourceListHandler(this.hasSelectedList));
          this.$emit('change', this.dataList, this.hasSelectedList, list);
        }
      },
      leftClick: function leftClick(index) {
        this.leftHoverIndex = -1;
        var transferItem = this.displayDataList[index];
        var hasSelectedList = this.hasSelectedList;
        hasSelectedList.push(transferItem);
        this.removeFromDataList(transferItem);
        if (this.sortList.length === this.sourceList.length) {
          this.hasSelectedList = _toConsumableArray(this.sortDataList(hasSelectedList, this.sortCode, this.sortList));
        } else {
          this.hasSelectedList = _toConsumableArray(hasSelectedList);
        }
        if (!this.typeFlag) {
          this.$emit('change', this.dataList, _toConsumableArray(this.generalListHandler(this.hasSelectedList)), []);
        } else {
          var list = _toConsumableArray(this.sourceListHandler(this.hasSelectedList));
          this.$emit('change', this.dataList, this.hasSelectedList, list);
        }
      },
      rightClick: function rightClick(index) {
        this.rightHoverIndex = -1;
        var transferItem = this.hasSelectedList.splice(index, 1)[0];
        var dataList = this.dataList;
        dataList.push(transferItem);
        if (this.sortList.length === this.sourceList.length) {
          this.dataList = _toConsumableArray(this.sortDataList(dataList, this.sortCode, this.sortList));
        } else {
          this.dataList = _toConsumableArray(dataList);
        }
        if (!this.typeFlag) {
          this.$emit('change', this.dataList, _toConsumableArray(this.generalListHandler(this.hasSelectedList)), []);
        } else {
          var list = _toConsumableArray(this.sourceListHandler(this.hasSelectedList));
          this.$emit('change', this.dataList, this.hasSelectedList, list);
        }
      },
      leftMouseover: function leftMouseover(index) {
        this.leftHoverIndex = index;
      },
      leftMouseleave: function leftMouseleave(index) {
        this.leftHoverIndex = -1;
      },
      rightMouseover: function rightMouseover(index) {
        this.rightHoverIndex = index;
      },
      rightMouseleave: function rightMouseleave(index) {
        this.rightHoverIndex = -1;
      }
    }
  };

  /* script */
  var __vue_script__$15 = script$15;
  /* template */

  var __vue_render__$17 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "transfer",
      staticClass: "bk-transfer",
      class: _vm.extCls
    }, [_c('div', {
      staticClass: "source-list"
    }, [_vm.slot['left-header'] ? _c('div', {
      staticClass: "slot-header"
    }, [_c('div', {
      staticClass: "slot-content"
    }, [_vm._t("left-header")], 2)]) : _c('div', {
      staticClass: "header"
    }, [_vm._v("\n            " + _vm._s(_vm.title[0] ? _vm.title[0] : _vm.t('bk.transfer.left')) + _vm._s(_vm.t('bk.transfer.total', {
      total: _vm.dataList.length
    })) + "\n            "), _vm.dataList.length === 0 ? _c('span', {
      staticClass: "disabled"
    }, [_vm._v(_vm._s(_vm.t('bk.transfer.addAll')))]) : _c('span', {
      on: {
        "click": _vm.allToRight
      }
    }, [_vm._v(_vm._s(_vm.t('bk.transfer.addAll')))])]), _vm.searchable ? _c('bk-input', {
      staticClass: "transfer-search-input",
      attrs: {
        "clearable": true,
        "left-icon": 'bk-icon icon-search',
        "placeholder": _vm.searchPlaceholder || _vm.t('bk.transfer.searchPlaceholder')
      },
      model: {
        value: _vm.keyword,
        callback: function callback($$v) {
          _vm.keyword = $$v;
        },
        expression: "keyword"
      }
    }) : _vm._e(), _vm.displayDataList.length ? [_c('ul', {
      staticClass: "content"
    }, _vm._l(_vm.displayDataList, function (item, index) {
      return _c('li', {
        key: index,
        on: {
          "click": function click($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.leftClick(index);
          },
          "mouseover": function mouseover($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.leftMouseover(index);
          },
          "mouseleave": function mouseleave($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.leftMouseleave(index);
          }
        }
      }, [_vm._t("source-option", [_vm.showOverflowTips ? _c('span', {
        directives: [{
          name: "bk-overflow-tips",
          rawName: "v-bk-overflow-tips"
        }],
        staticClass: "content-text"
      }, [_vm._v(_vm._s(item[_vm.displayCode]))]) : _c('span', {
        staticClass: "content-text",
        attrs: {
          "title": item[_vm.displayCode]
        }
      }, [_vm._v(_vm._s(item[_vm.displayCode]))]), _c('span', {
        staticClass: "icon-wrapper",
        class: [index === _vm.leftHoverIndex ? 'hover' : '']
      }, [_c('i', {
        staticClass: "bk-icon icon-arrows-right"
      })])], null, item)], 2);
    }), 0)] : [_vm.slot['left-empty-content'] ? _c('div', [_vm._t("left-empty-content")], 2) : _c('div', {
      staticClass: "empty"
    }, [_vm._v("\n                " + _vm._s(_vm.emptyContent[0] ? _vm.emptyContent[0] : _vm.t('bk.transfer.emptyContent')) + "\n            ")])]], 2), _c('div', {
      staticClass: "transfer"
    }), _c('div', {
      staticClass: "target-list"
    }, [_vm.slot['right-header'] ? _c('div', {
      staticClass: "slot-header"
    }, [_c('div', {
      staticClass: "slot-content"
    }, [_vm._t("right-header")], 2)]) : _c('div', {
      staticClass: "header"
    }, [_vm._v("\n            " + _vm._s(_vm.title[1] ? _vm.title[1] : _vm.t('bk.transfer.right')) + _vm._s(_vm.t('bk.transfer.total', {
      total: _vm.hasSelectedList.length
    })) + "\n            "), _vm.hasSelectedList.length === 0 ? _c('span', {
      staticClass: "disabled"
    }, [_vm._v(_vm._s(_vm.t('bk.transfer.removeAll')))]) : _c('span', {
      on: {
        "click": _vm.allToLeft
      }
    }, [_vm._v(_vm._s(_vm.t('bk.transfer.removeAll')))])]), _vm.hasSelectedList.length ? [_c('ul', {
      staticClass: "content"
    }, _vm._l(_vm.hasSelectedList, function (item, index) {
      return _c('li', {
        key: index,
        on: {
          "click": function click($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.rightClick(index);
          },
          "mouseover": function mouseover($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.rightMouseover(index);
          },
          "mouseleave": function mouseleave($event) {
            $event.stopPropagation();
            $event.preventDefault();

            _vm.rightMouseleave(index);
          }
        }
      }, [_vm._t("target-option", [_vm.showOverflowTips ? _c('span', {
        directives: [{
          name: "bk-overflow-tips",
          rawName: "v-bk-overflow-tips"
        }],
        staticClass: "content-text"
      }, [_vm._v(_vm._s(item[_vm.displayCode]))]) : _c('span', {
        staticClass: "content-text",
        attrs: {
          "title": item[_vm.displayCode]
        }
      }, [_vm._v(_vm._s(item[_vm.displayCode]))]), _c('span', {
        staticClass: "icon-wrapper",
        class: [index === _vm.rightHoverIndex ? 'hover' : '']
      }, [_c('i', {
        staticClass: "bk-icon icon-close"
      })])], null, item)], 2);
    }), 0)] : [_vm.slot['right-empty-content'] ? _c('div', [_vm._t("right-empty-content")], 2) : _c('div', {
      staticClass: "empty"
    }, [_vm._v("\n                " + _vm._s(_vm.emptyContent[1] ? _vm.emptyContent[1] : _vm.t('bk.transfer.emptySelected')) + "\n            ")])]], 2)]);
  };

  var __vue_staticRenderFns__$17 = [];
  /* style */

  var __vue_inject_styles__$17 = undefined;
  /* scoped */

  var __vue_scope_id__$17 = undefined;
  /* module identifier */

  var __vue_module_identifier__$17 = undefined;
  /* functional template */

  var __vue_is_functional_template__$17 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$17 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$17,
    staticRenderFns: __vue_staticRenderFns__$17
  }, __vue_inject_styles__$17, __vue_script__$15, __vue_scope_id__$17, __vue_is_functional_template__$17, __vue_module_identifier__$17, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$17);

  var $entries = _objectToArray(true);
  _export(_export.S, 'Object', {
    entries: function entries(it) {
      return $entries(it);
    }
  });

  var entries = _core.Object.entries;

  var entries$1 = entries;

  var Render = {
    name: 'render',
    functional: true,
    props: {
      node: Object,
      tpl: Function
    },
    render: function render(h, ct) {
      var titleClass = ct.props.node.selected ? 'node-title node-selected' : 'node-title';
      if (ct.props.tpl) {
        return ct.props.tpl(ct.props.node, h);
      }
      return h("span", {
        "domProps": {
          "innerHTML": ct.props.node.name
        },
        "attrs": {
          "title": ct.props.node.title
        },
        "class": titleClass,
        "style": 'user-select: none',
        "on": {
          "click": function click() {
            return ct.parent.nodeSelected(ct.props.node);
          }
        }
      });
    }
  };

  var script$16 = {
    name: 'bk-tree',
    components: {
      Render: Render,
      CollapseTransition: CollapseTransition
    },
    mixins: [locale.mixin],
    props: {
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      parent: {
        type: Object,
        default: function _default() {
          return null;
        }
      },
      multiple: {
        type: Boolean,
        default: false
      },
      nodeKey: {
        type: String,
        default: 'id'
      },
      draggable: {
        type: Boolean,
        default: false
      },
      hasBorder: {
        type: Boolean,
        default: false
      },
      dragAfterExpanded: {
        type: Boolean,
        default: true
      },
      isDeleteRoot: {
        type: Boolean,
        default: false
      },
      emptyText: {
        type: String,
        default: ''
      },
      dragSort: {
        type: Boolean,
        default: false
      },
      openedIcon: {
        type: String,
        default: 'icon-folder-open'
      },
      closedIcon: {
        type: String,
        default: 'icon-folder'
      },
      nodeIcon: {
        type: String,
        default: 'icon-file'
      },
      showIcon: {
        type: Boolean,
        default: true
      },
      tpl: Function,
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        halfcheck: true,
        isBorder: this.hasBorder,
        bkTreeDrag: {},
        isDragSort: this.dragSort,
        isShowIcon: this.showIcon
      };
    },
    computed: {
      shownData: function shownData() {
        return this.data.filter(function (item) {
          return item.hasOwnProperty('visible') ? item.visible : true;
        });
      }
    },
    watch: {
      data: function data() {
        this.initTreeData();
      },
      hasBorder: function hasBorder(value) {
        this.isBorder = !!value;
      },
      dragSort: function dragSort(value) {
        this.isDragSort = !!value;
      },
      showIcon: function showIcon(value) {
        this.isShowIcon = !!value;
      }
    },
    mounted: function mounted() {
      var _this = this;
      this.$on('childChecked', function (node, checked) {
        if (node.children && node.children.length) {
          var _iterator = _createForOfIteratorHelper(node.children),
              _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              if (!child.disabled) {
                _this.$set(child, 'checked', checked);
              }
              _this.$emit('on-broadcast-check', child, checked);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      });
      this.$on('parentChecked', function (node, checked) {
        if (!node.parent) {
          var allChildNodeChecked = node.children.every(function (node) {
            return node.checked;
          });
          var someChildNodeChecked = (node.children.some(function (node) {
            return node.halfcheck;
          }) || node.children.some(function (node) {
            return node.checked;
          })) && !allChildNodeChecked;
          if (_this.halfcheck) {
            if (!node.disabled) {
              _this.$set(node, 'checked', allChildNodeChecked);
              _this.$set(node, 'halfcheck', someChildNodeChecked);
            }
          }
          return false;
        }
        if (!node.parent.children.filter(function (child) {
          return child[_this.nodeKey] === node[_this.nodeKey];
        }).length && !node.disabled) {
          _this.$set(node, 'checked', checked);
        }
        var allBortherNodeChecked = node.parent.children.every(function (node) {
          return node.checked;
        });
        var someBortherNodeChecked = (node.parent.children.some(function (node) {
          return node.halfcheck;
        }) || node.parent.children.some(function (node) {
          return node.checked;
        })) && !allBortherNodeChecked;
        if (_this.halfcheck) {
          if (allBortherNodeChecked) {
            _this.$set(node.parent, 'halfcheck', false);
            _this.$set(node.parent, 'checked', true);
          } else {
            if (someBortherNodeChecked) {
              _this.$set(node.parent, 'halfcheck', true);
              _this.$set(node.parent, 'checked', false);
            } else {
              _this.$set(node.parent, 'halfcheck', false);
              _this.$set(node.parent, 'checked', false);
            }
          }
          if (!checked && someBortherNodeChecked) {
            _this.$set(node.parent, 'halfcheck', true);
          }
          _this.$emit('parentChecked', node.parent, checked);
        } else {
          if (checked && allBortherNodeChecked) _this.$emit('parentChecked', node.parent, checked);
          if (!checked) _this.$emit('parentChecked', node.parent, checked);
        }
      });
      this.$on('on-broadcast-check', function (node, checked) {
        if (!node.parent && !node.children) {
          return;
        }
        _this.$emit('parentChecked', node, checked);
        _this.$emit('childChecked', node, checked);
        _this.$emit('dropTreeChecked', node, checked);
      });
      this.$on('toggleshow', function (node, isShow) {
        _this.$set(node, 'visible', isShow);
        if (isShow && node.parent) {
          _this.$emit('toggleshow', node.parent, isShow);
        }
      });
      this.$on('cancelSelected', function (root) {
        var _iterator2 = _createForOfIteratorHelper(root.$children),
            _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var child = _step2.value;
            var _iterator3 = _createForOfIteratorHelper(child.data),
                _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var node = _step3.value;
                child.$set(node, 'selected', false);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
            if (child.$children) child.$emit('cancelSelected', child);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      });
      this.initTreeData();
    },
    destroyed: function destroyed() {
      this.$delete(window, 'bkTreeDrag');
    },
    methods: {
      gid: function gid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = Math.random() * 16 | 0;
          var v = c === 'x' ? r : r & 0x3 | 0x8;
          return v.toString(16);
        });
      },
      setDragNode: function setDragNode(id, node) {
        window['bkTreeDrag'] = {};
        window['bkTreeDrag'][id] = node;
      },
      getDragNode: function getDragNode(id) {
        return window['bkTreeDrag'][id];
      },
      hasInGenerations: function hasInGenerations(root, node) {
        if (root.hasOwnProperty('children') && root.children) {
          var _iterator4 = _createForOfIteratorHelper(root.children),
              _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var rn = _step4.value;
              if (rn === node) return true;
              if (rn.children) return this.hasInGenerations(rn, node);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          return false;
        }
      },
      isDragSortHolder: function isDragSortHolder(target, node) {
        if (target.hasOwnProperty('children') && target.children) {
          var _iterator5 = _createForOfIteratorHelper(target.children),
              _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var rn = _step5.value;
              if (rn[this.nodeKey] === node[this.nodeKey]) return false;
              if (rn.children) return this.isDragSortHolder(rn, node);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          return true;
        }
      },
      setNodeIcon: function setNodeIcon(node) {
        if (node.children && node.children.length) {
          if (node.expanded) {
            return node.openedIcon || this.openedIcon;
          } else {
            return node.closedIcon || this.closedIcon;
          }
        } else {
          return node.icon || this.nodeIcon;
        }
      },
      drop: function drop(node, ev) {
        var _this2 = this;
        ev.preventDefault();
        ev.stopPropagation();
        if (!this.draggable) {
          return;
        }
        var gid = ev.dataTransfer.getData('gid');
        var drag = this.getDragNode(gid);
        if (drag.parent === node || drag.parent === null || drag === node) {
          return false;
        }
        if (this.hasInGenerations(drag, node)) {
          return false;
        }
        if (this.isDragSort) {
          if ([true, false].includes(this.isDragSortHolder(node, drag))) {
            if (!this.isDragSortHolder(node, drag)) {
              return false;
            }
          }
          var dragNodeIndex = drag.parent.children.findIndex(function (dragItem) {
            return dragItem[_this2.nodeKey] === drag[_this2.nodeKey];
          });
          var targetNodeIndex = node.parent.children.findIndex(function (targetItem) {
            return targetItem[_this2.nodeKey] === node[_this2.nodeKey];
          });
          drag.parent.children.splice(dragNodeIndex, 1, node);
          node.parent.children.splice(targetNodeIndex, 1, drag);
          node.parent.children[targetNodeIndex].parent = drag.parent;
          if (this.multiple) {
            this.$emit('on-broadcast-check', drag, drag.checked);
          }
          drag.parent.children[dragNodeIndex].parent = node.parent;
          if (this.multiple) {
            this.$emit('on-broadcast-check', node, node.checked);
          }
        } else {
          var dragHost = drag.parent.children;
          if (node.children && node.children.indexOf(drag) === -1) {
            node.children.push(drag);
            if (node.children.length && this.isShowIcon) {
              this.$set(node, 'openedIcon', this.openedIcon);
              this.$set(node, 'closedIcon', this.closedIcon);
            }
            dragHost.splice(dragHost.indexOf(drag), 1);
            if (this.isShowIcon) {
              if (drag.parent.children && drag.parent.children.length) {
                this.$set(drag.parent, 'openedIcon', this.openedIcon);
                this.$set(drag.parent, 'closedIcon', this.closedIcon);
              } else {
                this.$set(drag.parent, 'icon', this.nodeIcon);
              }
            }
            node.children[node.children.length - 1].parent = node;
          } else {
            if (this.isShowIcon) {
              this.$set(node, 'openedIcon', this.openedIcon);
              this.$set(node, 'closedIcon', this.closedIcon);
            }
            this.$set(node, 'children', [drag]);
            dragHost.splice(dragHost.indexOf(drag), 1);
          }
          this.$set(node, 'expanded', this.dragAfterExpanded);
        }
        this.$emit('on-drag-node', {
          dragNode: drag,
          targetNode: node
        });
      },
      drag: function drag(node, ev) {
        var gid = this.gid();
        this.setDragNode(gid, node);
        ev.dataTransfer.setData('gid', gid);
        ev.dataTransfer.effectAllowed = 'move';
      },
      dragover: function dragover(ev) {
        ev.preventDefault();
        ev.stopPropagation();
      },
      initTreeData: function initTreeData() {
        var _iterator6 = _createForOfIteratorHelper(this.data),
            _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var node = _step6.value;
            this.$set(node, 'parent', this.parent);
            if (node.children && node.children.length) {
              if (node.hasOwnProperty('icon')) {
                this.$delete(node, 'icon');
              }
            } else {
              if (node.hasOwnProperty('openedIcon')) {
                this.$delete(node, 'openedIcon');
              }
              if (node.hasOwnProperty('closedIcon')) {
                this.$delete(node, 'closedIcon');
              }
            }
            if (this.multiple) {
              if (node.hasOwnProperty('selected')) {
                this.$delete(node, 'selected');
              }
              if (node.hasOwnProperty('checked') && node.checked) {
                this.$emit('on-broadcast-check', node, true);
              }
            } else {
              if (node.hasOwnProperty('checked')) {
                this.$delete(node, 'checked');
              }
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      },
      expandNode: function expandNode(node) {
        this.$set(node, 'expanded', !node.expanded);
        if (node.async && !node.children) {
          this.$emit('async-load-nodes', node);
        }
        if (node.children && node.children.length) {
          this.$emit('on-expanded', node, node.expanded);
        }
      },
      onExpanded: function onExpanded(node) {
        if (node.children && node.children.length) {
          this.$emit('on-expanded', node, node.expanded);
        }
      },
      triggerExpand: function triggerExpand(item) {
        if (!item.parent || item.children && item.children.length || item.async) {
          this.expandNode(item);
        }
      },
      asyncLoadNodes: function asyncLoadNodes(node) {
        if (node.async && !node.children) {
          this.$emit('async-load-nodes', node);
        }
      },
      isLeaf: function isLeaf(node) {
        return !(node.children && node.children.length) && node.parent && !node.async;
      },
      addNode: function addNode(parent, newNode) {
        var addnode = {};
        this.$set(parent, 'expanded', true);
        if (typeof newNode === 'undefined') {
          throw new ReferenceError('newNode is required but undefined');
        }
        if (_typeof(newNode) === 'object' && !newNode.hasOwnProperty('name')) {
          throw new ReferenceError('the name property is missed');
        }
        if (_typeof(newNode) === 'object' && !newNode.hasOwnProperty(this.nodeKey)) {
          throw new ReferenceError('the nodeKey property is missed');
        }
        if (_typeof(newNode) === 'object' && newNode.hasOwnProperty('name') && newNode.hasOwnProperty(this.nodeKey)) {
          addnode = _extends({}, newNode);
        }
        if (this.isLeaf(parent)) {
          this.$set(parent, 'children', []);
          parent.children.push(addnode);
        } else {
          parent.children.push(addnode);
        }
        this.$emit('addNode', {
          parentNode: parent,
          newNode: newNode
        });
      },
      addNodes: function addNodes(parent, newChildren) {
        var _iterator7 = _createForOfIteratorHelper(newChildren),
            _step7;
        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var n = _step7.value;
            this.addNode(parent, n);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      },
      getSearchResult: function getSearchResult() {
        var list = [];
        for (var i = 0; i < this.data.length; i++) {
          var queue = [];
          queue.push(this.data[i]);
          while (queue.length) {
            var node = queue.shift();
            if (node.children && node.children.length) {
              var tempList = [];
              tempList.splice.apply(tempList, [0, 0].concat(_toConsumableArray(node.children)));
              queue.push.apply(queue, tempList);
            }
            list.push(node);
          }
        }
        return {
          results: list.filter(function (item) {
            return item.hasOwnProperty('visible') && item.visible;
          }),
          isEmpty: list.every(function (item) {
            return item.hasOwnProperty('visible') && !item.visible;
          })
        };
      },
      onClick: function onClick(node) {
        this.$emit('on-click', node);
      },
      onCheck: function onCheck(node, checked) {
        this.$emit('on-check', node, checked);
      },
      onBroadcastCheck: function onBroadcastCheck(node, checked) {
        this.$emit('on-broadcast-check', node, checked);
      },
      nodeCheckStatusChange: function nodeCheckStatusChange(node, checked) {
        this.$emit('dropTreeChecked', node, checked);
      },
      onDragNode: function onDragNode(event) {
        this.$emit('on-drag-node', event);
      },
      delNode: function delNode(parent, node) {
        if (parent === null || typeof parent === 'undefined') {
          if (this.isDeleteRoot) {
            this.data.splice(0, 1);
          } else {
            throw new ReferenceError('the root element can\'t deleted!');
          }
        } else {
          parent.children.splice(parent.children.indexOf(node), 1);
        }
        this.$emit('delNode', {
          parentNode: parent,
          delNode: node
        });
      },
      changeCheckStatus: function changeCheckStatus(node, $event) {
        this.$emit('on-check', node, $event.target.checked);
        this.$emit('on-broadcast-check', node, $event.target.checked);
      },
      nodeSelected: function nodeSelected(node) {
        var getRoot = function getRoot(el) {
          if (el.$parent.$el.nodeName === 'UL') {
            el = el.$parent;
            return getRoot(el);
          }
          return el;
        };
        var root = getRoot(this);
        if (!this.multiple) {
          var _iterator8 = _createForOfIteratorHelper(root.data || []),
              _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var rn = _step8.value;
              this.$set(rn, 'selected', false);
              this.$emit('cancelSelected', root);
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
        this.$set(node, 'selected', !node.selected);
        this.$emit('on-click', node);
      },
      nodeDataHandler: function nodeDataHandler(opt, data, keyParton) {
        data = data || this.data;
        var res = [];
        var keyValue = keyParton;
        var _iterator9 = _createForOfIteratorHelper(data),
            _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var node = _step9.value;
            for (var _i = 0, _Object$entries = entries$1(opt); _i < _Object$entries.length; _i++) {
              var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                  key = _Object$entries$_i[0],
                  value = _Object$entries$_i[1];
              if (node[key] === value) {
                if (!keyValue.length || !keyValue) {
                  var n = _extends({}, node);
                  delete n['parent'];
                  if (!(n.children && n.children.length)) {
                    res.push(n);
                  }
                } else {
                  var _n = {};
                  if (Object.prototype.toString.call(keyValue) === '[object Array]') {
                    for (var i = 0; i < keyValue.length; i++) {
                      if (node.hasOwnProperty(keyValue[i])) {
                        _n[keyValue[i]] = node[keyValue[i]];
                      }
                    }
                  }
                  if (Object.prototype.toString.call(keyValue) === '[object String]') {
                    _n[keyValue] = node[keyValue];
                  }
                  if (!(node.children && node.children.length)) {
                    res.push(_n);
                  }
                }
              }
            }
            if (node.children && node.children.length) {
              res = res.concat(this.nodeDataHandler(opt, node.children, keyValue));
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
        return res;
      },
      getNode: function getNode(keyParton) {
        if (!this.multiple) {
          return this.nodeDataHandler({
            selected: true
          }, this.data, keyParton);
        } else {
          return this.nodeDataHandler({
            checked: true
          }, this.data, keyParton);
        }
      },
      searchNode: function searchNode(filter, data) {
        data = data || this.data;
        var _iterator10 = _createForOfIteratorHelper(data),
            _step10;
        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var node = _step10.value;
            var searched = filter ? typeof filter === 'function' ? filter(node) : node['name'].indexOf(filter) > -1 : false;
            this.$set(node, 'searched', searched);
            this.$set(node, 'visible', false);
            this.$emit('toggleshow', node, filter ? searched : true);
            if (node.children && node.children.length) {
              if (searched) {
                this.$set(node, 'expanded', true);
              }
              this.searchNode(filter, node.children);
            }
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      }
    }
  };

  var __vue_script__$16 = script$16;
  /* template */

  var __vue_render__$18 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('ul', {
      staticClass: "bk-tree",
      class: [{
        'bk-has-border-tree': _vm.isBorder
      }, _vm.extCls]
    }, _vm._l(_vm.shownData, function (item, index) {
      return _c('li', {
        key: item[_vm.nodeKey] ? item[_vm.nodeKey] : item.name,
        class: {
          'leaf': _vm.isLeaf(item),
          'tree-first-node': !_vm.parent && index === 0,
          'tree-only-node': !_vm.parent && _vm.shownData.length === 1,
          'tree-second-node': !_vm.parent && index === 1,
          'single': !_vm.multiple
        },
        on: {
          "drop": function drop($event) {
            _vm.drop(item, $event);
          },
          "dragover": function dragover($event) {
            _vm.dragover($event);
          }
        }
      }, [_c('div', {
        staticClass: "tree-drag-node",
        attrs: {
          "draggable": _vm.draggable
        },
        on: {
          "dragstart": function dragstart($event) {
            _vm.drag(item, $event);
          }
        }
      }, [!item.parent || item.children && item.children.length || item.async ? _c('span', {
        class: ['bk-icon', 'tree-expanded-icon', item.expanded ? 'icon-down-shape' : 'icon-right-shape'],
        on: {
          "click": function click($event) {
            _vm.expandNode(item);
          }
        }
      }) : _vm._e(), _vm.multiple ? _c('label', {
        class: ['bk-form-checkbox', {
          'bk-form-checkbox--indeterminate': item.halfcheck
        }, {
          'bk-form-checkbox--checked': item.checked
        }, {
          'bk-form-checkbox--disabled': item.disabled
        }]
      }, [_vm.multiple ? _c('input', {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: item.checked,
          expression: "item.checked"
        }],
        attrs: {
          "type": "checkbox",
          "disabled": item.disabled
        },
        domProps: {
          "checked": isArray$1(item.checked) ? _vm._i(item.checked, null) > -1 : item.checked
        },
        on: {
          "change": [function ($event) {
            var $$a = item.checked,
                $$el = $event.target,
                $$c = $$el.checked ? true : false;

            if (isArray$1($$a)) {
              var $$v = null,
                  $$i = _vm._i($$a, $$v);

              if ($$el.checked) {
                $$i < 0 && _vm.$set(item, "checked", $$a.concat([$$v]));
              } else {
                $$i > -1 && _vm.$set(item, "checked", $$a.slice(0, $$i).concat($$a.slice($$i + 1)));
              }
            } else {
              _vm.$set(item, "checked", $$c);
            }
          }, function ($event) {
            $event.stopPropagation();

            _vm.changeCheckStatus(item, $event);
          }]
        }
      }) : _vm._e()]) : _vm._e(), _c('div', {
        staticClass: "tree-node",
        on: {
          "click": function click($event) {
            _vm.triggerExpand(item);
          }
        }
      }, [_vm.isShowIcon ? _c('span', {
        staticClass: "node-icon"
      }, [_c('i', {
        staticClass: "bk-icon",
        class: _vm.setNodeIcon(item)
      })]) : _vm._e(), item.loading && item.expanded ? _c('div', {
        staticClass: "bk-spin-loading bk-spin-loading-mini bk-spin-loading-primary loading"
      }, [_c('div', {
        staticClass: "rotate rotate1"
      }), _c('div', {
        staticClass: "rotate rotate2"
      }), _c('div', {
        staticClass: "rotate rotate3"
      }), _c('div', {
        staticClass: "rotate rotate4"
      }), _c('div', {
        staticClass: "rotate rotate5"
      }), _c('div', {
        staticClass: "rotate rotate6"
      }), _c('div', {
        staticClass: "rotate rotate7"
      }), _c('div', {
        staticClass: "rotate rotate8"
      })]) : _vm._e(), _c('Render', {
        attrs: {
          "node": item,
          "tpl": _vm.tpl
        }
      })], 1)]), _c('collapse-transition', [!_vm.isLeaf(item) ? _c('bk-tree', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: item.expanded,
          expression: "item.expanded"
        }],
        attrs: {
          "drag-after-expanded": _vm.dragAfterExpanded,
          "draggable": _vm.draggable,
          "drag-sort": _vm.dragSort,
          "tpl": _vm.tpl,
          "data": item.children,
          "halfcheck": _vm.halfcheck,
          "parent": item,
          "is-delete-root": _vm.isDeleteRoot,
          "multiple": _vm.multiple,
          "show-icon": _vm.showIcon
        },
        on: {
          "dropTreeChecked": _vm.nodeCheckStatusChange,
          "async-load-nodes": _vm.asyncLoadNodes,
          "on-expanded": _vm.onExpanded,
          "on-click": _vm.onClick,
          "on-check": _vm.onCheck,
          "on-broadcast-check": _vm.onBroadcastCheck,
          "on-drag-node": _vm.onDragNode
        }
      }) : _vm._e()], 1)], 1);
    }), 0);
  };

  var __vue_staticRenderFns__$18 = [];
  /* style */

  var __vue_inject_styles__$18 = undefined;
  /* scoped */

  var __vue_scope_id__$18 = undefined;
  /* module identifier */

  var __vue_module_identifier__$18 = undefined;
  /* functional template */

  var __vue_is_functional_template__$18 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$18 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$18,
    staticRenderFns: __vue_staticRenderFns__$18
  }, __vue_inject_styles__$18, __vue_script__$16, __vue_scope_id__$18, __vue_is_functional_template__$18, __vue_module_identifier__$18, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$18);

  var parseResponse = function parseResponse(response) {
    if (!response) {
      return response || {};
    }
    try {
      return JSON.parse(response);
    } catch (error) {
      return response || {};
    }
  };
  function upload(options) {
    var xhr = new XMLHttpRequest();
    options.fileObj.xhr = xhr;
    var formData = new FormData();
    options.data.forEach(function (item) {
      formData.append(item.name, item.value);
    });
    formData.append(options.fileName, options.fileObj.origin);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        var reponseText = parseResponse(xhr.responseText || xhr.response);
        if (xhr.status < 200 || xhr.status >= 300) {
          options.fileObj.progress = 100 + '%';
          options.fileObj.errorMsg = reponseText.message || _t('bk.uploadFile.uploadFailed');
          options.onError(options.fileObj, options.fileList, xhr.response);
        } else {
          options.onSuccess(reponseText, options.fileObj);
        }
        options.onDone(options.fileObj);
      }
    };
    xhr.upload.addEventListener('progress', options.onProgress, false);
    xhr.withCredentials = options.withCredentials;
    xhr.open(options.method, options.url, true);
    if (options.header) {
      if (isArray$1(options.header)) {
        options.header.forEach(function (head) {
          var headerKey = head.name;
          var headerVal = head.value;
          xhr.setRequestHeader(headerKey, headerVal);
        });
      } else {
        var headerKey = options.header.name;
        var headerVal = options.header.value;
        xhr.setRequestHeader(headerKey, headerVal);
      }
    }
    xhr.send(formData);
    return {
      abort: function abort() {
        xhr.abort();
      }
    };
  }

  var script$17 = {
    name: 'bk-upload',
    directives: {
      bkOverflowTips: overflowTips
    },
    mixins: [locale.mixin],
    props: {
      theme: {
        type: String,
        default: 'draggable'
      },
      files: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      name: {
        type: String,
        default: 'upload_file'
      },
      multiple: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String
      },
      delayTime: {
        type: Number,
        default: 0
      },
      url: {
        required: true,
        type: String
      },
      size: {
        type: [Number, Object],
        default: function _default() {
          return {
            maxFileSize: 5,
            maxImgSize: 1
          };
        }
      },
      handleResCode: {
        type: Function,
        default: function _default(res) {
          if (res && res.code === 0) {
            return true;
          }
          return false;
        }
      },
      header: [Array, Object],
      tip: {
        type: String,
        default: ''
      },
      validateName: {
        type: RegExp
      },
      withCredentials: {
        type: Boolean,
        default: false
      },
      limit: Number,
      formDataAttributes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      customRequest: Function
    },
    data: function data() {
      return {
        dragText: '',
        clickText: '',
        showDialog: true,
        labelText: '',
        fileList: [],
        width: 0,
        barEl: null,
        fileIndex: null,
        speed: 0,
        total: 0,
        unit: 'kb/s',
        isdrag: false,
        progress: 0
      };
    },
    computed: {
      disabled: function disabled() {
        return this.theme === 'picture' && !this.multiple && this.fileList.length === 1 && this.fileList[0].status === 'running';
      },
      acceptTypes: function acceptTypes() {
        if (this.theme === 'picture' && this.accept === undefined) {
          return 'image/png,image/jpeg,image/jpg';
        }
        return this.accept;
      }
    },
    watch: {
      'fileIndex': function fileIndex(val) {
        if (val !== null && val < this.fileList.length) {
          if (!this.fileList[val].done) {
            this.uploadFile(this.fileList[val]);
          } else {
            this.fileIndex++;
          }
        }
      },
      'files': {
        immediate: true,
        deep: true,
        handler: function handler(list) {
          var _this = this;
          this.fileList = list.map(function (item) {
            _this.fileIndex++;
            return _extends({
              status: 'done',
              done: true,
              progress: '100%',
              name: "image.png".concat(uuid())
            }, item);
          });
        }
      }
    },
    created: function created() {
      this.dragText = this.t('bk.uploadFile.drag');
      this.clickText = this.t('bk.uploadFile.click');
      this.labelText = this.t('bk.uploadFile.uploadLabel');
    },
    mounted: function mounted() {
      var _this2 = this;
      if (this.theme === 'draggable') {
        var uploadEl = this.$refs.uploadel;
        uploadEl.addEventListener('dragenter', function (e) {
          _this2.isdrag = true;
        });
        uploadEl.addEventListener('dragleave', function (e) {
          _this2.isdrag = false;
        });
        uploadEl.addEventListener('dragend', function (e) {
          _this2.isdrag = false;
        });
      }
    },
    methods: {
      isImageType: function isImageType(fileType) {
        return fileType ? fileType.split('/').includes('image') : false;
      },
      getValidTypeFiles: function getValidTypeFiles(files) {
        var _this3 = this;
        return files.filter(function (file) {
          var type = file.type,
              name = file.name;
          var extension = name.indexOf('.') > -1 ? ".".concat(name.split('.').pop()) : '';
          var baseType = type.replace(/\/.*$/, '');
          return _this3.acceptTypes.split(',').map(function (type) {
            return type.trim();
          }).filter(function (type) {
            return type;
          }).some(function (acceptedType) {
            if (/\..+$/.test(acceptedType)) {
              return extension === acceptedType;
            }
            if (/\/\*$/.test(acceptedType)) {
              return baseType === acceptedType.replace(/\/\*$/, '');
            }
            if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
              return type === acceptedType;
            }
            return false;
          });
        });
      },
      filesize: function filesize(val) {
        var size = val / 1000;
        if (size < 1) {
          return "".concat(val.toFixed(3), " KB");
        }
        var index = size.toString().indexOf('.');
        return "".concat(size.toString().slice(0, index + 2), " MB");
      },
      handleWrapEnter: function handleWrapEnter(e) {
        if (e.target !== e.currentTarget) {
          return;
        }
        if ((e.keyCode === 13 || e.keyCode === 32) && this.$refs.uploadel) {
          this.$refs.uploadel.value = null;
          this.$refs.uploadel.click();
        }
      },
      selectFile: function selectFile(e) {
        var originalFiles = from_1$1(e.target.files);
        var files = this.acceptTypes ? this.getValidTypeFiles(originalFiles) : originalFiles;
        if (!files.length) {
          e.target.value = '';
          return;
        }
        if (typeof this.limit === 'number' && this.limit !== 1 && files.length + this.fileList.length > this.limit) {
          e.target.value = '';
          this.$emit('on-exceed', e.target.files, this.fileList);
          return;
        }
        var me = this;
        files.forEach(function (file, i) {
          var fileObj = {
            name: file.name,
            originSize: file.size,
            size: file.size / 1000,
            maxFileSize: null,
            maxImgSize: null,
            type: file.type,
            fileHeader: '',
            origin: file,
            url: '',
            base64: '',
            status: '',
            done: false,
            responseData: '',
            speed: null,
            errorMsg: '',
            progress: ''
          };
          var index = fileObj.type.indexOf('/');
          var type = fileObj.type.slice(0, index);
          fileObj.fileHeader = type;
          if (typeof me.size === 'number') {
            fileObj.maxFileSize = me.size;
            fileObj.maxImgSize = me.size;
          } else {
            fileObj.maxFileSize = me.size.maxFileSize;
            fileObj.maxImgSize = me.size.maxImgSize;
          }
          var onlyAcceptImage = !(me.accept || '').split(',').some(function (acc) {
            return acc.indexOf('image') < 0;
          });
          if (type === 'image' || onlyAcceptImage) {
            me.handleImage(fileObj, file);
          }
          if (type !== 'image' && fileObj.size > fileObj.maxFileSize * 1000) {
            fileObj.errorMsg = me.t('bk.uploadFile.fileExceedMsg', {
              fileName: fileObj.name,
              size: fileObj.maxFileSize
            });
          }
          if (me.validateName) {
            if (!me.validateName.test(fileObj.name)) {
              fileObj.errorMsg = me.t('bk.uploadFile.invalidFileName');
            }
          }
          if (me.theme === 'picture' && !me.multiple || me.limit === 1) {
            me.fileList = [fileObj];
          } else {
            me.fileList.push(fileObj);
          }
        });
        var len = this.fileList.length;
        var fileIndex = this.fileIndex;
        if (len - 1 === fileIndex) {
          this.uploadFile(this.fileList[fileIndex]);
        } else {
          this.fileIndex = 0;
        }
        e.target.value = '';
      },
      hideFileList: function hideFileList() {
        var _this4 = this;
        if (this.delayTime) {
          setTimeout(function () {
            _this4.fileList = [];
          }, this.delayTime);
        }
      },
      uploadFile: function uploadFile(fileObj) {
        var _this5 = this;
        if (fileObj.errorMsg) {
          this.fileIndex += 1;
          fileObj.progress = 100 + '%';
          this.$emit('on-error', fileObj, this.fileList);
          return;
        }
        var uploadProgress = function uploadProgress(e) {
          if (e.lengthComputable) {
            var percentComplete = Math.round(e.loaded * 100 / e.total);
            var kb = Math.round(e.loaded / 1000);
            fileObj.progress = percentComplete + '%';
            _this5.speed = kb - _this5.total;
            _this5.total = kb;
            _this5.unit = 'kb/s';
            if (_this5.speed > 1000) {
              _this5.speed = Math.round(_this5.speed / 1000);
              _this5.unit = 'mb/s';
            }
            _this5.$emit('on-progress', e, fileObj, _this5.fileList);
          }
          fileObj.status = 'running';
        };
        var options = {
          fileName: this.name,
          fileObj: fileObj,
          fileList: this.fileList,
          data: this.formDataAttributes || [],
          withCredentials: this.withCredentials,
          method: 'POST',
          header: this.header,
          url: this.url,
          onProgress: function onProgress(event) {
            uploadProgress(event);
          },
          onSuccess: function onSuccess(reponseText, fileObj) {
            _this5.handleSuccess(reponseText, fileObj);
          },
          onError: function onError(fileObj, fileList, response) {
            _this5.$emit('on-error', fileObj, fileList, response);
          },
          onDone: function onDone(fileObj) {
            _this5.handleDone(fileObj);
          }
        };
        this.isdrag = false;
        var request = this.customRequest || upload;
        request(options);
      },
      handleSuccess: function handleSuccess(response, file) {
        if (this.handleResCode(response)) {
          file.done = true;
          file.responseData = response;
          this.$emit('on-success', file, this.fileList);
        } else {
          file.errorMsg = response.message || this.t('bk.uploadFile.uploadFailed');
          this.$emit('on-error', file, this.fileList);
        }
      },
      handleDone: function handleDone(file) {
        this.fileIndex += 1;
        this.unit = 'kb/s';
        this.total = 0;
        file.status = 'done';
        if (this.fileIndex === this.fileList.length) {
          this.$emit('on-done', this.fileList);
          this.hideFileList();
        }
      },
      handleImage: function handleImage(fileObj, file) {
        var _this6 = this;
        if (fileObj.size > fileObj.maxImgSize * 1000) {
          fileObj.errorMsg = this.t('bk.uploadFile.imageExceedMsg', {
            imgSize: fileObj.maxImgSize
          });
          return false;
        }
        var reader = new FileReader();
        reader.onload = function (e) {
          _this6.smallImage(reader.result, fileObj);
        };
        reader.readAsDataURL(file);
        return true;
      },
      smallImage: function smallImage(result, fileObj) {
        var _this7 = this;
        var img = new Image();
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        img.onload = function () {
          var originWidth = img.width;
          var originHeight = img.height;
          var maxWidth = _this7.theme === 'picture' ? 90 : 36;
          var maxHeight = maxWidth;
          var targetWidth = originWidth;
          var targetHeight = originHeight;
          if (originWidth > maxWidth || originHeight > maxHeight) {
            if (originWidth / originHeight > maxWidth / maxHeight) {
              targetWidth = maxWidth;
              targetHeight = Math.round(maxWidth * (originHeight / originWidth));
            } else {
              targetWidth = maxWidth;
              targetHeight = maxHeight;
            }
          }
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          context.clearRect(0, 0, targetWidth, targetHeight);
          context.drawImage(img, 0, 0, targetWidth, targetHeight);
          var base64 = canvas.toDataURL();
          fileObj['url'] = base64;
          fileObj['base64'] = base64;
        };
        img.src = result;
      },
      getIcon: function getIcon(file) {
        var zipType = ['application/zip', 'application/rar', 'application/tar', 'application/gz'];
        if (zipType.includes(file.type)) {
          return 'bk-icon icon-compressed-file';
        }
        return 'bk-icon icon-text-file';
      },
      deleteFile: function deleteFile(index, file) {
        if (file.xhr) {
          file.xhr.abort();
        }
        this.fileList.splice(index, 1);
        var len = this.fileList.length;
        if (!len) {
          this.fileIndex = null;
        }
        this.$emit('on-delete', file, this.fileList);
      }
    }
  };

  /* script */
  var __vue_script__$17 = script$17;
  /* template */

  var __vue_render__$19 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-upload', _vm.theme, _vm.extCls]
    }, [_vm.theme === 'picture' && _vm.multiple && _vm.fileList.length ? _vm._l(_vm.fileList, function (file, index) {
      return _c('div', {
        key: index,
        staticClass: "pic-item",
        class: {
          fail: file.errorMsg
        }
      }, [_c('img', {
        attrs: {
          "src": file.url
        }
      }), file.status === 'running' ? _c('div', {
        staticClass: "uploading-status"
      }, [_c('span', [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploading')))]), _c('div', {
        staticClass: "progress-bar-wrapper"
      }, [_c('div', {
        staticClass: "progress-bar uploading",
        style: {
          width: _vm.fileList[0].progress
        }
      })])]) : _vm._e(), file.done || file.errorMsg ? _c('div', {
        staticClass: "mask"
      }, [file.errorMsg ? _c('div', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips.top",
          value: file.errorMsg,
          expression: "file.errorMsg",
          modifiers: {
            "top": true
          }
        }],
        staticClass: "fail-tips"
      }) : _vm._e(), _c('i', {
        staticClass: "bk-icon icon-close delete-file",
        on: {
          "click": function click($event) {
            _vm.deleteFile(index, file);
          }
        }
      })]) : _vm._e()]);
    }) : _vm._e(), _c('div', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips",
        value: {
          disabled: _vm.theme !== 'picture' || _vm.multiple || _vm.fileList.length === 0 || _vm.fileList.length > 1 || !_vm.fileList[0].errorMsg,
          content: _vm.fileList.length && _vm.fileList[0].errorMsg
        },
        expression: "{\n            disabled: theme !== 'picture' || multiple || fileList.length === 0 || fileList.length > 1 || !fileList[0].errorMsg,\n            content: fileList.length && fileList[0].errorMsg\n        }"
      }],
      staticClass: "file-wrapper",
      class: {
        'isdrag': _vm.isdrag
      },
      attrs: {
        "tabindex": "0",
        "bk-lableName": _vm.labelText
      },
      on: {
        "keydown": _vm.handleWrapEnter
      }
    }, [_vm.theme === 'draggable' ? _c('div', [_c('i', {
      staticClass: "bk-icon upload-icon icon-upload-cloud"
    }), _c('p', {
      staticClass: "text-area"
    }, [_c('span', {
      staticClass: "drop-upload"
    }, [_vm._v(_vm._s(_vm.dragText))]), _c('span', {
      staticClass: "click-upload"
    }, [_vm._v(_vm._s(_vm.clickText))])])]) : _vm._e(), _vm.theme === 'picture' ? _c('div', {
      staticClass: "picture-btn"
    }, [[_vm.multiple || _vm.fileList.length === 0 ? _c('div', {
      staticClass: "upload-btn"
    }, [_c('i', {
      staticClass: "bk-icon icon-plus-line"
    }), _c('div', [_vm._v(_vm._s(_vm.t('bk.uploadFile.click')))])]) : _c('div', {
      staticClass: "pic-item",
      class: {
        fail: !_vm.multiple && _vm.fileList.length && _vm.fileList[0].errorMsg
      }
    }, [_vm.fileList[0].status === 'running' ? _c('div', {
      staticClass: "uploading-status"
    }, [_c('span', [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploading')))]), _c('div', {
      staticClass: "progress-bar-wrapper"
    }, [_c('div', {
      staticClass: "progress-bar uploading",
      style: {
        width: _vm.fileList[0].progress
      }
    })])]) : _vm._e(), _vm.fileList[0].errorMsg ? _c('div', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips.top",
        value: _vm.fileList[0].errorMsg,
        expression: "fileList[0].errorMsg",
        modifiers: {
          "top": true
        }
      }],
      staticClass: "fail-status"
    }, [_c('i', {
      staticClass: "bk-icon icon-image error-pic"
    }), _c('div', {
      staticClass: "reupload"
    }, [_vm._v(_vm._s(_vm.t('bk.uploadFile.reupload')))]), _c('i', {
      staticClass: "bk-icon icon-close delete-file error",
      on: {
        "click": function click($event) {
          _vm.deleteFile(0, _vm.fileList[0]);
        }
      }
    })]) : _vm._e(), _vm.fileList[0].status === 'done' && !_vm.fileList[0].errorMsg ? _c('div', {
      staticClass: "uploaded-status"
    }, [_c('img', {
      attrs: {
        "src": _vm.fileList[0].url
      }
    }), _c('div', {
      staticClass: "mask"
    }, [_vm._v("\n                            " + _vm._s(_vm.t('bk.uploadFile.replace')) + "\n                            "), _c('i', {
      staticClass: "bk-icon icon-close delete-file",
      on: {
        "click": function click($event) {
          _vm.deleteFile(0, _vm.fileList[0]);
        }
      }
    })])]) : _vm._e()])]], 2) : _vm._e(), _c('input', {
      ref: "uploadel",
      attrs: {
        "tabindex": "-1",
        "accept": _vm.acceptTypes,
        "multiple": _vm.multiple,
        "disabled": _vm.disabled,
        "type": "file"
      },
      on: {
        "change": _vm.selectFile
      }
    })]), _vm.tip ? _c('p', {
      staticClass: "tip"
    }, [_vm._v(_vm._s(_vm.tip))]) : _vm._e(), _vm.fileList.length && _vm.theme !== 'picture' ? _c('div', {
      staticClass: "all-file"
    }, _vm._l(_vm.fileList, function (file, index) {
      return _c('div', {
        key: index
      }, [_c('div', {
        staticClass: "file-item",
        class: {
          'file-item-fail': file.errorMsg
        }
      }, [_c('div', {
        staticClass: "file-icon"
      }, [_vm.isImageType(file.type) ? _c('img', {
        attrs: {
          "src": file.url
        }
      }) : _c('i', {
        class: _vm.getIcon(file)
      })]), _c('i', {
        staticClass: "bk-icon icon-close close-upload",
        on: {
          "click": function click($event) {
            _vm.deleteFile(index, file);
          }
        }
      }), _c('div', {
        staticClass: "file-info"
      }, [_c('div', {
        staticClass: "file-name"
      }, [_c('span', [_vm._v(_vm._s(file.name))])]), _c('div', {
        staticClass: "file-message"
      }, [_c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !file.done && file.status === 'running',
          expression: "!file.done && file.status === 'running'"
        }],
        staticClass: "upload-speed"
      }, [_vm._v(_vm._s(_vm.speed) + _vm._s(_vm.unit))]), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !file.done,
          expression: "!file.done"
        }],
        staticClass: "file-size"
      }, [_vm._v(_vm._s(_vm.filesize(file.size)))]), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: file.done,
          expression: "file.done"
        }],
        staticClass: "file-size done"
      }, [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploadDone')))])]), file.errorMsg ? _c('p', {
        directives: [{
          name: "bk-overflow-tips",
          rawName: "v-bk-overflow-tips"
        }],
        staticClass: "error-msg"
      }, [_vm._v(_vm._s(file.errorMsg))]) : _c('div', {
        staticClass: "progress-bar-wrapper"
      }, [_c('div', {
        staticClass: "progress-bar",
        class: {
          'success': file.done,
          'uploading': file.status === 'running' && !file.errorMsg
        },
        style: {
          width: file.progress
        }
      })])])])]);
    }), 0) : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$19 = [];
  /* style */

  var __vue_inject_styles__$19 = undefined;
  /* scoped */

  var __vue_scope_id__$19 = undefined;
  /* module identifier */

  var __vue_module_identifier__$19 = undefined;
  /* functional template */

  var __vue_is_functional_template__$19 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$19 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$19,
    staticRenderFns: __vue_staticRenderFns__$19
  }, __vue_inject_styles__$19, __vue_script__$17, __vue_scope_id__$19, __vue_is_functional_template__$19, __vue_module_identifier__$19, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$19);

  var script$18 = {
    name: 'bk-container',
    props: {
      col: {
        type: Number,
        default: 24,
        validator: function validator(value) {
          if (value <= 0) {
            console.error("col property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      gutter: {
        type: Number,
        default: 20,
        validator: function validator(value) {
          if (value < 0) {
            console.error("gutter property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      margin: {
        type: Number,
        default: 20,
        validator: function validator(value) {
          if (value < 0) {
            console.error("margin property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      flex: {
        type: Boolean,
        default: false
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    provide: function provide() {
      var col = this.col,
          gutter = this.gutter,
          flex = this.flex;
      return {
        col: col,
        gutter: gutter,
        flex: flex
      };
    },
    computed: {
      style: function style() {
        var margin = this.margin;
        return {
          'padding-right': "".concat(margin, "px"),
          'padding-left': "".concat(margin, "px")
        };
      }
    }
  };

  /* script */
  var __vue_script__$18 = script$18;
  /* template */

  var __vue_render__$1a = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-grid-container",
      class: _vm.extCls,
      style: _vm.style
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$1a = [];
  /* style */

  var __vue_inject_styles__$1a = undefined;
  /* scoped */

  var __vue_scope_id__$1a = undefined;
  /* module identifier */

  var __vue_module_identifier__$1a = undefined;
  /* functional template */

  var __vue_is_functional_template__$1a = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1a = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1a,
    staticRenderFns: __vue_staticRenderFns__$1a
  }, __vue_inject_styles__$1a, __vue_script__$18, __vue_scope_id__$1a, __vue_is_functional_template__$1a, __vue_module_identifier__$1a, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1a);

  var script$19 = {
    name: 'bk-col',
    props: {
      span: {
        type: Number,
        default: 1
      },
      offset: {
        type: Number,
        default: 0
      },
      pull: {
        type: Number,
        default: 0
      },
      push: {
        type: Number,
        default: 0
      }
    },
    provide: function provide() {
      var flex = this.flex,
          gutter = this.gutter,
          realSpan = this.realSpan;
      return {
        flex: flex,
        gutter: gutter,
        col: realSpan
      };
    },
    inject: ['col', 'gutter', 'flex'],
    computed: {
      realSpan: function realSpan() {
        return this.span || this.col;
      },
      width: function width() {
        var col = this.col,
            realSpan = this.realSpan;
        return formatPercentage(realSpan / col);
      },
      style: function style() {
        var width = this.width,
            gutter = this.gutter,
            col = this.col,
            offset = this.offset,
            pull = this.pull,
            push = this.push;
        return {
          width: width,
          'padding-right': "".concat(gutter / 2, "px"),
          'padding-left': "".concat(gutter / 2, "px"),
          'margin-left': offset ? formatPercentage(offset / col) : null,
          'right': pull ? formatPercentage(pull / col) : null,
          'left': push ? formatPercentage(push / col) : null
        };
      }
    }
  };

  /* script */
  var __vue_script__$19 = script$19;
  /* template */

  var __vue_render__$1b = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-grid-col",
      style: _vm.style
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$1b = [];
  /* style */

  var __vue_inject_styles__$1b = undefined;
  /* scoped */

  var __vue_scope_id__$1b = undefined;
  /* module identifier */

  var __vue_module_identifier__$1b = undefined;
  /* functional template */

  var __vue_is_functional_template__$1b = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1b = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1b,
    staticRenderFns: __vue_staticRenderFns__$1b
  }, __vue_inject_styles__$1b, __vue_script__$19, __vue_scope_id__$1b, __vue_is_functional_template__$1b, __vue_module_identifier__$1b, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1b);

  var script$1a = {
    name: 'bk-row',
    provide: function provide() {
      var col = this.col,
          gutter = this.gutter,
          flex = this.flex;
      return {
        col: col,
        gutter: gutter,
        flex: flex
      };
    },
    inject: ['col', 'gutter', 'flex'],
    computed: {
      style: function style() {
        var flex = this.flex,
            gutter = this.gutter;
        var o = flex ? {
          display: ['-webkit-box', '-ms-flexbox', 'flex']
        } : {};
        return _objectSpread({}, o, {
          'margin-right': "-".concat(gutter / 2, "px"),
          'margin-left': "-".concat(gutter / 2, "px")
        });
      }
    }
  };

  /* script */
  var __vue_script__$1a = script$1a;
  /* template */

  var __vue_render__$1c = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-grid-row",
      style: _vm.style
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$1c = [];
  /* style */

  var __vue_inject_styles__$1c = undefined;
  /* scoped */

  var __vue_scope_id__$1c = undefined;
  /* module identifier */

  var __vue_module_identifier__$1c = undefined;
  /* functional template */

  var __vue_is_functional_template__$1c = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1c = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1c,
    staticRenderFns: __vue_staticRenderFns__$1c
  }, __vue_inject_styles__$1c, __vue_script__$1a, __vue_scope_id__$1c, __vue_is_functional_template__$1c, __vue_module_identifier__$1c, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1c);

  var script$1b = {
    name: 'bk-star',
    props: {
      rate: {
        type: Number,
        default: 0
      },
      width: {
        type: Number,
        default: 15
      },
      height: {
        type: Number,
        default: 16
      },
      edit: {
        type: Boolean,
        default: true
      },
      hoverRate: {
        type: Number,
        default: 0
      },
      tooltips: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      maxStars: {
        type: Number,
        default: 5
      }
    },
    computed: {
      displayRate: function displayRate() {
        return this.hoverRate || this.rate;
      }
    },
    methods: {
      chooseRate: function chooseRate(index) {
        if (!this.edit) return;
        var rate = index + 1;
        this.$emit('chooseRate', rate);
      },
      changeHover: function changeHover(index) {
        if (!this.edit) return;
        var rate = index + 1;
        this.$emit('changeHover', rate);
      }
    }
  };

  /* script */
  var __vue_script__$1b = script$1b;
  /* template */

  var __vue_render__$1d = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('p', {
      staticClass: "bk-rate-stars"
    }, _vm._l(_vm.maxStars, function (item, index) {
      return _c('svg', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips",
          value: {
            content: _vm.tooltips[index],
            disabled: !_vm.tooltips[index]
          },
          expression: "{ content: tooltips[index], disabled: !tooltips[index] }"
        }],
        key: index,
        class: [{
          'bk-yellow': index < Math.floor(_vm.displayRate)
        }, {
          'bk-is-edit': _vm.edit
        }, 'bk-rate-star'],
        style: {
          width: _vm.width + 'px',
          height: _vm.height + 'px',
          'min-width': _vm.width + 'px'
        },
        attrs: {
          "x": "0px",
          "y": "0px",
          "viewBox": "0 0 64 64"
        },
        on: {
          "click": function click($event) {
            _vm.chooseRate(index);
          },
          "mouseenter": function mouseenter($event) {
            _vm.changeHover(index);
          }
        }
      }, [_c('g', {
        attrs: {
          "transform": "translate(-143.000000, -635.000000)"
        }
      }, [_c('g', {
        attrs: {
          "transform": "translate(83.000000, 114.000000)"
        }
      }, [_c('g', {
        attrs: {
          "transform": "translate(15.000000, 384.000000)"
        }
      }, [_c('g', {
        attrs: {
          "transform": "translate(29.000000, 137.000000)"
        }
      }, [_c('polygon', {
        staticClass: "st1",
        attrs: {
          "points": "48,53 28.2,63.9 32,40.8 16,24.4 38.1,21 48,-0.1 57.8,21 79.9,24.4 63.9,40.8 67.7,63.9"
        }
      })])])])])]);
    }), 0);
  };

  var __vue_staticRenderFns__$1d = [];
  /* style */

  var __vue_inject_styles__$1d = undefined;
  /* scoped */

  var __vue_scope_id__$1d = undefined;
  /* module identifier */

  var __vue_module_identifier__$1d = undefined;
  /* functional template */

  var __vue_is_functional_template__$1d = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1d = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1d,
    staticRenderFns: __vue_staticRenderFns__$1d
  }, __vue_inject_styles__$1d, __vue_script__$1b, __vue_scope_id__$1d, __vue_is_functional_template__$1d, __vue_module_identifier__$1d, false, undefined, undefined, undefined);

  var script$1c = {
    name: 'bk-rate',
    components: {
      bkStar: __vue_component__$1d
    },
    props: {
      rate: {
        type: Number,
        default: 0
      },
      width: {
        type: Number,
        default: 15
      },
      height: {
        type: Number,
        default: 16
      },
      edit: {
        type: Boolean,
        default: true
      },
      tooltips: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        hoverRate: 0
      };
    },
    computed: {
      starWidth: function starWidth() {
        var integer = Math.floor(this.rate);
        var fixWidth = (this.width + 3) * integer;
        var rateWidth = this.width * (this.rate - integer);
        return "".concat(fixWidth + rateWidth, "px");
      }
    },
    methods: {
      chooseRate: function chooseRate(val) {
        if (!this.edit) return;
        this.$emit('update:rate', val);
        this.$emit('score', val);
      },
      changeHover: function changeHover(val) {
        this.hoverRate = val;
      }
    }
  };

  /* script */
  var __vue_script__$1c = script$1c;
  /* template */

  var __vue_render__$1e = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('p', {
      staticClass: "bk-score-group",
      class: _vm.extCls
    }, [_vm.edit ? [_c('bk-star', {
      attrs: {
        "rate": _vm.rate,
        "hover-rate": _vm.hoverRate,
        "width": _vm.width,
        "height": _vm.height,
        "tooltips": _vm.tooltips
      },
      on: {
        "chooseRate": _vm.chooseRate,
        "changeHover": _vm.changeHover
      },
      nativeOn: {
        "mouseleave": function mouseleave($event) {
          _vm.changeHover(0);
        }
      }
    })] : [_c('bk-star', {
      staticClass: "bk-score-real",
      style: {
        width: _vm.starWidth
      },
      attrs: {
        "rate": 5,
        "width": _vm.width,
        "height": _vm.height,
        "edit": false,
        "tooltips": _vm.tooltips
      }
    }), _c('bk-star', {
      attrs: {
        "rate": 0,
        "width": _vm.width,
        "height": _vm.height,
        "edit": false,
        "tooltips": _vm.tooltips
      }
    })]], 2);
  };

  var __vue_staticRenderFns__$1e = [];
  /* style */

  var __vue_inject_styles__$1e = undefined;
  /* scoped */

  var __vue_scope_id__$1e = undefined;
  /* module identifier */

  var __vue_module_identifier__$1e = undefined;
  /* functional template */

  var __vue_is_functional_template__$1e = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1e = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1e,
    staticRenderFns: __vue_staticRenderFns__$1e
  }, __vue_inject_styles__$1e, __vue_script__$1c, __vue_scope_id__$1e, __vue_is_functional_template__$1e, __vue_module_identifier__$1e, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1e);

  setInstaller(__vue_component__$1d);

  var script$1d = {
    name: 'bk-swiper',
    props: {
      pics: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      isLoop: {
        type: Boolean,
        default: true
      },
      loopTime: {
        type: Number,
        default: 8000
      },
      extCls: {
        type: String,
        default: ''
      },
      height: {
        type: [Number, String],
        default: 0
      },
      width: {
        type: [Number, String],
        default: 0
      }
    },
    data: function data() {
      return {
        swiperMainWith: 0,
        currentIndex: 1,
        isStartMove: false,
        isTransition: false,
        startMovePoint: 0,
        mouseDistance: 0,
        loopId: '',
        isClick: false,
        realWidth: 0
      };
    },
    computed: {
      sourceList: function sourceList() {
        return this.list.length > 0 ? this.list : this.pics;
      },
      dataList: function dataList() {
        var first = this.sourceList[0];
        var last = this.sourceList.slice(-1);
        return [].concat(_toConsumableArray(last), _toConsumableArray(this.sourceList), [first]);
      },
      imageTransfer: function imageTransfer() {
        var indexMove = this.realWidth * this.currentIndex;
        var imageMove = indexMove - this.mouseDistance;
        return -imageMove;
      }
    },
    watch: {
      currentIndex: {
        handler: function handler(val) {
          if (val <= 0 || val > this.dataList.length - 2) return;
          this.$emit('index-change', val);
        },
        immediate: true
      },
      height: function height(val) {
        var ele = this.$refs.swiper || {
          style: {
            width: 0,
            height: 0
          },
          offsetWidth: 0
        };
        if (+val > 0) ele.style.height = val + 'px';
      },
      width: function width(val) {
        var ele = this.$refs.swiper || {
          style: {
            width: 0,
            height: 0
          },
          offsetWidth: 0
        };
        this.realWidth = +val > 0 ? +val : ele.offsetWidth;
        ele.style.width = this.realWidth + 'px';
      },
      list: function list() {
        var _this = this;
        this.$nextTick(function () {
          _this.calcSize();
        });
      },
      pics: function pics() {
        var _this2 = this;
        this.$nextTick(function () {
          _this2.calcSize();
        });
      }
    },
    mounted: function mounted() {
      this.initStatus();
    },
    beforeDestroy: function beforeDestroy() {
      this.destoryStatus();
    },
    methods: {
      calcSize: function calcSize() {
        var ele = this.$refs.swiper || {
          style: {
            width: 0,
            height: 0
          },
          offsetWidth: 0
        };
        if (+this.height > 0) ele.style.height = this.height + 'px';
        this.realWidth = +this.width > 0 ? +this.width : ele.offsetWidth;
        ele.style.width = this.realWidth + 'px';
        this.swiperMainWith = this.realWidth * this.dataList.length;
      },
      initStatus: function initStatus() {
        this.calcSize();
        this.startLoop();
        document.addEventListener('visibilitychange', this.visChange);
      },
      destoryStatus: function destoryStatus() {
        this.endLoop();
        document.removeEventListener('visibilitychange', this.visChange);
      },
      goToLink: function goToLink(link) {
        if (this.isClick && link) window.open(link, '_blank');
      },
      visChange: function visChange(event) {
        var hidden = event.target.hidden || false;
        if (hidden) this.endLoop();else this.startLoop();
      },
      changeIndex: function changeIndex(index) {
        this.isTransition = true;
        this.startLoop();
        this.changeCurrentIndex(index);
      },
      moveStart: function moveStart(event) {
        this.endLoop();
        event.preventDefault();
        this.isTransition = false;
        this.isStartMove = true;
        this.startMovePoint = event.clientX;
      },
      moving: function moving(event) {
        if (!this.isStartMove) return;
        var mouseMove = event.clientX - this.startMovePoint;
        this.mouseDistance = mouseMove;
      },
      moveEnd: function moveEnd(event) {
        if (!this.isStartMove) return;
        var threshold = this.realWidth / 3;
        var absMouseDis = Math.abs(this.mouseDistance);
        this.isClick = this.isStartMove && absMouseDis < 5;
        if (absMouseDis > threshold) {
          var index = this.currentIndex - absMouseDis / this.mouseDistance;
          this.changeCurrentIndex(index);
        }
        this.startLoop();
        this.isTransition = true;
        this.isStartMove = false;
        this.mouseDistance = 0;
      },
      changeCurrentIndex: function changeCurrentIndex(val) {
        var picLength = this.dataList.length;
        if (val <= -1) {
          val = picLength - 2;
        } else if (this.currentIndex >= picLength) {
          val = 1;
        }
        this.currentIndex = val;
      },
      transitionend: function transitionend() {
        var picLength = this.dataList.length - 1;
        if (this.currentIndex <= 0) {
          this.isTransition = false;
          this.currentIndex = picLength - 1;
        } else if (this.currentIndex >= picLength) {
          this.isTransition = false;
          this.currentIndex = 1;
        }
      },
      startLoop: function startLoop() {
        var _this3 = this;
        if (!this.isLoop) return;
        this.endLoop();
        this.loopId = window.setTimeout(function () {
          _this3.isTransition = true;
          _this3.changeCurrentIndex(_this3.currentIndex + 1);
          _this3.startLoop();
        }, this.loopTime);
      },
      endLoop: function endLoop() {
        window.clearTimeout(this.loopId);
      }
    }
  };

  /* script */
  var __vue_script__$1d = script$1d;
  /* template */

  var __vue_render__$1f = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.sourceList.length ? _c('section', {
      ref: "swiper",
      staticClass: "bk-swiper-home",
      class: _vm.extCls
    }, [_c('hgroup', {
      class: [{
        'bk-transition': _vm.isTransition
      }, 'bk-swiper-main'],
      style: {
        width: _vm.swiperMainWith + "px",
        transform: "translateX(" + _vm.imageTransfer + "px)"
      },
      on: {
        "mousedown": _vm.moveStart,
        "mousemove": _vm.moving,
        "mouseup": _vm.moveEnd,
        "mouseout": _vm.moveEnd,
        "transitionend": _vm.transitionend
      }
    }, _vm._l(_vm.dataList, function (pic, index) {
      return _c('h3', {
        key: index,
        staticClass: "bk-swiper-card",
        style: {
          'width': _vm.realWidth + "px"
        }
      }, [_vm._t("default", [_c('span', {
        class: [{
          'bk-swiper-link': pic.link
        }, pic.class, 'bk-swiper-img'],
        style: {
          'background-image': "url(" + pic.url + ")",
          'background-color': pic.color
        },
        on: {
          "click": function click($event) {
            _vm.goToLink(pic.link);
          }
        }
      })], {
        data: pic
      })], 2);
    }), 0), _c('ul', {
      staticClass: "bk-swiper-index"
    }, _vm._l(_vm.sourceList, function (pic, index) {
      return _c('li', {
        key: index,
        class: {
          'bk-current-index': _vm.currentIndex === index + 1
        },
        on: {
          "mouseover": function mouseover($event) {
            _vm.changeIndex(index + 1);
          }
        }
      });
    }), 0), _c('span', {
      staticClass: "bk-swiper-nav bk-nav-prev",
      on: {
        "click": function click($event) {
          _vm.changeIndex(_vm.currentIndex - 1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-swiper-nav-icon"
    })]), _c('span', {
      staticClass: "bk-swiper-nav bk-nav-next",
      on: {
        "click": function click($event) {
          _vm.changeIndex(_vm.currentIndex + 1);
        }
      }
    }, [_c('i', {
      staticClass: "bk-swiper-nav-icon"
    })])]) : _vm._e();
  };

  var __vue_staticRenderFns__$1f = [];
  /* style */

  var __vue_inject_styles__$1f = undefined;
  /* scoped */

  var __vue_scope_id__$1f = undefined;
  /* module identifier */

  var __vue_module_identifier__$1f = undefined;
  /* functional template */

  var __vue_is_functional_template__$1f = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1f = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1f,
    staticRenderFns: __vue_staticRenderFns__$1f
  }, __vue_inject_styles__$1f, __vue_script__$1d, __vue_scope_id__$1f, __vue_is_functional_template__$1f, __vue_module_identifier__$1f, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1f);

  var script$1e = {
    name: 'bk-zoom-image',
    props: {
      src: String,
      extCls: String
    },
    data: function data() {
      return {
        imgSrc: '',
        isInit: true,
        startMove: false,
        startTime: 0,
        startX: 0,
        startY: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0
      };
    },
    watch: {
      imgSrc: function imgSrc(val) {
        if (val) {
          this.isInit = true;
          this.width = 0;
          this.height = 0;
          this.top = 0;
          this.left = 0;
        }
      }
    },
    methods: {
      startChange: function startChange(event) {
        if (!this.isInit) return;
        this.top = event.clientY - event.offsetY;
        this.left = event.clientX - event.offsetX;
        this.width = this.$refs.screenImg.clientWidth;
        this.height = this.$refs.screenImg.clientHeight;
        this.isInit = false;
      },
      scrollImage: function scrollImage(event) {
        var deltaY = Math.max(-1, Math.min(1, event.wheelDeltaY || -event.detail));
        var zoomDis = deltaY * 0.2;
        this.startChange(event);
        this.width += this.width * zoomDis;
        this.height += this.height * zoomDis;
        this.top -= event.offsetY * zoomDis;
        this.left -= event.offsetX * zoomDis;
      },
      mouseDown: function mouseDown(event) {
        event.preventDefault();
        this.startTime = new Date();
        this.startX = event.clientX;
        this.startY = event.clientY;
        this.startMove = true;
        this.startChange(event);
      },
      mouseMove: function mouseMove(event) {
        if (!this.startMove) return;
        this.top += event.clientY - (this.mouseMove.tempY || this.startY);
        this.left += event.clientX - (this.mouseMove.tempX || this.startX);
        this.mouseMove.tempY = event.clientY;
        this.mouseMove.tempX = event.clientX;
      },
      mouseUp: function mouseUp(event) {
        var diffTime = new Date() - this.startTime;
        var diffDis = Math.sqrt(Math.pow(event.clientX - this.startX, 2) + Math.pow(event.clientY - this.startY, 2));
        if (!this.startMove || diffTime < 300 && diffDis < 20) this.imgSrc = '';
        this.mouseMove.tempY = 0;
        this.mouseMove.tempX = 0;
        this.startMove = false;
      }
    }
  };

  /* script */
  var __vue_script__$1e = script$1e;
  /* template */

  var __vue_render__$1g = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('section', {
      class: [_vm.extCls, 'bk-zoom-image']
    }, [_c('img', {
      staticClass: "bk-real-image",
      attrs: {
        "src": _vm.src
      },
      on: {
        "click": function click($event) {
          _vm.imgSrc = _vm.src;
        }
      }
    }), _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_vm.imgSrc ? _c('section', {
      staticClass: "bk-full-screen",
      on: {
        "mousemove": _vm.mouseMove,
        "mouseup": _vm.mouseUp
      }
    }, [_c('img', {
      ref: "screenImg",
      class: [{
        'bk-zoom-init': _vm.isInit
      }, 'bk-full-image'],
      style: {
        width: _vm.width + "px",
        height: _vm.height + "px",
        top: _vm.top + "px",
        left: _vm.left + "px"
      },
      attrs: {
        "src": _vm.imgSrc
      },
      on: {
        "mousewheel": function mousewheel($event) {
          $event.preventDefault();
          return _vm.scrollImage($event);
        },
        "DOMMouseScroll": function DOMMouseScroll($event) {
          $event.preventDefault();
          return _vm.scrollImage($event);
        },
        "mousedown": _vm.mouseDown
      }
    })]) : _vm._e()])], 1);
  };

  var __vue_staticRenderFns__$1g = [];
  /* style */

  var __vue_inject_styles__$1g = undefined;
  /* scoped */

  var __vue_scope_id__$1g = undefined;
  /* module identifier */

  var __vue_module_identifier__$1g = undefined;
  /* functional template */

  var __vue_is_functional_template__$1g = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1g = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1g,
    staticRenderFns: __vue_staticRenderFns__$1g
  }, __vue_inject_styles__$1g, __vue_script__$1e, __vue_scope_id__$1g, __vue_is_functional_template__$1g, __vue_module_identifier__$1g, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1g);

  var script$1f = {
    name: 'bk-version-detail',
    components: {
      BkDialog: __vue_component__$u
    },
    directives: {
      bkOverflowTips: overflowTips,
      bkloading: bkLoading
    },
    props: {
      show: Boolean,
      versionList: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      versionDetail: {
        type: String,
        default: ''
      },
      finished: {
        type: Boolean,
        default: true
      },
      getVersionList: {
        type: Function,
        default: function _default() {
          return function () {};
        }
      },
      getVersionDetail: {
        type: Function,
        default: function _default() {
          return function () {};
        }
      },
      currentVersion: {
        type: String,
        default: ''
      },
      minLeftWidth: {
        type: Number,
        default: 180
      },
      maxLeftWidth: {
        type: Number,
        default: 500
      },
      versionTitleName: {
        type: String,
        default: 'title'
      },
      versionSubTitleName: {
        type: String,
        default: 'date'
      }
    },
    data: function data() {
      return {
        left: {
          loading: false,
          width: this.minLeftWidth || 180,
          scroll: false
        },
        dialog: {
          width: 850,
          height: 520,
          show: false
        },
        active: 0,
        loading: false,
        unWatchShow: null
      };
    },
    mounted: function mounted() {
      this.dialog.show = this.show;
      this.$refs.leftList.addEventListener('scroll', this.handleLeftScroll, {
        passive: true
      });
      this.unWatchShow = this.$watch('show', this.handleOnShowChange, {
        immediate: true
      });
    },
    beforeDestroy: function beforeDestroy() {
      this.handleValueChange(false);
      document.body.style.cursor = '';
      this.$refs.leftList.removeEventListener('scroll', this.handleLeftScroll, {
        passive: true
      });
      this.unWatchShow && this.unWatchShow();
    },
    methods: {
      handleMouseDown: function handleMouseDown(e) {
        var _this = this;
        var target = event.target;
        while (target && target.dataset['tag'] !== 'resizeTarget') {
          target = target.parentNode;
        }
        var rect = target.getBoundingClientRect();
        document.onselectstart = function () {
          return false;
        };
        document.ondragstart = function () {
          return false;
        };
        var handleMouseMove = function handleMouseMove(event) {
          _this.left.width = Math.min(Math.max(_this.minLeftWidth, event.clientX - rect.left), _this.maxLeftWidth);
        };
        var handleMouseUp = function handleMouseUp() {
          document.body.style.cursor = '';
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.onselectstart = null;
          document.ondragstart = null;
        };
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      },
      handleMouseMove: function handleMouseMove(e) {
        var target = event.target;
        while (target && target.dataset['tag'] !== 'resizeTarget') {
          target = target.parentNode;
        }
        var bodyStyle = document.body.style;
        bodyStyle.cursor = 'col-resize';
      },
      handleMouseOut: function handleMouseOut(e) {
        document.body.style.cursor = '';
      },
      handleValueChange: function handleValueChange(v) {
        this.$emit('update:show', v);
        this.$emit('change', v);
      },
      handleOnShowChange: function handleOnShowChange(v) {
        var _this2 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this2.dialog.show = v;
                  if (!v) {
                    _context.next = 20;
                    break;
                  }
                  _this2.dialog.width = window.innerWidth >= 1920 ? 1110 : 850;
                  _this2.dialog.height = window.innerWidth >= 1920 ? 640 : 520;
                  _this2.loading = true;
                  _context.t0 = !_this2.versionList.length && typeof _this2.getVersionList === 'function';
                  if (!_context.t0) {
                    _context.next = 9;
                    break;
                  }
                  _context.next = 9;
                  return _this2.getVersionList();
                case 9:
                  if (!_this2.versionList.length) {
                    _context.next = 19;
                    break;
                  }
                case 10:
                  if (!(!_this2.finished && _this2.dialog.height - 40 > _this2.versionList.length * 55)) {
                    _context.next = 17;
                    break;
                  }
                  _context.t1 = typeof _this2.getVersionList === 'function';
                  if (!_context.t1) {
                    _context.next = 15;
                    break;
                  }
                  _context.next = 15;
                  return _this2.getVersionList();
                case 15:
                  _context.next = 10;
                  break;
                case 17:
                  _context.next = 19;
                  return _this2.handleItemClick();
                case 19:
                  _this2.loading = false;
                case 20:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      handleLeftScroll: function handleLeftScroll(e) {
        var _this3 = this;
        return _asyncToGenerator( regenerator.mark(function _callee2() {
          var el, scrollHeight, scrollTop, clientHeight;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  el = _this3.$refs.leftList;
                  scrollHeight = el.scrollHeight;
                  scrollTop = el.scrollTop;
                  clientHeight = el.clientHeight;
                  if (!(!_this3.finished && clientHeight + scrollTop >= scrollHeight && !_this3.scroll)) {
                    _context2.next = 16;
                    break;
                  }
                  _this3.left.scroll = true;
                  _this3.left.loading = true;
                  _context2.t0 = typeof _this3.getVersionList === 'function';
                  if (!_context2.t0) {
                    _context2.next = 11;
                    break;
                  }
                  _context2.next = 11;
                  return _this3.getVersionList().catch(function (_) {
                    return false;
                  });
                case 11:
                  _context2.next = 13;
                  return _this3.$nextTick();
                case 13:
                  el.scrollTo(0, scrollTop - 100);
                  _this3.left.loading = false;
                  _this3.left.scroll = false;
                case 16:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      handleItemClick: function handleItemClick() {
        var _this4 = this;
        var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return _asyncToGenerator( regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this4.active = v;
                  _this4.loading = true;
                  _context3.t0 = typeof _this4.getVersionDetail === 'function';
                  if (!_context3.t0) {
                    _context3.next = 6;
                    break;
                  }
                  _context3.next = 6;
                  return _this4.getVersionDetail(_this4.versionList[v]).catch(function (_) {
                    return false;
                  });
                case 6:
                  _this4.loading = false;
                case 7:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      }
    }
  };

  /* script */
  var __vue_script__$1f = script$1f;
  /* template */

  var __vue_render__$1h = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('bk-dialog', {
      attrs: {
        "value": _vm.dialog.show,
        "width": _vm.dialog.width,
        "show-footer": false,
        "draggable": "",
        "ext-cls": "version-detail-dialog"
      },
      on: {
        "value-change": _vm.handleValueChange
      }
    }, [[_c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: _vm.loading
        },
        expression: "{ isLoading: loading }"
      }],
      staticClass: "bk-version"
    }, [_c('div', {
      staticClass: "bk-version-left",
      style: {
        'flex-basis': _vm.left.width + 'px',
        width: _vm.left.width + 'px',
        height: _vm.dialog.height + 'px'
      },
      attrs: {
        "data-tag": "resizeTarget"
      }
    }, [_c('div', {
      staticClass: "left-fill fill-top"
    }), _c('ul', {
      ref: "leftList",
      staticClass: "left-list"
    }, [_vm._l(_vm.versionList, function (item, index) {
      return _c('li', {
        key: index,
        staticClass: "left-list-item",
        class: {
          'item-active': index === _vm.active,
          'border-after': index !== _vm.active
        },
        on: {
          "click": function click($event) {
            index !== _vm.active && _vm.handleItemClick(index);
          }
        }
      }, [_vm._t("item", [_c('span', {
        directives: [{
          name: "bk-overflow-tips",
          rawName: "v-bk-overflow-tips",
          value: {
            content: item[_vm.versionTitleName],
            placement: 'right'
          },
          expression: "{ content: item[versionTitleName], placement: 'right' }"
        }],
        staticClass: "item-title"
      }, [_vm._v(_vm._s(item[_vm.versionTitleName]))]), _c('span', {
        staticClass: "item-date"
      }, [_vm._v(_vm._s(item[_vm.versionSubTitleName]))]), item[_vm.versionTitleName] === _vm.currentVersion ? _c('span', {
        staticClass: "item-current"
      }, [_vm._v(" " + _vm._s('当前版本') + " ")]) : _vm._e()], {
        version: {
          item: item,
          index: index
        }
      })], 2);
    }), !_vm.finished ? _c('li', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: _vm.left.loading,
          size: 'mini',
          theme: 'default'
        },
        expression: "{ isLoading: left.loading, size: 'mini', theme: 'default' }"
      }],
      staticClass: "left-list-loading border-after"
    }) : _vm._e(), _c('li', {
      staticClass: "left-list-fill border-after"
    })], 2), _c('div', {
      staticClass: "left-fill fill-bottom"
    }), _c('div', {
      staticClass: "resize-line",
      on: {
        "mousedown": _vm.handleMouseDown,
        "mousemove": _vm.handleMouseMove,
        "mouseout": _vm.handleMouseOut
      }
    }, [_c('div', {
      staticClass: "drag-content"
    })])]), _c('div', {
      staticClass: "bk-version-right",
      style: {
        height: _vm.dialog.height + 'px'
      }
    }, [_vm._t("default", [_vm._v("\n                    " + _vm._s(_vm.versionDetail) + "\n                ")], {
      detail: _vm.versionDetail
    })], 2)])]], 2);
  };

  var __vue_staticRenderFns__$1h = [];
  /* style */

  var __vue_inject_styles__$1h = undefined;
  /* scoped */

  var __vue_scope_id__$1h = undefined;
  /* module identifier */

  var __vue_module_identifier__$1h = undefined;
  /* functional template */

  var __vue_is_functional_template__$1h = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1h = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1h,
    staticRenderFns: __vue_staticRenderFns__$1h
  }, __vue_inject_styles__$1h, __vue_script__$1f, __vue_scope_id__$1h, __vue_is_functional_template__$1h, __vue_module_identifier__$1h, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1h);

  var script$1g = {
    name: 'bk-search-select-menu',
    mixins: [locale.mixin],
    props: {
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      isCondition: Boolean,
      condition: Object,
      displayKey: {
        type: String,
        require: true
      },
      filter: {
        type: String,
        default: ''
      },
      error: {
        type: String,
        default: ''
      },
      multiable: Boolean,
      child: Boolean,
      loading: Boolean,
      remoteEmptyText: String,
      remoteLoadingText: String,
      checked: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      primaryKey: {
        type: String,
        require: true
      },
      isChildCondition: Boolean
    },
    data: function data() {
      return {
        hoverId: '',
        hasFocus: false
      };
    },
    mounted: function mounted() {
      this.handleMounted();
    },
    beforeDestroy: function beforeDestroy() {
      this.handleDestroy();
    },
    methods: {
      handleDestroy: function handleDestroy() {
        document.removeEventListener('keydown', this.handleDocumentKeydown);
      },
      handleMounted: function handleMounted() {
        this.handleDestroy();
        document.addEventListener('keydown', this.handleDocumentKeydown);
      },
      handleClick: function handleClick(item, index) {
        if (item.disabled) {
          return false;
        }
        if (this.isChildCondition && !this.multiable) {
          this.$emit('child-condition-select', item, index);
          this.hasFocus = false;
        } else if (!this.multiable || !this.child) {
          this.$emit('select', item, index);
          this.hasFocus = false;
          this.handleDestroy();
        } else {
          this.$refs[item[this.primaryKey]].style.display = this.checked[item[this.primaryKey]] ? 'none' : 'block';
          this.$emit('select-check', item, index);
        }
      },
      handleCheckClick: function handleCheckClick(item, index, next, old, id) {
        this.$emit('select-check', item, index, next, old);
      },
      setCheckValue: function setCheckValue(item, val) {
        var ref = this.$refs[item[this.primaryKey]];
        if (ref) {
          ref.style.display = this.checked[item[this.primaryKey]] ? 'none' : 'block';
        }
      },
      handleSelectEnter: function handleSelectEnter(e) {
        this.$emit('select-enter', e);
      },
      handleDocumentKeydown: function handleDocumentKeydown(e) {
        var _this = this;
        var len = this.list && this.list.length;
        if (['ArrowDown', 'ArrowUp'].includes(e.code) && len && this.list.some(function (item) {
          return !item.disabled;
        })) {
          e.preventDefault();
          e.stopPropagation();
          this.$el.focus();
          this.hasFocus = true;
          var i = len;
          var curIndex = this.list.findIndex(function (set) {
            return set[_this.primaryKey] === _this.hoverId;
          });
          while (i >= 0) {
            curIndex = e.code === 'ArrowDown' ? curIndex + 1 : curIndex - 1;
            curIndex = curIndex > len - 1 ? 0 : curIndex < 0 ? len - 1 : curIndex;
            var item = this.list[curIndex];
            if (!item.disabled) {
              i = -1;
              this.hoverId = item.id;
              return;
            }
            i--;
          }
        } else if (this.hasFocus && ['Enter', 'NumpadEnter'].includes(e.code) && len && this.hoverId) {
          var _curIndex = this.list.findIndex(function (set) {
            return set[_this.primaryKey] === _this.hoverId;
          });
          if (_curIndex > -1) {
            var curItem = this.list[_curIndex];
            this.handleClick(curItem, _curIndex);
          }
        }
      },
      handleKeyDown: function handleKeyDown(e) {
        if (e.code === 'Enter' || e.code === 'NumpadEnter') ;
      },
      handleSelectCancel: function handleSelectCancel(e) {
        var _this2 = this;
        keys$1(this.checked).forEach(function (key) {
          _this2.$refs[key] && (_this2.$refs[key].style.display = 'none');
        });
        this.$emit('select-cancel', e);
      }
    },
    render: function render(h) {
      var _this3 = this;
      var list = this.list,
          condition = this.condition,
          displayKey = this.displayKey,
          primaryKey = this.primaryKey,
          filter = this.filter,
          multiable = this.multiable,
          child = this.child,
          checked = this.checked,
          remoteLoadingText = this.remoteLoadingText,
          remoteEmptyText = this.remoteEmptyText,
          _this$loading = this.loading,
          loading = _this$loading === void 0 ? false : _this$loading,
          _this$isCondition = this.isCondition,
          isCondition = _this$isCondition === void 0 ? false : _this$isCondition,
          _this$isChildConditio = this.isChildCondition,
          isChildCondition = _this$isChildConditio === void 0 ? false : _this$isChildConditio,
          _this$error = this.error,
          error = _this$error === void 0 ? '' : _this$error,
          hoverId = this.hoverId;
      if (error) {
        return h("div", {
          "class": {
            'bk-search-list': true
          }
        }, [h("div", {
          "class": {
            'bk-search-list-error': true
          }
        }, [error])]);
      } else if (!loading && (!list || !list.length)) {
        return h("div", {
          "class": {
            'bk-search-list': true
          }
        }, [h("div", {
          "class": {
            'bk-search-list-loading': true
          }
        }, [remoteEmptyText])]);
      }
      var conditionEvent = {
        on: {}
      };
      var wrapEvent = {
        on: {}
      };
      var footerEnterEvent = {
        on: {}
      };
      var footerCancelEvent = {
        on: {}
      };
      this.hoverIndex = 0;
      var items = this._l(list, function (item, index) {
        var id = item[primaryKey];
        var isFilter = filter && item[displayKey].includes(filter);
        var text = item[displayKey];
        var events = {
          on: {}
        };
        var i, pre, next;
        events.on.click = function (e) {
          return _this3.handleClick(item, index);
        };
        if (isFilter) {
          i = text.indexOf(filter);
          pre = text.slice(0, i);
          next = text.slice(i + filter.length, text.length);
        }
        return h("li", {
          "class": {
            'bk-search-list-menu-item': true,
            'is-group': !!item.isGroup,
            'is-disabled': item.disabled,
            'is-hover': !item.disabled && hoverId === id
          }
        }, [h("div", helper([{}, events, {
          "class": {
            'item-name': true
          }
        }]), [isFilter ? h("div", [pre, h("span", {
          "class": {
            'item-name-filter': true
          }
        }, [filter]), next]) : text]), h("span", {
          "directives": [{
            name: "show",
            value: multiable && child && checked[text] && !isChildCondition
          }],
          "ref": id,
          "class": {
            'bk-icon icon-check-1 item-icon': true
          }
        })]);
      });
      if (multiable && child) {
        footerEnterEvent['on']['click'] = function (e) {
          return _this3.handleSelectEnter(e);
        };
        footerCancelEvent['on']['click'] = function (e) {
          return _this3.handleSelectCancel(e);
        };
      }
      if (isCondition && !isChildCondition) {
        conditionEvent['on']['click'] = function (_) {
          return _this3.$emit('select-conditon', condition);
        };
      }
      return h("div", helper([{
        "class": {
          'bk-search-list': true
        }
      }, wrapEvent, {
        "attrs": {
          "tabIndex": "-1"
        }
      }]), [h("div", {
        "directives": [{
          name: "show",
          value: loading
        }],
        "class": {
          'bk-search-list-loading': true
        }
      }, [remoteLoadingText]), !isCondition ? '' : h("div", helper([{
        "directives": [{
          name: "show",
          value: !loading
        }],
        "class": {
          'bk-search-list-condition': true
        }
      }, conditionEvent]), [condition[displayKey]]), h("div", {
        "directives": [{
          name: "show",
          value: !loading
        }],
        "class": "search-menu-wrap"
      }, [h("ul", {
        "class": {
          'bk-search-list-menu': true
        }
      }, [items])]), multiable && child && !loading ? h("div", {
        "class": {
          'bk-search-list-footer': true
        }
      }, [h("span", helper([{
        "class": {
          'footer-btn': true
        }
      }, footerEnterEvent]), [this.t('bk.searchSelect.ok')]), h("span", helper([{
        "class": {
          'footer-btn': true
        }
      }, footerCancelEvent]), [this.t('bk.searchSelect.cancel')])]) : '']);
    }
  };

  /* script */
  var __vue_script__$1g = script$1g;
  /* template */

  /* style */

  var __vue_inject_styles__$1i = undefined;
  /* scoped */

  var __vue_scope_id__$1i = undefined;
  /* module identifier */

  var __vue_module_identifier__$1i = undefined;
  /* functional template */

  var __vue_is_functional_template__$1i = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1i = /*#__PURE__*/normalizeComponent_1({}, __vue_inject_styles__$1i, __vue_script__$1g, __vue_scope_id__$1i, __vue_is_functional_template__$1i, __vue_module_identifier__$1i, false, undefined, undefined, undefined);

  var script$1h = {
    name: 'bk-search-select',
    directives: {
      clickoutside: bkClickoutside
    },
    mixins: [emitter, locale.mixin],
    model: {
      prop: 'values',
      event: 'change'
    },
    props: {
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      splitCode: {
        type: String,
        default: ' | '
      },
      explainCode: {
        type: String,
        default: '：'
      },
      placeholder: {
        type: String,
        default: ''
      },
      emptyText: {
        type: String,
        default: ''
      },
      maxHeight: {
        type: [String, Number],
        default: 120
      },
      minHeight: {
        type: [String, Number],
        default: 26
      },
      shrink: {
        type: Boolean,
        default: true
      },
      showDelay: {
        type: Number,
        default: 100
      },
      displayKey: {
        type: String,
        default: 'name'
      },
      primaryKey: {
        type: String,
        default: 'id'
      },
      condition: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      values: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      filter: Boolean,
      filterChildrenMethod: Function,
      filterMenuMethod: Function,
      remoteMethod: Function,
      remoteEmptyText: {
        type: String,
        default: ''
      },
      remoteLoadingText: {
        type: String,
        default: ''
      },
      multiable: {
        type: Boolean,
        default: false
      },
      keyDelay: {
        type: Number,
        default: 300
      },
      showCondition: {
        type: Boolean,
        default: true
      },
      readonly: {
        type: Boolean,
        default: false
      },
      wrapZindex: {
        type: [String, Number],
        default: 9
      },
      defaultFocus: {
        type: Boolean,
        default: false
      },
      inputType: {
        type: String,
        default: 'text',
        validator: function validator(v) {
          return ['text', 'number'].indexOf(v) !== -1;
        }
      },
      popoverZindex: {
        type: Number,
        default: 999
      },
      showPopoverTagChange: {
        type: Boolean,
        default: true
      },
      clearable: {
        type: Boolean,
        default: false
      },
      validateMessage: {
        type: String,
        default: ''
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        menuInstance: null,
        popperMenuInstance: null,
        menuChildInstance: null,
        menu: {
          active: -1,
          id: null,
          child: false,
          checked: {},
          loading: false,
          childCondition: {}
        },
        chip: {
          list: []
        },
        input: {
          focus: false,
          value: ''
        },
        overflow: {
          chipIndex: -1
        },
        handleInputSearchPlus: function handleInputSearchPlus() {},
        handleSearchSelectResize: function handleSearchSelectResize() {},
        defaultPlaceholder: '',
        defaultEmptyText: '',
        defaultRemoteEmptyText: '',
        defaultRemoteLoadingText: '',
        defaultCondition: {},
        validateStr: ''
      };
    },
    computed: {
      curItem: function curItem() {
        var _this = this;
        return this.data.find(function (item) {
          return item[_this.primaryKey] === _this.menu.id;
        }) || {};
      },
      childList: function childList() {
        var ret = [];
        var i = 0;
        while (i < this.data.length) {
          var item = this.data[i];
          if (item.children && item.children.length) {
            ret.push.apply(ret, _toConsumableArray(item.children));
          }
          i++;
        }
        return ret;
      },
      showItemPlaceholder: function showItemPlaceholder() {
        return this.menu.active >= 0 && String(this.curItem.placeholder).length && this.input.value === this.curItem[this.displayKey] + this.explainCode;
      }
    },
    watch: {
      values: {
        handler: function handler(v) {
          if (v !== this.chip.list) {
            this.chip.list = _toConsumableArray(v);
          }
        },
        deep: true,
        immediate: true
      },
      validateMessage: {
        handler: function handler(v) {
          this.validateStr = v;
        },
        immediate: true
      },
      'input.focus': {
        handler: function handler(v) {
          var _this2 = this;
          if (v) {
            this.overflow.chipIndex = -1;
          } else {
            this.$refs.wrap && this.$refs.wrap.scrollTo(0, 0);
            setTimeout(function () {
              _this2._isMounted && _this2.handleSearchInputResize();
            }, 300);
          }
        },
        immediate: true
      }
    },
    created: function created() {
      var _this3 = this;
      this.input.focus = this.defaultFocus;
      this.defaultPlaceholder = this.placeholder || this.t('bk.searchSelect.placeholder');
      this.defaultEmptyText = this.emptyText || this.t('bk.searchSelect.emptyText');
      this.defaultRemoteEmptyText = this.remoteEmptyText || this.t('bk.searchSelect.remoteEmptyText');
      this.defaultRemoteLoadingText = this.remoteLoadingText || this.t('bk.searchSelect.remoteLoadingText');
      this.defaultCondition = _extends({}, {
        name: this.t('bk.searchSelect.condition')
      });
      if (!keys$1(this.defaultCondition).includes(this.displayKey)) {
        this.defaultCondition[this.displayKey] = this.t('bk.searchSelect.condition');
      }
      this.handleInputSearchPlus = debounce(this.keyDelay, function (v) {
        return _this3.handleSearch(v);
      });
    },
    mounted: function mounted() {
      if (this.input.focus) {
        this.$refs.input.focus();
      }
      this.handleSearchSelectResize = debounce(32, this.handleSearchInputResize);
      addResizeListener(this.$el, this.handleSearchSelectResize);
    },
    beforeDestroy: function beforeDestroy() {
      this.menuInstance = null;
      this.menuChildInstance = null;
      this.popperMenuInstance && this.popperMenuInstance.destroy(true);
      removeResizeListener(this.$el, this.handleSearchSelectResize);
    },
    methods: {
      handleSearchInputResize: function handleSearchInputResize() {
        if (this.input.focus || this.chip.list.length < 1) {
          this.overflow.chipIndex = -1;
          return;
        }
        var inputEl = this.$el.querySelector('.bk-search-select');
        var maxWidth = this.$el.querySelector('.search-input').clientWidth - 8;
        var tagList = inputEl.querySelectorAll('.search-input-chip:not(.overflow-chip)');
        var width = 0;
        var index = 0;
        var i = 0;
        while (width <= maxWidth - 40 && i <= tagList.length - 1) {
          var el = tagList[i];
          width += el ? el.clientWidth + 6 : 0;
          i += 1;
          if (width <= maxWidth - 40) index = i;
        }
        if (index === tagList.length - 1 && width <= maxWidth) {
          this.overflow.chipIndex = -1;
          return;
        }
        this.overflow.chipIndex = width >= maxWidth - 40 ? index : -1;
      },
      initMenu: function initMenu() {
        if (!this.menuInstance) {
          this.menuInstance = new Vue(__vue_component__$1i).$mount();
          this.menuInstance.condition = this.defaultCondition;
          this.menuInstance.displayKey = this.displayKey;
          this.menuInstance.primaryKey = this.primaryKey;
          this.menuInstance.multiable = false;
          this.menuInstance.$on('select', this.handleMenuSelect);
          this.menuInstance.$on('select-conditon', this.handleSelectConditon);
        }
      },
      initChildMenu: function initChildMenu() {
        this.menuChildInstance = new Vue(__vue_component__$1i).$mount();
        this.menuChildInstance.displayKey = this.displayKey;
        this.menuChildInstance.primaryKey = this.primaryKey;
        this.menuChildInstance.multiable = this.curItem.conditions && this.curItem.conditions.length ? false : this.curItem.multiable || false;
        this.menuChildInstance.child = true;
        this.menuChildInstance.remoteEmptyText = this.defaultRemoteEmptyText;
        this.menuChildInstance.remoteLoadingText = this.defaultRemoteLoadingText;
        this.menuChildInstance.$on('select', this.handleMenuChildSelect);
        this.menuChildInstance.$on('select-check', this.handleSelectCheck);
        this.menuChildInstance.$on('select-enter', this.handleKeyEnter);
        this.menuChildInstance.$on('select-cancel', this.handleCancel);
        this.menuChildInstance.$on('child-condition-select', this.handleChildConditionSelect);
      },
      initPopover: function initPopover(el) {
        var _this4 = this;
        if (!this.popperMenuInstance) {
          this.popperMenuInstance = tippy(this.$refs.input, {
            content: el || this.menuInstance.$el,
            arrow: false,
            placement: 'bottom-start',
            trigger: 'manual',
            theme: 'light bk-search-select-theme',
            hideOnClick: false,
            animateFill: false,
            animation: 'slide-toggle',
            lazy: false,
            ignoreAttributes: true,
            boundary: 'window',
            distance: 10 + _parseInt$2(variable_1),
            zIndex: this.popoverZindex,
            onHide: function onHide() {
              _this4.menuInstance && _this4.menuInstance.handleDestroy();
              _this4.menuChildInstance && _this4.menuChildInstance.handleDestroy();
              return true;
            }
          });
        }
      },
      showMenu: function showMenu() {
        var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        if (!this.menuInstance) {
          this.initMenu();
        }
        this.handelePopperEventListener(false);
        this.menuInstance.isCondition = this.showCondition && !!this.chip.list.length && this.chip.list[this.chip.list.length - 1][this.primaryKey] !== this.defaultCondition[this.primaryKey];
        this.menuInstance.list = this.data;
        if (show) {
          this.showPopper(this.menuInstance.$el);
          this.$emit('show-menu', this.menuInstance);
        } else {
          this.hidePopper();
        }
      },
      showChildMenu: function showChildMenu(list, filter) {
        var isShow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        this.menuChildInstance.filter = filter;
        this.menuChildInstance.list = list;
        this.handelePopperEventListener(true);
        isShow && this.showPopper(this.menuChildInstance.$el);
      },
      handelePopperEventListener: function handelePopperEventListener() {
        var isChild = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (isChild) {
          this.menuInstance && this.menuInstance.handleDestroy();
          this.menuChildInstance && this.menuChildInstance.handleMounted();
          return;
        }
        this.menuChildInstance && this.menuChildInstance.handleDestroy();
        this.menuInstance.handleMounted();
      },
      showPopper: function showPopper(el) {
        if (this.data.length) {
          if (!this.popperMenuInstance) {
            this.initPopover();
          } else {
            this.popperMenuInstance.setContent(el);
          }
          this.popperMenuInstance.popperInstance.update();
          this.popperMenuInstance.show(this.showDelay);
        }
      },
      hidePopper: function hidePopper() {
        this.popperMenuInstance && this.popperMenuInstance.hide(0);
      },
      handleInputChange: function handleInputChange(e) {
        this.clearInput();
        var text = e.target.innerText;
        if (/(\r|\n)/gm.test(text) || /\s{2}/gm.test(text)) {
          e.preventDefault();
          text = text.replace(/(\r|\n)/gm, this.splitCode).replace(/\s{2}/gm, '');
          this.$refs.input.innerText = text;
          this.handleInputFocus();
        }
        this.input.value = text;
        this.handleInputSearchPlus(text);
        this.$emit('input-change', e);
      },
      handleSearch: function handleSearch(text) {
        var _this5 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var include, list, filter;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  include = _this5.input.value.includes(_this5.explainCode);
                  list = [];
                  if (!(include && _this5.menuChildInstance)) {
                    _context.next = 16;
                    break;
                  }
                  filter = text.replace(_this5.curItem[_this5.displayKey] + _this5.explainCode, '');
                  if (!(_this5.curItem.remote && typeof _this5.remoteMethod === 'function')) {
                    _context.next = 12;
                    break;
                  }
                  _this5.menuChildInstance.loading = true;
                  _context.next = 8;
                  return _this5.remoteMethod(filter, _this5.curItem, _this5.menu.active).finally(function () {
                    _this5.menuChildInstance.loading = false;
                  });
                case 8:
                  list = _context.sent;
                  if (list && list.length) {
                    _this5.showChildMenu(list, filter, !!list.length);
                  } else {
                    _this5.hidePopper();
                  }
                  _context.next = 14;
                  break;
                case 12:
                  list = _this5.handleFilter(filter);
                  if (list && list.length) {
                    _this5.showChildMenu(list, filter, !!list.length);
                  } else {
                    _this5.hidePopper();
                  }
                case 14:
                  _context.next = 17;
                  break;
                case 16:
                  if (!include && _this5.menuInstance) {
                    list = _this5.handleFilter(text);
                    if (list && list.length) {
                      _this5.menuInstance.filter = text;
                      _this5.menuInstance.list = list;
                      _this5.showPopper(_this5.menuInstance.$el);
                    } else {
                      if (_this5.$refs.input.innerText) {
                        _this5.hidePopper();
                      }
                    }
                  }
                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      handleFilter: function handleFilter(v) {
        var _this6 = this;
        var filterList = [];
        if (!this.input.value.length || !~this.input.value.indexOf(this.explainCode)) {
          if (this.filter && typeof this.filterMenuMethod === 'function') {
            filterList = this.filterMenuMethod(this.data, v);
          } else {
            if (v.length) {
              var _filterList;
              filterList = this.childList.filter(function (item) {
                return item[_this6.displayKey] && ~item[_this6.displayKey].indexOf(v);
              });
              if (filterList.length) {
                var item = filterList[filterList.length - 1];
                item = _objectSpread({}, item, {
                  isGroup: true
                });
                filterList[filterList.length - 1] = item;
              }
              (_filterList = filterList).push.apply(_filterList, _toConsumableArray(this.data.filter(function (item) {
                return item[_this6.displayKey] && ~item[_this6.displayKey].indexOf(v);
              })));
            } else {
              filterList = this.data;
            }
          }
        } else if (this.curItem.children && this.curItem.children.length) {
          if (this.filter && typeof this.filterChildrenMethod === 'function') {
            filterList = this.filterChildrenMethod(this.curItem.children, v);
          } else {
            filterList = this.curItem.children.filter(function (item) {
              return item[_this6.displayKey] && ~item[_this6.displayKey].indexOf(v);
            });
          }
        }
        return filterList;
      },
      handleInputCut: function handleInputCut(e) {
        var selection = document.getSelection();
        if (selection.anchorOffset >= this.input.value.length) {
          this.input.value = '';
        }
        this.$emit('input-cut', e);
      },
      handleInputOutSide: function handleInputOutSide(e) {
        var parent = e.target.offsetParent;
        var classList = parent ? parent.classList : null;
        var unFocus = !parent || classList && !from_1$1(classList.values()).some(function (key) {
          return ['bk-search-select', 'bk-search-list', 'tippy-tooltip', 'bk-form-checkbox', 'search-input-list', 'search-input-chip'].includes(key);
        });
        if (unFocus) {
          this.hidePopper();
          this.input.focus = false;
        }
        this.$emit('input-click-outside', e);
      },
      handleCancel: function handleCancel(e) {
        this.handleClearChildSelectChecked();
        this.hidePopper();
        this.input.focus = false;
        this.$refs.input.focus();
      },
      handleInputClick: function handleInputClick(e) {
        var _this7 = this;
        this.input.focus = true;
        if (!this.input.value) {
          if (!this.menuInstance) {
            this.initMenu();
          }
          this.menuInstance.isCondition = this.showCondition && !!this.chip.list.length && this.chip.list[this.chip.list.length - 1][this.primaryKey] !== this.defaultCondition[this.primaryKey];
          this.menuInstance.list = this.data;
          this.menu.child = false;
          this.$nextTick(function (_) {
            _this7.handelePopperEventListener();
            _this7.showPopper(_this7.menuInstance.$el);
          });
        } else {
          var cur = this.curItem;
          if (cur && (cur.children && cur.children.length || cur.conditions && cur.conditions.length) && this.popperMenuInstance) {
            if (this.menuChildInstance) {
              this.menuChildInstance.error = '';
            }
            this.menu.child = true;
            this.popperMenuInstance.show(this.showDelay);
          } else if (typeof cur.id === 'undefined' && this.menuInstance && this.menuInstance.list.length && this.menuInstance.filter) {
            this.popperMenuInstance.show(this.showDelay);
          }
          this.handelePopperEventListener(true);
        }
        this.$emit('input-click', e);
      },
      handleInputFocus: function handleInputFocus(e) {
        this.input.focus = true;
        var input = this.$refs.input;
        var selection = null;
        if (window.getSelection) {
          selection = window.getSelection();
          selection.selectAllChildren(input);
          selection.collapseToEnd();
        } else if (document.onselectionchange) {
          selection = document.onselectionchange.createRange();
          selection.moveToElementText(input);
          selection.collapse(false);
          selection.select();
        }
        this.$emit('input-focus', e);
      },
      updateChildMenu: function updateChildMenu(item, index, isCondition) {
        var _this8 = this;
        return _asyncToGenerator( regenerator.mark(function _callee2() {
          var isChild, isRemote, list;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  isChild = item.children && item.children.length;
                  if (!isCondition) {
                    _context2.next = 14;
                    break;
                  }
                  _this8.$refs.input.blur();
                  if (!_this8.menuChildInstance || _this8.menuChildInstance.multiable || _this8.menuChildInstance.multiable !== _this8.curItem.multiable) {
                    _this8.initChildMenu();
                  }
                  _this8.menuChildInstance.isChildCondition = isCondition;
                  _this8.menuChildInstance.error = '';
                  _this8.menuChildInstance.loading = false;
                  _this8.menuChildInstance.checked = _this8.menu.checked;
                  _this8.showPopper(_this8.menuChildInstance.$el);
                  _this8.menu.child = false;
                  _this8.menuChildInstance.list = item.conditions;
                  setTimeout(function () {
                    _this8.$refs.input.focus();
                  }, 20);
                  _context2.next = 37;
                  break;
                case 14:
                  isRemote = _this8.curItem.remote && typeof _this8.remoteMethod === 'function';
                  if (!(isChild || isRemote)) {
                    _context2.next = 35;
                    break;
                  }
                  _this8.$refs.input.blur();
                  if (!_this8.menuChildInstance || _this8.menuChildInstance.multiable || _this8.menuChildInstance.multiable !== _this8.curItem.multiable) {
                    _this8.initChildMenu();
                  }
                  _this8.menuChildInstance.isChildCondition = isCondition;
                  _this8.menuChildInstance.error = '';
                  _this8.menuChildInstance.loading = isRemote;
                  _this8.menuChildInstance.checked = _this8.menu.checked;
                  _this8.showPopper(_this8.menuChildInstance.$el);
                  _this8.menu.child = true;
                  if (!isRemote) {
                    _context2.next = 31;
                    break;
                  }
                  _context2.next = 27;
                  return _this8.remoteMethod(_this8.input.value, item, index).finally(function () {
                    _this8.menuChildInstance.loading = false;
                  });
                case 27:
                  list = _context2.sent;
                  _this8.menuChildInstance.list = list;
                  _context2.next = 32;
                  break;
                case 31:
                  _this8.menuChildInstance.list = item.children;
                case 32:
                  setTimeout(function () {
                    _this8.$refs.input.focus();
                  }, 20);
                  _context2.next = 37;
                  break;
                case 35:
                  _this8.hidePopper();
                  setTimeout(function () {
                    _this8.handleInputFocus();
                  }, 20);
                case 37:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      handleMenuSelect: function handleMenuSelect(item, index) {
        var _this9 = this;
        var isChildClick = ~this.data.findIndex(function (set) {
          return set[_this9.primaryKey] === item[_this9.primaryKey];
        });
        if (!isChildClick) {
          this.input.value = item[this.displayKey];
          this.$nextTick().then(function () {
            _this9.updateInput(_this9.input.value);
            _this9.handleKeyEnter();
          });
        } else {
          this.menu.active = ~isChildClick;
          this.menu.id = this.data[this.menu.active][this.primaryKey];
          var isChildCondition = !!(this.curItem.conditions && this.curItem.conditions.length);
          this.input.value = item[this.displayKey] + this.explainCode;
          this.$nextTick().then(function () {
            _this9.updateInput(_this9.input.value);
            _this9.updateChildMenu(item, index, isChildCondition);
            _this9.$emit('menu-select', item, index);
          });
        }
      },
      handleMenuChildSelect: function handleMenuChildSelect(item, index) {
        this.input.value += item[this.displayKey];
        this.updateInput(this.input.value);
        this.handleEnter(this.input.value, item, true);
        this.$emit('menu-child-select', item, index);
      },
      handleChildConditionSelect: function handleChildConditionSelect(item, index) {
        this.input.value += item[this.displayKey];
        this.updateInput(this.input.value);
        this.menu.childCondition = item;
        this.updateChildMenu(this.curItem, index, false);
        this.$emit('menu-child-condition-select', item, index);
      },
      handleInputKeyup: function handleInputKeyup(e) {
        if (this.readonly && !(e.code === 'Backspace')) {
          e.preventDefault();
          return false;
        }
        switch (e.code) {
          case 'Enter':
          case 'NumpadEnter':
            this.handleKeyEnter(e, true, true);
            break;
          case 'Backspace':
            this.handleKeyBackspace(e);
            break;
          case 'ArrowDown':
          case 'ArrowUp':
            e.preventDefault();
            break;
          default:
            if (this.inputType === 'number') {
              var value = this.input.value + '';
              if (!(value === '' && e.key === '-' || value !== '0' && value !== '-0' && e.key === '0' || (value === '0' || value === '-0' || /^-?[1-9]?[0-9]*[1-9]+$/.test(value)) && e.key === '.' || '123456789'.indexOf(e.key) > -1)) {
                e.preventDefault();
                return false;
              }
            }
            this.handleKeyDefault(e);
            return false;
        }
      },
      handleKeyDefault: function handleKeyDefault(e) {
        if (keys$1(this.menu.checked).length) {
          e.preventDefault();
          return false;
        }
      },
      handleKeyBackspace: function handleKeyBackspace(e) {
        var _this10 = this;
        var keys = keys$1(this.menu.checked);
        if (this.curItem.multiable && keys.length) {
          var key = keys[keys.length - 1];
          this.menuChildInstance && this.menuChildInstance.setCheckValue(this.menu.checked[key], false);
          delete this.menu.checked[key];
          this.updateCheckedInputVal();
          e.preventDefault();
          this.handleInputFocus();
          return false;
        }
        var condition = this.menu.childCondition[this.displayKey];
        var curVal = this.curItem[this.displayKey] + this.explainCode;
        if (condition && curVal + condition === this.input.value) {
          this.menu.childCondition = {};
          this.input.value = curVal;
          this.updateInput(this.input.value);
          this.updateChildMenu(this.curItem, this.menu.active, true);
          e.preventDefault();
          return false;
        }
        if (!this.input.value && !(!this.chip.list.length && !this.$refs.input.textContent.length)) {
          var item = this.chip.list.pop();
          this.$nextTick().then(function () {
            _this10.showMenu(_this10.showPopoverTagChange);
          });
          this.$emit('change', this.chip.list);
          this.$emit('key-delete', item);
          this.dispatch('bk-form-item', 'form-change');
        } else {
          if (!this.input.value.includes(this.curItem[this.displayKey] + this.explainCode)) {
            this.menu.active = -1;
            this.menu.id = null;
          } else {
            if (this.readonly) {
              this.updateInput();
              this.handleCancel();
              this.menu.active = -1;
              this.menu.id = null;
              this.input.value = '';
              e.preventDefault();
              return false;
            }
          }
        }
      },
      handleKeyEnter: function handleKeyEnter(e) {
        var _this11 = this;
        var needShowPopover = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var needEmitKeyEnter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return _asyncToGenerator( regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return new promise$1(function (resolve) {
                    if (!_this11.input.value) {
                      resolve();
                    } else if (_this11.input.value === _this11.curItem[_this11.displayKey] + _this11.explainCode) {
                      e.preventDefault();
                      if (!_this11.menuChildInstance) {
                        _this11.initChildMenu();
                      }
                      _this11.menuChildInstance.error = _this11.defaultEmptyText;
                      _this11.$nextTick(function (_) {
                        _this11.showPopper(_this11.menuChildInstance.$el);
                      });
                      _this11.handleInputFocus();
                      resolve();
                    } else {
                      setTimeout(function () {
                        if (_this11.menu.id !== null) {
                          var _this11$handleEnter;
                          var val = _this11.input.value.replace(_this11.curItem[_this11.displayKey] + _this11.explainCode, '');
                          if (keys$1(_this11.menu.childCondition).length) {
                            val = val.replace(_this11.menu.childCondition[_this11.displayKey], '');
                          }
                          _this11.handleEnter(_this11.input.value, (_this11$handleEnter = {}, _defineProperty(_this11$handleEnter, _this11.primaryKey, val), _defineProperty(_this11$handleEnter, _this11.displayKey, val), _this11$handleEnter), true, needShowPopover);
                        } else {
                          var _this11$handleEnter2;
                          _this11.handleEnter(_this11.input.value, (_this11$handleEnter2 = {}, _defineProperty(_this11$handleEnter2, _this11.primaryKey, _this11.input.value), _defineProperty(_this11$handleEnter2, _this11.displayKey, _this11.input.value), _this11$handleEnter2), false, needShowPopover);
                        }
                        resolve();
                      }, 0);
                    }
                  });
                case 2:
                  needEmitKeyEnter && _this11.$emit('key-enter', e);
                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      handleValidate: function handleValidate(valList) {
        var _this12 = this;
        return _asyncToGenerator( regenerator.mark(function _callee4() {
          var validate, selection;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  validate = true;
                  if (!(_this12.curItem && _this12.curItem.validate && typeof _this12.curItem.validate === 'function')) {
                    _context4.next = 8;
                    break;
                  }
                  _context4.next = 4;
                  return _this12.curItem.validate(_toConsumableArray(valList), _this12.curItem);
                case 4:
                  validate = _context4.sent;
                  if (typeof validate === 'string') {
                    _this12.validateStr = validate;
                    validate = false;
                  } else {
                    validate && (_this12.validateStr = '');
                  }
                  _context4.next = 9;
                  break;
                case 8:
                  _this12.validateStr = '';
                case 9:
                  if (!validate) {
                    selection = window.getSelection();
                    if (selection.focusOffset === 0) {
                      selection.selectAllChildren(_this12.$refs.input);
                      selection.collapseToEnd();
                    }
                  }
                  return _context4.abrupt("return", validate);
                case 11:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },
      handleEnter: function handleEnter(val, item) {
        var _this13 = this;
        var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var needShowPopover = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        return _asyncToGenerator( regenerator.mark(function _callee5() {
          var values, data, validate, _validate;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  if (!child) {
                    _context5.next = 19;
                    break;
                  }
                  if (!(_this13.input.value === _this13.defaultCondition[_this13.displayKey])) {
                    _context5.next = 5;
                    break;
                  }
                  _this13.chip.list.push(_this13.defaultCondition);
                  _context5.next = 17;
                  break;
                case 5:
                  values = [];
                  if (keys$1(_this13.menu.checked).length) {
                    values = values$1(_this13.menu.checked);
                  } else {
                    values.push(item);
                  }
                  data = _extends({}, _this13.curItem, {
                    values: values
                  });
                  if (keys$1(_this13.menu.childCondition).length) {
                    data['condition'] = _this13.menu.childCondition;
                  }
                  if (data.children) {
                    delete data.children;
                  }
                  if (data.conditions) {
                    delete data.conditions;
                  }
                  _context5.next = 13;
                  return _this13.handleValidate(values);
                case 13:
                  validate = _context5.sent;
                  if (validate) {
                    _context5.next = 16;
                    break;
                  }
                  return _context5.abrupt("return");
                case 16:
                  _this13.chip.list.push(data);
                case 17:
                  _context5.next = 25;
                  break;
                case 19:
                  _context5.next = 21;
                  return _this13.handleValidate([item]);
                case 21:
                  _validate = _context5.sent;
                  if (_validate) {
                    _context5.next = 24;
                    break;
                  }
                  return _context5.abrupt("return");
                case 24:
                  _this13.chip.list.push(item);
                case 25:
                  _this13.menu.checked = {};
                  _this13.menu.active = -1;
                  _this13.menu.id = null;
                  _this13.input.value = '';
                  _this13.menu.childCondition = {};
                  _this13.updateInput();
                  if (_this13.menuInstance) {
                    _this13.menuInstance.filter = '';
                  }
                  if (needShowPopover) {
                    _this13.$nextTick(function (_) {
                      return _this13.showMenu(_this13.showPopoverTagChange);
                    });
                    _this13.$refs.input.focus();
                  }
                  _this13.$emit('change', _this13.chip.list);
                  _this13.dispatch('bk-form-item', 'form-change');
                case 35:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },
      handleClear: function handleClear(index, item) {
        var _this14 = this;
        var name = this.chip.list.splice(index, 1);
        setTimeout(function () {
          _this14.popperMenuInstance && _this14.popperMenuInstance.popperInstance && _this14.popperMenuInstance.popperInstance.update();
          !_this14.input.value.length && _this14.showMenu();
          _this14.$emit('change', _this14.chip.list);
          _this14.$emit('chip-del', name);
          _this14.dispatch('bk-form-item', 'form-change');
        }, 0);
      },
      handleSelectConditon: function handleSelectConditon(item) {
        this.input.value = item[this.displayKey];
        this.updateInput(this.input.value);
        this.handleEnter(this.input.value, item, true);
        this.$emit('condition-select', item);
      },
      handleSelectCheck: function handleSelectCheck(item, index) {
        var next = !this.menu.checked[item[this.primaryKey]];
        if (next) {
          this.menu.checked[item[this.primaryKey]] = item;
        } else {
          delete this.menu.checked[item[this.primaryKey]];
        }
        this.menuChildInstance.checked = this.menu.checked;
        this.updateCheckedInputVal();
        this.handlePopoverCheckUpdate();
        this.popperMenuInstance.popperInstance.update();
        this.$emit('child-checked', item, index, next);
      },
      handleClearChildSelectChecked: function handleClearChildSelectChecked() {
        this.menu.checked = {};
        this.menuChildInstance.checked = this.menu.checked;
        this.updateCheckedInputVal();
        this.handlePopoverCheckUpdate();
        this.popperMenuInstance.popperInstance.update();
      },
      handleWrapClick: function handleWrapClick() {
        if (this.shrink) {
          this.$refs.input.focus();
        }
      },
      updateCheckedInputVal: function updateCheckedInputVal() {
        var _this15 = this;
        if (this.menu.id !== null) {
          var val = values$1(this.menu.checked).map(function (set) {
            return set[_this15.displayKey];
          }).join(this.splitCode);
          this.input.value = this.curItem[this.displayKey] + this.explainCode + val;
          this.updateInput(this.input.value);
        }
      },
      updateInput: function updateInput() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        this.$refs.input.innerText = val;
      },
      clearInput: function clearInput() {
        var text = this.$refs.input.innerText;
        if (text[text.length - 1] === '\n' || text[0] === '\r') {
          this.updateInput(text.slice(0, -1));
          this.clearInput();
        } else if (text[0] === '\n' || text[0] === '\r') {
          this.updateInput(text.slice(1));
          this.clearInput();
        }
      },
      handlePopoverCheckUpdate: function handlePopoverCheckUpdate() {
        var distance = this.popperMenuInstance.props.distance;
        var height = this.$refs.wrap.clientHeight;
        if (-height !== distance) {
          this.popperMenuInstance.popperInstance.update();
        }
      },
      handleClearAll: function handleClearAll(e) {
        this.menu.active = -1;
        this.menu.id = null;
        this.input.value = '';
        this.menuInstance = null;
        this.updateInput(this.input.value);
        this.clearInput();
        this.values.splice(0, this.values.length);
        this.$emit('clear', e);
      },
      handleClickSearch: function handleClickSearch(e) {
        this.handleKeyEnter(e, false, false);
        this.$emit('search', e);
      },
      getMenuInstance: function getMenuInstance() {
        return this.menuInstance;
      },
      getChildMenuInstance: function getChildMenuInstance() {
        return this.menuChildInstance;
      },
      getInputInstance: function getInputInstance() {
        return this.$refs.input;
      }
    }
  };

  /* script */
  var __vue_script__$1h = script$1h;
  /* template */

  var __vue_render__$1i = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', _vm._b({
      staticClass: "search-select-wrap",
      class: _vm.extCls,
      style: {
        'z-index': _vm.wrapZindex
      }
    }, 'div', _vm.$attrs, false), [_c('div', {
      ref: "wrap",
      staticClass: "bk-search-select",
      class: {
        'is-focus': _vm.input.focus
      },
      on: {
        "click": _vm.handleWrapClick
      }
    }, [_c('div', {
      staticClass: "search-prefix"
    }, [_vm._t("prefix")], 2), _c('div', {
      staticClass: "search-input",
      style: {
        maxHeight: (_vm.shrink ? _vm.input.focus ? _vm.maxHeight : _vm.minHeight : _vm.maxHeight) + 'px'
      }
    }, [_vm._l(_vm.chip.list, function (item, index) {
      return [(_vm.overflow.chipIndex >= 0 ? index < _vm.overflow.chipIndex : index >= 0) ? _c('div', {
        key: index + "_pre_key",
        staticClass: "search-input-chip"
      }, [_c('span', {
        staticClass: "chip-name"
      }, [_vm._v("\n                        " + _vm._s(item[_vm.displayKey] + (item.values && item.values.length ? _vm.explainCode + (item.condition ? item.condition[_vm.displayKey] : '') + item.values.map(function (v) {
        return v[_vm.displayKey];
      }).join(_vm.splitCode) : '')) + "\n                    ")]), _c('span', {
        staticClass: "chip-clear bk-icon icon-close",
        on: {
          "click": function click($event) {
            _vm.handleClear(index, item);
          }
        }
      })]) : _vm._e()];
    }), _vm.chip.list.length && _vm.overflow.chipIndex >= 0 ? _c('div', {
      staticClass: "search-input-chip overflow-chip",
      staticStyle: {
        "padding-right": "8px"
      }
    }, [_vm._v("+" + _vm._s(_vm.chip.list.length - _vm.overflow.chipIndex))]) : _vm._e(), _vm.chip.list.length && _vm.overflow.chipIndex >= 0 ? [_vm._l(_vm.chip.list, function (item, index) {
      return [index >= _vm.overflow.chipIndex ? _c('div', {
        key: index + "_next_key",
        staticClass: "search-input-chip hidden-chip"
      }, [_c('span', {
        staticClass: "chip-name"
      }, [_vm._v("\n                            " + _vm._s(item[_vm.displayKey] + (item.values && item.values.length ? _vm.explainCode + (item.condition ? item.condition[_vm.displayKey] : '') + item.values.map(function (v) {
        return v[_vm.displayKey];
      }).join(_vm.splitCode) : '')) + "\n                        ")]), _c('span', {
        staticClass: "chip-clear bk-icon icon-close",
        on: {
          "click": function click($event) {
            _vm.handleClear(index, item);
          }
        }
      })]) : _vm._e()];
    })] : _vm._e(), _c('div', {
      staticClass: "search-input-input"
    }, [_c('div', {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleInputOutSide,
        expression: "handleInputOutSide"
      }],
      ref: "input",
      staticClass: "div-input",
      class: {
        'input-before': !_vm.chip.list.length && !_vm.input.value.length,
        'input-after': _vm.showItemPlaceholder
      },
      attrs: {
        "contenteditable": "plaintext-only",
        "data-placeholder": _vm.defaultPlaceholder,
        "data-tips": _vm.curItem.placeholder || '',
        "spellcheck": "false"
      },
      on: {
        "click": _vm.handleInputClick,
        "focus": _vm.handleInputFocus,
        "cut": _vm.handleInputCut,
        "input": _vm.handleInputChange,
        "keydown": _vm.handleInputKeyup
      }
    })])], 2), _c('div', {
      staticClass: "search-nextfix"
    }, [_vm.clearable && (_vm.chip.list.length || _vm.input.value.length) ? _c('i', {
      staticClass: "search-clear bk-icon icon-close-circle-shape",
      on: {
        "click": function click($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          return _vm.handleClearAll($event);
        }
      }
    }) : _vm._e(), _vm._t("nextfix", [_c('i', {
      staticClass: "bk-icon icon-search search-nextfix-icon",
      class: {
        'is-focus': _vm.input.focus
      },
      on: {
        "click": function click($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          return _vm.handleClickSearch($event);
        }
      }
    })])], 2)]), _vm.validateStr.length ? _c('div', {
      staticClass: "bk-select-tips"
    }, [_vm._t("validate", [_c('i', {
      staticClass: "bk-icon icon-exclamation-circle-shape select-tips"
    }), _vm._v(_vm._s(_vm.validateStr || '') + "\n        ")])], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__$1i = [];
  /* style */

  var __vue_inject_styles__$1j = undefined;
  /* scoped */

  var __vue_scope_id__$1j = undefined;
  /* module identifier */

  var __vue_module_identifier__$1j = undefined;
  /* functional template */

  var __vue_is_functional_template__$1j = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1j = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1i,
    staticRenderFns: __vue_staticRenderFns__$1i
  }, __vue_inject_styles__$1j, __vue_script__$1h, __vue_scope_id__$1j, __vue_is_functional_template__$1j, __vue_module_identifier__$1j, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1j);

  var getNodeId = function getNodeId(data, tree) {
    var idKey = tree.nodeOptions.idKey;
    if (typeof idKey === 'function') {
      return idKey(data);
    }
    return data[idKey];
  };
  var getNodeIcon = function getNodeIcon(data, tree) {
    var icon = {
      expand: tree.expandIcon,
      collapse: tree.collapseIcon,
      node: tree.nodeIcon
    };
    if (typeof icon.node === 'function') {
      icon.node = icon.node(data);
    }
    return icon;
  };
  var isNullOrUndefined = function isNullOrUndefined(value) {
    return value === null || value === undefined;
  };
  var convertToArray = function convertToArray(value) {
    return isArray$1(value) ? value : [value];
  };
  var checkIsLazy = function checkIsLazy(node, tree) {
    if (typeof tree.lazyMethod !== 'function') {
      return false;
    }
    if (typeof tree.lazyDisabled === 'boolean') {
      return !tree.lazyDisabled;
    } else if (typeof tree.lazyDisabled === 'function') {
      return !tree.lazyDisabled(node);
    }
    return true;
  };

  var TreeNode = function () {
    function TreeNode(data, options, tree) {
      var _this = this;
      _classCallCheck(this, TreeNode);
      var folderKey = tree.nodeOptions['folderKey'];
      var isFolder = folderKey && data[folderKey];
      var sealData = {
        data: data,
        tree: tree,
        _vNode: null,
        id: getNodeId(data, tree),
        icon: getNodeIcon(data, tree),
        line: 0,
        level: options.level,
        index: options.index,
        childIndex: options.childIndex || 0,
        parent: options.parent,
        children: [],
        timer: null,
        isFolder: isFolder
      };
      keys$1(sealData).forEach(function (key) {
        defineProperty$1(_this, key, {
          enumerable: true,
          configurable: tree.configurable,
          writable: true,
          value: sealData[key]
        });
      });
      this.state = {
        checked: false,
        expanded: tree.defaultExpandAll,
        disabled: false,
        visible: true,
        matched: true,
        loading: false,
        lazy: checkIsLazy(this, tree)
      };
    }
    _createClass(TreeNode, [{
      key: "uid",
      get: function get() {
        return "".concat(this.tree.id, "-node-").concat(this.index);
      }
    }, {
      key: "name",
      get: function get() {
        return this.data[this.tree.nodeOptions.nameKey];
      }
    }, {
      key: "vNode",
      get:
      function get() {
        return this._vNode;
      }
      ,
      set: function set(vNode) {
        this._vNode = vNode;
        if (this.expanded) {
          this.recalculateLinkLine();
        }
      }
    }, {
      key: "parents",
      get: function get() {
        if (!this.parent) {
          return [];
        }
        return [].concat(_toConsumableArray(this.parent.parents), [this.parent]);
      }
    }, {
      key: "descendants",
      get: function get() {
        var descendants = [];
        this.children.forEach(function (node) {
          descendants.push(node);
          descendants.push.apply(descendants, _toConsumableArray(node.descendants));
        });
        return descendants;
      }
    }, {
      key: "isLeaf",
      get: function get() {
        return !this.lazy && !this.loading && !this.children.length;
      }
    }, {
      key: "lazy",
      get: function get() {
        return this.state.lazy && !this.children.length;
      }
    }, {
      key: "loading",
      get: function get() {
        return this.state.loading;
      }
    }, {
      key: "hasCheckbox",
      get: function get() {
        var showCheckbox = this.tree.showCheckbox;
        if (typeof showCheckbox === 'function') {
          return showCheckbox(this.data);
        }
        return showCheckbox;
      }
    }, {
      key: "collapseIcon",
      get: function get() {
        return this.icon.collapse;
      }
    }, {
      key: "selected",
      get: function get() {
        return this.tree.selectable && this.tree.selected === this.id;
      }
    }, {
      key: "expandIcon",
      get: function get() {
        return this.icon.expand;
      }
    }, {
      key: "nodeIcon",
      get: function get() {
        return this.icon.node;
      }
    }, {
      key: "checked",
      get: function get() {
        return this.state.checked;
      },
      set: function set(checked) {
        if (this.state.checked === checked && !this.indeterminate) {
          return false;
        }
        this.setState('checked', checked);
        if (this.tree.checkStrictly) {
          this.children.forEach(function (child) {
            if (child.checkable) {
              child.checked = checked;
            }
          });
          if (this.parent) {
            this.parents.reverse().forEach(function (parent) {
              if (checked) {
                var parentChecked = !parent.children.some(function (node) {
                  return !node.checked;
                });
                parent.setState('checked', parentChecked);
              } else {
                parent.setState('checked', false);
              }
            });
          }
        }
      }
    }, {
      key: "checkable",
      get: function get() {
        if (this.disabled) {
          return false;
        }
        if (this.tree.inSearch && this.tree.checkOnlyAvailableStrictly) {
          if (this.tree.displayMatchedNodeDescendants) {
            return this.matched || this.childrenMatched || this.parentsMatched;
          }
          return this.matched || this.childrenMatched;
        }
        return true;
      }
    }, {
      key: "expanded",
      get: function get() {
        return this.state.expanded;
      },
      set: function set(expanded) {
        var _this2 = this;
        if (this.state.expanded === expanded) {
          return false;
        }
        this.setState('expanded', expanded);
        if (expanded && this.parent) {
          this.parent.expanded = true;
        }
        this.children.forEach(function (node) {
          node.visible = expanded;
        });
        this.tree.$nextTick( _asyncToGenerator( regenerator.mark(function _callee() {
          var _yield$_this2$tree$la, _yield$_this2$tree$la2, leaf, _yield$_this2$tree$la3, data, newNodes;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(expanded && _this2.lazy)) {
                    _context.next = 21;
                    break;
                  }
                  _this2.setState('loading', true);
                  _this2.setState('lazy', false);
                  _context.prev = 3;
                  _context.next = 6;
                  return _this2.tree.lazyMethod(_this2);
                case 6:
                  _yield$_this2$tree$la = _context.sent;
                  _yield$_this2$tree$la2 = _yield$_this2$tree$la.leaf;
                  leaf = _yield$_this2$tree$la2 === void 0 ? [] : _yield$_this2$tree$la2;
                  _yield$_this2$tree$la3 = _yield$_this2$tree$la.data;
                  data = _yield$_this2$tree$la3 === void 0 ? [] : _yield$_this2$tree$la3;
                  newNodes = _this2.tree.addNode(data, _this2.id);
                  newNodes.forEach(function (node) {
                    if (leaf.includes(node.id)) {
                      node.setState('lazy', false);
                    }
                  });
                  _context.next = 18;
                  break;
                case 15:
                  _context.prev = 15;
                  _context.t0 = _context["catch"](3);
                  console.error(_context.t0);
                case 18:
                  _context.prev = 18;
                  _this2.setState('loading', false);
                  return _context.finish(18);
                case 21:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[3, 15, 18, 21]]);
        })));
        this.recalculateLinkLine();
      }
    }, {
      key: "disabled",
      get: function get() {
        return this.state.disabled;
      },
      set: function set(disabled) {
        if (this.state.disabled === disabled) {
          return false;
        }
        this.setState('disabled', disabled);
        if (this.tree.disableStrictly) {
          this.descendants.forEach(function (descendant) {
            descendant.disabled = disabled;
          });
        }
      }
    }, {
      key: "matched",
      get: function get() {
        return this.state.matched;
      },
      set: function set(matched) {
        this.setState('matched', matched);
      }
    }, {
      key: "childrenMatched",
      get: function get() {
        return this.children.some(function (child) {
          return child.matched || child.childrenMatched;
        });
      }
    }, {
      key: "parentsMatched",
      get: function get() {
        return this.parents.some(function (parent) {
          return parent.matched;
        });
      }
    }, {
      key: "visible",
      get: function get() {
        var basicVisible = this.parent ? this.parent.expanded && this.state.visible : this.state.visible;
        if (!this.tree.inSearch) {
          return basicVisible;
        }
        var searchVisible = basicVisible && (this.matched || this.childrenMatched);
        if (this.tree.displayMatchedNodeDescendants) {
          var parentMatchedVisible = basicVisible && this.parentsMatched;
          return searchVisible || parentMatchedVisible;
        }
        return searchVisible;
      },
      set: function set(visible) {
        if (this.state.visible === visible) {
          return false;
        }
        this.setState('visible', visible);
        this.children.forEach(function (node) {
          node.visible = visible;
        });
      }
    }, {
      key: "indeterminate",
      get: function get() {
        if (this.tree.checkStrictly) {
          var childrenIndeterminate = this.children.some(function (child) {
            return child.indeterminate;
          });
          if (childrenIndeterminate) {
            return true;
          }
          var checkedChildren = this.children.filter(function (child) {
            return child.checked;
          });
          return !!checkedChildren.length && checkedChildren.length !== this.children.length;
        }
        return false;
      }
    }, {
      key: "setState",
      value: function setState(key, value) {
        if (this.state.hasOwnProperty(key)) {
          this.state[key] = value;
        }
      }
    }, {
      key: "recalculateLinkLine",
      value: function recalculateLinkLine() {
        if (this.tree.hasLine) {
          var needsCalculateNodes = this.tree.needsCalculateNodes;
          if (needsCalculateNodes.includes(this)) {
            return false;
          }
          needsCalculateNodes.push(this);
          this.parent && this.parent.recalculateLinkLine();
        }
      }
    }, {
      key: "appendChild",
      value: function appendChild(node, offset, options) {
        var _this$children;
        var nodes = isArray$1(node) ? node : [node];
        (_this$children = this.children).splice.apply(_this$children, [offset, 0].concat(_toConsumableArray(nodes)));
        this.children.slice(offset).forEach(function (node, index) {
          node.childIndex = offset + index;
        });
        this.expanded = options.expandParent;
        this.recalculateLinkLine();
        return nodes;
      }
    }, {
      key: "removeChild",
      value: function removeChild(node) {
        var _this3 = this;
        var nodes = isArray$1(node) ? node : [node];
        var removedChildIndex = [];
        var removedIndex = [];
        nodes.forEach(function (node) {
          var childIndex = node.childIndex;
          removedChildIndex.push(childIndex);
          removedIndex.push(node.index);
          _this3.children.splice(childIndex, 1);
        });
        var minIndex = Math.min.apply(Math, removedChildIndex);
        this.children.slice(minIndex).forEach(function (node, index) {
          node.childIndex = minIndex + index;
        });
        this.recalculateLinkLine();
        return nodes;
      }
    }]);
    return TreeNode;
  }();

  /* script */

  /* template */
  var __vue_render__$1j = function __vue_render__(_h, _vm) {
    var _c = _vm._c;
    return _vm.props.node.visible ? _c('div', {
      staticClass: "bk-big-tree-node clearfix",
      class: {
        'is-root': _vm.props.node.parent === null,
        'is-leaf': !_vm.props.node.isFolder && _vm.props.node.isLeaf,
        'is-folder': _vm.props.node.isFolder,
        'is-expand': _vm.props.node.expanded,
        'is-selected': _vm.props.node.selected,
        'is-disabled': _vm.props.node.disabled,
        'is-checked': _vm.props.node.checked,
        'has-link-line': _vm.props.node.tree.hasLine
      },
      style: {
        '--level': _vm.props.node.level,
        '--line': _vm.props.node.line,
        '--padding': _vm.props.node.tree.padding + "px"
      },
      attrs: {
        "id": _vm.props.node.uid
      },
      on: {
        "click": function click($event) {
          _vm.props.node.tree.handleNodeClick(_vm.props.node);
        }
      }
    }, [_c('div', {
      staticClass: "node-options fl"
    }, [_vm.props.node.loading ? _c('i', {
      class: _vm.props.node.tree.loadingClass
    }) : _vm.props.node.isFolder || !_vm.props.node.isLeaf ? _c('i', {
      class: ['node-folder-icon', _vm.props.node.expanded ? _vm.props.node.expandIcon : _vm.props.node.collapseIcon],
      on: {
        "click": function click($event) {
          $event.stopPropagation();

          _vm.props.node.tree.handleNodeExpand(_vm.props.node);
        }
      }
    }) : _vm._e(), _vm.props.node.hasCheckbox ? _c('span', {
      staticClass: "node-checkbox",
      class: {
        'is-disabled': _vm.props.node.disabled,
        'is-checked': _vm.props.node.checked,
        'is-indeterminate': _vm.props.node.indeterminate
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();

          _vm.props.node.tree.handleNodeCheck(_vm.props.node);
        }
      }
    }) : _vm._e(), _vm.props.node.nodeIcon ? _c('i', {
      class: ['node-icon', _vm.props.node.nodeIcon]
    }) : _vm._e()]), _c('div', {
      staticClass: "node-content"
    }, [_vm._t("default", [_vm._v("\n            " + _vm._s(_vm.props.node.name) + "\n        ")], {
      node: _vm.props.node,
      data: _vm.props.node.data
    })], 2)]) : _vm._e();
  };

  var __vue_staticRenderFns__$1j = [];
  /* style */

  var __vue_inject_styles__$1k = undefined;
  /* scoped */

  var __vue_scope_id__$1k = undefined;
  /* module identifier */

  var __vue_module_identifier__$1k = undefined;
  /* functional template */

  var __vue_is_functional_template__$1k = true;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1k = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1j,
    staticRenderFns: __vue_staticRenderFns__$1j
  }, __vue_inject_styles__$1k, {}, __vue_scope_id__$1k, __vue_is_functional_template__$1k, __vue_module_identifier__$1k, false, undefined, undefined, undefined);

  var idSeed = 0;
  var script$1i = {
    name: 'bk-big-tree',
    components: {
      bkVirtualScroll: __vue_component__$J,
      treeItem: __vue_component__$1k
    },
    mixins: [locale.mixin],
    props: {
      data: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      lazyMethod: Function,
      lazyDisabled: [Boolean, Function],
      selectable: Boolean,
      showCheckbox: [Boolean, Function],
      checkStrictly: {
        type: Boolean,
        default: true
      },
      checkOnlyAvailableStrictly: Boolean,
      disableStrictly: {
        type: Boolean,
        default: true
      },
      displayMatchedNodeDescendants: Boolean,
      showLinkLine: Boolean,
      expandIcon: {
        type: String,
        default: 'bk-icon icon-down-shape'
      },
      collapseIcon: {
        type: String,
        default: 'bk-icon icon-right-shape'
      },
      loadingClass: {
        type: String,
        default: 'node-loading'
      },
      nodeIcon: {
        type: [String, Function]
      },
      defaultExpandAll: Boolean,
      defaultExpandedNodes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      defaultCheckedNodes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      defaultSelectedNode: {
        type: [String, Number],
        default: null
      },
      defaultDisabledNodes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      beforeSelect: Function,
      beforeCheck: Function,
      expandOnClick: {
        type: Boolean,
        default: true
      },
      checkOnClick: Boolean,
      filterMethod: Function,
      nodeWidth: {
        type: [String, Number]
      },
      extCls: {
        type: String,
        default: ''
      },
      useDefaultEmpty: Boolean,
      height: Number,
      nodeHeight: {
        type: Number,
        default: 32
      },
      configurable: {
        type: Boolean,
        default: true
      },
      padding: {
        type: Number,
        default: 16
      },
      size: {
        type: String,
        default: 'normal'
      }
    },
    data: function data() {
      return {
        nodes: [],
        map: {},
        selected: this.defaultSelectedNode,
        needsCalculateNodes: [],
        calculateTimer: null,
        inSearch: false,
        isSearchEmpty: false,
        id: "bk-big-tree-".concat(idSeed++)
      };
    },
    computed: {
      computedNodeWidth: function computedNodeWidth() {
        var parsedWidth = _parseInt$2(this.nodeWidth);
        if (isNaN(parsedWidth)) {
          return null;
        }
        return parsedWidth;
      },
      nodeOptions: function nodeOptions() {
        var nodeOptions = {
          idKey: 'id',
          nameKey: 'name',
          childrenKey: 'children'
        };
        return _extends(nodeOptions, this.options);
      },
      checkedNodes: function checkedNodes() {
        return this.nodes.filter(function (node) {
          return node.checked && node.hasCheckbox;
        });
      },
      checked: function checked() {
        return this.checkedNodes.map(function (node) {
          return node.id;
        });
      },
      visibleNodes: function visibleNodes() {
        return this.nodes.filter(function (node) {
          return !!node.visible;
        });
      },
      treeHeight: function treeHeight() {
        return this.height ? "".concat(this.height, "px") : 'auto';
      },
      hasLine: function hasLine() {
        return !this.height && this.showLinkLine;
      }
    },
    watch: {
      needsCalculateNodes: function needsCalculateNodes() {
        this.handleCalculateLine();
      },
      data: function data(value) {
        this.setData(value);
      },
      hasLine: function hasLine(_hasLine) {
        var _this$needsCalculateN;
        _hasLine && (_this$needsCalculateN = this.needsCalculateNodes).push.apply(_this$needsCalculateN, _toConsumableArray(this.visibleNodes));
      }
    },
    mounted: function mounted() {
      this.setData(this.data);
    },
    methods: {
      setData: function setData(data) {
        var _this$needsCalculateN2;
        var nodes = [];
        var map = {};
        this.recurrenceNodes(data, null, nodes, map);
        this.nodes = nodes;
        this.map = map;
        this.initNodeState();
        this.setVirtualScrollList();
        this.registryOptions(this.nodes);
        this.hasLine && (_this$needsCalculateN2 = this.needsCalculateNodes).push.apply(_this$needsCalculateN2, _toConsumableArray(this.visibleNodes));
      },
      registryOptions: function registryOptions(nodes) {
        var parent = this.$parent.$parent || this.$root;
        var name = parent.$options.name;
        if (name && name === 'bk-select' && parent.registerOption) {
          parent.autoUpdate = true;
          nodes.forEach(function (node) {
            parent.registerOption({
              id: node.id,
              name: node.name,
              disabled: node.disabled,
              unmatched: false,
              isHighlight: false
            });
          });
        }
      },
      recurrenceNodes: function recurrenceNodes(data, parent, nodes, map) {
        var _this = this;
        data.forEach(function (datum, index) {
          var node = new TreeNode(datum, {
            level: parent ? parent.level + 1 : 0,
            parent: parent,
            index: nodes.length
          }, _this);
          if (parent) {
            node.childIndex = parent.children.length;
            parent.children.push(node);
          }
          nodes.push(node);
          map[node.id] = node;
          var children = datum[_this.nodeOptions.childrenKey];
          if (isArray$1(children) && children.length) {
            _this.recurrenceNodes(children, node, nodes, map);
          }
        });
      },
      getNodeById: function getNodeById(id) {
        return this.map[id];
      },
      initNodeState: function initNodeState() {
        !this.defaultExpandAll && this.initDefaultExpanded();
        this.initDefaultChecked();
        this.initDefaultDisabled();
      },
      initDefaultExpanded: function initDefaultExpanded() {
        var _this2 = this;
        var defaultExpandedNodes = this.defaultSelectedNode !== null ? [].concat(_toConsumableArray(this.defaultExpandedNodes), [this.defaultSelectedNode]) : this.defaultExpandedNodes;
        defaultExpandedNodes.forEach(function (id) {
          var node = _this2.getNodeById(id);
          if (node) {
            node.expanded = true;
          }
        });
      },
      initDefaultChecked: function initDefaultChecked() {
        var _this3 = this;
        this.defaultCheckedNodes.forEach(function (id) {
          var node = _this3.getNodeById(id);
          if (node) {
            node.checked = true;
          }
        });
      },
      initDefaultDisabled: function initDefaultDisabled() {
        var _this4 = this;
        this.defaultDisabledNodes.forEach(function (id) {
          var node = _this4.getNodeById(id);
          if (node) {
            node.disabled = true;
          }
        });
      },
      addNode: function addNode(nodeData, parentId) {
        var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var options = _typeof(parentId) === 'object' ? parentId : {
          parentId: parentId,
          trailing: trailing
        };
        var mergeOptions = _extends({
          parentId: null,
          trailing: true,
          expandParent: true
        }, options);
        var data = convertToArray(nodeData);
        if (!data.length) {
          return [];
        }
        if (isNullOrUndefined(mergeOptions.parentId)) {
          return this.addRootNode(data, mergeOptions);
        }
        return this.addChildNode(data, mergeOptions);
      },
      addRootNode: function addRootNode(data, _ref) {
        var _this5 = this,
            _this$nodes;
        var trailing = _ref.trailing;
        var rootNodes = this.nodes.filter(function (node) {
          return node.level === 0;
        });
        var offset = typeof trailing === 'number' ? Math.min(trailing, rootNodes.length) : trailing ? rootNodes.length : 0;
        var insertIndex = 0;
        if (offset > 0) {
          var referenceRoot = rootNodes[offset - 1];
          var referenceRootWithDescendants = [referenceRoot].concat(_toConsumableArray(referenceRoot.descendants));
          var referenceNode = referenceRootWithDescendants[referenceRootWithDescendants.length - 1];
          insertIndex = referenceNode.index + 1;
        }
        var nodes = data.map(function (datum) {
          return new TreeNode(datum, {
            level: 0,
            parent: null
          }, _this5);
        });
        nodes.forEach(function (node) {
          _this5.$set(_this5.map, node.id, node);
        });
        (_this$nodes = this.nodes).splice.apply(_this$nodes, [insertIndex, 0].concat(_toConsumableArray(nodes)));
        this.nodes.slice(insertIndex).forEach(function (node, index) {
          node.index = insertIndex + index;
        });
        this.setVirtualScrollList();
        return nodes;
      },
      addChildNode: function addChildNode(data, options) {
        var _this6 = this,
            _this$nodes2;
        var parentId = options.parentId,
            trailing = options.trailing;
        var parent = this.getNodeById(parentId);
        if (!parent) {
          console.warn('Unexpected parent id, add node failed');
          return;
        }
        var children = parent.children;
        var offset = typeof trailing === 'number' ? Math.min(trailing, children.length) : trailing ? children.length : 0;
        var insertIndex;
        if (offset > 0) {
          var referenceChild = children[offset - 1];
          var referenceChildWithDescendants = [referenceChild].concat(_toConsumableArray(referenceChild.descendants));
          var referenceNode = referenceChildWithDescendants[referenceChildWithDescendants.length - 1];
          insertIndex = referenceNode.index + 1;
        } else {
          insertIndex = parent.index + 1;
        }
        var nodes = data.map(function (datum) {
          return new TreeNode(datum, {
            level: parent.level + 1,
            parent: parent
          }, _this6);
        });
        parent.appendChild(nodes, offset, options);
        nodes.forEach(function (node) {
          _this6.$set(_this6.map, node.id, node);
        });
        (_this$nodes2 = this.nodes).splice.apply(_this$nodes2, [insertIndex, 0].concat(_toConsumableArray(nodes)));
        this.nodes.slice(insertIndex).forEach(function (node, index) {
          node.index = insertIndex + index;
        });
        this.setVirtualScrollList();
        return nodes;
      },
      removeNode: function removeNode(nodeId) {
        var _this7 = this;
        try {
          var ids = convertToArray(nodeId);
          var nodes = [];
          ids.forEach(function (id) {
            var node = _this7.getNodeById(id);
            if (node) {
              nodes.push(node);
            }
          });
          nodes.sort(function (M, N) {
            return N.index - M.index;
          });
          nodes.forEach(function (node) {
            var removeNodes = [node].concat(_toConsumableArray(node.descendants));
            _this7.nodes.splice(node.index, removeNodes.length);
            if (node.parent) {
              node.parent.removeChild(node);
            }
          });
          var minChangedIndex = Math.min.apply(Math, _toConsumableArray(nodes.map(function (node) {
            return node.index;
          })));
          this.nodes.slice(minChangedIndex).forEach(function (node, index) {
            node.index = minChangedIndex + index;
          });
          this.setVirtualScrollList();
        } catch (e) {
          console.warn(e.message);
        }
      },
      setSelected: function setSelected(nodeId) {
        var _this8 = this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var mergeOptions, node, response;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  if (!(!_this8.selectable || nodeId === _this8.selected)) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 3:
                  mergeOptions = _objectSpread({
                    emitEvent: false,
                    beforeSelect: true
                  }, options);
                  node = _this8.getNodeById(nodeId);
                  if (!(mergeOptions.beforeSelect && typeof _this8.beforeSelect === 'function')) {
                    _context.next = 11;
                    break;
                  }
                  _context.next = 8;
                  return _this8.beforeSelect(node);
                case 8:
                  response = _context.sent;
                  if (response) {
                    _context.next = 11;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 11:
                  _this8.selected = nodeId;
                  if (mergeOptions.emitEvent) {
                    _this8.$emit('select-change', node);
                  }
                  _context.next = 18;
                  break;
                case 15:
                  _context.prev = 15;
                  _context.t0 = _context["catch"](0);
                  console.warn(_context.t0.message);
                case 18:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 15]]);
        }))();
      },
      removeChecked: function removeChecked() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        try {
          var mergeOptions = _objectSpread({
            emitEvent: true
          }, options);
          this.checkedNodes.forEach(function (node) {
            node.checked = false;
          });
          if (mergeOptions.emitEvent) {
            this.$emit('check-change', [], null, null);
          }
        } catch (e) {
          console.warn(e.message);
        }
      },
      setChecked: function setChecked(nodeId) {
        var _this9 = this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return _asyncToGenerator( regenerator.mark(function _callee2() {
          var isMultiple, ids, mergeOptions, nodes, response;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  isMultiple = isArray$1(nodeId);
                  ids = isMultiple ? nodeId : [nodeId];
                  if (!ids.length) {
                    _context2.next = 14;
                    break;
                  }
                  mergeOptions = _objectSpread({
                    emitEvent: false,
                    beforeCheck: true,
                    checked: true
                  }, options);
                  nodes = ids.map(function (id) {
                    return _this9.getNodeById(id);
                  });
                  if (!(mergeOptions.beforeCheck && typeof _this9.beforeCheck === 'function')) {
                    _context2.next = 12;
                    break;
                  }
                  _context2.next = 9;
                  return _this9.beforeCheck(nodes.length > 1 ? nodes : nodes[0], mergeOptions.checked);
                case 9:
                  response = _context2.sent;
                  if (response) {
                    _context2.next = 12;
                    break;
                  }
                  return _context2.abrupt("return", false);
                case 12:
                  nodes.forEach(function (node) {
                    node.checked = mergeOptions.checked;
                  });
                  if (mergeOptions.emitEvent) {
                    setTimeout(function () {
                      _this9.$emit('check-change', _this9.checked, isMultiple ? nodes : nodes[0]);
                    }, 0);
                  }
                case 14:
                  _context2.next = 19;
                  break;
                case 16:
                  _context2.prev = 16;
                  _context2.t0 = _context2["catch"](0);
                  console.warn(_context2.t0.message);
                case 19:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 16]]);
        }))();
      },
      setExpanded: function setExpanded(nodeId) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        try {
          var mergeOptions = _objectSpread({
            expanded: true,
            emitEvent: false
          }, options);
          var node = this.getNodeById(nodeId);
          if (!node) {
            console.warn('Unexpected node id, set expanded failed.');
            return false;
          }
          node.expanded = mergeOptions.expanded;
          if (mergeOptions.emitEvent) {
            this.$emit('expand-change', node);
          }
          this.setVirtualScrollList();
        } catch (e) {
          console.warn(e.message);
        }
      },
      setDisabled: function setDisabled(nodeId) {
        var _this10 = this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        try {
          var mergeOptions = _objectSpread({
            disabled: true,
            emitEvent: false
          }, options);
          var ids = convertToArray(nodeId);
          var nodes = ids.map(function (id) {
            return _this10.getNodeById(id);
          }).filter(function (node) {
            return !!node;
          });
          nodes.forEach(function (node) {
            node.disabled = mergeOptions.disabled;
          });
          if (mergeOptions.emitEvent) {
            this.$emit('disable-change', nodes.length > 1 ? nodes : nodes[0]);
          }
        } catch (e) {
          console.warn(e.message);
        }
      },
      handleCalculateLine: function handleCalculateLine() {
        var _this11 = this;
        this.calculateTimer && clearTimeout(this.calculateTimer);
        if (this.needsCalculateNodes.length) {
          this.calculateTimer = setTimeout(function () {
            _this11.needsCalculateNodes.forEach(function (node) {
              _this11.calculateNodeLine(node);
            });
            _this11.needsCalculateNodes.splice(0);
          }, 0);
        } else {
          this.calculateTimer = null;
        }
      },
      calculateNodeLine: function calculateNodeLine(node) {
        var children = node.children,
            isLeaf = node.isLeaf,
            expanded = node.expanded;
        if (isLeaf || !expanded) {
          node.line = 0;
          return;
        }
        var visibleChildren = children.filter(function (child) {
          return child.visible;
        });
        if (!visibleChildren.length) {
          node.line = 0;
          return;
        }
        var firstChild = visibleChildren[0];
        var firstChildElement = this.$el.querySelector("#".concat(firstChild.uid));
        var lastChild = visibleChildren[visibleChildren.length - 1];
        var lastChildElement = this.$el.querySelector("#".concat(lastChild.uid));
        node.line = lastChildElement.getBoundingClientRect().bottom - firstChildElement.getBoundingClientRect().top;
      },
      defaultFilterMethod: function defaultFilterMethod(keyword, node) {
        return String(node.name).toLowerCase().indexOf(keyword) > -1;
      },
      filter: function filter() {
        var _this12 = this;
        var keyword = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var matchedNodes = [];
        var filterMethod = this.filterMethod || this.defaultFilterMethod;
        if (keyword === '') {
          this.inSearch = false;
          this.nodes.forEach(function (node) {
            node.setState('matched', true);
            node.recalculateLinkLine();
            if (_this12.checkOnlyAvailableStrictly) {
              node.setState('checked', false);
            }
            matchedNodes.push(node);
          });
        } else {
          this.inSearch = true;
          var convertKeyword = this.filterMethod ? keyword : String(keyword).toLowerCase();
          this.nodes.forEach(function (node) {
            var matched = filterMethod(convertKeyword, node);
            node.setState('matched', matched);
            if (_this12.checkOnlyAvailableStrictly) {
              node.setState('checked', false);
            }
            if (matched) {
              node.parent && (node.parent.expanded = true);
              matchedNodes.push(node);
            } else {
              node.recalculateLinkLine();
            }
          });
        }
        this.isSearchEmpty = matchedNodes.length === 0;
        this.setVirtualScrollList();
        return matchedNodes;
      },
      handleNodeClick: function handleNodeClick(node) {
        if (node.disabled) {
          return false;
        }
        this.$emit('node-click', node);
        this.setSelected(node.id, {
          emitEvent: true,
          beforeSelect: true
        });
        if (this.expandOnClick && !node.isLeaf) {
          this.setExpanded(node.id, {
            emitEvent: true,
            expanded: !node.expanded
          });
        }
        if (this.checkOnClick) {
          this.setChecked(node.id, {
            emitEvent: true,
            checked: !node.checked
          });
        }
      },
      handleNodeExpand: function handleNodeExpand(node) {
        this.setExpanded(node.id, {
          expanded: !node.expanded,
          emitEvent: true
        });
      },
      handleNodeCheck: function handleNodeCheck(node) {
        if (node.disabled) {
          return false;
        }
        this.setChecked(node.id, {
          checked: node.indeterminate ? true : !node.checked,
          emitEvent: true,
          beforeCheck: true
        });
      },
      setVirtualScrollList: function setVirtualScrollList() {
        var _this13 = this;
        if (!this.height) return;
        if (!this.$refs.virtualScroll) {
          console.warn('virtual dom is not ready');
          return;
        }
        this.$nextTick(function () {
          _this13.$refs.virtualScroll.setListData(_this13.visibleNodes);
        });
      },
      resize: function resize() {
        this.$refs.virtualScroll && this.$refs.virtualScroll.resize();
      }
    }
  };

  /* script */
  var __vue_script__$1i = script$1i;
  /* template */

  var __vue_render__$1k = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-big-tree', _vm.extCls, {
        'with-virtual-scroll': !!_vm.height
      }, {
        'bk-big-tree--small': _vm.size === 'small'
      }],
      style: {
        height: _vm.treeHeight
      }
    }, [_vm.height ? _c('bk-virtual-scroll', {
      ref: "virtualScroll",
      attrs: {
        "item-height": _vm.nodeHeight
      },
      scopedSlots: _vm._u([{
        key: "default",
        fn: function fn(ref) {
          var node = ref.data;
          return _c('tree-item', {
            attrs: {
              "node": node,
              "id": "bk-big-tree-" + _vm.id + "-node-" + node.id
            }
          }, [_vm._t("default", null, {
            node: node,
            data: node.data
          })], 2);
        }
      }])
    }) : _vm._l(_vm.nodes, function (node) {
      return [_c('tree-item', {
        key: node.id,
        ref: node.id,
        refInFor: true,
        attrs: {
          "node": node
        }
      }, [_vm._t("default", null, {
        node: node,
        data: node.data
      })], 2)];
    }), (_vm.$slots.empty || _vm.useDefaultEmpty) && _vm.isSearchEmpty ? _c('div', {
      staticClass: "bk-big-tree-empty"
    }, [_vm._t("empty", [_vm._v("\n            " + _vm._s(_vm.t('bk.bigTree.emptyText')) + "\n        ")])], 2) : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$1k = [];
  /* style */

  var __vue_inject_styles__$1l = undefined;
  /* scoped */

  var __vue_scope_id__$1l = undefined;
  /* module identifier */

  var __vue_module_identifier__$1l = undefined;
  /* functional template */

  var __vue_is_functional_template__$1l = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1l = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1k,
    staticRenderFns: __vue_staticRenderFns__$1k
  }, __vue_inject_styles__$1l, __vue_script__$1i, __vue_scope_id__$1l, __vue_is_functional_template__$1l, __vue_module_identifier__$1l, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1l);

  var script$1j = {
    name: 'navigation-menu-title',
    props: {
      sideTitle: {
        type: String,
        default: ''
      },
      navigationType: {
        type: String,
        default: 'left-right'
      }
    }
  };

  /* script */
  var __vue_script__$1j = script$1j;
  /* template */

  var __vue_render__$1l = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', _vm._b({
      staticClass: "bk-navigation-title",
      style: {
        borderBottomWidth: _vm.navigationType === 'left-right' ? '0' : '1px'
      }
    }, 'div', _vm.$attrs, false), [_vm._t("default", [_c('span', {
      staticClass: "title-icon"
    }, [_vm._t("side-icon", [_c('i', {
      staticClass: "bk-icon icon-rtx"
    })])], 2), _c('span', {
      staticClass: "title-desc"
    }, [_vm._v(_vm._s(_vm.sideTitle))])])], 2);
  };

  var __vue_staticRenderFns__$1l = [];
  /* style */

  var __vue_inject_styles__$1m = undefined;
  /* scoped */

  var __vue_scope_id__$1m = undefined;
  /* module identifier */

  var __vue_module_identifier__$1m = undefined;
  /* functional template */

  var __vue_is_functional_template__$1m = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1m = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1l,
    staticRenderFns: __vue_staticRenderFns__$1l
  }, __vue_inject_styles__$1m, __vue_script__$1j, __vue_scope_id__$1m, __vue_is_functional_template__$1m, __vue_module_identifier__$1m, false, undefined, undefined, undefined);

  var script$1k = {
    name: 'bk-navigation',
    components: {
      NavigationMenuTitle: __vue_component__$1m
    },
    props: {
      navWidth: {
        type: [Number, String],
        default: 60
      },
      hoverWidth: {
        type: [Number, String],
        default: 260
      },
      sideTitle: {
        type: String,
        default: ''
      },
      headerTitle: {
        type: String,
        default: ''
      },
      hoverLeaveDelay: {
        type: [Number, String],
        default: 0
      },
      hoverEnterDelay: {
        type: [Number, String],
        default: 100
      },
      defaultOpen: Boolean,
      headThemeColor: {
        type: String,
        default: '#182132'
      },
      themeColor: {
        type: String,
        default: '#182132'
      },
      headHeight: {
        type: [Number, String],
        default: 52
      },
      navigationType: {
        type: String,
        default: 'left-right',
        validator: function validator(v) {
          return ['top-bottom', 'left-right'].includes(v);
        }
      },
      needMenu: {
        type: Boolean,
        default: true
      }
    },
    provide: function provide() {
      return {
        rootNavigation: this
      };
    },
    data: function data() {
      return {
        defaultHeaderTitle: '',
        nav: {
          click: false,
          hover: false,
          delay: false,
          timer: null,
          enterTimer: null
        }
      };
    },
    computed: {
      defaultThemeColor: {
        get: function get() {
          var defTheme = ['#182132', '#FFFFFF'];
          return !defTheme.includes(this.themeColor) ? this.themeColor : defTheme[+(this.navigationType === 'top-bottom')];
        }
      }
    },
    created: function created() {
      this.defaultHeaderTitle = this.headerTitle || _t('bk.navigation.headerTitle');
      if (this.defaultOpen) {
        this.nav.click = !this.nav.click;
        this.nav.hover = this.nav.click;
        this.$emit('toggle', this.nav.hover);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.nav.timer && window.clearTimeout(this.nav.timer);
    },
    methods: {
      handleMouseOver: function handleMouseOver(e) {
        var _this = this;
        if (!this.nav.click) {
          this.nav.enterTimer = setTimeout(function () {
            _this.nav.hover = true;
            _this.nav.enterTimer && window.clearTimeout(_this.nav.enterTimer);
            _this.nav.timer && window.clearTimeout(_this.nav.timer);
            _this.$emit('hover', _this.nav.hover);
            _this.$emit('toggle', _this.nav.hover);
          }, this.hoverEnterDelay);
        }
      },
      handleMouseLeave: function handleMouseLeave(e) {
        var _this2 = this;
        if (!this.nav.click) {
          this.nav.enterTimer && window.clearTimeout(this.nav.enterTimer);
          this.nav.timer = setTimeout(function () {
            _this2.nav.hover = false;
            window.clearTimeout(_this2.nav.timer);
            _this2.$emit('leave', _this2.nav.hover);
            _this2.$emit('toggle', _this2.nav.hover);
          }, this.hoverLeaveDelay);
        }
      },
      handleClick: function handleClick() {
        this.nav.click = !this.nav.click;
        this.nav.hover = this.nav.click;
        this.$emit('toggle', this.nav.hover);
        this.$emit('toggle-click', this.nav.hover);
      }
    }
  };

  /* script */
  var __vue_script__$1k = script$1k;
  /* template */

  var __vue_render__$1m = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', _vm._b({
      staticClass: "bk-navigation"
    }, 'div', _vm.$attrs, false), [_vm.navigationType === 'top-bottom' ? _c('div', {
      staticClass: "bk-navigation-header",
      style: {
        backgroundColor: _vm.headThemeColor,
        flexBasis: _vm.headHeight + 'px'
      }
    }, [_c('navigation-menu-title', {
      attrs: {
        "side-title": _vm.sideTitle
      }
    }, [_vm.$slots['side-header'] || _vm.$slots['side-icon'] ? [_vm.$slots['side-header'] ? _vm._t("side-header", [_vm.$slots['side-icon'] ? _c('template', {
      slot: "side-icon"
    }, [_vm._t("side-icon")], 2) : _vm._e()]) : _vm.$slots['side-icon'] ? _c('template', {
      slot: "side-icon"
    }, [_vm._t("side-icon")], 2) : _vm._e()] : _vm._e()], 2), _c('div', {
      staticClass: "header-right"
    }, [_vm._t("header")], 2)], 1) : _vm._e(), _c('div', {
      staticClass: "bk-navigation-wrapper"
    }, [_vm.needMenu ? _c('div', {
      staticClass: "navigation-nav",
      style: {
        width: !_vm.nav.click ? _vm.navWidth + "px" : _vm.hoverWidth + "px"
      }
    }, [_c('div', {
      staticClass: "nav-slider",
      style: {
        width: !_vm.nav.hover ? _vm.navWidth + "px" : _vm.hoverWidth + "px",
        backgroundColor: _vm.defaultThemeColor,
        borderRight: _vm.navigationType !== 'top-bottom' ? 'none' : '1px solid #DCDEE5'
      },
      on: {
        "&mouseenter": function mouseenter($event) {
          return _vm.handleMouseOver($event);
        },
        "&mouseleave": function mouseleave($event) {
          return _vm.handleMouseLeave($event);
        }
      }
    }, [_vm.navigationType !== 'top-bottom' ? [_c('navigation-menu-title', {
      style: {
        flexBasis: _vm.headHeight + 'px'
      },
      attrs: {
        "side-title": _vm.sideTitle
      }
    }, [_vm.$slots['side-header'] || _vm.$slots['side-icon'] ? [_vm.$slots['side-header'] ? _vm._t("side-header", [_vm.$slots['side-icon'] ? _c('template', {
      slot: "side-icon"
    }, [_vm._t("side-icon")], 2) : _vm._e()]) : _vm.$slots['side-icon'] ? _c('template', {
      slot: "side-icon"
    }, [_vm._t("side-icon")], 2) : _vm._e()] : _vm._e()], 2)] : _vm._e(), _c('div', {
      staticClass: "nav-slider-list",
      style: {
        height: "calc(100vh - " + (_vm.headHeight + 56) + "px)"
      }
    }, [_vm._t("menu")], 2), _c('div', {
      staticClass: "nav-slider-footer"
    }, [_c('div', {
      staticClass: "footer-icon",
      class: {
        'is-left': _vm.navigationType !== 'top-bottom'
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.handleClick($event);
        }
      }
    }, [_c('span', {
      staticClass: "footer-icon-svg",
      style: {
        transform: _vm.nav.click ? 'rotate(180deg)' : 'rotate(0deg)'
      }
    }, [_c('svg', {
      staticStyle: {
        "width": "1em",
        "height": "1em",
        "vertical-align": "middle",
        "fill": "currentColor",
        "overflow": "hidden"
      },
      attrs: {
        "viewBox": "0 0 64 64",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg"
      }
    }, [_c('path', {
      attrs: {
        "d": "M31,13.5l-4.77,4.77,9.54,9.55H4v6.36H35.76l-9.53,9.55L31,48.5,48.47,31Zm22.65,0v35H60v-35Z"
      }
    })])])])])], 2)]) : _vm._e(), _c('div', {
      staticClass: "navigation-container",
      style: {
        maxWidth: _vm.needMenu ? 'calc(100vw - 60px)' : '100vw'
      }
    }, [_vm.navigationType !== 'top-bottom' ? [_c('div', {
      staticClass: "container-header",
      style: {
        flexBasis: _vm.headHeight + 'px'
      }
    }, [_vm._t("header", [_c('div', {
      staticClass: "container-header-title"
    }, [_vm._v(_vm._s(_vm.headerTitle))]), _c('div', {
      staticClass: "container-header-sets"
    }, [_vm._t("header-set")], 2)])], 2)] : _vm._e(), _c('div', {
      staticClass: "container-content",
      style: {
        maxHeight: "calc(100vh - " + _vm.headHeight + "px)"
      }
    }, [_vm._t("default"), _c('div', {
      staticClass: "container-footer"
    }, [_vm._t("footer")], 2)], 2)], 2)])]);
  };

  var __vue_staticRenderFns__$1m = [];
  /* style */

  var __vue_inject_styles__$1n = undefined;
  /* scoped */

  var __vue_scope_id__$1n = undefined;
  /* module identifier */

  var __vue_module_identifier__$1n = undefined;
  /* functional template */

  var __vue_is_functional_template__$1n = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1n = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1m,
    staticRenderFns: __vue_staticRenderFns__$1m
  }, __vue_inject_styles__$1n, __vue_script__$1k, __vue_scope_id__$1n, __vue_is_functional_template__$1n, __vue_module_identifier__$1n, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1n);

  var script$1l = {
    name: 'bk-navigation-menu',
    provide: function provide() {
      return {
        rootMenu: this
      };
    },
    inject: {
      rootNavigation: {
        default: null
      }
    },
    props: {
      defaultActive: {
        type: [String, Number],
        default: ''
      },
      uniqueOpened: {
        type: Boolean,
        default: true
      },
      toggleActive: Boolean,
      itemHoverBgColor: {
        type: String,
        default: 'linear-gradient(90deg,rgba(37,48,71,1) 0%,rgba(32,42,60,1) 100%)'
      },
      itemHoverColor: {
        type: String,
        default: '#D3D9E4'
      },
      itemActiveBgColor: {
        type: String,
        default: 'linear-gradient(90deg,rgba(63,135,255,1) 0%,rgba(58,132,255,1) 100%)'
      },
      itemActiveColor: {
        type: String,
        default: '#FFFFFF'
      },
      itemDefaultBgColor: {
        type: String,
        default: '#182132'
      },
      itemDefaultColor: {
        type: String,
        default: '#ACB9D1'
      },
      itemDefaultIconColor: {
        type: String,
        default: '#63656E'
      },
      itemActiveIconColor: {
        type: String,
        default: '#FFFFFF'
      },
      itemHoverIconColor: {
        type: String,
        default: '#D3D9E4'
      },
      itemChildIconDefaultColor: {
        type: String,
        default: '#3E4655'
      },
      itemChildIconHoverColor: {
        type: String,
        default: '#D3D9E4'
      },
      itemChildIconActiveColor: {
        type: String,
        default: '#FFFFFF'
      },
      subMenuOpenBgColor: {
        type: String,
        default: '#151D2C'
      },
      beforeNavChange: {
        type: Function,
        default: function _default() {
          return function () {};
        }
      }
    },
    data: function data() {
      return {
        activeId: this.defaultActive,
        item: {},
        subItems: {}
      };
    },
    computed: {
      parentId: function parentId() {
        return this.item.parentMenu ? this.item.parentMenu.id : '';
      },
      navigationType: function navigationType() {
        if (this.rootNavigation && this.rootNavigation.navigationType) {
          return this.rootNavigation.navigationType;
        }
        return 'left-right';
      },
      defItemHoverBgColor: {
        get: function get() {
          var themeVals = ['linear-gradient(270deg,rgba(235,237,243,1) 0%,rgba(240,241,245,1) 100%)', 'linear-gradient(90deg,rgba(37,48,71,1) 0%,rgba(32,42,60,1) 100%)'];
          return !themeVals.includes(this.itemHoverBgColor) ? this.itemHoverBgColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemHoverColor: {
        get: function get() {
          var themeVals = ['#3A3C42', '#D3D9E4'];
          return !themeVals.includes(this.itemHoverColor) ? this.itemHoverColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemActiveBgColor: {
        get: function get() {
          var themeVals = ['linear-gradient(90deg,rgba(63,135,255,1) 0%,rgba(58,132,255,1) 100%)', 'linear-gradient(90deg,rgba(63,135,255,1) 0%,rgba(58,132,255,1) 100%)'];
          return !themeVals.includes(this.itemActiveBgColor) ? this.itemActiveBgColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemActiveColor: {
        get: function get() {
          var themeVals = ['#FFFFFF', '#FFFFFF'];
          return !themeVals.includes(this.itemActiveColor) ? this.itemActiveColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemDefaultBgColor: {
        get: function get() {
          var themeVals = ['#FFFFFF', '#182132'];
          return !themeVals.includes(this.itemDefaultBgColor) ? this.itemDefaultBgColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemDefaultColor: {
        get: function get() {
          var themeVals = ['#63656E', '#ACB9D1'];
          return !themeVals.includes(this.itemDefaultColor) ? this.itemDefaultColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemDefaultIconColor: {
        get: function get() {
          var themeVals = ['#63656E', '#B0BDD5'];
          return !themeVals.includes(this.itemDefaultIconColor) ? this.itemDefaultIconColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemHoverIconColor: {
        get: function get() {
          var themeVals = ['#3A3C42', '#D3D9E4'];
          return !themeVals.includes(this.itemHoverIconColor) ? this.itemHoverIconColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemActiveIconColor: {
        get: function get() {
          var themeVals = ['#FFFFFF', '#FFFFFF'];
          return !themeVals.includes(this.itemActiveIconColor) ? this.itemActiveIconColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defSubMenuOpenBgColor: {
        get: function get() {
          var themeVals = ['#F0F1F5', '#151D2C'];
          return !themeVals.includes(this.subMenuOpenBgColor) ? this.subMenuOpenBgColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemChildIconDefaultColor: {
        get: function get() {
          var themeVals = ['#979BA5', '#3E4655'];
          return !themeVals.includes(this.itemChildIconDefaultColor) ? this.itemChildIconDefaultColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemChildIconHoverColor: {
        get: function get() {
          var themeVals = ['#63656E', '#D3D9E4'];
          return !themeVals.includes(this.itemChildIconHoverColor) ? this.itemChildIconHoverColor : themeVals[+(this.navigationType === 'left-right')];
        }
      },
      defItemChildIconActiveColor: {
        get: function get() {
          var themeVals = ['#FFFFFF', '#FFFFFF'];
          return !themeVals.includes(this.itemChildIconActiveColor) ? this.itemChildIconActiveColor : themeVals[+(this.navigationType === 'left-right')];
        }
      }
    },
    watch: {
      defaultActive: function defaultActive(v) {
        this.activeId = v;
        if (this.item.id !== v) {
          var item = this.getActiveItem(this.$children, v);
          if (item) {
            this.item = item;
          }
        }
      },
      toggleActive: function toggleActive(v) {
        var _this = this;
        if (this.uniqueOpened) {
          keys$1(this.subItems).forEach(function (key) {
            var subItem = _this.subItems[key];
            subItem.menuActive = _this.toggleActive ? false : key === _this.parentId;
            if (_this.parentId && _this.parentId !== subItem.id) {
              var activeSubItem = _this.item.parentMenu;
              activeSubItem.menuActive = !_this.toggleActive;
            }
            if (!v) {
              subItem.markCollapse && subItem.handleClose();
            } else {
              subItem.markCollapse && subItem.handleOpen();
            }
          });
        }
      }
    },
    mounted: function mounted() {
      this.$on('item-click', this.handleItemClick);
      this.$on('sub-menu-click', this.handleSubMenuClick);
    },
    beforeDestroy: function beforeDestroy() {
      this.$off('item-click', this.handleItemClick);
      this.$off('sub-menu-click', this.handleSubMenuClick);
    },
    methods: {
      handleItemClick: function handleItemClick(item) {
        this.handleSetItem(item);
      },
      handleSubMenuClick: function handleSubMenuClick(item) {
        this.handleSetSubMenu(item);
      },
      handleSetSubMenu: function handleSetSubMenu(item) {
        var _this2 = this;
        var id = item.id;
        if (id) {
          if (this.uniqueOpened) {
            keys$1(this.subItems).forEach(function (key) {
              if (key !== id) {
                _this2.subItems[key].handleClose();
                delete _this2.subItems[key];
              }
            });
            item.markCollapse = item.collapse;
          }
          this.subItems[id] = item;
        }
      },
      handleSetItem: function handleSetItem(item) {
        var _this3 = this;
        return _asyncToGenerator( regenerator.mark(function _callee() {
          var canChange, id;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  canChange = false;
                  _context.prev = 1;
                  _context.next = 4;
                  return _this3.beforeNavChange(item.id, _this3.activeId, _extends({}, item.$props, item.$attrs));
                case 4:
                  canChange = _context.sent;
                  _context.next = 10;
                  break;
                case 7:
                  _context.prev = 7;
                  _context.t0 = _context["catch"](1);
                  canChange = typeof _context.t0 === 'boolean' ? _context.t0 : false;
                case 10:
                  if (canChange) {
                    id = item.id;
                    if (id) {
                      _this3.item = item;
                      _this3.activeId = id;
                    }
                    _this3.$emit('select', _this3.activeId, _extends({}, item.$props, item.$attrs));
                  } else if (_this3.activeId === item.id) {
                    _this3.item = item;
                  }
                case 11:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[1, 7]]);
        }))();
      },
      getActiveItem: function getActiveItem(list, id) {
        for (var i = 0, j = list.length; i < j; i++) {
          var item = list[i];
          if (item.id === id) {
            return item;
          } else if (item.$children && item.$children.length) {
            return this.getActiveItem(item.$children, id);
          }
        }
      }
    },
    render: function render() {
      var h = arguments[0];
      var defItemDefaultBgColor = this.defItemDefaultBgColor,
          navigationType = this.navigationType;
      return h("div", {
        "class": {
          'navigation-menu': true
        },
        "style": {
          backgroundColor: defItemDefaultBgColor
        },
        "key": navigationType
      }, [this.$slots.default]);
    }
  };

  /* script */
  var __vue_script__$1l = script$1l;
  /* template */

  /* style */

  var __vue_inject_styles__$1o = undefined;
  /* scoped */

  var __vue_scope_id__$1o = undefined;
  /* module identifier */

  var __vue_module_identifier__$1o = undefined;
  /* functional template */

  var __vue_is_functional_template__$1o = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1o = /*#__PURE__*/normalizeComponent_1({}, __vue_inject_styles__$1o, __vue_script__$1l, __vue_scope_id__$1o, __vue_is_functional_template__$1o, __vue_module_identifier__$1o, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1o);

  var script$1m = {
    name: 'bk-navigation-menu-item',
    inject: {
      rootMenu: 'rootMenu',
      parentMenu: {
        default: null
      },
      rootNavigation: {
        default: null
      }
    },
    provide: function provide() {
      return {
        parentMenu: this
      };
    },
    props: {
      id: {
        type: [String, Number],
        required: true
      },
      disabled: Boolean,
      icon: {
        type: [String, Object, Array],
        validator: function validator(v) {
          return v.length;
        }
      },
      hasChild: Boolean,
      group: Boolean,
      title: Boolean
    },
    data: function data() {
      return {
        collapse: false,
        menuActive: false,
        mouseover: false
      };
    },
    computed: {
      isActive: function isActive() {
        return this.id === this.rootMenu.activeId;
      },
      activeBgColor: function activeBgColor() {
        if (this.isActive) {
          return this.rootMenu.defItemActiveBgColor;
        } else if (!this.parentMenu) {
          if (this.mouseover) {
            return this.rootMenu.defItemHoverBgColor;
          } else if (this.parentMenu && this.parentMenu.collapse || this.collapse) {
            return this.defSubMenuOpenBgColor;
          }
        }
        return '';
      },
      activeColor: function activeColor() {
        if (this.isActive) {
          return this.rootMenu.defItemActiveColor;
        } else if (this.mouseover) {
          return this.rootMenu.defItemHoverColor;
        }
        return this.rootMenu.defItemDefaultColor;
      },
      activeIconColor: function activeIconColor() {
        if (this.isActive) {
          return this.rootMenu.defItemActiveIconColor;
        } else if (this.mouseover) {
          return this.rootMenu.defItemHoverIconColor;
        }
        return this.rootMenu.defItemDefaultIconColor;
      },
      activeChildIconColor: function activeChildIconColor() {
        if (this.isActive) {
          return this.rootMenu.defItemChildIconActiveColor;
        } else if (this.mouseover) {
          return this.rootMenu.defItemChildIconHoverColor;
        }
        return this.rootMenu.defItemChildIconDefaultColor;
      },
      collapseBgColor: function collapseBgColor() {
        return this.parentMenu && this.parentMenu.collapse || this.collapse ? this.rootMenu.defSubMenuOpenBgColor : this.rootMenu.defItemDefaultBgColor;
      },
      menuActiveBgColor: function menuActiveBgColor() {
        if (this.rootMenu.navigationType && !this.parentMenu && this.menuActive) {
          return this.rootMenu.defItemActiveBgColor;
        } else if (this.rootMenu.navigationType && this.collapse) {
          return this.rootMenu.defSubMenuOpenBgColor;
        } else if (this.rootMenu.navigationType && this.mouseover) {
          return this.rootMenu.defItemHoverBgColor;
        }
        return this.rootMenu.defItemDefaultBgColor;
      },
      menuActiveColor: function menuActiveColor() {
        if (!this.parentMenu && this.menuActive) {
          return this.rootMenu.defItemActiveColor;
        } else if (this.mouseover && !this.collapse) {
          return this.rootMenu.defItemHoverColor;
        }
        return this.rootMenu.defItemDefaultColor;
      },
      menuActiveIconColor: function menuActiveIconColor() {
        if (!this.parentMenu && this.menuActive) {
          return this.rootMenu.defItemActiveIconColor;
        } else if (this.mouseover && !this.collapse) {
          return this.rootMenu.defItemHoverIconColor;
        }
        return this.rootMenu.defItemDefaultIconColor;
      }
    },
    watch: {
      'rootMenu.activeId': {
        handler: 'handlerActiveChange'
      }
    },
    created: function created() {
      if (this.isActive && this.parentMenu) {
        if (this.rootMenu.uniqueOpened) {
          this.parentMenu.collapse = this.rootNavigation ? this.rootNavigation.defaultOpen : true;
          this.parentMenu.menuActive = this.rootNavigation ? !this.rootNavigation.defaultOpen : false;
        } else {
          this.parentMenu.collapse = !!this.rootNavigation;
          this.parentMenu.menuActive = false;
        }
        this.rootMenu.handleSetItem(this);
        this.rootMenu.handleSetSubMenu(this.parentMenu);
      }
    },
    methods: {
      handleMouseHover: function handleMouseHover(mouseover) {
        this.mouseover = mouseover;
      },
      handlerActiveChange: function handlerActiveChange(newVal, oldVal) {
        if (this.parentMenu && this.rootMenu) {
          if (this.id === oldVal && this.rootMenu.uniqueOpened) {
            if (this.rootMenu.parentId) {
              if (this.rootMenu.toggleActive) {
                this.parentMenu.collapse = this.rootMenu.parentId === this.parentMenu.id || !this.rootMenu.uniqueOpened;
              } else {
                this.parentMenu.collapse = !this.rootNavigation && this.rootMenu.uniqueOpened && this.rootMenu.parentId === this.parentMenu.id;
              }
            }
            this.parentMenu.menuActive = false;
          } else if (this.id === newVal) {
            if (this.rootMenu.uniqueOpened) {
              this.parentMenu.collapse = this.rootNavigation ? this.rootMenu.toggleActive : true;
              this.parentMenu.menuActive = this.rootNavigation && !this.rootMenu.toggleActive;
            } else {
              this.parentMenu.collapse = true;
              this.parentMenu.menuActive = false;
            }
            this.rootMenu.handleSetItem(this);
            this.rootMenu.handleSetSubMenu(this.parentMenu);
          }
        }
      },
      handleClick: function handleClick(e) {
        if (this.disabled || this.title) {
          e.preventDefault();
          return;
        } else if (e.metaKey || e.ctrlKey) {
          return;
        }
        e.preventDefault();
        this.rootMenu.$emit('item-click', this);
        this.$emit('click', this.id);
      },
      handleSbmenuClick: function handleSbmenuClick() {
        if (!this.disabled) {
          if (this.collapse) {
            this.handleClose();
          } else {
            this.handleOpen();
          }
          this.rootMenu.$emit('sub-menu-click', this);
          this.$emit('sub-menu-click', this.id);
        }
      },
      handleClose: function handleClose() {
        this.collapse = false;
        this.$emit('close', this.id);
      },
      handleOpen: function handleOpen() {
        this.collapse = true;
        this.$emit('open', this.id);
      },
      beforeEnter: function beforeEnter(el) {
        el.classList.add('collapse-transition');
        el.style.background = this.collapseBgColor;
        el.style.marginTop = '-4px';
        el.style.height = '0';
      },
      enter: function enter(el, done) {
        el.dataset.oldOverflow = el.style.overflow;
        if (el.scrollHeight !== 0) {
          el.style.height = el.scrollHeight + 'px';
        } else {
          el.style.height = '';
        }
        el.style.overflow = 'hidden';
      },
      afterEnter: function afterEnter(el) {
        el.classList.remove('collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
      },
      beforeLeave: function beforeLeave(el) {
        el.dataset.oldOverflow = el.style.overflow;
        el.style.height = el.scrollHeight + 'px';
        el.style.overflow = 'hidden';
      },
      leave: function leave(el, done) {
        if (el.scrollHeight !== 0) {
          el.classList.add('collapse-transition');
          el.style.height = 0;
        }
      },
      afterLeave: function afterLeave(el) {
        el.classList.remove('collapse-transition');
        el.style.height = '';
        el.style.overflow = el.dataset.oldOverflow;
      }
    }
  };

  /* script */
  var __vue_script__$1m = script$1m;
  /* template */

  var __vue_render__$1n = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.hasChild ? _c('div', {
      staticClass: "navigation-sbmenu",
      class: {
        'is-disabled': _vm.disabled
      },
      attrs: {
        "disabled": _vm.disabled,
        "group": _vm.group
      }
    }, [_c('div', {
      staticClass: "navigation-sbmenu-title",
      style: {
        background: _vm.menuActiveBgColor
      },
      on: {
        "mouseover": function mouseover($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          _vm.handleMouseHover(!_vm.disabled);
        },
        "mouseleave": function mouseleave($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          _vm.handleMouseHover(false);
        },
        "click": function click($event) {
          $event.stopPropagation();
          $event.preventDefault();
          return _vm.handleSbmenuClick($event);
        }
      }
    }, [_vm.icon ? _c('span', {
      staticClass: "bk-icon navigation-sbmenu-title-icon",
      class: _vm.icon,
      style: {
        color: _vm.menuActiveIconColor
      }
    }) : _vm._e(), _c('span', {
      staticClass: "navigation-sbmenu-title-content",
      style: {
        color: _vm.menuActiveColor
      }
    }, [_vm._t("default")], 2), _c('span', {
      staticClass: "navigation-sbmenu-title-arrow",
      style: {
        transform: _vm.collapse ? 'rotate(90deg)' : 'rotate(0deg)',
        color: _vm.menuActiveColor
      }
    }, [_c('svg', {
      staticClass: "bk-icon",
      staticStyle: {
        "width": "1em",
        "height": "1em",
        "vertical-align": "middle",
        "fill": "currentColor",
        "overflow": "hidden"
      },
      attrs: {
        "viewBox": "0 0 16 16",
        "version": "1.1",
        "xmlns": "http://www.w3.org/2000/svg"
      }
    }, [_c('path', {
      attrs: {
        "d": "M6.19 13.44l-1.13-1.13 4.13-4.12-4.13-4.13 1.13-1.12 5.25 5.25-5.25 5.25z"
      }
    })])])]), _c('transition', {
      attrs: {
        "css": false
      },
      on: {
        "before-enter": _vm.beforeEnter,
        "enter": _vm.enter,
        "after-enter": _vm.afterEnter,
        "before-leave": _vm.beforeLeave,
        "leave": _vm.leave,
        "after-leave": _vm.afterLeave
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.collapse,
        expression: "collapse"
      }],
      staticClass: "navigation-sbmenu-content"
    }, [_vm._t("child")], 2)])], 1) : _c('a', {
      staticClass: "navigation-menu-item",
      class: {
        'is-disabled': _vm.disabled,
        'group-theme': _vm.rootMenu.navigationType !== 'left-right'
      },
      style: {
        background: _vm.activeBgColor,
        color: _vm.activeColor
      },
      attrs: {
        "group": _vm.group,
        "disabled": _vm.disabled
      },
      on: {
        "click": function click($event) {
          $event.stopPropagation();

          _vm.handleClick($event);
        },
        "mouseover": function mouseover($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          !_vm.title && _vm.handleMouseHover(!_vm.disabled);
        },
        "mouseleave": function mouseleave($event) {
          if ($event.target !== $event.currentTarget) {
            return null;
          }

          _vm.handleMouseHover(false);
        }
      }
    }, [_vm.icon ? _c('span', {
      staticClass: "bk-icon navigation-menu-item-icon",
      class: _vm.icon,
      style: {
        color: _vm.activeIconColor
      }
    }) : _vm.parentMenu && _vm.parentMenu.hasChild ? _c('span', {
      staticClass: "navigation-menu-item-default"
    }, [_c('i', {
      staticClass: "navigation-menu-item-default-icon",
      style: {
        backgroundColor: _vm.activeChildIconColor
      }
    })]) : _vm._e(), _c('span', {
      staticClass: "navigation-menu-item-name",
      style: {
        color: _vm.activeColor
      }
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$1n = [];
  /* style */

  var __vue_inject_styles__$1p = undefined;
  /* scoped */

  var __vue_scope_id__$1p = undefined;
  /* module identifier */

  var __vue_module_identifier__$1p = undefined;
  /* functional template */

  var __vue_is_functional_template__$1p = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1p = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1n,
    staticRenderFns: __vue_staticRenderFns__$1n
  }, __vue_inject_styles__$1p, __vue_script__$1m, __vue_scope_id__$1p, __vue_is_functional_template__$1p, __vue_module_identifier__$1p, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1p);

  var script$1n = {
    name: 'bk-navigation-menu-group',
    props: {
      groupName: {
        type: String,
        default: ''
      }
    },
    methods: {
      content: function content(h) {
        if (!this.$slots.group && !this.groupName) {
          return null;
        }
        return h('div', {
          class: {
            'group-name-wrap': true
          }
        }, [h('div', {
          class: {
            'group-name': true
          }
        }, this.$slots.group || this.groupName)]);
      }
    },
    render: function render(h) {
      var _this = this;
      return h('div', {
        class: {
          'bk-navigation-menu-group': true
        },
        on: {
          click: function click(e) {
            return _this.$emit('click', e, _this.groupName);
          }
        }
      }, [this.content(h), this.$slots.default]);
    }
  };

  /* script */
  var __vue_script__$1n = script$1n;
  /* template */

  /* style */

  var __vue_inject_styles__$1q = undefined;
  /* scoped */

  var __vue_scope_id__$1q = undefined;
  /* module identifier */

  var __vue_module_identifier__$1q = undefined;
  /* functional template */

  var __vue_is_functional_template__$1q = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1q = /*#__PURE__*/normalizeComponent_1({}, __vue_inject_styles__$1q, __vue_script__$1n, __vue_scope_id__$1q, __vue_is_functional_template__$1q, __vue_module_identifier__$1q, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1q);

  var bkCopy = {
    bind: function bind(el, _ref, vnode) {
      var value = _ref.value;
      el.$value = value;
      el.copyHandler = function () {
        var that = vnode.context;
        if (!el.$value) {
          that.$bkMessage({
            theme: 'warning',
            message: '无复制内容',
            delay: 2000,
            dismissable: false
          });
          return;
        }
        var textarea = document.createElement('textarea');
        textarea.readOnly = true;
        textarea.style.position = 'absolute';
        textarea.style.left = '-9999px';
        textarea.value = el.$value;
        document.body.appendChild(textarea);
        textarea.select();
        var result = document.execCommand('Copy');
        if (result) {
          that.$bkMessage({
            theme: 'success',
            message: '复制成功',
            delay: 2000,
            dismissable: false
          });
        }
        document.body.removeChild(textarea);
      };
      el.addEventListener('click', el.copyHandler);
    },
    componentUpdated: function componentUpdated(el, _ref2) {
      var value = _ref2.value;
      el.$value = value;
    },
    unbind: function unbind(el) {
      el.removeEventListener('click', el.copyHandler);
    }
  };
  bkCopy.install = function (Vue) {
    Vue.directive('bkCopy', bkCopy);
  };

  var script$1o = {
    name: 'optionItem',
    components: {
      bkCheckbox: __vue_component__$8
    },
    props: {
      item: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      selectedItem: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      multiple: {
        type: Boolean,
        default: false
      },
      isRemote: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      handleCheckItem: function handleCheckItem() {
        this.$emit('handleCheckItem', this.item);
      }
    }
  };

  /* script */
  var __vue_script__$1o = script$1o;
  /* template */

  var __vue_render__$1o = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('li', {
      staticClass: "bk-option",
      class: {
        'is-selected': _vm.selectedItem.id === _vm.item.id,
        'is-multiple': _vm.multiple,
        'is-disabled': _vm.item.disabled
      }
    }, [_c('div', {
      staticClass: "bk-option-content"
    }, [_vm._t("default", [_c('div', {
      staticClass: "bk-option-content-default",
      attrs: {
        "title": _vm.item.name
      }
    }, [_vm.multiple ? _c('div', {
      staticClass: "bk-cascade-check"
    }, [_c('bk-checkbox', {
      attrs: {
        "value": _vm.item.isSelected,
        "disabled": _vm.item.disabled,
        "indeterminate": _vm.item.isIndeterminate
      },
      on: {
        "change": _vm.handleCheckItem
      }
    })], 1) : _vm._e(), _c('span', {
      staticClass: "bk-option-name",
      class: {
        'bk-margin-left': _vm.multiple
      }
    }, [_vm._v("\n                    " + _vm._s(_vm.item.name) + "\n                    "), _vm._t("prepend", null, {
      node: _vm.item
    })], 2)])])], 2), _vm.isRemote ? [_vm.item.isLoading ? _c('i', {
      staticClass: "bk-icon left-icon icon-loading bk-button-icon-loading bk-cascade-right"
    }, [_c('span', {
      staticClass: "loading"
    })]) : _vm._e(), _vm.item.children && _vm.item.children.length || _vm.item.isLoading === undefined && !_vm.item.disabled ? _c('i', {
      staticClass: "bk-cascade-right bk-icon icon-angle-right"
    }) : _vm._e()] : [_vm.item.children && _vm.item.children.length ? _c('i', {
      staticClass: "bk-cascade-right bk-icon icon-angle-right"
    }) : _vm._e()]], 2);
  };

  var __vue_staticRenderFns__$1o = [];
  /* style */

  var __vue_inject_styles__$1r = undefined;
  /* scoped */

  var __vue_scope_id__$1r = undefined;
  /* module identifier */

  var __vue_module_identifier__$1r = undefined;
  /* functional template */

  var __vue_is_functional_template__$1r = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1r = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1o,
    staticRenderFns: __vue_staticRenderFns__$1o
  }, __vue_inject_styles__$1r, __vue_script__$1o, __vue_scope_id__$1r, __vue_is_functional_template__$1r, __vue_module_identifier__$1r, false, undefined, undefined, undefined);

  function _broadcast(componentName, eventName, params) {
    this.$children.forEach(function (child) {
      var name = child.$options.name;
      if (name === componentName) {
        child.$emit.apply(child, [eventName].concat(params));
      } else {
        _broadcast.apply(child, [componentName, eventName].concat([params]));
      }
    });
  }
  var cascadeInfo = {
    methods: {
      dispatch: function dispatch(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!name || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, [eventName].concat(params));
        }
      },
      broadcast: function broadcast(componentName, eventName, params) {
        _broadcast.call(this, componentName, eventName, params);
      },
      findComponentDownward: function findComponentDownward(context, componentName) {
        var childrens = context.$children;
        var children = null;
        if (childrens.length) {
          var _iterator = _createForOfIteratorHelper(childrens),
              _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var child = _step.value;
              var name = child.$options.name;
              if (name === componentName) {
                children = child;
                break;
              } else {
                children = this.findComponentDownward(child, componentName);
                if (children) break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
        return children;
      },
      findComponentUpward: function findComponentUpward(context, componentName, componentNames) {
        if (typeof componentName === 'string') {
          componentNames = [componentName];
        } else {
          componentNames = componentName;
        }
        var parent = context.$parent;
        var name = parent.$options.name;
        while (parent && (!name || componentNames.indexOf(name) < 0)) {
          parent = parent.$parent;
          if (parent) name = parent.$options.name;
        }
        return parent;
      }
    }
  };

  var script$1p = {
    name: 'bkCaspanel',
    components: {
      optionItem: __vue_component__$1r
    },
    mixins: [cascadeInfo, locale.mixin],
    props: {
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      trigger: {
        type: String,
        default: ''
      },
      scrollWidth: {
        type: Number,
        default: 160
      },
      multiple: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      checkAnyLevel: {
        type: Boolean,
        default: false
      },
      isRemote: {
        type: Boolean,
        default: false
      },
      remoteMethod: {
        type: Function
      }
    },
    data: function data() {
      return {
        childrenList: [],
        selectedList: [],
        selectedItem: {},
        multipleSeleted: []
      };
    },
    mounted: function mounted() {
      var _this = this;
      this.$on('change-selected', function (params) {
        var idInfo = params.idList;
        var valueList = _toConsumableArray(idInfo);
        for (var i = 0; i < valueList.length; i++) {
          for (var j = 0; j < _this.list.length; j++) {
            if (valueList[i] === _this.list[j].id) {
              _this.handleItemFn(_this.list[j], true);
              valueList.splice(0, 1);
              _this.$nextTick(function () {
                _this.broadcast('bkCaspanel', 'change-selected', {
                  idList: valueList
                });
              });
              return false;
            }
          }
        }
      });
      this.$on('multiple-selected', function (params) {
        var valueList = params.idList;
        var changeCheckStatus = function changeCheckStatus(arr) {
          arr.forEach(function (item) {
            if (valueList[valueList.length - 1] === item.id) {
              item.isSelected = params.isSelected;
              item.isIndeterminate = false;
              _this.handleItemFn(item, true);
            }
            if (item.children && item.children.length) {
              changeCheckStatus(item.children);
            }
          });
        };
        changeCheckStatus(_this.list);
      });
      this.$on('on-clear', function () {
        _this.childrenList = [];
        _this.selectedItem = {};
      });
    },
    methods: {
      cascadeClick: function cascadeClick(item) {
        if (this.trigger !== 'click' && item.children && item.children.length) return;
        this.handleItem(item, false);
      },
      cascadeHover: function cascadeHover(item) {
        if (this.trigger === 'hover' && item.children && item.children.length) {
          this.handleItem(item, false);
        }
      },
      handleItem: function handleItem(item) {
        var _this2 = this;
        var fromInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (item.disabled) return;
        if (this.isRemote) {
          new promise$1(function (resolve, reject) {
            _this2.remoteMethod(item, resolve);
          }).then(function () {
            _this2.handleItemFn(item, fromInit);
          }).catch(function () {
          }).finally(function () {
            item.isLoading = false;
          });
        } else {
          this.handleItemFn(item, fromInit);
        }
      },
      handleItemFn: function handleItemFn(item, fromInit) {
        var _this3 = this;
        this.broadcast('bkCaspanel', 'on-clear');
        this.childrenList = item.children && item.children.length ? item.children : [];
        if (this.multiple && this.childrenList.length) {
          if (!this.checkAnyLevel) {
            var childrenRecursive = function childrenRecursive(arr) {
              arr.forEach(function (child) {
                _this3.childSelected(child, item);
                _this3.childIndeterminate(child, item);
                if (child.children && child.children.length) {
                  childrenRecursive(child.children);
                }
              });
            };
            childrenRecursive(this.childrenList);
          }
        }
        if (this.checkAnyLevel || item.id !== this.selectedItem.id || item.name !== this.selectedItem.name || item.id === this.selectedItem.id && item.name === this.selectedItem.name) {
          this.selectedItem = item;
          this.emitUpdate([item]);
        }
        if (this.multiple) {
          this.dispatch('bkCascade', 'on-multiple-change', {
            item: item,
            checkAnyLevel: this.checkAnyLevel,
            fromInit: fromInit
          });
        } else {
          this.dispatch('bkCascade', 'on-id-change', {
            item: item,
            isLast: !(item.children && item.children.length),
            checkAnyLevel: this.checkAnyLevel,
            fromInit: fromInit
          });
        }
        this.dispatch('bkCascade', 'on-popover-width', {
          item: item
        });
      },
      childSelected: function childSelected(child, item) {
        if (child.disabled || !item.isSelected && !item.isIndeterminate) {
          child.isSelected = false;
        } else if (item.isSelected) {
          child.isSelected = true;
        }
      },
      childIndeterminate: function childIndeterminate(child, item) {
        if (child.disabled || !item.isSelected && !item.isIndeterminate || item.isSelected) {
          child.isIndeterminate = false;
        }
      },
      updateSelectedList: function updateSelectedList(item) {
        this.selectedList = [this.selectedItem].concat(item);
        if (!this.checkAnyLevel) {
          item.forEach(function (itemItem) {
            if (itemItem.children && itemItem.children.length) {
              itemItem.isSelected = itemItem.children.every(function (child) {
                return child.isSelected || child.disabled;
              });
              itemItem.isIndeterminate = itemItem.isSelected ? false : itemItem.children.some(function (child) {
                return child.isSelected || child.isIndeterminate;
              });
            }
          });
        }
        this.emitUpdate(this.selectedList);
      },
      emitUpdate: function emitUpdate(selectedList) {
        this.$emit('updateSelectedList', selectedList);
      },
      handleCheckItem: function handleCheckItem(item) {
        item.isSelected = !item.isSelected;
        item.isIndeterminate = false;
      }
    }
  };

  /* script */
  var __vue_script__$1p = script$1p;
  /* template */

  var __vue_render__$1p = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-cascade-panel"
    }, [_vm.list.length ? _c('ul', {
      staticClass: "bk-cascade-panel-ul",
      class: {
        'bk-cascade-border': _vm.childrenList && _vm.childrenList.length
      },
      style: {
        width: _vm.scrollWidth + 'px'
      }
    }, _vm._l(_vm.list, function (item, index) {
      return _c('option-item', {
        key: index,
        attrs: {
          "item": item,
          "selected-item": _vm.selectedItem,
          "multiple": _vm.multiple,
          "is-remote": _vm.isRemote
        },
        on: {
          "handleCheckItem": _vm.handleCheckItem
        },
        nativeOn: {
          "click": function click($event) {
            $event.stopPropagation();

            _vm.cascadeClick(item);
          },
          "mouseenter": function mouseenter($event) {
            $event.stopPropagation();

            _vm.cascadeHover(item);
          }
        },
        scopedSlots: _vm._u([{
          key: "prepend",
          fn: function fn(ref) {
            var node = ref.node;
            return [_vm._t("prepend", null, {
              node: node
            })];
          }
        }])
      });
    }), 1) : _c('ul', {
      staticClass: "bk-cascade-panel-ul",
      staticStyle: {
        "width": "100%"
      }
    }, [_c('li', {
      staticClass: "bk-option-none"
    }, [_c('span', [_vm._v(_vm._s(_vm.t('bk.select.dataEmpty')))])])]), _vm.childrenList && _vm.childrenList.length ? _c('bk-caspanel', {
      attrs: {
        "list": _vm.childrenList,
        "trigger": _vm.trigger,
        "scroll-width": _vm.scrollWidth,
        "disabled": _vm.disabled,
        "multiple": _vm.multiple,
        "check-any-level": _vm.checkAnyLevel,
        "is-remote": _vm.isRemote,
        "remote-method": _vm.remoteMethod
      },
      on: {
        "updateSelectedList": _vm.updateSelectedList
      },
      scopedSlots: _vm._u([{
        key: "prepend",
        fn: function fn(ref) {
          var node = ref.node;
          return [_vm._t("prepend", null, {
            node: node
          })];
        }
      }])
    }) : _vm._e()], 1);
  };

  var __vue_staticRenderFns__$1p = [];
  /* style */

  var __vue_inject_styles__$1s = undefined;
  /* scoped */

  var __vue_scope_id__$1s = undefined;
  /* module identifier */

  var __vue_module_identifier__$1s = undefined;
  /* functional template */

  var __vue_is_functional_template__$1s = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1s = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1p,
    staticRenderFns: __vue_staticRenderFns__$1p
  }, __vue_inject_styles__$1s, __vue_script__$1p, __vue_scope_id__$1s, __vue_is_functional_template__$1s, __vue_module_identifier__$1s, false, undefined, undefined, undefined);

  var script$1q = {
    name: 'bkCascade',
    components: {
      bkPopover: __vue_component__$G,
      bkCaspanel: __vue_component__$1s
    },
    mixins: [cascadeInfo, locale.mixin],
    props: {
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      value: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      placeholder: {
        type: String,
        default: ''
      },
      disabled: {
        type: Boolean,
        default: false
      },
      scrollWidth: {
        type: Number,
        default: 160
      },
      scrollHeight: {
        type: Number,
        default: 216
      },
      clearable: {
        type: Boolean,
        default: false
      },
      checkAnyLevel: {
        type: Boolean,
        default: false
      },
      showCompleteName: {
        type: Boolean,
        default: true
      },
      filterable: {
        type: Boolean,
        default: false
      },
      multiple: {
        type: Boolean,
        default: false
      },
      limitOneLine: {
        type: Boolean,
        default: false
      },
      separator: {
        type: String,
        default: ' / '
      },
      trigger: {
        validator: function validator(value) {
          return ['click', 'hover'].includes(value);
        },
        default: 'click'
      },
      emptyText: {
        type: String,
        default: ''
      },
      isRemote: {
        type: Boolean,
        default: false
      },
      remoteMethod: {
        type: Function
      },
      popoverOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      extPopoverCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {
        popoverWidth: 1,
        historyPopover: 0,
        showCascade: false,
        defaultWidth: 0,
        searchContent: '',
        searchList: [],
        cascadeList: [],
        selectedList: [],
        tmpSelected: [],
        currentList: [],
        multipleSelectedList: [],
        multipleCurrentList: [],
        filterableStatus: false,
        filterRestoreStatus: false,
        remoteSearchLoading: false
      };
    },
    computed: {
      selectedName: function selectedName() {
        var label = [];
        if (this.multiple) {
          label = this.multipleSelectedList.map(function (item) {
            return item.name;
          });
        } else {
          if (!this.showCompleteName && this.selectedList.length) {
            label = [this.selectedList[this.selectedList.length - 1].name];
          } else {
            label = this.selectedList.map(function (item) {
              return item.name;
            });
          }
        }
        return this.multiple ? label.join(' , ') : label.join(this.separator);
      },
      isUnselected: function isUnselected() {
        return this.selectedName === '';
      },
      placeContent: function placeContent() {
        return this.placeholder ? this.placeholder : this.t('bk.select.pleaseselect');
      },
      nodeOptions: function nodeOptions() {
        var nodeOptions = {
          idKey: 'id',
          nameKey: 'name',
          childrenKey: 'children'
        };
        return _extends(nodeOptions, this.options);
      }
    },
    watch: {
      showCascade: function showCascade(val) {
        this.$emit('toggle', val);
        this.filterableStatus = this.searchContent !== '';
        if (val) {
          this.popoverWidth = 1;
          if (this.currentList.length) {
            this.updateSelected();
          }
        } else {
          if (this.filterable && !this.multiple) {
            if (this.searchContent !== this.selectedName) {
              this.filterRestoreStatus = true;
            }
            this.searchContent = this.selectedName;
          }
          this.tippyInstance();
        }
        this.filterableStatus = false;
      },
      searchContent: function searchContent(val) {
        if (this.filterRestoreStatus) {
          this.filterRestoreStatus = false;
          return;
        }
        if (val) {
          this.filterableStatus = true;
          this.$refs.cascadeDropdown.$refs.reference._tippy.show();
          this.handleDropdownShow();
          this.getSearchList();
        } else {
          this.filterableStatus = false;
          if (this.multiple) {
            this.recursiveList(this.cascadeList, this.multipleCurrentList, 'search');
          }
        }
      },
      selectedName: function selectedName() {
        if (this.filterable && !this.multiple) {
          this.searchContent = this.selectedName;
        }
      },
      list: {
        handler: function handler(newValue) {
          var _this = this;
          this.cascadeList = this.recurrenceNodes(JSON.parse(stringify$1(newValue)));
          if (this.multiple) {
            this.recursiveList(this.cascadeList, this.multipleCurrentList, 'init');
            this.checkListStatus(this.multipleCurrentList);
            var newList = this.changeList();
            this.multipleSelectedList = newList.filter(function (item) {
              return item.isSelected;
            }).map(function (item) {
              return {
                id: item.id,
                name: item.name
              };
            });
          } else {
            if (this.currentList.length) {
              var findStatus = false;
              var checkInfo = function checkInfo(arr) {
                arr.forEach(function (itemArr) {
                  if (itemArr.id === _this.currentList[_this.currentList.length - 1]) {
                    findStatus = true;
                  }
                  if (itemArr.children && itemArr.children.length) {
                    checkInfo(itemArr.children);
                  }
                });
              };
              checkInfo(this.cascadeList);
              if (!findStatus) {
                this.currentList = [];
                this.selectedList = [];
                this.tmpSelected = [];
              }
            }
          }
        },
        deep: true
      },
      value: {
        handler: function handler() {
          this.initValue();
        },
        deep: true
      }
    },
    created: function created() {
      var _this2 = this;
      this.cascadeList = this.recurrenceNodes(JSON.parse(stringify$1(this.list)));
      this.$on('on-id-change', function (params) {
        var isLast = params.isLast,
            checkAnyLevel = params.checkAnyLevel,
            fromInit = params.fromInit;
        if (isLast || checkAnyLevel) {
          var oldIdList = JSON.parse(stringify$1(_this2.currentList));
          _this2.selectedList = _this2.tmpSelected;
          var newIdList = _this2.selectedList.map(function (item) {
            return item.id;
          });
          if (!fromInit) {
            _this2.currentList = newIdList;
            _this2.exposedId(_this2.currentList, oldIdList);
          }
        }
        if (isLast && !fromInit) {
          _this2.tippyInstance();
        }
      });
      this.$on('on-multiple-change', function (params) {
        var checkAnyLevel = params.checkAnyLevel,
            fromInit = params.fromInit;
        _this2.selectedList = _this2.tmpSelected;
        var newIdList = _this2.selectedList.map(function (item) {
          return item.id;
        });
        if (!fromInit) {
          _this2.currentList = newIdList;
        }
        if (!checkAnyLevel) {
          _this2.cascadeList.forEach(function (item) {
            if (item.children && item.children.length) {
              item.isSelected = item.children.every(function (child) {
                return child.isSelected || child.disabled;
              });
              item.isIndeterminate = item.children.some(function (child) {
                return child.isIndeterminate || child.isSelected;
              });
            }
          });
        }
        var oldIdList = JSON.parse(stringify$1(_this2.multipleCurrentList));
        _this2.exposeMultiple(oldIdList);
      });
      this.$on('on-popover-width', function (params) {
        var currentItem = params.item;
        _this2.popoverWidth = _this2.tmpSelected.length;
        if (currentItem.children && currentItem.children.length) {
          _this2.popoverWidth += 1;
        }
      });
    },
    mounted: function mounted() {
      this.initValue();
      if (this.isRemote) {
        this.filterable = false;
      }
    },
    methods: {
      recurrenceNodes: function recurrenceNodes(list) {
        var _this3 = this;
        if (!isArray$1(list) || !list.length) {
          return [];
        }
        var _this$nodeOptions = this.nodeOptions,
            idKey = _this$nodeOptions.idKey,
            nameKey = _this$nodeOptions.nameKey,
            childrenKey = _this$nodeOptions.childrenKey;
        list.forEach(function (item, index) {
          item.id = _this3.multiple ? String(item[idKey]) : item[idKey];
          item.name = item[nameKey] || '';
          var children = item[childrenKey];
          if (isArray$1(children)) {
            item.children = _this3.recurrenceNodes(children);
          }
        });
        return list;
      },
      initValue: function initValue() {
        if (this.multiple) {
          this.multipleCurrentList = this.value;
          this.changeValueList();
        } else {
          this.currentList = this.value;
          if (this.value.length) {
            this.updateSelected();
          } else {
            this.clearData();
          }
        }
      },
      clearData: function clearData() {
        if (this.disabled) return;
        if (this.multiple) {
          var oldId = JSON.parse(stringify$1(this.multipleCurrentList));
          this.multipleCurrentList = [];
          this.multipleSelectedList = [];
          this.exposedId(this.multipleCurrentList, oldId);
          var changeCheckStatus = function changeCheckStatus(arr) {
            arr.forEach(function (item) {
              item.isSelected = false;
              item.isIndeterminate = false;
              if (item.children && item.children.length) {
                changeCheckStatus(item.children);
              }
            });
          };
          changeCheckStatus(this.cascadeList);
        } else {
          var _oldId = JSON.parse(stringify$1(this.currentList));
          this.currentList = [];
          this.selectedList = [];
          this.tmpSelected = [];
          this.exposedId(this.currentList, _oldId);
        }
        this.broadcast('bkCaspanel', 'on-clear');
        this.tippyInstance();
      },
      handleDropdownShow: function handleDropdownShow() {
        this.popoverWidth = 1;
        this.defaultWidth = this.$el.offsetWidth;
        if (this.currentList.length) {
          this.updateSelected();
        }
        if (this.disabled) return;
        this.showCascade = true;
        if (!this.currentList.length) {
          this.broadcast('bkCaspanel', 'on-clear');
        }
      },
      handleDropdownHide: function handleDropdownHide() {
        this.showCascade = false;
      },
      tippyInstance: function tippyInstance() {
        if (this.$refs.cascadeDropdown) {
          this.$refs.cascadeDropdown.$refs.reference._tippy.hide();
        }
      },
      showTippyInstance: function showTippyInstance() {
        if (this.$refs.cascadeDropdown) {
          this.$refs.cascadeDropdown.$refs.reference._tippy.show();
        }
      },
      exposedId: function exposedId(newId, oldId) {
        if (stringify$1(newId) !== stringify$1(oldId)) {
          var selectedList = this.multiple ? this.multipleSelectedList : this.selectedList;
          this.$emit('input', newId);
          this.$emit('change', newId, oldId, JSON.parse(stringify$1(selectedList)));
        }
      },
      exposeMultiple: function exposeMultiple(oldId) {
        var newList = this.changeList();
        this.multipleSelectedList = [];
        this.multipleCurrentList = [];
        for (var i = 0; i < newList.length; i++) {
          if (newList[i].isSelected) {
            this.multipleSelectedList.push({
              id: newList[i].id,
              name: newList[i].name
            });
          }
        }
        for (var _i = 0; _i < newList.length; _i++) {
          if (newList[_i].isSelected) {
            this.multipleCurrentList.push(newList[_i].id);
          }
        }
        this.exposedId(this.multipleCurrentList, oldId);
      },
      updateSelectedList: function updateSelectedList(selectedList) {
        this.tmpSelected = selectedList;
      },
      updateSelected: function updateSelected() {
        this.broadcast('bkCaspanel', 'change-selected', {
          idList: this.currentList
        });
      },
      getSearchList: function getSearchList() {
        var _this4 = this;
        var selections = this.changeList();
        this.searchList = selections.filter(function (item) {
          return item.name && item.name.indexOf(_this4.searchContent) > -1;
        });
        if (!this.multiple) {
          this.searchList.forEach(function (item) {
            item.isSelected = _this4.currentList.join(',') === item.id.join(',');
          });
        }
      },
      changeList: function changeList() {
        var _this5 = this;
        var listInfo = JSON.parse(stringify$1(this.cascadeList));
        var selections = [];
        var getSelections = function getSelections(arr, id, name) {
          arr.forEach(function (item) {
            item.id = id ? id + _this5.separator + item.id : item.id;
            item.name = name ? name + _this5.separator + item.name : item.name;
            if (_this5.checkAnyLevel) {
              selections.push({
                id: String(item.id).split(_this5.separator),
                name: item.name,
                disabled: !!item.disabled,
                isSelected: !!item.isSelected
              });
              if (item.children && item.children.length) {
                getSelections(item.children, item.id, item.name);
              }
            } else {
              if (item.children && item.children.length) {
                getSelections(item.children, item.id, item.name);
                delete item.id;
                delete item.name;
              } else {
                if (!item.id.split) {
                  return false;
                }
                selections.push({
                  id: item.id.split(_this5.separator),
                  name: item.name,
                  disabled: !!item.disabled,
                  isSelected: !!item.isSelected
                });
              }
            }
          });
        };
        getSelections(listInfo);
        return selections;
      },
      changeValueList: function changeValueList() {
        if (this.isRemote) {
          this.recursiveList(this.cascadeList, this.value, 'search');
        } else {
          this.recursiveList(this.cascadeList, this.value, 'init');
        }
        this.checkListStatus(this.value);
        var newList = this.changeList();
        this.multipleSelectedList = newList.filter(function (item) {
          return item.isSelected;
        }).map(function (item) {
          return {
            id: item.id,
            name: item.name
          };
        });
      },
      recursiveList: function recursiveList(arr, valueList, type) {
        var _this6 = this;
        arr.forEach(function (arrItem) {
          if (type === 'init') {
            _this6.$set(arrItem, 'isSelected', false);
            _this6.$set(arrItem, 'isIndeterminate', false);
          }
          valueList.forEach(function (item) {
            if (isArray$1(item)) {
              if (item[item.length - 1] === arrItem.id) {
                arrItem.isSelected = true;
              }
              if (!_this6.checkAnyLevel) {
                item.forEach(function (child) {
                  if (child === arrItem.id) {
                    arrItem.isIndeterminate = true;
                  }
                });
              }
            }
          });
          if (arrItem.children && arrItem.children.length) {
            _this6.recursiveList(arrItem.children, valueList, type);
          }
        });
      },
      checkListStatus: function checkListStatus(currentValue) {
        var _this7 = this;
        if (!this.checkAnyLevel) {
          var valueList = [];
          currentValue.forEach(function (item) {
            isArray$1(item) && valueList.push(item.length);
          });
          var value = Math.max.apply(Math, valueList);
          var _loop = function _loop(i) {
            var checkInfo = function checkInfo(arr) {
              arr.forEach(function (arrItem) {
                if (arrItem.children && arrItem.children.length) {
                  arrItem.isSelected = arrItem.children.every(function (child) {
                    return child.isSelected || child.disabled;
                  });
                  arrItem.isIndeterminate = arrItem.children.some(function (child) {
                    return child.isIndeterminate || child.isSelected;
                  });
                  checkInfo(arrItem.children);
                }
              });
            };
            checkInfo(_this7.cascadeList);
          };
          for (var i = 0; i <= value; i++) {
            _loop(i);
          }
        }
      },
      handleSelectItem: function handleSelectItem(item, index) {
        var _this8 = this;
        if (item.disabled) {
          return;
        }
        if (this.multiple) {
          var oldId = JSON.parse(stringify$1(this.multipleCurrentList));
          item.isSelected = !item.isSelected;
          if (item.isSelected) {
            this.multipleCurrentList.push(item.id);
            this.multipleSelectedList.push({
              id: item.id,
              name: item.name
            });
          } else {
            this.multipleCurrentList = this.multipleCurrentList.filter(function (node) {
              return node.join('/') !== item.id.join('/');
            });
            this.multipleSelectedList = this.multipleSelectedList.filter(function (node) {
              return node.id.join('/') !== item.id.join('/');
            });
          }
          this.recursiveList(this.cascadeList, this.multipleCurrentList, 'search');
          this.broadcast('bkCaspanel', 'multiple-selected', {
            idList: item.id,
            isSelected: item.isSelected
          });
          this.exposeMultiple(oldId);
        } else {
          var oldVal = JSON.parse(stringify$1(this.currentList));
          this.currentList = item.id;
          this.tmpSelected = [];
          this.selectedList = [];
          this.updateSelected();
          setTimeout(function () {
            _this8.searchContent = _this8.selectedName;
            _this8.exposedId(_this8.currentList, oldVal);
            _this8.tippyInstance();
          }, 0);
        }
      },
      removeTag: function removeTag(item, index) {
        var oldId = JSON.parse(stringify$1(this.multipleCurrentList));
        this.multipleCurrentList = this.multipleCurrentList.filter(function (itemInfo) {
          return itemInfo.join(',') !== item.id.join(',');
        });
        this.multipleSelectedList = this.multipleSelectedList.filter(function (itemInfo) {
          return itemInfo.id.join(',') !== item.id.join(',');
        });
        var itemId = item.id[item.id.length - 1];
        var changeCheckStatus = function changeCheckStatus(arr) {
          arr.forEach(function (item) {
            if ("".concat(itemId) === "".concat(item.id)) {
              item.isSelected = false;
              item.isIndeterminate = false;
            }
            if (item.children && item.children.length) {
              changeCheckStatus(item.children);
            }
          });
        };
        changeCheckStatus(this.cascadeList);
        this.checkListStatus(this.multipleCurrentList);
        this.exposeMultiple(oldId);
      },
      handleSearchInput: function handleSearchInput(event) {
        var value = event.target.value;
        this.$emit('search', value, event);
      }
    }
  };

  /* script */
  var __vue_script__$1q = script$1q;
  /* template */

  var __vue_render__$1q = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-cascade",
      class: {
        'is-focus': _vm.showCascade,
        'is-disabled': _vm.disabled,
        'is-unselected': _vm.isUnselected,
        'is-default-trigger': !_vm.$scopedSlots.trigger
      },
      attrs: {
        "tabindex": "0",
        "data-placeholder": _vm.placeContent
      },
      on: {
        "keydown": [function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
            return null;
          }

          $event.preventDefault();
          return _vm.showTippyInstance($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
            return null;
          }

          return _vm.handleDropdownHide($event);
        }, function ($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
            return null;
          }

          $event.stopPropagation();
          $event.preventDefault();
          return _vm.handleDropdownHide($event);
        }]
      }
    }, [_c('i', {
      staticClass: "bk-cascade-angle bk-icon icon-angle-down"
    }), _vm.clearable && !_vm.disabled && _vm.selectedName ? _c('i', {
      staticClass: "bk-cascade-clear bk-icon icon-close",
      on: {
        "click": function click($event) {
          $event.preventDefault();
          $event.stopPropagation();
          return _vm.clearData($event);
        }
      }
    }) : _vm._e(), _c('bk-popover', {
      ref: "cascadeDropdown",
      staticClass: "bk-cascade-dropdown",
      staticStyle: {
        "max-width": "100%"
      },
      attrs: {
        "trigger": "click",
        "placement": "bottom-start",
        "theme": "light bk-cascade-dropdown",
        "animation": "slide-toggle",
        "distance": 12,
        "on-show": _vm.handleDropdownShow,
        "on-hide": _vm.handleDropdownHide,
        "tippy-options": _vm.popoverOptions
      }
    }, [_vm.multiple ? [_vm.limitOneLine ? _c('div', {
      staticClass: "bk-cascade-name",
      attrs: {
        "title": _vm.selectedName
      }
    }, [_c('span', [_vm._v(_vm._s(_vm.selectedName))])]) : _c('section', [_vm.multipleSelectedList.length || !_vm.filterable ? _c('div', {
      staticClass: "bk-cascade-tag-list"
    }, _vm._l(_vm.multipleSelectedList, function (item, index) {
      return _c('span', {
        key: index,
        staticClass: "bk-cascade-tag-item",
        staticStyle: {
          "padding-right": "18px"
        }
      }, [_c('span', {
        staticClass: "bk-cascade-item-name",
        attrs: {
          "title": item.name
        }
      }, [_vm._v(_vm._s(item.name))]), _c('a', {
        staticClass: "remove-key",
        attrs: {
          "href": "javascript:void(0)",
          "tabindex": "-1"
        },
        on: {
          "click": function click($event) {
            $event.stopPropagation();

            _vm.removeTag(item, index);
          }
        }
      }, [_c('i', {
        staticClass: "bk-icon icon-close"
      })])]);
    }), 0) : _vm._e()]), _vm.filterable ? _c('div', {
      staticClass: "bk-cascade-name"
    }, [_c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: _vm.searchContent,
        expression: "searchContent"
      }],
      ref: "searchInput",
      staticClass: "bk-cascade-search-input",
      attrs: {
        "type": "text",
        "placeholder": _vm.t('bk.select.searchPlaceholder')
      },
      domProps: {
        "value": _vm.searchContent
      },
      on: {
        "input": [function ($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.searchContent = $event.target.value;
        }, _vm.handleSearchInput]
      }
    })]) : _vm._e()] : _c('div', {
      staticClass: "bk-cascade-name",
      attrs: {
        "title": _vm.selectedName
      }
    }, [_vm.filterable ? _c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: _vm.searchContent,
        expression: "searchContent"
      }],
      ref: "searchInput",
      staticClass: "bk-cascade-search-input",
      attrs: {
        "type": "text",
        "placeholder": _vm.t('bk.select.searchPlaceholder')
      },
      domProps: {
        "value": _vm.searchContent
      },
      on: {
        "input": [function ($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.searchContent = $event.target.value;
        }, _vm.handleSearchInput]
      }
    }) : _c('span', [_vm._v(_vm._s(_vm.selectedName))])]), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.disabled,
        expression: "!disabled"
      }],
      class: ['bk-cascade-dropdown-content', _vm.extPopoverCls],
      style: {
        width: (_vm.filterable && !!_vm.searchContent && _vm.filterableStatus && !_vm.searchList.length || !_vm.cascadeList.length ? _vm.defaultWidth : _vm.scrollWidth * _vm.popoverWidth + 2) + 'px'
      },
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [_c('div', {
      staticClass: "bk-cascade-options",
      style: {
        height: (_vm.filterable && !!_vm.searchContent && _vm.filterableStatus && !_vm.searchList.length || !_vm.cascadeList.length ? 32 : _vm.scrollHeight) + 'px'
      }
    }, [_vm.filterable && !!_vm.searchContent && _vm.filterableStatus ? _c('div', {
      staticClass: "bk-cascade-panel"
    }, [_c('ul', {
      staticClass: "bk-cascade-panel-ul",
      staticStyle: {
        "width": "100%"
      }
    }, [_vm._l(_vm.searchList, function (item, index) {
      return _c('li', {
        key: index,
        staticClass: "bk-option",
        class: {
          'is-selected': item.isSelected,
          'is-disabled': item.disabled
        },
        on: {
          "click": function click($event) {
            $event.preventDefault();
            $event.stopPropagation();

            _vm.handleSelectItem(item, index);
          }
        }
      }, [_c('div', {
        staticClass: "bk-option-content"
      }, [_vm._t("default", [_c('div', {
        staticClass: "bk-option-content-default",
        attrs: {
          "title": item.name
        }
      }, [_c('span', {
        staticClass: "bk-option-name"
      }, [_vm._v(_vm._s(item.name))])])])], 2)]);
    }), !_vm.searchList.length ? _c('li', {
      staticClass: "bk-option-none"
    }, [_c('span', [_vm._v(_vm._s(_vm.emptyText || _vm.t('bk.select.searchEmpty')))])]) : _vm._e()], 2)]) : _vm._e(), _c('bk-caspanel', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.filterableStatus,
        expression: "!filterableStatus"
      }],
      attrs: {
        "list": _vm.cascadeList,
        "trigger": _vm.trigger,
        "scroll-width": _vm.scrollWidth,
        "disabled": _vm.disabled,
        "check-any-level": _vm.checkAnyLevel,
        "filterable": _vm.filterable,
        "multiple": _vm.multiple,
        "is-remote": _vm.isRemote,
        "remote-method": _vm.remoteMethod
      },
      on: {
        "updateSelectedList": _vm.updateSelectedList
      },
      scopedSlots: _vm._u([{
        key: "prepend",
        fn: function fn(ref) {
          var node = ref.node;
          return [_vm._t("prepend", null, {
            node: node
          })];
        }
      }])
    })], 1)])], 2)], 1);
  };

  var __vue_staticRenderFns__$1q = [];
  /* style */

  var __vue_inject_styles__$1t = undefined;
  /* scoped */

  var __vue_scope_id__$1t = undefined;
  /* module identifier */

  var __vue_module_identifier__$1t = undefined;
  /* functional template */

  var __vue_is_functional_template__$1t = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1t = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1q,
    staticRenderFns: __vue_staticRenderFns__$1q
  }, __vue_inject_styles__$1t, __vue_script__$1q, __vue_scope_id__$1t, __vue_is_functional_template__$1t, __vue_module_identifier__$1t, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1t);

  var script$1r = {
    name: 'bk-card',
    components: {
      bkInput: __vue_component__$A
    },
    props: {
      title: {
        type: String,
        default: ''
      },
      showHead: {
        type: Boolean,
        default: true
      },
      showFoot: {
        type: Boolean,
        default: false
      },
      isEdit: {
        type: Boolean,
        default: false
      },
      isCollapse: {
        type: Boolean,
        default: false
      },
      collapseIcons: {
        type: Array,
        default: function _default() {
          return ['icon-angle-up-line', 'icon-angle-down-line'];
        }
      },
      position: {
        type: String,
        default: 'left'
      },
      border: {
        type: Boolean,
        default: true
      },
      collapseStatus: {
        type: Boolean,
        default: true
      },
      disableHeaderStyle: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        collapseActive: true,
        showInput: true,
        renderTitle: ''
      };
    },
    computed: {
      collapseIcon: function collapseIcon() {
        return this.collapseIcons[Number(this.collapseActive)];
      },
      collapseClass: function collapseClass() {
        return this.isCollapse ? "bk-card-head bk-card-head-".concat(this.position) : 'bk-card-head';
      }
    },
    watch: {
      title: {
        immediate: true,
        handler: function handler(value) {
          this.renderTitle = value;
        }
      },
      collapseStatus: {
        immediate: true,
        handler: function handler(value) {
          this.collapseActive = value;
        }
      }
    },
    methods: {
      handleCollapse: function handleCollapse() {
        if (!this.isCollapse) {
          return;
        }
        this.collapseActive = !this.collapseActive;
        this.$emit('update:collapseStatus', this.collapseActive);
      },
      clickEdit: function clickEdit() {
        var _this = this;
        this.showInput = !this.showInput;
        this.$nextTick(function () {
          _this.$refs.titleInputComp && _this.$refs.titleInputComp.focus();
        });
      },
      saveEdit: function saveEdit() {
        this.showInput = true;
        this.$emit('edit', this.renderTitle);
      }
    }
  };

  /* script */
  var __vue_script__$1r = script$1r;
  /* template */

  var __vue_render__$1r = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('section', {
      class: ['bk-card', {
        'bk-card-border-none': !_vm.border
      }]
    }, [_vm.showHead ? _c('div', {
      class: [_vm.collapseClass, {
        'collapse': _vm.collapseActive
      }, {
        'no-line-height': _vm.disableHeaderStyle
      }],
      on: {
        "click": _vm.handleCollapse
      }
    }, [_vm.isCollapse ? _c('i', {
      class: "bk-icon bk-card-head-icon " + _vm.collapseIcon
    }) : _vm._e(), _vm._t("header", [_vm.showInput ? [_c('span', {
      staticClass: "title",
      attrs: {
        "title": _vm.renderTitle
      }
    }, [_vm._v(_vm._s(_vm.renderTitle))]), _c('span', {
      staticClass: "card-edit"
    }, [_vm.isEdit ? _c('i', {
      staticClass: "bk-icon icon-edit-line",
      on: {
        "click": _vm.clickEdit
      }
    }) : _vm._e()])] : _c('bk-input', {
      ref: "titleInputComp",
      attrs: {
        "ext-cls": "bk-card-input"
      },
      on: {
        "blur": _vm.saveEdit,
        "enter": _vm.saveEdit
      },
      model: {
        value: _vm.renderTitle,
        callback: function callback($$v) {
          _vm.renderTitle = $$v;
        },
        expression: "renderTitle"
      }
    })])], 2) : _vm._e(), _vm.collapseActive ? [_c('div', {
      staticClass: "bk-card-body"
    }, [_vm._t("default")], 2), _vm.showFoot ? _c('div', {
      staticClass: "bk-card-foot"
    }, [_vm._t("footer")], 2) : _vm._e()] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$1r = [];
  /* style */

  var __vue_inject_styles__$1u = undefined;
  /* scoped */

  var __vue_scope_id__$1u = undefined;
  /* module identifier */

  var __vue_module_identifier__$1u = undefined;
  /* functional template */

  var __vue_is_functional_template__$1u = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1u = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1r,
    staticRenderFns: __vue_staticRenderFns__$1r
  }, __vue_inject_styles__$1u, __vue_script__$1r, __vue_scope_id__$1u, __vue_is_functional_template__$1u, __vue_module_identifier__$1u, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1u);

  function rafThrottle(fn) {
    var locked = false;
    return function () {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (locked) return;
      locked = true;
      window.requestAnimationFrame(function (_) {
        fn.apply(_this, args);
        locked = false;
      });
    };
  }
  var script$1s = {
    name: 'bk-image-viewer',
    mixins: [locale.mixin],
    props: {
      urlList: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      zIndex: {
        type: Number,
        default: 2000
      },
      onSwitch: {
        type: Function,
        default: function _default() {}
      },
      onClose: {
        type: Function,
        default: function _default() {}
      },
      isShowTitle: {
        type: Boolean,
        default: true
      },
      initialIndex: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        name: '',
        index: this.initialIndex,
        isShow: false,
        infinite: true,
        loading: false,
        error: false,
        mode: 'contain',
        transform: {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        }
      };
    },
    computed: {
      isSingle: function isSingle() {
        return this.urlList.length <= 1;
      },
      isFirst: function isFirst() {
        return this.index === 0;
      },
      isLast: function isLast() {
        return this.index === this.urlList.length - 1;
      },
      currentImg: function currentImg() {
        return this.urlList[this.index];
      },
      currentName: function currentName() {
        var arr = this.currentImg.split('/');
        return arr[arr.length - 1];
      },
      imgStyle: function imgStyle() {
        var _this$transform = this.transform,
            scale = _this$transform.scale,
            deg = _this$transform.deg,
            offsetX = _this$transform.offsetX,
            offsetY = _this$transform.offsetY,
            enableTransition = _this$transform.enableTransition;
        var style = {
          transform: "scale(".concat(scale, ") rotate(").concat(deg, "deg)"),
          transition: enableTransition ? 'transform .3s' : '',
          'margin-left': "".concat(offsetX, "px"),
          'margin-top': "".concat(offsetY, "px")
        };
        if (this.mode === 'contain') {
          style.maxWidth = style.maxHeight = '100%';
        }
        return style;
      }
    },
    watch: {
      index: {
        handler: function handler(val) {
          this.reset();
          this.onSwitch(val);
          this.$emit('change', val);
        }
      },
      currentImg: function currentImg(val) {
        var _this2 = this;
        this.$nextTick(function (_) {
          var $img = _this2.$refs.img[0];
          if (!$img.complete) {
            _this2.loading = true;
          }
        });
      }
    },
    mounted: function mounted() {
      this.deviceSupportInstall();
      this.$refs['bk-image-viewer-wrapper'].focus();
    },
    methods: {
      hide: function hide() {
        this.deviceSupportUninstall();
        this.onClose();
        this.$emit('hide');
      },
      deviceSupportInstall: function deviceSupportInstall() {
        var _this3 = this;
        this._keyDownHandler = rafThrottle(function (e) {
          var keyCode = e.keyCode;
          switch (keyCode) {
            case 27:
              _this3.hide();
              break;
            case 32:
              _this3.toggleMode();
              break;
            case 37:
              _this3.prev();
              break;
            case 38:
              _this3.handleActions('zoomIn');
              break;
            case 39:
              _this3.next();
              break;
            case 40:
              _this3.handleActions('zoomOut');
              break;
          }
        });
        this._mouseWheelHandler = rafThrottle(function (e) {
          var delta = e.wheelDelta ? e.wheelDelta : -e.detail;
          if (delta > 0) {
            _this3.handleActions('zoomIn', {
              zoomRate: 0.015,
              enableTransition: false
            });
          } else {
            _this3.handleActions('zoomOut', {
              zoomRate: 0.015,
              enableTransition: false
            });
          }
        });
        addEvent(document, 'keydown', this._keyDownHandler);
        addEvent(document, 'mousewheel', this._mouseWheelHandler);
      },
      deviceSupportUninstall: function deviceSupportUninstall() {
        removeEvent(document, 'keydown', this._keyDownHandler);
        removeEvent(document, 'mousewheel', this._mouseWheelHandler);
        this._keyDownHandler = null;
        this._mouseWheelHandler = null;
      },
      handleImgLoad: function handleImgLoad(e) {
        this.loading = false;
        this.error = false;
      },
      handleImgError: function handleImgError(e) {
        this.error = true;
        this.loading = false;
        e.target.alt = '加载失败';
      },
      handleMouseDown: function handleMouseDown(e) {
        var _this4 = this;
        if (this.loading || e.button !== 0) return;
        var _this$transform2 = this.transform,
            offsetX = _this$transform2.offsetX,
            offsetY = _this$transform2.offsetY;
        var startX = e.pageX;
        var startY = e.pageY;
        this._dragHandler = rafThrottle(function (ev) {
          _this4.transform.offsetX = offsetX + ev.pageX - startX;
          _this4.transform.offsetY = offsetY + ev.pageY - startY;
        });
        addEvent(document, 'mousemove', this._dragHandler);
        addEvent(document, 'mouseup', function (ev) {
          removeEvent(document, 'mousemove', _this4._dragHandler);
        });
        e.preventDefault();
      },
      reset: function reset() {
        this.transform = {
          scale: 1,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: false
        };
      },
      toggleMode: function toggleMode(modeNames) {
        if (this.loading) return;
        this.mode = modeNames;
        this.reset();
      },
      prev: function prev() {
        if (this.isFirst && !this.infinite) return;
        var len = this.urlList.length;
        this.index = (this.index - 1 + len) % len;
      },
      next: function next() {
        if (this.isLast && !this.infinite) return;
        var len = this.urlList.length;
        this.index = (this.index + 1) % len;
      },
      handleActions: function handleActions(action) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (this.loading) return;
        var _zoomRate$rotateDeg$e = _objectSpread({
          zoomRate: 0.2,
          rotateDeg: 90,
          enableTransition: true
        }, options),
            zoomRate = _zoomRate$rotateDeg$e.zoomRate,
            rotateDeg = _zoomRate$rotateDeg$e.rotateDeg,
            enableTransition = _zoomRate$rotateDeg$e.enableTransition;
        var transform = this.transform;
        switch (action) {
          case 'zoomOut':
            if (transform.scale > 0.2) {
              transform.scale = _parseFloat$2((transform.scale - zoomRate).toFixed(3));
            }
            break;
          case 'zoomIn':
            transform.scale = _parseFloat$2((transform.scale + zoomRate).toFixed(3));
            break;
          case 'clocelise':
            transform.deg += rotateDeg;
            break;
          case 'anticlocelise':
            transform.deg -= rotateDeg;
            break;
        }
        transform.enableTransition = enableTransition;
      }
    }
  };

  /* script */
  var __vue_script__$1s = script$1s;
  /* template */

  var __vue_render__$1s = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "bk-zoom"
      }
    }, [_c('div', {
      ref: "bk-image-viewer-wrapper",
      staticClass: "bk-image-viewer-wrapper",
      style: {
        'z-index': _vm.zIndex
      },
      attrs: {
        "tabindex": "-1"
      }
    }, [_vm.isShowTitle && _vm.urlList.length ? _c('div', {
      staticClass: "bk-image-viewer-header"
    }, [_c('div', [_vm._v(_vm._s(_vm.currentName))]), _c('div', {
      staticClass: "tc"
    }, [_vm._v(_vm._s(_vm.index + 1) + "/" + _vm._s(_vm.urlList.length))]), _c('div', {
      staticClass: "quit-box tr"
    }, [_c('div', {
      staticClass: "quit-tips mr10"
    }, [_vm._v(_vm._s(_vm.t('bk.imageViewer.quitTips')))]), _c('div', {
      staticClass: "bk-image-viewer-close",
      on: {
        "click": _vm.hide
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-close"
    })])])]) : _vm._e(), !_vm.isSingle ? [_c('div', {
      staticClass: "bk-image-viewer-btn bk-image-viewer-prev",
      class: {
        'is-disabled': !_vm.infinite && _vm.isFirst
      },
      on: {
        "click": _vm.prev
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-left"
    })]), _c('div', {
      staticClass: "bk-image-viewer-btn bk-image-viewer-next",
      class: {
        'is-disabled': !_vm.infinite && _vm.isLast
      },
      on: {
        "click": _vm.next
      }
    }, [_c('i', {
      staticClass: "bk-icon icon-angle-right"
    })])] : _vm._e(), _c('div', {
      staticClass: "bk-image-viewer-btn bk-image-viewer-actions"
    }, [_c('div', {
      staticClass: "bk-image-viewer-actions-inner"
    }, [_c('i', {
      staticClass: "bk-icon icon-narrow-line",
      on: {
        "click": function click($event) {
          _vm.handleActions('zoomOut');
        }
      }
    }), _c('i', {
      staticClass: "bk-icon icon-enlarge-line",
      on: {
        "click": function click($event) {
          _vm.handleActions('zoomIn');
        }
      }
    }), _c('i', {
      staticClass: "bk-icon icon-normalized",
      on: {
        "click": function click($event) {
          _vm.toggleMode('original');
        }
      }
    }), _c('i', {
      staticClass: "bk-icon icon-left-turn-line",
      on: {
        "click": function click($event) {
          _vm.handleActions('anticlocelise');
        }
      }
    }), _c('i', {
      staticClass: "bk-icon icon-right-turn-line",
      on: {
        "click": function click($event) {
          _vm.handleActions('clocelise');
        }
      }
    }), _c('i', {
      staticClass: "bk-icon icon-unfull-screen",
      on: {
        "click": function click($event) {
          _vm.toggleMode('contain');
        }
      }
    })])]), _c('div', {
      staticClass: "bk-image-viewer-canvas",
      class: {
        'bk-image-viewer-has-header': _vm.isShowTitle
      }
    }, [_vm.error ? _c('div', {
      staticClass: "bk-image-viewer-error"
    }, [_c('div', [_c('i', {
      staticClass: "bk-icon icon-image-fail"
    })]), _c('div', [_vm._v(_vm._s(_vm.t('bk.imageViewer.loadFailed')))])]) : _vm._e(), _vm._l(_vm.urlList, function (url, i) {
      return i === _vm.index ? _c('img', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !_vm.error,
          expression: "!error"
        }],
        key: url,
        ref: "img",
        refInFor: true,
        staticClass: "bk-image-viewer-img",
        style: _vm.imgStyle,
        attrs: {
          "src": _vm.currentImg
        },
        on: {
          "load": _vm.handleImgLoad,
          "error": _vm.handleImgError,
          "mousedown": _vm.handleMouseDown
        }
      }) : _vm._e();
    })], 2)], 2)]);
  };

  var __vue_staticRenderFns__$1s = [];
  /* style */

  var __vue_inject_styles__$1v = undefined;
  /* scoped */

  var __vue_scope_id__$1v = undefined;
  /* module identifier */

  var __vue_module_identifier__$1v = undefined;
  /* functional template */

  var __vue_is_functional_template__$1v = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1v = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1s,
    staticRenderFns: __vue_staticRenderFns__$1s
  }, __vue_inject_styles__$1v, __vue_script__$1s, __vue_scope_id__$1v, __vue_is_functional_template__$1v, __vue_module_identifier__$1v, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1v);

  var isSupportObjectFit = function isSupportObjectFit() {
    return document.documentElement.style.objectFit !== undefined;
  };
  var ObjectFit = {
    NONE: 'none',
    CONTAIN: 'contain',
    COVER: 'cover',
    FILL: 'fill',
    SCALE_DOWN: 'scale-down'
  };
  var prevOverflow = '';
  var script$1t = {
    name: 'bk-image',
    components: {
      bkImageViewer: __vue_component__$1v
    },
    mixins: [locale.mixin],
    inheritAttrs: false,
    props: {
      src: String,
      fallback: String,
      fit: String,
      lazy: Boolean,
      scrollContainer: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      previewSrcList: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      isShowPreviewTitle: {
        type: Boolean,
        default: true
      },
      zIndex: {
        type: Number,
        default: 2000
      }
    },
    data: function data() {
      return {
        loading: true,
        error: false,
        show: !this.lazy,
        imageWidth: 0,
        imageHeight: 0,
        showViewer: false
      };
    },
    computed: {
      imageStyle: function imageStyle() {
        var fit = this.fit;
        if (!this.$isServer && fit) {
          return isSupportObjectFit() ? {
            'object-fit': fit
          } : this.getImageStyle(fit);
        }
        return {};
      },
      alignCenter: function alignCenter() {
        return !this.$isServer && !isSupportObjectFit() && this.fit !== ObjectFit.FILL;
      },
      preview: function preview() {
        var previewSrcList = this.previewSrcList;
        return isArray$1(previewSrcList) && previewSrcList.length > 0;
      },
      imageIndex: function imageIndex() {
        var previewIndex = 0;
        var srcIndex = this.previewSrcList.indexOf(this.src);
        if (srcIndex >= 0) {
          previewIndex = srcIndex;
        }
        return previewIndex;
      }
    },
    watch: {
      src: function src(val) {
        this.show && this.loadImage();
      },
      show: function show(val) {
        val && this.loadImage();
      }
    },
    mounted: function mounted() {
      if (this.lazy) {
        this.addLazyLoadListener();
      } else {
        this.loadImage();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.lazy && this.removeLazyLoadListener();
    },
    methods: {
      loadImage: function loadImage() {
        var _this = this;
        if (this.$isServer) return;
        this.loading = true;
        this.error = false;
        var img = new Image();
        img.onload = function (e) {
          return _this.handleLoad(e, img);
        };
        img.onerror = this.handleError.bind(this);
        keys$1(this.$attrs).forEach(function (key) {
          var value = _this.$attrs[key];
          img.setAttribute(key, value);
        });
        img.src = this.src;
      },
      handleLoad: function handleLoad(e, img) {
        this.imageWidth = img.width;
        this.imageHeight = img.height;
        this.loading = false;
        this.error = false;
      },
      handleError: function handleError(e) {
        this.loading = false;
        this.error = true;
        this.$emit('error', e);
      },
      handleLazyLoad: function handleLazyLoad() {
        if (isInContainer(this.$el, this._scrollContainer)) {
          this.show = true;
          this.removeLazyLoadListener();
        }
      },
      addLazyLoadListener: function addLazyLoadListener() {
        if (this.$isServer) return;
        var scrollContainer = this.scrollContainer;
        var _scrollContainer = null;
        if (isHtmlElement(scrollContainer)) {
          _scrollContainer = scrollContainer;
        } else if (isString(scrollContainer)) {
          _scrollContainer = document.querySelector(scrollContainer);
        } else {
          if ([window, document, document.documentElement].includes(this.$el)) {
            _scrollContainer = window;
          } else {
            _scrollContainer = this.$el.parentNode;
          }
        }
        if (_scrollContainer) {
          this._scrollContainer = _scrollContainer;
          this._lazyLoadHandler = throttle(200, this.handleLazyLoad);
          addEvent(_scrollContainer, 'scroll', this._lazyLoadHandler);
          this.handleLazyLoad();
        }
      },
      removeLazyLoadListener: function removeLazyLoadListener() {
        var _scrollContainer = this._scrollContainer,
            _lazyLoadHandler = this._lazyLoadHandler;
        if (this.$isServer || !_scrollContainer || !_lazyLoadHandler) return;
        removeEvent(_scrollContainer, 'scroll', _lazyLoadHandler);
        this._scrollContainer = null;
        this._lazyLoadHandler = null;
      },
      getImageStyle: function getImageStyle(fit) {
        var imageWidth = this.imageWidth,
            imageHeight = this.imageHeight;
        var _this$$el = this.$el,
            containerWidth = _this$$el.clientWidth,
            containerHeight = _this$$el.clientHeight;
        if (!imageWidth || !imageHeight || !containerWidth || !containerHeight) return {};
        var vertical = imageWidth / imageHeight < 1;
        if (fit === ObjectFit.SCALE_DOWN) {
          var isSmaller = imageWidth < containerWidth && imageHeight < containerHeight;
          fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
        }
        switch (fit) {
          case ObjectFit.NONE:
            return {
              width: 'auto',
              height: 'auto'
            };
          case ObjectFit.CONTAIN:
            return vertical ? {
              width: 'auto'
            } : {
              height: 'auto'
            };
          case ObjectFit.COVER:
            return vertical ? {
              height: 'auto'
            } : {
              width: 'auto'
            };
          default:
            return {};
        }
      },
      clickHandler: function clickHandler() {
        if (!this.preview) {
          return;
        }
        prevOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        this.showViewer = true;
      },
      closeViewer: function closeViewer() {
        document.body.style.overflow = prevOverflow;
        this.showViewer = false;
      }
    }
  };

  /* script */
  var __vue_script__$1t = script$1t;
  /* template */

  var __vue_render__$1t = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-image"
    }, [_vm.loading ? _vm._t("placeholder", [_vm._m(0)]) : _vm.error ? _vm._t("error", [_c('div', {
      staticClass: "bk-image-placeholder"
    }, [_vm.fallback ? _c('img', {
      attrs: {
        "src": _vm.fallback
      }
    }) : _c('i', {
      staticClass: "bk-icon icon-image-fail"
    })])]) : _c('img', _vm._g(_vm._b({
      staticClass: "bk-image-inner",
      class: {
        'bk-image-inner-center': _vm.alignCenter,
        'bk-image-preview': _vm.preview
      },
      style: _vm.imageStyle,
      attrs: {
        "src": _vm.src
      },
      on: {
        "click": _vm.clickHandler
      }
    }, 'img', _vm.$attrs, false), _vm.$listeners)), _vm.preview ? [_vm.showViewer ? _c('bk-image-viewer', {
      attrs: {
        "z-index": _vm.zIndex,
        "is-show-title": _vm.isShowPreviewTitle,
        "initial-index": _vm.imageIndex,
        "url-list": _vm.previewSrcList,
        "on-close": _vm.closeViewer
      }
    }) : _vm._e()] : _vm._e()], 2);
  };

  var __vue_staticRenderFns__$1t = [function () {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-image-placeholder"
    }, [_c('i', {
      staticClass: "bk-icon icon-image"
    })]);
  }];
  /* style */

  var __vue_inject_styles__$1w = undefined;
  /* scoped */

  var __vue_scope_id__$1w = undefined;
  /* module identifier */

  var __vue_module_identifier__$1w = undefined;
  /* functional template */

  var __vue_is_functional_template__$1w = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1w = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1t,
    staticRenderFns: __vue_staticRenderFns__$1t
  }, __vue_inject_styles__$1w, __vue_script__$1t, __vue_scope_id__$1w, __vue_is_functional_template__$1w, __vue_module_identifier__$1w, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1w);

  var script$1u = {
    name: 'bk-breadcrumb',
    props: {
      separator: {
        type: String,
        default: '/'
      },
      separatorClass: {
        type: String,
        default: ''
      },
      backRouter: {
        type: [Object, String],
        default: function _default() {
          return null;
        }
      },
      replace: {
        type: Boolean,
        default: false
      }
    },
    provide: function provide() {
      return {
        bkBreadcrumb: this
      };
    },
    mounted: function mounted() {
      var items = this.$el.querySelectorAll('.bk-breadcrumb__item');
      if (items.length) {
        items[items.length - 1].setAttribute('aria-current', 'page');
      }
    },
    methods: {
      goBack: function goBack() {
        var backRouter = this.backRouter,
            $router = this.$router;
        if (!backRouter || !$router) return;
        this.replace ? $router.replace(backRouter) : $router.push(backRouter);
      }
    }
  };

  /* script */
  var __vue_script__$1u = script$1u;
  /* template */

  var __vue_render__$1u = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-breadcrumb",
      attrs: {
        "aria-label": "Breadcrumb",
        "role": "navigation"
      }
    }, [!_vm.$slots.prefix && _vm.backRouter ? _c('div', {
      staticClass: "bk-breadcrumb-goback"
    }, [_c('i', {
      staticClass: "bk-icon icon-arrows-left icon-default",
      on: {
        "click": _vm.goBack
      }
    })]) : _vm._e(), _vm.$slots.prefix ? _c('div', {
      staticClass: "bk-breadcrumb-goback"
    }, [_vm._t("prefix")], 2) : _vm._e(), _vm._t("default")], 2);
  };

  var __vue_staticRenderFns__$1u = [];
  /* style */

  var __vue_inject_styles__$1x = undefined;
  /* scoped */

  var __vue_scope_id__$1x = undefined;
  /* module identifier */

  var __vue_module_identifier__$1x = undefined;
  /* functional template */

  var __vue_is_functional_template__$1x = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1x = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1u,
    staticRenderFns: __vue_staticRenderFns__$1u
  }, __vue_inject_styles__$1x, __vue_script__$1u, __vue_scope_id__$1x, __vue_is_functional_template__$1x, __vue_module_identifier__$1x, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1x);

  var script$1v = {
    name: 'bk-breadcrumb-item',
    props: {
      to: {
        type: [Object, String],
        default: function _default() {
          return null;
        }
      },
      replace: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      jump: function jump() {
        var to = this.to,
            $router = this.$router;
        if (!to || !$router) return;
        this.replace ? $router.replace(to) : $router.push(to);
      }
    }
  };

  /* script */
  var __vue_script__$1v = script$1v;
  /* template */

  var __vue_render__$1v = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-breadcrumb-item"
    }, [_c('span', {
      ref: "link",
      class: ['bk-breadcrumb-item-inner', _vm.to ? 'is-link' : ''],
      attrs: {
        "role": "link"
      },
      on: {
        "click": _vm.jump
      }
    }, [_vm._t("default")], 2), _vm.$parent.separatorClass ? _c('i', {
      staticClass: "bk-breadcrumb-separator",
      class: _vm.$parent.separatorClass
    }) : _c('span', {
      staticClass: "bk-breadcrumb-separator",
      attrs: {
        "role": "presentation"
      }
    }, [_vm._v(_vm._s(_vm.$parent.separator))])]);
  };

  var __vue_staticRenderFns__$1v = [];
  /* style */

  var __vue_inject_styles__$1y = undefined;
  /* scoped */

  var __vue_scope_id__$1y = undefined;
  /* module identifier */

  var __vue_module_identifier__$1y = undefined;
  /* functional template */

  var __vue_is_functional_template__$1y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1y = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1v,
    staticRenderFns: __vue_staticRenderFns__$1v
  }, __vue_inject_styles__$1y, __vue_script__$1v, __vue_scope_id__$1y, __vue_is_functional_template__$1y, __vue_module_identifier__$1y, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1y);

  var script$1w = {
    name: 'bk-divider',
    props: {
      direction: {
        type: String,
        default: 'horizontal',
        validator: function validator(val) {
          return ['horizontal', 'vertical'].indexOf(val) !== -1;
        }
      },
      align: {
        type: String,
        default: 'center',
        validator: function validator(val) {
          return ['left', 'center', 'right'].indexOf(val) !== -1;
        }
      },
      color: {
        type: String,
        default: '#dcdee5'
      },
      width: {
        type: Number,
        default: 1
      },
      type: {
        type: String,
        default: 'solid'
      }
    },
    data: function data() {
      return {};
    },
    computed: {
      style: function style() {
        if (this.direction === 'vertical') {
          return {
            display: 'inline-block',
            width: 0,
            height: '1em',
            margin: '0 8px',
            verticalAlign: 'middle',
            borderRight: "".concat(this.width, "px ").concat(this.type, " ").concat(this.color)
          };
        }
        return {
          display: 'block',
          width: '100%',
          height: 0,
          margin: '1em 0',
          verticalAlign: 'middle',
          borderBottom: "".concat(this.width, "px ").concat(this.type, " ").concat(this.color)
        };
      }
    }
  };

  /* script */
  var __vue_script__$1w = script$1w;
  /* template */

  var __vue_render__$1w = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-divider",
      style: _vm.style
    }, [_vm.direction === 'horizontal' ? _c('div', {
      class: ['bk-divider-info', "bk-divider-info-" + _vm.align]
    }, [_vm._t("default")], 2) : _vm._e()]);
  };

  var __vue_staticRenderFns__$1w = [];
  /* style */

  var __vue_inject_styles__$1z = undefined;
  /* scoped */

  var __vue_scope_id__$1z = undefined;
  /* module identifier */

  var __vue_module_identifier__$1z = undefined;
  /* functional template */

  var __vue_is_functional_template__$1z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1z = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1w,
    staticRenderFns: __vue_staticRenderFns__$1w
  }, __vue_inject_styles__$1z, __vue_script__$1w, __vue_scope_id__$1z, __vue_is_functional_template__$1z, __vue_module_identifier__$1z, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1z);

  var script$1x = {
    name: 'bk-tag',
    props: {
      icon: {
        type: String,
        default: ''
      },
      closable: {
        type: Boolean,
        default: false
      },
      theme: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: ''
      },
      checkable: {
        type: Boolean,
        default: false
      },
      checked: {
        type: Boolean,
        default: false
      },
      radius: {
        type: String,
        default: '2px'
      },
      extCls: {
        type: String,
        default: ''
      }
    },
    data: function data() {
      return {};
    },
    computed: {
      classes: function classes() {
        return ['bk-tag', this.closable ? "bk-tag-closable" : '', this.type ? "bk-tag-".concat(this.type) : '', this.theme ? "bk-tag-".concat(this.theme) : '', this.checkable ? "bk-tag-checkable" : '', this.checked ? "bk-tag-check" : '', this.extCls];
      },
      style: function style() {
        return {
          'border-radius': this.radius
        };
      }
    },
    watch: {},
    methods: {
      handleClose: function handleClose(e) {
        e.stopPropagation();
        this.$emit('close', e);
      },
      handleClick: function handleClick(e) {
        if (this.checkable) {
          this.$emit('change', !this.checked);
        }
      }
    }
  };

  /* script */
  var __vue_script__$1x = script$1x;
  /* template */

  var __vue_render__$1x = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('section', {
      class: _vm.classes,
      style: _vm.style,
      on: {
        "click": _vm.handleClick
      }
    }, [_vm.icon ? _c('i', {
      class: "bk-icon bk-tag-icon " + _vm.icon
    }) : _vm._e(), _c('span', [_vm._t("default")], 2), _vm.closable ? _c('i', {
      staticClass: "bk-icon icon-close bk-tag-close",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.handleClose($event);
        }
      }
    }) : _vm._e()]);
  };

  var __vue_staticRenderFns__$1x = [];
  /* style */

  var __vue_inject_styles__$1A = undefined;
  /* scoped */

  var __vue_scope_id__$1A = undefined;
  /* module identifier */

  var __vue_module_identifier__$1A = undefined;
  /* functional template */

  var __vue_is_functional_template__$1A = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1A = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1x,
    staticRenderFns: __vue_staticRenderFns__$1x
  }, __vue_inject_styles__$1A, __vue_script__$1x, __vue_scope_id__$1A, __vue_is_functional_template__$1A, __vue_module_identifier__$1A, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1A);

  var meta$1 = _meta.onFreeze;
  _objectSap('freeze', function ($freeze) {
    return function freeze(it) {
      return $freeze && _isObject(it) ? $freeze(meta$1(it)) : it;
    };
  });

  var freeze = _core.Object.freeze;

  var freeze$1 = freeze;

  var script$1y = {
    name: 'bk-resize-layout',
    props: {
      placement: {
        default: function _default() {
          return 'left';
        },
        validator: function validator(val) {
          var placements = ['top', 'right', 'bottom', 'left'];
          return placements.includes(val);
        }
      },
      min: {
        type: Number,
        default: 3,
        validator: function validator(min) {
          return min >= 3;
        }
      },
      max: {
        type: Number,
        default: Infinity
      },
      triggerWidth: {
        type: Number,
        default: 5
      },
      triggerOffset: {
        type: Number,
        default: 3
      },
      initialDivide: {
        type: [String, Number],
        default: '20%'
      },
      immediate: Boolean,
      disabled: Boolean,
      collapsible: Boolean,
      autoMinimize: {
        type: [Boolean, Number],
        default: false
      },
      border: {
        type: Boolean,
        default: true
      },
      extCls: String
    },
    data: function data() {
      return {
        collapsed: false,
        asideContentVisible: true,
        minimized: false,
        limitMax: null,
        state: {}
      };
    },
    computed: {
      vertical: function vertical() {
        return ['left', 'right'].includes(this.placement);
      },
      computedStyleKey: function computedStyleKey() {
        return this.vertical ? 'width' : 'height';
      },
      computedAsideStyle: function computedAsideStyle() {
        var divide = this.initialDivide;
        if (typeof divide === 'number') {
          divide = "".concat(divide, "px");
        }
        return _defineProperty({}, this.computedStyleKey, divide);
      },
      computedTriggerStyle: function computedTriggerStyle() {
        var _style;
        var style = (_style = {}, _defineProperty(_style, "margin-".concat(this.placement), "".concat(this.triggerOffset - this.triggerWidth, "px")), _defineProperty(_style, this.computedStyleKey, "".concat(this.triggerWidth, "px")), _style);
        return style;
      },
      computedAutoMinimize: function computedAutoMinimize() {
        if (this.autoMinimize) {
          return typeof this.autoMinimize === 'boolean' ? 50 : this.autoMinimize;
        }
        return 0;
      }
    },
    mounted: function mounted() {
      this.setupLimit();
      addResizeListener(this.$el, this.setupLimit);
    },
    beforeDestroy: function beforeDestroy() {
      removeResizeListener(this.$el, this.setupLimit);
    },
    methods: {
      setupLimit: function setupLimit() {
        var rect = this.$el.getBoundingClientRect();
        this.limitMax = this.vertical ? rect.width : rect.height;
      },
      updateResizeProxyStyle: function updateResizeProxyStyle() {
        var placement = this.placement;
        var resizeProxy = this.$refs.resizeProxy;
        resizeProxy.style.visibility = 'visible';
        switch (placement) {
          case 'left':
            resizeProxy.style.inset = "0 auto auto ".concat(this.state.aside.width, "px");
            break;
          case 'right':
            resizeProxy.style.inset = "0  ".concat(this.state.aside.width, "px auto auto");
            break;
          case 'top':
            resizeProxy.style.inset = "".concat(this.state.aside.height, "px auto auto 0");
            break;
          case 'bottom':
            resizeProxy.style.inset = "auto auto ".concat(this.state.aside.height, "px 0");
            break;
        }
      },
      updateResizeMaskStyle: function updateResizeMaskStyle() {
        var resizeMask = this.$refs.resizeMask;
        resizeMask.style.display = 'block';
        resizeMask.style.cursor = this.vertical ? 'col-resize' : 'row-resize';
      },
      getRealValue: function getRealValue(current) {
        return Math.min(this.max, Math.max(this.min, current), this.limitMax - this.triggerWidth);
      },
      handleMousedown: function handleMousedown(event) {
        var _this = this;
        this.$emit('before-resize', event);
        var placement = this.placement;
        var aside = this.$refs.aside;
        var asideRect = aside.getBoundingClientRect();
        var resizeProxy = this.$refs.resizeProxy;
        var resizeMask = this.$refs.resizeMask;
        this.state = freeze$1({
          mouse: {
            clientX: event.clientX,
            clientY: event.clientY
          },
          aside: {
            width: asideRect.width,
            height: asideRect.height
          }
        });
        this.updateResizeMaskStyle();
        if (!this.immediate) {
          this.updateResizeProxyStyle();
        }
        document.onselectstart = function () {
          return false;
        };
        document.ondragstart = function () {
          return false;
        };
        var resizingCallback = throttle(100, function (value) {
          return _this.$emit('resizing', value);
        });
        var handleMouseMove = function handleMouseMove(event) {
          var delta;
          switch (placement) {
            case 'top':
              delta = event.clientY - _this.state.mouse.clientY;
              break;
            case 'right':
              delta = _this.state.mouse.clientX - event.clientX;
              break;
            case 'bottom':
              delta = _this.state.mouse.clientY - event.clientY;
              break;
            case 'left':
              delta = event.clientX - _this.state.mouse.clientX;
          }
          var current = _this.state.aside[_this.computedStyleKey] + delta;
          var realValue = _this.getRealValue(current) + _this.triggerOffset;
          var pixel = "".concat(realValue, "px");
          if (_this.immediate) {
            aside.style[_this.computedStyleKey] = pixel;
          } else {
            resizeProxy.style[placement] = pixel;
          }
          resizingCallback(realValue);
        };
        var handleMouseUp = function handleMouseUp(event) {
          resizingCallback.cancel();
          resizeProxy.style.visibility = 'hidden';
          resizeMask.style.display = 'none';
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
          document.onselectstart = null;
          document.ondragstart = null;
          _this.$nextTick(function () {
            _this.setupAutoMinimize();
            _this.$emit('after-resize', _parseFloat$2(resizeProxy.style[placement], 10));
          });
          if (_this.immediate) {
            return false;
          }
          aside.style[_this.computedStyleKey] = resizeProxy.style[placement];
        };
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      },
      setupAutoMinimize: function setupAutoMinimize() {
        var _this2 = this;
        if (!this.autoMinimize) {
          return false;
        }
        var aside = this.$refs.aside;
        var asideRect = aside.getBoundingClientRect();
        this.minimized = this.collapsed = asideRect[this.computedStyleKey] <= this.computedAutoMinimize;
        if (!this.minimized) {
          this.asideContentVisible = true;
          return false;
        }
        this.setupAsideAnimation();
        this.$nextTick(function () {
          aside.setAttribute("data-".concat(_this2.computedStyleKey), _this2.computedAsideStyle[_this2.computedStyleKey]);
        });
      },
      setCollapse: function setCollapse(collapsed) {
        this.collapsed = typeof collapsed === 'boolean' ? collapsed : !this.collapsed;
        this.setupAsideAnimation();
        this.$emit('collapse-change', this.collapsed);
      },
      setupAsideAnimation: function setupAsideAnimation() {
        var aside = this.$refs.aside;
        var asideRect = aside.getBoundingClientRect();
        this.setupAsideListener(!this.collapsed);
        if (this.collapsed) {
          aside.setAttribute("data-".concat(this.computedStyleKey), asideRect[this.computedStyleKey] + 'px');
          aside.style[this.computedStyleKey] = '5px';
        } else {
          this.asideContentVisible = true;
          aside.style[this.computedStyleKey] = aside.getAttribute("data-".concat(this.computedStyleKey));
        }
      },
      setupAsideListener: function setupAsideListener(asideContentVisible) {
        var _this3 = this;
        var aside = this.$refs.aside;
        var removeClass = function removeClass() {
          _this3.asideContentVisible = asideContentVisible;
          aside.style.transition = '';
          aside.removeEventListener('transitionend', removeClass);
        };
        aside.addEventListener('transitionend', removeClass);
        aside.style.transition = "".concat(this.computedStyleKey, " cubic-bezier(0.4, 0, 0.2, 1) .3s");
      }
    }
  };

  /* script */
  var __vue_script__$1y = script$1y;
  /* template */

  var __vue_render__$1y = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: [_vm.extCls, 'bk-resize-layout', "bk-resize-layout-" + _vm.placement, {
        'bk-resize-layout-collapsed': _vm.collapsed,
        'bk-resize-layout-border': _vm.border
      }]
    }, [_c('aside', {
      ref: "aside",
      staticClass: "bk-resize-layout-aside",
      style: _vm.computedAsideStyle
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.asideContentVisible,
        expression: "asideContentVisible"
      }],
      staticClass: "bk-resize-layout-aside-content"
    }, [_vm._t("aside")], 2), _c('i', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.disabled && (!_vm.collapsed || _vm.autoMinimize),
        expression: "!disabled && (!collapsed || autoMinimize)"
      }],
      staticClass: "bk-resize-trigger",
      style: _vm.computedTriggerStyle,
      on: {
        "mousedown": function mousedown($event) {
          if (!('button' in $event) && _vm._k($event.keyCode, "left", 37, $event.key, ["Left", "ArrowLeft"])) {
            return null;
          }

          if ('button' in $event && $event.button !== 0) {
            return null;
          }

          _vm.handleMousedown($event);
        }
      }
    }), _c('i', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.collapsed || _vm.autoMinimize,
        expression: "!collapsed || autoMinimize"
      }],
      ref: "resizeProxy",
      class: ['bk-resize-proxy', _vm.placement]
    }), _vm.collapsible ? _vm._t("collapse-trigger", [_c('i', {
      staticClass: "bk-resize-collapse bk-icon icon-angle-left",
      on: {
        "click": _vm.setCollapse
      }
    })]) : _vm._e()], 2), _c('main', {
      staticClass: "bk-resize-layout-main"
    }, [_vm._t("main")], 2), _c('div', {
      ref: "resizeMask",
      staticClass: "bk-resize-mask"
    })]);
  };

  var __vue_staticRenderFns__$1y = [];
  /* style */

  var __vue_inject_styles__$1B = undefined;
  /* scoped */

  var __vue_scope_id__$1B = undefined;
  /* module identifier */

  var __vue_module_identifier__$1B = undefined;
  /* functional template */

  var __vue_is_functional_template__$1B = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1B = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1y,
    staticRenderFns: __vue_staticRenderFns__$1y
  }, __vue_inject_styles__$1B, __vue_script__$1y, __vue_scope_id__$1B, __vue_is_functional_template__$1B, __vue_module_identifier__$1B, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1B);

  var script$1z = {
    name: 'bk-spin',
    props: {
      theme: {
        type: String,
        default: 'primary',
        validator: function validator(value) {
          if (!['primary', 'warning', 'success', 'danger', 'info'].includes(value)) {
            console.error("theme property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      size: {
        type: String,
        default: 'small',
        validator: function validator(value) {
          if (!['large', 'normal', 'small', 'mini'].includes(value)) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      icon: {
        type: String,
        default: ''
      },
      extCls: {
        type: String,
        default: ''
      },
      placement: {
        type: String,
        default: 'bottom',
        validator: function validator(value) {
          if (!['bottom', 'right'].includes(value)) {
            console.error("placement property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      spinning: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {};
    },
    computed: {
      dotClass: function dotClass() {
        var dotClass = ["bk-spin-rotation", "bk-spin-rotation-".concat(this.size), "bk-spin-rotation-".concat(this.theme)];
        !this.spinning && dotClass.push("bk-spin-rotation-".concat(this.theme, "-wait"));
        this.placement === 'right' && dotClass.push("bk-spin-rotation-flex");
        this.placement === 'bottom' && dotClass.push("bk-spin-rotation-margin");
        return dotClass;
      },
      slotTypeClass: function slotTypeClass() {
        var slotType = ["rotate"];
        this.$slots.default && this.placement === 'right' && slotType.push("slots-".concat(this.placement, "-rotate"));
        return slotType;
      },
      iconClass: function iconClass() {
        var iconClass = ["bk-spin-icon", "bk-spin-icon-".concat(this.size), "bk-spin-icon-".concat(this.theme)];
        !this.spinning && iconClass.push("bk-spin-icon-wait");
        this.placement === 'right' && iconClass.push("bk-display-flex");
        return iconClass;
      },
      slotClass: function slotClass() {
        var slotClass = ["bk-spin-title", "bk-spin-title-".concat(this.placement)];
        this.placement === 'right' && slotClass.push("bk-spin-title-".concat(this.size), "bk-display-flex");
        return slotClass;
      }
    }
  };

  /* script */
  var __vue_script__$1z = script$1z;
  /* template */

  var __vue_render__$1z = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('transition', {
      attrs: {
        "name": "fade"
      }
    }, [_c('div', {
      class: ['bk-spin', _vm.extCls]
    }, [_c('div', {
      style: {
        display: _vm.placement === 'right' ? 'flex' : ''
      }
    }, [!_vm.icon ? _c('div', {
      class: [_vm.dotClass]
    }, [_c('div', {
      staticClass: "rotate1",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate2",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate3",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate4",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate5",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate6",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate7",
      class: _vm.slotTypeClass
    }), _c('div', {
      staticClass: "rotate8",
      class: _vm.slotTypeClass
    })]) : _vm._e(), _vm.icon ? _c('div', {
      class: [_vm.iconClass]
    }, [_c('i', {
      class: ['bk-icon', 'icon-' + _vm.icon]
    })]) : _vm._e(), _vm.$slots.default ? _c('div', {
      class: [_vm.slotClass]
    }, [_vm._t("default")], 2) : _vm._e()])])]);
  };

  var __vue_staticRenderFns__$1z = [];
  /* style */

  var __vue_inject_styles__$1C = undefined;
  /* scoped */

  var __vue_scope_id__$1C = undefined;
  /* module identifier */

  var __vue_module_identifier__$1C = undefined;
  /* functional template */

  var __vue_is_functional_template__$1C = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1C = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1z,
    staticRenderFns: __vue_staticRenderFns__$1z
  }, __vue_inject_styles__$1C, __vue_script__$1z, __vue_scope_id__$1C, __vue_is_functional_template__$1C, __vue_module_identifier__$1C, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$1C);

  var components = {
    bkBackTop: __vue_component__,
    bkAffix: __vue_component__$1,
    bkFixedNavbar: __vue_component__$2,
    bkTransition: __vue_component__$3,
    bkAlert: __vue_component__$4,
    bkBadge: __vue_component__$6,
    bkButton: __vue_component__$7,
    bkAnimateNumber: __vue_component__$5,
    bkCheckbox: __vue_component__$8,
    bkCheckboxGroup: __vue_component__$9,
    bkCollapse: __vue_component__$a,
    bkCollapseItem: __vue_component__$b,
    bkColorPicker: __vue_component__$i,
    bkComposeFormItem: bkComposeFormItem,
    bkDatePicker: bkDatePicker,
    bkDialog: __vue_component__$u,
    bkDiff: __vue_component__$v,
    bkDropdownMenu: __vue_component__$w,
    bkException: __vue_component__$x,
    bkForm: __vue_component__$y,
    bkFormItem: __vue_component__$z,
    bkIcon: Icon,
    bkInput: __vue_component__$A,
    bkOption: __vue_component__$E,
    bkOptionGroup: __vue_component__$F,
    bkPagination: __vue_component__$O,
    bkPopover: __vue_component__$G,
    bkPopconfirm: __vue_component__$P,
    bkProcess: __vue_component__$Q,
    bkProgress: __vue_component__$R,
    bkRadio: __vue_component__$S,
    bkRadioButton: __vue_component__$T,
    bkRadioGroup: __vue_component__$U,
    bkRoundProgress: __vue_component__$V,
    bkSelect: __vue_component__$K,
    bkSideslider: __vue_component__$W,
    bkSlider: __vue_component__$Y,
    bkSteps: __vue_component__$Z,
    bkSwitcher: __vue_component__$_,
    bkTab: __vue_component__$$,
    bkTabPanel: __vue_component__$10,
    bkTable: __vue_component__$13,
    bkTableColumn: TableColumn,
    bkTableSettingContent: __vue_component__$14,
    bkTagInput: __vue_component__$15,
    bkTimePicker: bkTimePicker,
    bkTimeline: __vue_component__$16,
    bkTransfer: __vue_component__$17,
    bkTree: __vue_component__$18,
    bkUpload: __vue_component__$19,
    bkContainer: __vue_component__$1a,
    bkCol: __vue_component__$1b,
    bkRow: __vue_component__$1c,
    bkNavigation: __vue_component__$1n,
    bkNavigationMenu: __vue_component__$1o,
    bkNavigationMenuItem: __vue_component__$1p,
    bkNavigationMenuGroup: __vue_component__$1q,
    bkSearchSelect: __vue_component__$1j,
    bkRate: __vue_component__$1e,
    bkStar: __vue_component__$1d,
    bkSwiper: __vue_component__$1f,
    bkVirtualScroll: __vue_component__$J,
    bkZoomImage: __vue_component__$1g,
    bkBigTree: __vue_component__$1l,
    bkLink: __vue_component__$11,
    bkCascade: __vue_component__$1t,
    bkVersionDetail: __vue_component__$1h,
    bkCard: __vue_component__$1u,
    bkImage: __vue_component__$1w,
    bkImageViewer: __vue_component__$1v,
    bkBreadcrumb: __vue_component__$1x,
    bkBreadcrumbItem: __vue_component__$1y,
    bkDivider: __vue_component__$1z,
    bkTag: __vue_component__$1A,
    bkResizeLayout: __vue_component__$1B,
    bkSpin: __vue_component__$1C,
    bkVirtualRender: Component
  };
  var directives = {
    bkClickoutside: bkClickoutside,
    bkTooltips: bkTooltips,
    bkLoading: bkLoading$1,
    bkOverflowTips: overflowTips,
    bkCopy: bkCopy
  };
  function install(Vue) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    locale.use(opts.locale);
    locale.i18n(opts.i18n);
    Vue.prototype.$BK_EL = {
      zIndex: opts.zIndex || 2000
    };
    values$1(components).forEach(function (component) {
      Vue.use(component, _objectSpread({
        namespace: opts.namespace
      }, opts[component.name] || {}));
    });
    values$1(directives).forEach(function (directive) {
      Vue.use(directive);
    });
  }
  if (typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }
  var bkMagic = _objectSpread({}, components, directives, {
    bkMessage: BkMessage,
    bkNotify: BkNotify,
    bkInfoBox: Info,
    locale: locale,
    lang: lang,
    install: install
  });

  exports.bkAffix = __vue_component__$1;
  exports.bkAlert = __vue_component__$4;
  exports.bkAnimateNumber = __vue_component__$5;
  exports.bkBackTop = __vue_component__;
  exports.bkBadge = __vue_component__$6;
  exports.bkBigTree = __vue_component__$1l;
  exports.bkBreadcrumb = __vue_component__$1x;
  exports.bkBreadcrumbItem = __vue_component__$1y;
  exports.bkButton = __vue_component__$7;
  exports.bkCard = __vue_component__$1u;
  exports.bkCascade = __vue_component__$1t;
  exports.bkCheckbox = __vue_component__$8;
  exports.bkCheckboxGroup = __vue_component__$9;
  exports.bkClickoutside = bkClickoutside;
  exports.bkCol = __vue_component__$1b;
  exports.bkCollapse = __vue_component__$a;
  exports.bkCollapseItem = __vue_component__$b;
  exports.bkColorPicker = __vue_component__$i;
  exports.bkComposeFormItem = bkComposeFormItem;
  exports.bkContainer = __vue_component__$1a;
  exports.bkCopy = bkCopy;
  exports.bkDatePicker = bkDatePicker;
  exports.bkDialog = __vue_component__$u;
  exports.bkDiff = __vue_component__$v;
  exports.bkDivider = __vue_component__$1z;
  exports.bkDropdownMenu = __vue_component__$w;
  exports.bkException = __vue_component__$x;
  exports.bkFixedNavbar = __vue_component__$2;
  exports.bkForm = __vue_component__$y;
  exports.bkFormItem = __vue_component__$z;
  exports.bkIcon = Icon;
  exports.bkImage = __vue_component__$1w;
  exports.bkImageViewer = __vue_component__$1v;
  exports.bkInfoBox = Info;
  exports.bkInput = __vue_component__$A;
  exports.bkLink = __vue_component__$11;
  exports.bkLoading = bkLoading$1;
  exports.bkMessage = BkMessage;
  exports.bkNavigation = __vue_component__$1n;
  exports.bkNavigationMenu = __vue_component__$1o;
  exports.bkNavigationMenuGroup = __vue_component__$1q;
  exports.bkNavigationMenuItem = __vue_component__$1p;
  exports.bkNotify = BkNotify;
  exports.bkOption = __vue_component__$E;
  exports.bkOptionGroup = __vue_component__$F;
  exports.bkOverflowTips = overflowTips;
  exports.bkPagination = __vue_component__$O;
  exports.bkPopconfirm = __vue_component__$P;
  exports.bkPopover = __vue_component__$G;
  exports.bkProcess = __vue_component__$Q;
  exports.bkProgress = __vue_component__$R;
  exports.bkRadio = __vue_component__$S;
  exports.bkRadioButton = __vue_component__$T;
  exports.bkRadioGroup = __vue_component__$U;
  exports.bkRate = __vue_component__$1e;
  exports.bkResizeLayout = __vue_component__$1B;
  exports.bkRoundProgress = __vue_component__$V;
  exports.bkRow = __vue_component__$1c;
  exports.bkSearchSelect = __vue_component__$1j;
  exports.bkSelect = __vue_component__$K;
  exports.bkSideslider = __vue_component__$W;
  exports.bkSlider = __vue_component__$Y;
  exports.bkSpin = __vue_component__$1C;
  exports.bkStar = __vue_component__$1d;
  exports.bkSteps = __vue_component__$Z;
  exports.bkSwiper = __vue_component__$1f;
  exports.bkSwitcher = __vue_component__$_;
  exports.bkTab = __vue_component__$$;
  exports.bkTabPanel = __vue_component__$10;
  exports.bkTable = __vue_component__$13;
  exports.bkTableColumn = TableColumn;
  exports.bkTableSettingContent = __vue_component__$14;
  exports.bkTag = __vue_component__$1A;
  exports.bkTagInput = __vue_component__$15;
  exports.bkTimePicker = bkTimePicker;
  exports.bkTimeline = __vue_component__$16;
  exports.bkTooltips = bkTooltips;
  exports.bkTransfer = __vue_component__$17;
  exports.bkTransition = __vue_component__$3;
  exports.bkTree = __vue_component__$18;
  exports.bkUpload = __vue_component__$19;
  exports.bkVersionDetail = __vue_component__$1h;
  exports.bkVirtualRender = Component;
  exports.bkVirtualScroll = __vue_component__$J;
  exports.bkZoomImage = __vue_component__$1g;
  exports.default = bkMagic;
  exports.install = install;
  exports.lang = lang;
  exports.locale = locale;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
