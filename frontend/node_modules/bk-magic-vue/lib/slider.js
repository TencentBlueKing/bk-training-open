(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('bk-magic-vue/lib/locale'), require('vue')) :
	typeof define === 'function' && define.amd ? define(['exports', 'bk-magic-vue/lib/locale', 'vue'], factory) :
	(global = global || self, factory(global.library = {}, global.locale, global.Vue));
}(this, function (exports, locale, Vue) { 'use strict';

	locale = locale && locale.hasOwnProperty('default') ? locale['default'] : locale;
	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  : Function('return this')();
	if (typeof __g == 'number') __g = global;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.12' };
	if (typeof __e == 'number') __e = core;
	});
	var _core_1 = _core.version;

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function () {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var PROTOTYPE = 'prototype';
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    out = own ? target[key] : source[key];
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    : IS_BIND && own ? _ctx(out, _global)
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;

	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');
	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	var _stringTrim = exporter;

	var $parseFloat = _global.parseFloat;
	var $trim = _stringTrim.trim;
	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	_export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

	var _parseFloat$1 = _core.parseFloat;

	var _parseFloat$2 = _parseFloat$1;

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var toString = {}.toString;
	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');
	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');
	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	_export(_export.S, 'Array', { isArray: _isArray });

	var isArray = _core.Array.isArray;

	var isArray$1 = isArray;

	var $parseInt = _global.parseInt;
	var $trim$1 = _stringTrim.trim;
	var hex = /^[-+]?0[xX]/;
	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim$1(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	_export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

	var _parseInt$1 = _core.parseInt;

	var _parseInt$2 = _parseInt$1;

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? Object(arguments[i]) : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	_export(_export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

	var maxSafeInteger = 0x1fffffffffffff;

	var maxSafeInteger$1 = maxSafeInteger;

	_export(_export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

	var minSafeInteger = -0x1fffffffffffff;

	var minSafeInteger$1 = minSafeInteger;

	var emitter = {
	  methods: {
	    dispatch: function dispatch(componentName, eventName, params) {
	      var parent = this.$parent || this.$root;
	      var name = parent.$options.name;
	      while (parent && (!name || name !== componentName)) {
	        parent = parent.$parent;
	        if (parent) {
	          name = parent.$options.name;
	        }
	      }
	      if (parent) {
	        parent.$emit.apply(parent, [eventName].concat(params));
	      }
	    }
	  }
	};

	var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	  window.setTimeout(callback, 1000 / 60);
	};
	var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
	  window.clearTimeout(id);
	};
	var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
	var MOZ_HACK_REGEXP = /^moz([A-Z])/;
	var camelCase = function camelCase(name) {
	  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
	    return offset ? letter.toUpperCase() : letter;
	  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
	};
	var getStyle = Number(document.documentMode) < 9 ? function (element, styleName) {
	  if (!element || !styleName) return null;
	  styleName = camelCase(styleName);
	  if (styleName === 'float') {
	    styleName = 'styleFloat';
	  }
	  try {
	    switch (styleName) {
	      case 'opacity':
	        try {
	          return element.filters.item('alpha').opacity / 100;
	        } catch (e) {
	          return 1.0;
	        }
	      default:
	        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
	    }
	  } catch (e) {
	    return element.style[styleName];
	  }
	} : function (element, styleName) {
	  if (!element || !styleName) return null;
	  styleName = camelCase(styleName);
	  if (styleName === 'float') {
	    styleName = 'cssFloat';
	  }
	  try {
	    var computed = document.defaultView.getComputedStyle(element, '');
	    return element.style[styleName] || computed ? computed[styleName] : null;
	  } catch (e) {
	    return element.style[styleName];
	  }
	};

	var script = {
	  name: 'bk-input',
	  mixins: [emitter, locale.mixin],
	  props: {
	    type: {
	      type: String,
	      default: 'text',
	      validator: function validator(value) {
	        return ['text', 'textarea', 'password', 'number', 'email', 'url', 'date'].indexOf(value) > -1;
	      }
	    },
	    value: {
	      type: [String, Number],
	      default: ''
	    },
	    placeholder: {
	      type: String,
	      default: ''
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    clearable: {
	      type: Boolean,
	      default: false
	    },
	    readonly: {
	      type: Boolean,
	      default: false
	    },
	    name: {
	      type: String,
	      default: ''
	    },
	    maxlength: {
	      type: [Number, String]
	    },
	    minlength: {
	      type: [Number, String]
	    },
	    min: {
	      type: Number,
	      default: minSafeInteger$1
	    },
	    max: {
	      type: Number,
	      default: maxSafeInteger$1
	    },
	    size: {
	      type: String,
	      default: '',
	      validator: function validator(val) {
	        return ['', 'large', 'small'].includes(val);
	      }
	    },
	    leftIcon: {
	      type: String,
	      default: ''
	    },
	    rightIcon: {
	      type: String,
	      default: ''
	    },
	    rows: {
	      type: Number
	    },
	    inputStyle: {
	      type: Object
	    },
	    fontSize: {
	      type: String,
	      default: 'normal'
	    },
	    precision: Number,
	    passwordIcon: {
	      type: Array,
	      default: function _default() {
	        return ['icon-eye-slash', 'icon-eye'];
	      }
	    },
	    showControls: {
	      type: Boolean,
	      default: true
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    nativeAttributes: {
	      type: Object,
	      default: null
	    },
	    showWordLimit: {
	      type: Boolean,
	      default: undefined
	    },
	    behavior: {
	      type: String,
	      default: 'normal',
	      validate: function validate(v) {
	        return ['simplicity', 'normal'].indexOf(v) > -1;
	      }
	    },
	    showClearOnlyHover: {
	      type: Boolean,
	      default: false
	    }
	  },
	  data: function data() {
	    return {
	      hover: false,
	      curValue: '',
	      prepend: false,
	      append: false,
	      isActive: false,
	      defaultPlaceholder: '',
	      rightIconStyle: {
	        right: '10px'
	      },
	      rightPasswordIconStyle: {
	        right: '10px'
	      },
	      inputType: this.type,
	      inputSize: this.size,
	      inputPasswordIcon: this.passwordIcon,
	      inputRightPadding: '10px',
	      iconAreaSizeObserver: null
	    };
	  },
	  computed: {
	    showClearIcon: function showClearIcon() {
	      return this.clearable && this.curValue && !this.disabled && (this.showClearOnlyHover ? this.hover : true);
	    },
	    showPwdVisable: function showPwdVisable() {
	      return this.type === 'password' && this.curValue && this.inputPasswordIcon.length && !this.readonly && !this.disabled;
	    },
	    showInputWordLimit: function showInputWordLimit() {
	      if (!['text', 'textarea'].includes(this.type)) return false;
	      return this.type === 'text' ? this.maxlength && this.showWordLimit : this.maxlength && this.showWordLimit !== false;
	    },
	    bindAttribute: function bindAttribute() {
	      return this.getAttributeByType(this.inputType);
	    },
	    computedStyle: function computedStyle() {
	      return _extends(this.inputType === 'textarea' ? {} : {
	        'padding-right': this.inputRightPadding
	      }, this.inputStyle);
	    },
	    showLeftIcon: function showLeftIcon() {
	      return this.leftIcon;
	    },
	    showRightIcon: function showRightIcon() {
	      return this.rightIcon || this.clearable && this.curValue || this.type === 'password' || this.maxlength;
	    },
	    showTwoRightIcon: function showTwoRightIcon() {
	      return this.clearable && this.curValue && this.type === 'password';
	    },
	    wrapperClass: function wrapperClass() {
	      var wrapperClass = ['bk-form-control', {
	        'with-left-icon': this.showLeftIcon,
	        'with-right-icon': this.showRightIcon,
	        'with-two-right-icon': this.showTwoRightIcon,
	        'control-prepend-group': this.prepend,
	        'control-append-group': this.append,
	        'control-active': this.isActive,
	        'control-disable': this.disabled
	      }];
	      if (this.inputSize) {
	        wrapperClass.push("bk-input-wrapper-".concat(this.inputSize));
	      }
	      return wrapperClass;
	    },
	    fontSizeCls: function fontSizeCls() {
	      var cls = '';
	      if (this.fontSize === 'medium') {
	        cls = 'medium-font';
	      } else if (this.fontSize === 'large') {
	        cls = 'large-font';
	      }
	      return cls;
	    },
	    inputSizeCls: function inputSizeCls() {
	      if (this.inputSize) {
	        return "bk-input-".concat(this.inputSize);
	      }
	      return '';
	    }
	  },
	  watch: {
	    value: {
	      handler: function handler(val, old) {
	        this.setCurValue(val);
	        old === undefined && this.updateNumberValue(val);
	      },
	      immediate: true
	    },
	    placeholder: function placeholder(val) {
	      this.defaultPlaceholder = val || this.t('bk.input.input');
	    },
	    type: function type(val) {
	      this.inputType = val;
	    },
	    size: function size(val) {
	      this.inputSize = val;
	    }
	  },
	  created: function created() {
	    this.defaultPlaceholder = this.placeholder || this.t('bk.input.input');
	  },
	  mounted: function mounted() {
	    var _this = this;
	    this.prepend = this.$slots.prepend !== undefined;
	    this.append = this.$slots.append !== undefined;
	    if (this.$slots.append) {
	      this.$nextTick(function () {
	        var appendWidth = _parseFloat$2(getStyle(_this.$slots.append[0].elm, 'width'));
	        _this.rightIconStyle = {
	          right: _parseFloat$2(_this.rightIconStyle.right) + appendWidth + 'px'
	        };
	      });
	    }
	    if (this.clearable) {
	      this.rightPasswordIconStyle = {
	        right: '30px'
	      };
	    }
	    this.observerIconSize();
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.iconAreaSizeObserver && typeof this.iconAreaSizeObserver.disconnect === 'function' && this.iconAreaSizeObserver.disconnect();
	    this.iconAreaSizeObserver = null;
	  },
	  methods: {
	    observerIconSize: function observerIconSize() {
	      var _this2 = this;
	      var element = this.$refs.rightIconArea;
	      if (!element) return;
	      if (typeof ResizeObserver !== 'undefined') {
	        var defaultPadding = 10;
	        this.iconAreaSizeObserver = new ResizeObserver(function (entries) {
	          var _iterator = _createForOfIteratorHelper(entries),
	              _step;
	          try {
	            for (_iterator.s(); !(_step = _iterator.n()).done;) {
	              var entry = _step.value;
	              var cr = entry.contentRect;
	              _this2.inputRightPadding = "".concat(cr.width + defaultPadding, "px");
	            }
	          } catch (err) {
	            _iterator.e(err);
	          } finally {
	            _iterator.f();
	          }
	        });
	        this.iconAreaSizeObserver.observe(element);
	      }
	    },
	    getAttributeByType: function getAttributeByType() {
	      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var defaultAttr = {
	        type: type,
	        name: this.name,
	        placeholder: this.defaultPlaceholder,
	        disabled: this.disabled,
	        readonly: this.readonly,
	        maxlength: this.maxlength,
	        minlength: this.minlength,
	        value: this.curValue
	      };
	      type = type.toLocaleLowerCase();
	      var outputAttr = this.nativeAttributes || {};
	      switch (type) {
	        case 'number':
	          var numberAttr = {
	            min: this.min,
	            max: this.max
	          };
	          _extends(outputAttr, defaultAttr, numberAttr);
	          break;
	        case 'textarea':
	          var txtAttr = {
	            rows: this.rows
	          };
	          _extends(outputAttr, defaultAttr, txtAttr);
	          break;
	        default:
	          _extends(outputAttr, defaultAttr);
	          break;
	      }
	      return outputAttr;
	    },
	    handleToFixed: function handleToFixed(defaultNumber, len) {
	      var number = Number(defaultNumber);
	      if (isNaN(number) || number >= Math.pow(10, 21)) {
	        return number.toString();
	      }
	      if (typeof len === 'undefined' || len === 0) {
	        return Math.round(number).toString();
	      }
	      var result = number.toString();
	      var numberArr = result.split('.');
	      if (numberArr.length < 2) {
	        return this.handlePadNum(result, len);
	      }
	      var intNum = numberArr[0];
	      var deciNum = numberArr[1];
	      var lastNum = deciNum.substr(len, 1);
	      if (deciNum.length === len) {
	        return result;
	      }
	      if (deciNum.length < len) {
	        return this.handlePadNum(result, len);
	      }
	      result = intNum + '.' + deciNum.substr(0, len);
	      if (_parseInt$2(lastNum, 10) >= 5) {
	        var times = Math.pow(10, len);
	        var changedInt = Number(result.replace('.', ''));
	        changedInt++;
	        changedInt /= times;
	        result = this.handlePadNum(changedInt + '', len);
	      }
	      return result;
	    },
	    handlePadNum: function handlePadNum(num, len) {
	      var dotPos = num.indexOf('.');
	      if (dotPos === -1) {
	        num += '.';
	        for (var i = 0; i < len; i++) {
	          num += '0';
	        }
	        return num;
	      } else {
	        var need = len - (num.length - dotPos - 1);
	        for (var j = 0; j < need; j++) {
	          num += '0';
	        }
	        return num;
	      }
	    },
	    handleNumberDelete: function handleNumberDelete(event) {
	      var curNumberValue = Number(this.curValue);
	      if (curNumberValue - 1 >= this.min) {
	        var curLenAfterDot = (String(curNumberValue) || '').split('.')[1] || '';
	        var newVal = curNumberValue - 1;
	        if (typeof this.precision !== 'undefined') {
	          newVal = this.handleToFixed(newVal, Math.min(16, Math.max(curLenAfterDot.length, this.precision)));
	        }
	        this.setCurValue(newVal);
	        this.$emit('input', newVal, event);
	        this.$emit('change', newVal, event);
	        this.dispatch('bk-form-item', 'form-change');
	      }
	    },
	    handleNumberAdd: function handleNumberAdd(event) {
	      var curNumberValue = Number(this.curValue);
	      if (curNumberValue <= this.max - 1) {
	        var curLenAfterDot = (String(curNumberValue) || '').split('.')[1] || '';
	        var newVal = curNumberValue + 1;
	        if (typeof this.precision !== 'undefined') {
	          newVal = this.handleToFixed(newVal, Math.min(16, Math.max(curLenAfterDot.length, this.precision)));
	        }
	        this.setCurValue(newVal);
	        this.$emit('input', newVal, event);
	        this.$emit('change', newVal, event);
	        this.dispatch('bk-form-item', 'form-change');
	      }
	    },
	    handlerEnter: function handlerEnter(event) {
	      var value = event.target.value;
	      this.$emit('enter', value, event);
	    },
	    handlerKeyup: function handlerKeyup(event) {
	      var value = event.target.value;
	      this.$emit('keyup', value, event);
	    },
	    handlerKeypress: function handlerKeypress(event) {
	      var value = event.target.value;
	      this.$emit('keypress', value, event);
	    },
	    handlerKeydown: function handlerKeydown(event) {
	      var value = event.target.value;
	      this.$emit('keydown', value, event);
	    },
	    handlerFocus: function handlerFocus(event) {
	      var value = event.target.value;
	      this.isActive = true;
	      this.$emit('focus', value, event);
	      this.dispatch('bk-form-item', 'form-focus');
	    },
	    toPrecision: function toPrecision(num, precision) {
	      if (precision === undefined) precision = 0;
	      return this.handleToFixed(num, precision);
	    },
	    handlerBlur: function handlerBlur(event) {
	      var value = event.target.value;
	      if (/^number$/i.test(this.type) && value !== '') {
	        if (value !== '' && /^-?\d*(.\d*)?$/i.test(value)) {
	          if (value > this.max || value < this.min) {
	            value = this.getCurrentNumberValue();
	          }
	        }
	        if (typeof this.precision !== 'undefined') {
	          value = this.toPrecision(Number(value), this.precision, true);
	        } else {
	          value = Number(value);
	        }
	        if (value + '' !== event.target.value + '') {
	          this.setCurValue(value);
	          event.target.value = value;
	          this.$emit('change', value, event);
	          this.$emit('input', value, event);
	        }
	      }
	      this.isActive = false;
	      this.$emit('blur', value, event);
	      this.dispatch('bk-form-item', 'form-blur');
	    },
	    handlerPaste: function handlerPaste(event) {
	      var value = event.target.value;
	      this.$emit('paste', value, event);
	      this.$emit('change', value, event);
	      this.dispatch('bk-form-item', 'form-change');
	    },
	    getCurrentNumberValue: function getCurrentNumberValue() {
	      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      val = val === null ? this.curValue : val;
	      var value = '';
	      if (val !== '' && /^-?\d*(.\d*)?$/i.test(val)) {
	        value = Number(val);
	        value = value > this.max ? this.max : value;
	        value = value < this.min ? this.min : value;
	        return value;
	      }
	      return '';
	    },
	    handlerInput: function handlerInput(event) {
	      var value = event.target.value;
	      this.setCurValue(value);
	      this.$emit('input', value, event);
	      this.$emit('change', value, event);
	      this.dispatch('bk-form-item', 'form-change');
	    },
	    handlerClear: function handlerClear(event) {
	      this.curValue = '';
	      this.$emit('input', this.curValue, event);
	      this.$emit('change', this.curValue, event);
	      this.$emit('clear', this.curValue, event);
	      this.dispatch('bk-form-item', 'form-change');
	    },
	    handlerLeftIcon: function handlerLeftIcon(event) {
	      this.$emit('left-icon-click', this.curValue, event);
	    },
	    handlerRightIcon: function handlerRightIcon(event) {
	      this.$emit('right-icon-click', this.curValue, event);
	    },
	    focus: function focus(event) {
	      if (this.type === 'textarea') {
	        this.$refs.textarea.focus();
	      } else {
	        this.$refs.input.focus();
	      }
	    },
	    blur: function blur(event) {
	      if (this.type === 'textarea') {
	        this.$refs.textarea.blur();
	      } else {
	        this.$refs.input.blur();
	      }
	    },
	    setCurValue: function setCurValue(val) {
	      if (val === this.curValue) {
	        return false;
	      }
	      this.curValue = val;
	    },
	    updateNumberValue: function updateNumberValue(val) {
	      if (val !== '' && /^number$/i.test(this.type) && /^-?\d*(.\d*)?$/i.test(val)) {
	        val = this.getCurrentNumberValue(val);
	        this.curValue = typeof this.precision === 'number' ? this.toPrecision(Number(val), this.precision) : Number(val);
	      }
	    },
	    togglePass: function togglePass() {
	      if (this.inputType === 'password') {
	        this.inputType = 'text';
	      } else {
	        this.inputType = 'password';
	      }
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  }
	  var options = typeof script === 'function' ? script.options : script;
	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true;
	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  }
	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    hook = function hook(context) {
	      context = context ||
	      this.$vnode && this.$vnode.ssrContext ||
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      }
	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      }
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    };
	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}
	var normalizeComponent_1 = normalizeComponent;

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    class: [_vm.wrapperClass, _vm.fontSizeCls, _vm.extCls],
	    on: {
	      "mouseenter": function mouseenter($event) {
	        _vm.hover = true;
	      },
	      "mouseleave": function mouseleave($event) {
	        _vm.hover = false;
	      }
	    }
	  }, [_vm.leftIcon ? _c('div', {
	    staticClass: "control-icon left-icon",
	    on: {
	      "click": _vm.handlerLeftIcon
	    }
	  }, [_c('i', {
	    class: ['bk-icon', _vm.leftIcon]
	  })]) : _vm._e(), _vm.prepend ? _c('div', {
	    staticClass: "group-box group-prepend"
	  }, [_vm._t("prepend")], 2) : _vm._e(), _vm.inputType === 'textarea' ? [_c('div', {
	    staticClass: "bk-textarea-wrapper"
	  }, [_c('textarea', _vm._b({
	    ref: "textarea",
	    class: ['bk-form-textarea', {
	      'textarea-maxlength': _vm.maxlength
	    }],
	    style: _vm.computedStyle,
	    on: {
	      "keyup": function keyup($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
	          return null;
	        }

	        return _vm.handlerEnter($event);
	      },
	      "keypress": _vm.handlerKeypress,
	      "keydown": _vm.handlerKeydown,
	      "focus": _vm.handlerFocus,
	      "blur": _vm.handlerBlur,
	      "input": _vm.handlerInput,
	      "paste": _vm.handlerPaste
	    }
	  }, 'textarea', _vm.bindAttribute, false)), _vm.showInputWordLimit ? [_c('p', {
	    staticClass: "bk-limit-box"
	  }, [_c('span', {
	    staticClass: "strong"
	  }, [_vm._v(_vm._s(_vm.curValue && _vm.curValue.length || 0))]), _vm._v("/"), _c('span', [_vm._v(_vm._s(_vm.maxlength))])])] : _vm._e()], 2)] : [_c('div', {
	    class: ["bk-input-" + _vm.type]
	  }, [_c('input', _vm._b({
	    ref: "input",
	    class: ['bk-form-input', _vm.inputSizeCls, {
	      'only-bottom-border': _vm.behavior === 'simplicity'
	    }],
	    style: _vm.computedStyle,
	    on: {
	      "keyup": [function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
	          return null;
	        }

	        return _vm.handlerEnter($event);
	      }, _vm.handlerKeyup],
	      "keypress": _vm.handlerKeypress,
	      "keydown": _vm.handlerKeydown,
	      "focus": _vm.handlerFocus,
	      "blur": _vm.handlerBlur,
	      "input": _vm.handlerInput,
	      "paste": _vm.handlerPaste
	    }
	  }, 'input', _vm.bindAttribute, false)), /^number$/i.test(_vm.type) && !_vm.disabled && !_vm.readonly ? [_vm.showControls ? _c('span', {
	    staticClass: "input-number-option"
	  }, [_c('span', {
	    staticClass: "number-option-item bk-icon icon-angle-up",
	    on: {
	      "click": _vm.handleNumberAdd
	    }
	  }), _c('span', {
	    staticClass: "number-option-item bk-icon icon-angle-down",
	    on: {
	      "click": _vm.handleNumberDelete
	    }
	  })]) : _vm._e()] : _vm._e()], 2)], _vm.append ? _c('div', {
	    staticClass: "group-box group-append"
	  }, [_vm._t("append")], 2) : _vm._e(), !/^number$/i.test(_vm.type) ? _c('div', {
	    ref: "rightIconArea",
	    staticClass: "control-icon right-icon",
	    style: _vm.rightIconStyle,
	    on: {
	      "click": _vm.handlerRightIcon
	    }
	  }, [_vm.showPwdVisable ? _c('i', {
	    class: ['bk-icon', _vm.inputType === 'password' ? _vm.inputPasswordIcon[0] : _vm.inputPasswordIcon[1]],
	    on: {
	      "click": _vm.togglePass
	    }
	  }) : _vm._e(), _vm.showClearIcon ? _c('i', {
	    staticClass: "bk-icon icon-close-circle-shape clear-icon ml5",
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();
	        $event.preventDefault();
	        return _vm.handlerClear($event);
	      }
	    }
	  }) : _vm.rightIcon ? _c('i', {
	    class: ['bk-icon', _vm.rightIcon]
	  }) : _vm._e(), _vm.type === 'text' ? [_c('p', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.showInputWordLimit,
	      expression: "showInputWordLimit"
	    }],
	    staticClass: "bk-limit-box ml5",
	    staticStyle: {
	      "position": "static"
	    }
	  }, [_c('span', {
	    staticClass: "strong"
	  }, [_vm._v(_vm._s(_vm.curValue && _vm.curValue.length || 0))]), _vm._v("/"), _c('span', [_vm._v(_vm._s(_vm.maxlength))])])] : _vm._e()], 2) : _vm._e()], 2);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	function setInstaller (component, afterInstall) {
	  component.install = function (Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var props = component.props || {};
	    keys$1(options).forEach(function (key) {
	      if (props.hasOwnProperty(key)) {
	        if (typeof props[key] === 'function' || props[key] instanceof Array) {
	          props[key] = {
	            type: props[key],
	            default: options[key]
	          };
	        } else {
	          props[key].default = options[key];
	        }
	      }
	    });
	    component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
	    Vue.component(component.name, component);
	    typeof afterInstall === 'function' && afterInstall(Vue, options);
	  };
	}

	setInstaller(__vue_component__);

	var f$1 = Object.getOwnPropertySymbols;
	var _objectGops = {
		f: f$1
	};

	var f$2 = {}.propertyIsEnumerable;
	var _objectPie = {
		f: f$2
	};

	var $assign = Object.assign;
	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {};
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;
	  while (aLen > index) {
	    var S = _iobject(arguments[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : $assign;

	_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

	var assign = _core.Object.assign;

	var assign$1 = assign;

	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
	var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	var timeoutDuration = 0;
	for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	    timeoutDuration = 1;
	    break;
	  }
	}
	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}
	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}
	var supportsMicroTasks = isBrowser && window.Promise;
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}
	function getScrollParent(element) {
	  if (!element) {
	    return document.body;
	  }
	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }
	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;
	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }
	  return getScrollParent(getParentNode(element));
	}
	var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
	function isIE(version) {
	  if (version === 11) {
	    return isIE11;
	  }
	  if (version === 10) {
	    return isIE10;
	  }
	  return isIE11 || isIE10;
	}
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }
	  var noOffsetParent = isIE(10) ? document.body : null;
	  var offsetParent = element.offsetParent || null;
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }
	  var nodeName = offsetParent && offsetParent.nodeName;
	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
	    return getOffsetParent(offsetParent);
	  }
	  return offsetParent;
	}
	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }
	  return node;
	}
	function findCommonOffsetParent(element1, element2) {
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;
	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }
	    return getOffsetParent(commonAncestorContainer);
	  }
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }
	  return element[upperSide];
	}
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}
	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
	  return _parseFloat$2(styles["border".concat(sideA, "Width")], 10) + _parseFloat$2(styles["border".concat(sideB, "Width")], 10);
	}
	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body["offset".concat(axis)], body["scroll".concat(axis)], html["client".concat(axis)], html["offset".concat(axis)], html["scroll".concat(axis)], isIE(10) ? _parseInt$2(html["offset".concat(axis)]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Top' : 'Left')]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}
	function getWindowSizes(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE(10) && getComputedStyle(html);
	  return {
	    height: getSize('Height', body, html, computedStyle),
	    width: getSize('Width', body, html, computedStyle)
	  };
	}
	var _extends$1 = assign$1 || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	function getClientRect(offsets) {
	  return _extends$1({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}
	function getBoundingClientRect(element) {
	  var rect = {};
	  try {
	    if (isIE(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, 'top');
	      var scrollLeft = getScroll(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}
	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;
	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, 'x');
	    vertScrollbar -= getBordersSize(styles, 'y');
	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }
	  return getClientRect(result);
	}
	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var isIE10 = isIE(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);
	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = _parseFloat$2(styles.borderTopWidth, 10);
	  var borderLeftWidth = _parseFloat$2(styles.borderLeftWidth, 10);
	  if (fixedPosition && isHTML) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;
	  if (!isIE10 && isHTML) {
	    var marginTop = _parseFloat$2(styles.marginTop, 10);
	    var marginLeft = _parseFloat$2(styles.marginLeft, 10);
	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }
	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll(offsets, parent);
	  }
	  return offsets;
	}
	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);
	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };
	  return getClientRect(offset);
	}
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
	    return true;
	  }
	  var parentNode = getParentNode(element);
	  if (!parentNode) {
	    return false;
	  }
	  return isFixed(parentNode);
	}
	function getFixedPositionOffsetParent(element) {
	  if (!element || !element.parentElement || isIE()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	  var boundaries = {
	    top: 0,
	    left: 0
	  };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    var boundariesNode;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }
	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
	    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;
	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      boundaries = offsets;
	    }
	  }
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
	  return boundaries;
	}
	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;
	  return width * height;
	}
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }
	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };
	  var sortedAreas = keys$1(rects).map(function (key) {
	    return _extends$1({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });
	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });
	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
	  var variation = placement.split('-')[1];
	  return computedPlacement + (variation ? "-".concat(variation) : '');
	}
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}
	function getOuterSizes(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = _parseFloat$2(styles.marginTop || 0) + _parseFloat$2(styles.marginBottom || 0);
	  var y = _parseFloat$2(styles.marginLeft || 0) + _parseFloat$2(styles.marginRight || 0);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}
	function getOppositePlacement(placement) {
	  var hash = {
	    left: 'right',
	    right: 'left',
	    bottom: 'top',
	    top: 'bottom'
	  };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];
	  var popperRect = getOuterSizes(popper);
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }
	  return popperOffsets;
	}
	function find(arr, check) {
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }
	  return arr.filter(check)[0];
	}
	function findIndex(arr, prop, value) {
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn;
	    if (modifier.enabled && isFunction(fn)) {
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);
	      data = fn(data, modifier);
	    }
	  });
	  return data;
	}
	function _update() {
	  if (this.state.isDestroyed) {
	    return;
	  }
	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
	  data.originalPlacement = data.placement;
	  data.positionFixed = this.options.positionFixed;
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
	  data = runModifiers(this.modifiers, data);
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref3) {
	    var name = _ref3.name,
	        enabled = _ref3.enabled;
	    return enabled && name === modifierName;
	  });
	}
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
	  for (var _i = 0; _i < prefixes.length; _i++) {
	    var prefix = prefixes[_i];
	    var toCheck = prefix ? "".concat(prefix).concat(upperProp) : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}
	function _destroy() {
	  this.state.isDestroyed = true;
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style.left = '';
	    this.popper.style.right = '';
	    this.popper.style.bottom = '';
	    this.popper.style.willChange = '';
	    this.popper.style[getSupportedPropertyName('transform')] = '';
	  }
	  this.disableEventListeners();
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}
	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, {
	    passive: true
	  });
	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}
	function setupEventListeners(reference, options, state, updateBound) {
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, {
	    passive: true
	  });
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;
	  return state;
	}
	function _enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}
	function removeEventListeners(reference, state) {
	  getWindow(reference).removeEventListener('resize', state.updateBound);
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}
	function _disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}
	function isNumeric(n) {
	  return n !== '' && !isNaN(_parseFloat$2(n)) && isFinite(n);
	}
	function setStyles(element, styles) {
	  keys$1(styles).forEach(function (prop) {
	    var unit = '';
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}
	function setAttributes(element, attributes) {
	  keys$1(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}
	function applyStyle(data) {
	  setStyles(data.instance.popper, data.styles);
	  setAttributes(data.instance.popper, data.attributes);
	  if (data.arrowElement && keys$1(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }
	  return data;
	}
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
	  popper.setAttribute('x-placement', placement);
	  setStyles(popper, {
	    position: options.positionFixed ? 'fixed' : 'absolute'
	  });
	  return options;
	}
	function getRoundedOffsets(data, shouldRound) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var round = Math.round,
	      floor = Math.floor;
	  var noRound = function noRound(v) {
	    return v;
	  };
	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);
	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;
	  return {
	    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
	    top: verticalToInteger(popper.top),
	    bottom: verticalToInteger(popper.bottom),
	    right: horizontalToInteger(popper.right)
	  };
	}
	var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;
	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);
	  var styles = {
	    position: popper.position
	  };
	  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';
	  var prefixedProperty = getSupportedPropertyName('transform');
	  var left, top;
	  if (sideA === 'bottom') {
	    if (offsetParent.nodeName === 'HTML') {
	      top = -offsetParent.clientHeight + offsets.bottom;
	    } else {
	      top = -offsetParentRect.height + offsets.bottom;
	    }
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    if (offsetParent.nodeName === 'HTML') {
	      left = -offsetParent.clientWidth + offsets.right;
	    } else {
	      left = -offsetParentRect.width + offsets.right;
	    }
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = "translate3d(".concat(left, "px, ").concat(top, "px, 0)");
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = "".concat(sideA, ", ").concat(sideB);
	  }
	  var attributes = {
	    'x-placement': data.placement
	  };
	  data.attributes = _extends$1({}, attributes, data.attributes);
	  data.styles = _extends$1({}, styles, data.styles);
	  data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
	  return data;
	}
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref4) {
	    var name = _ref4.name;
	    return name === requestingName;
	  });
	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });
	  if (!isRequired) {
	    var _requesting = "`".concat(requestingName, "`");
	    var requested = "`".concat(requestedName, "`");
	    console.warn("".concat(requested, " modifier is required by ").concat(_requesting, " modifier in order to work, be sure to include it before ").concat(_requesting, "!"));
	  }
	  return isRequired;
	}
	function arrow(data, options) {
	  var _data$offsets$arrow;
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }
	  var arrowElement = options.element;
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }
	  var placement = data.placement.split('-')[0];
	  var _data$offsets2 = data.offsets,
	      popper = _data$offsets2.popper,
	      reference = _data$offsets2.reference;
	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = _parseFloat$2(css["margin".concat(sideCapitalized)], 10);
	  var popperBorderSide = _parseFloat$2(css["border".concat(sideCapitalized, "Width")], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
	  return data;
	}
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
	var validPlacements = placements.slice(3);
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}
	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};
	function flip(data, options) {
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	    return data;
	  }
	  if (data.flipped && data.placement === data.originalPlacement) {
	    return data;
	  }
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';
	  var flipOrder = [];
	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }
	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }
	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement(placement);
	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
	    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
	    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      data.flipped = true;
	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }
	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }
	      data.placement = placement + (variation ? '-' + variation : '');
	      data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
	      data = runModifiers(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}
	function keepTogether(data) {
	  var _data$offsets3 = data.offsets,
	      popper = _data$offsets3.popper,
	      reference = _data$offsets3.reference;
	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';
	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }
	  return data;
	}
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];
	  if (!value) {
	    return str;
	  }
	  if (unit.indexOf('%') === 0) {
	    var element;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }
	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    var size;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    return value;
	  }
	}
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));
	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
	  ops = ops.map(function (op, index) {
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}
	function offset(data, _ref5) {
	  var offset = _ref5.offset;
	  var placement = data.placement,
	      _data$offsets4 = data.offsets,
	      popper = _data$offsets4.popper,
	      reference = _data$offsets4.reference;
	  var basePlacement = placement.split('-')[0];
	  var offsets;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }
	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }
	  data.popper = popper;
	  return data;
	}
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }
	  var transformProp = getSupportedPropertyName('transform');
	  var popperStyles = data.instance.popper.style;
	  var top = popperStyles.top,
	      left = popperStyles.left,
	      transform = popperStyles[transformProp];
	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;
	  options.boundaries = boundaries;
	  var order = options.priority;
	  var popper = data.offsets.popper;
	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return _defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return _defineProperty({}, mainSide, value);
	    }
	  };
	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends$1({}, popper, check[side](placement));
	  });
	  data.offsets.popper = popper;
	  return data;
	}
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];
	  if (shiftvariation) {
	    var _data$offsets5 = data.offsets,
	        reference = _data$offsets5.reference,
	        popper = _data$offsets5.popper;
	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';
	    var shiftOffsets = {
	      start: _defineProperty({}, side, reference[side]),
	      end: _defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };
	    data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
	  }
	  return data;
	}
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }
	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;
	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    if (data.hide === true) {
	      return data;
	    }
	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    if (data.hide === false) {
	      return data;
	    }
	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }
	  return data;
	}
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets6 = data.offsets,
	      popper = _data$offsets6.popper,
	      reference = _data$offsets6.reference;
	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);
	  return data;
	}
	var modifiers = {
	  shift: {
	    order: 100,
	    enabled: true,
	    fn: shift
	  },
	  offset: {
	    order: 200,
	    enabled: true,
	    fn: offset,
	    offset: 0
	  },
	  preventOverflow: {
	    order: 300,
	    enabled: true,
	    fn: preventOverflow,
	    priority: ['left', 'right', 'top', 'bottom'],
	    padding: 5,
	    boundariesElement: 'scrollParent'
	  },
	  keepTogether: {
	    order: 400,
	    enabled: true,
	    fn: keepTogether
	  },
	  arrow: {
	    order: 500,
	    enabled: true,
	    fn: arrow,
	    element: '[x-arrow]'
	  },
	  flip: {
	    order: 600,
	    enabled: true,
	    fn: flip,
	    behavior: 'flip',
	    padding: 5,
	    boundariesElement: 'viewport',
	    flipVariations: false,
	    flipVariationsByContent: false
	  },
	  inner: {
	    order: 700,
	    enabled: false,
	    fn: inner
	  },
	  hide: {
	    order: 800,
	    enabled: true,
	    fn: hide
	  },
	  computeStyle: {
	    order: 850,
	    enabled: true,
	    fn: computeStyle,
	    gpuAcceleration: true,
	    x: 'bottom',
	    y: 'right'
	  },
	  applyStyle: {
	    order: 900,
	    enabled: true,
	    fn: applyStyle,
	    onLoad: applyStyleOnLoad,
	    gpuAcceleration: undefined
	  }
	};
	var Defaults = {
	  placement: 'bottom',
	  positionFixed: false,
	  eventsEnabled: true,
	  removeOnDestroy: false,
	  onCreate: function onCreate() {},
	  onUpdate: function onUpdate() {},
	  modifiers: modifiers
	};
	var Popper = function () {
	  function Popper(reference, popper) {
	    var _this = this;
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    _classCallCheck(this, Popper);
	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };
	    this.update = debounce(this.update.bind(this));
	    this.options = _extends$1({}, Popper.Defaults, options);
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;
	    this.options.modifiers = {};
	    keys$1(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });
	    this.modifiers = keys$1(this.options.modifiers).map(function (name) {
	      return _extends$1({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });
	    this.update();
	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      this.enableEventListeners();
	    }
	    this.state.eventsEnabled = eventsEnabled;
	  }
	  _createClass(Popper, [{
	    key: "update",
	    value: function update() {
	      return _update.call(this);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      return _destroy.call(this);
	    }
	  }, {
	    key: "enableEventListeners",
	    value: function enableEventListeners() {
	      return _enableEventListeners.call(this);
	    }
	  }, {
	    key: "disableEventListeners",
	    value: function disableEventListeners() {
	      return _disableEventListeners.call(this);
	    }
	  }]);
	  return Popper;
	}();
	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	function _extends$2() {
	  _extends$2 = assign$1 || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$2.apply(this, arguments);
	}
	var version = "4.3.4";
	var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
	var ua = isBrowser$1 ? navigator.userAgent : '';
	var isIE$1 = /MSIE |Trident\//.test(ua);
	var isUCBrowser = /UCBrowser\//.test(ua);
	var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
	var defaultProps = {
	  a11y: true,
	  allowHTML: true,
	  animateFill: true,
	  animation: 'shift-away',
	  appendTo: function appendTo() {
	    return document.body;
	  },
	  aria: 'describedby',
	  arrow: false,
	  arrowType: 'sharp',
	  boundary: 'scrollParent',
	  content: '',
	  delay: 0,
	  distance: 10,
	  duration: [325, 275],
	  flip: true,
	  flipBehavior: 'flip',
	  flipOnUpdate: false,
	  followCursor: false,
	  hideOnClick: true,
	  ignoreAttributes: false,
	  inertia: false,
	  interactive: false,
	  interactiveBorder: 2,
	  interactiveDebounce: 0,
	  lazy: true,
	  width: 'auto',
	  maxWidth: 'auto',
	  multiple: false,
	  offset: 0,
	  onHidden: function onHidden() {},
	  onHide: function onHide() {},
	  onMount: function onMount() {},
	  onShow: function onShow() {},
	  onShown: function onShown() {},
	  onTrigger: function onTrigger() {},
	  placement: 'top',
	  popperOptions: {},
	  role: 'tooltip',
	  showOnInit: false,
	  size: 'regular',
	  sticky: false,
	  target: '',
	  theme: 'dark',
	  touch: true,
	  touchHold: false,
	  trigger: 'mouseenter focus',
	  triggerTarget: null,
	  updateDuration: 0,
	  wait: null,
	  zIndex: 9999,
	  extCls: ''
	};
	var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
	var elementProto = isBrowser$1 ? Element.prototype : {};
	var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
	function arrayFrom(value) {
	  return [].slice.call(value);
	}
	function closest(element, selector) {
	  return closestCallback(element, function (el) {
	    return matches.call(el, selector);
	  });
	}
	function closestCallback(element, callback) {
	  while (element) {
	    if (callback(element)) {
	      return element;
	    }
	    element = element.parentElement;
	  }
	  return null;
	}
	var PASSIVE = {
	  passive: true
	};
	var PADDING = 4;
	var PLACEMENT_ATTRIBUTE = 'x-placement';
	var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries';
	var IOS_CLASS = "tippy-iOS";
	var ACTIVE_CLASS = "tippy-active";
	var POPPER_CLASS = "tippy-popper";
	var TOOLTIP_CLASS = "tippy-tooltip";
	var CONTENT_CLASS = "tippy-content";
	var BACKDROP_CLASS = "tippy-backdrop";
	var ARROW_CLASS = "tippy-arrow";
	var ROUND_ARROW_CLASS = "tippy-roundarrow";
	var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
	var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
	var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
	var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
	var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
	var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
	var isUsingTouch = false;
	function onDocumentTouch() {
	  if (isUsingTouch) {
	    return;
	  }
	  isUsingTouch = true;
	  if (isIOS) {
	    document.body.classList.add(IOS_CLASS);
	  }
	  if (window.performance) {
	    document.addEventListener('mousemove', onDocumentMouseMove);
	  }
	}
	var lastMouseMoveTime = 0;
	function onDocumentMouseMove() {
	  var now = performance.now();
	  if (now - lastMouseMoveTime < 20) {
	    isUsingTouch = false;
	    document.removeEventListener('mousemove', onDocumentMouseMove);
	    if (!isIOS) {
	      document.body.classList.remove(IOS_CLASS);
	    }
	  }
	  lastMouseMoveTime = now;
	}
	function onWindowBlur() {
	  var _document = document,
	      activeElement = _document.activeElement;
	  if (activeElement && activeElement.blur && activeElement._tippy) {
	    activeElement.blur();
	  }
	}
	function bindGlobalEventListeners() {
	  document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
	  window.addEventListener('blur', onWindowBlur);
	}
	var keys$2 = keys$1(defaultProps);
	function getDataAttributeOptions(reference) {
	  return keys$2.reduce(function (acc, key) {
	    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();
	    if (!valueAsString) {
	      return acc;
	    }
	    if (key === 'content') {
	      acc[key] = valueAsString;
	    } else {
	      try {
	        acc[key] = JSON.parse(valueAsString);
	      } catch (e) {
	        acc[key] = valueAsString;
	      }
	    }
	    return acc;
	  }, {});
	}
	function polyfillElementPrototypeProperties(virtualReference) {
	  var polyfills = {
	    isVirtual: true,
	    attributes: virtualReference.attributes || {},
	    contains: function contains() {},
	    setAttribute: function setAttribute(key, value) {
	      virtualReference.attributes[key] = value;
	    },
	    getAttribute: function getAttribute(key) {
	      return virtualReference.attributes[key];
	    },
	    removeAttribute: function removeAttribute(key) {
	      delete virtualReference.attributes[key];
	    },
	    hasAttribute: function hasAttribute(key) {
	      return key in virtualReference.attributes;
	    },
	    addEventListener: function addEventListener() {},
	    removeEventListener: function removeEventListener() {},
	    classList: {
	      classNames: {},
	      add: function add(key) {
	        virtualReference.classList.classNames[key] = true;
	      },
	      remove: function remove(key) {
	        delete virtualReference.classList.classNames[key];
	      },
	      contains: function contains(key) {
	        return key in virtualReference.classList.classNames;
	      }
	    }
	  };
	  for (var key in polyfills) {
	    virtualReference[key] = polyfills[key];
	  }
	}
	function isBareVirtualElement(value) {
	  return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
	}
	function isReferenceElement(value) {
	  return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
	}
	function hasOwnProperty$1(obj, key) {
	  return {}.hasOwnProperty.call(obj, key);
	}
	function getArrayOfElements(value) {
	  if (isSingular(value)) {
	    return [value];
	  }
	  if (value instanceof NodeList) {
	    return arrayFrom(value);
	  }
	  if (isArray$1(value)) {
	    return value;
	  }
	  try {
	    return arrayFrom(document.querySelectorAll(value));
	  } catch (e) {
	    return [];
	  }
	}
	function getValue(value, index, defaultValue) {
	  if (isArray$1(value)) {
	    var v = value[index];
	    return v == null ? defaultValue : v;
	  }
	  return value;
	}
	function debounce$1(fn, ms) {
	  if (ms === 0) {
	    return fn;
	  }
	  var timeout;
	  return function (arg) {
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      fn(arg);
	    }, ms);
	  };
	}
	function getModifier(obj, key) {
	  return obj && obj.modifiers && obj.modifiers[key];
	}
	function includes(a, b) {
	  return a.indexOf(b) > -1;
	}
	function isRealElement(value) {
	  return value instanceof Element;
	}
	function isSingular(value) {
	  return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);
	}
	function innerHTML() {
	  return 'innerHTML';
	}
	function invokeWithArgsOrReturn(value, args) {
	  return typeof value === 'function' ? value.apply(null, args) : value;
	}
	function setFlipModifierEnabled(modifiers, value) {
	  modifiers.filter(function (m) {
	    return m.name === 'flip';
	  })[0].enabled = value;
	}
	function canReceiveFocus(element) {
	  return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
	}
	function div() {
	  return document.createElement('div');
	}
	function setTransitionDuration(els, value) {
	  els.forEach(function (el) {
	    if (el) {
	      el.style.transitionDuration = "".concat(value, "ms");
	    }
	  });
	}
	function setVisibilityState(els, state) {
	  els.forEach(function (el) {
	    if (el) {
	      el.setAttribute('data-state', state);
	    }
	  });
	}
	function evaluateProps(reference, props) {
	  var out = _extends$2({}, props, {
	    content: invokeWithArgsOrReturn(props.content, [reference])
	  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
	  if (out.arrow || isUCBrowser) {
	    out.animateFill = false;
	  }
	  return out;
	}
	function validateOptions(options, defaultProps) {
	  keys$1(options).forEach(function (option) {
	    if (!hasOwnProperty$1(defaultProps, option)) {
	      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
	    }
	  });
	}
	function setInnerHTML(element, html) {
	  element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
	}
	function setContent(contentEl, props) {
	  if (isRealElement(props.content)) {
	    setInnerHTML(contentEl, '');
	    contentEl.appendChild(props.content);
	  } else if (typeof props.content !== 'function') {
	    var key = props.allowHTML ? 'innerHTML' : 'textContent';
	    contentEl[key] = props.content;
	  }
	}
	function getChildren(popper) {
	  return {
	    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
	    backdrop: popper.querySelector(BACKDROP_SELECTOR),
	    content: popper.querySelector(CONTENT_SELECTOR),
	    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
	  };
	}
	function addInertia(tooltip) {
	  tooltip.setAttribute('data-inertia', '');
	}
	function removeInertia(tooltip) {
	  tooltip.removeAttribute('data-inertia');
	}
	function createArrowElement(arrowType) {
	  var arrow = div();
	  if (arrowType === 'round') {
	    arrow.className = ROUND_ARROW_CLASS;
	    setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
	  } else {
	    arrow.className = ARROW_CLASS;
	  }
	  return arrow;
	}
	function createBackdropElement() {
	  var backdrop = div();
	  backdrop.className = BACKDROP_CLASS;
	  backdrop.setAttribute('data-state', 'hidden');
	  return backdrop;
	}
	function addInteractive(popper, tooltip) {
	  popper.setAttribute('tabindex', '-1');
	  tooltip.setAttribute('data-interactive', '');
	}
	function removeInteractive(popper, tooltip) {
	  popper.removeAttribute('tabindex');
	  tooltip.removeAttribute('data-interactive');
	}
	function updateTransitionEndListener(tooltip, action, listener) {
	  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
	  tooltip[action + 'EventListener'](eventName, listener);
	}
	function getBasicPlacement(popper) {
	  var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	  return fullPlacement ? fullPlacement.split('-')[0] : '';
	}
	function reflow(popper) {
	  void popper.offsetHeight;
	}
	function updateTheme(tooltip, action, theme) {
	  theme.split(' ').forEach(function (themeName) {
	    tooltip.classList[action](themeName + '-theme');
	  });
	}
	function setWidth(tooltip, props, key) {
	  var width = props[key];
	  var parsedWidth = _parseInt$2(width);
	  if (typeof width === 'number') {
	    tooltip.style[key] = width + 'px';
	  } else if (isNaN(parsedWidth)) {
	    tooltip.style[key] = width;
	  } else {
	    tooltip.style[key] = parsedWidth + 'px';
	  }
	}
	function createPopperElement(id, props) {
	  var popper = div();
	  popper.className = POPPER_CLASS + (props.extCls ? " ".concat(props.extCls) : '');
	  popper.id = "tippy-".concat(id);
	  popper.style.zIndex = '' + props.zIndex;
	  popper.style.position = 'absolute';
	  popper.style.top = '0';
	  popper.style.left = '0';
	  if (props.role) {
	    popper.setAttribute('role', props.role);
	  }
	  var tooltip = div();
	  tooltip.className = TOOLTIP_CLASS;
	  setWidth(tooltip, props, 'maxWidth');
	  setWidth(tooltip, props, 'width');
	  tooltip.setAttribute('data-size', props.size);
	  tooltip.setAttribute('data-animation', props.animation);
	  tooltip.setAttribute('data-state', 'hidden');
	  updateTheme(tooltip, 'add', props.theme);
	  var content = div();
	  content.className = CONTENT_CLASS;
	  content.setAttribute('data-state', 'hidden');
	  if (props.interactive) {
	    addInteractive(popper, tooltip);
	  }
	  if (props.arrow) {
	    tooltip.appendChild(createArrowElement(props.arrowType));
	  }
	  if (props.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  }
	  if (props.inertia) {
	    addInertia(tooltip);
	  }
	  setContent(content, props);
	  tooltip.appendChild(content);
	  popper.appendChild(tooltip);
	  return popper;
	}
	function updatePopperElement(popper, prevProps, nextProps) {
	  var _getChildren = getChildren(popper),
	      tooltip = _getChildren.tooltip,
	      content = _getChildren.content,
	      backdrop = _getChildren.backdrop,
	      arrow = _getChildren.arrow;
	  popper.style.zIndex = '' + nextProps.zIndex;
	  tooltip.setAttribute('data-size', nextProps.size);
	  tooltip.setAttribute('data-animation', nextProps.animation);
	  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');
	  if (nextProps.role) {
	    popper.setAttribute('role', nextProps.role);
	  } else {
	    popper.removeAttribute('role');
	  }
	  if (prevProps.content !== nextProps.content) {
	    setContent(content, nextProps);
	  }
	  if (!prevProps.animateFill && nextProps.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  } else if (prevProps.animateFill && !nextProps.animateFill) {
	    tooltip.removeChild(backdrop);
	    tooltip.removeAttribute('data-animatefill');
	  }
	  if (!prevProps.arrow && nextProps.arrow) {
	    tooltip.appendChild(createArrowElement(nextProps.arrowType));
	  } else if (prevProps.arrow && !nextProps.arrow) {
	    tooltip.removeChild(arrow);
	  }
	  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
	    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
	  }
	  if (!prevProps.interactive && nextProps.interactive) {
	    addInteractive(popper, tooltip);
	  } else if (prevProps.interactive && !nextProps.interactive) {
	    removeInteractive(popper, tooltip);
	  }
	  if (!prevProps.inertia && nextProps.inertia) {
	    addInertia(tooltip);
	  } else if (prevProps.inertia && !nextProps.inertia) {
	    removeInertia(tooltip);
	  }
	  if (prevProps.theme !== nextProps.theme) {
	    updateTheme(tooltip, 'remove', prevProps.theme);
	    updateTheme(tooltip, 'add', nextProps.theme);
	  }
	}
	function hideAll() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      excludedReferenceOrInstance = _ref.exclude,
	      duration = _ref.duration;
	  arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
	    var instance = popper._tippy;
	    if (instance) {
	      var isExcluded = false;
	      if (excludedReferenceOrInstance) {
	        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
	      }
	      if (!isExcluded) {
	        instance.hide(duration);
	      }
	    }
	  });
	}
	function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
	  if (!popperPlacement) {
	    return true;
	  }
	  var x = event.clientX,
	      y = event.clientY;
	  var interactiveBorder = props.interactiveBorder,
	      distance = props.distance;
	  var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
	  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
	}
	function getOffsetDistanceInPx(distance) {
	  return -(distance - 10) + 'px';
	}
	var idCounter = 1;
	var mouseMoveListeners = [];
	function createTippy(reference, collectionProps) {
	  var props = evaluateProps(reference, collectionProps);
	  if (!props.multiple && reference._tippy) {
	    return null;
	  }
	  var lastTriggerEventType;
	  var lastMouseMoveEvent;
	  var showTimeoutId;
	  var hideTimeoutId;
	  var scheduleHideAnimationFrameId;
	  var isScheduledToShow = false;
	  var isBeingDestroyed = false;
	  var previousPlacement;
	  var wasVisibleDuringPreviousUpdate = false;
	  var hasMountCallbackRun = false;
	  var currentMountCallback;
	  var currentTransitionEndListener;
	  var listeners = [];
	  var currentComputedPadding;
	  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
	  var id = idCounter++;
	  var popper = createPopperElement(id, props);
	  var popperChildren = getChildren(popper);
	  var popperInstance = null;
	  var state = {
	    isEnabled: true,
	    isVisible: false,
	    isDestroyed: false,
	    isMounted: false,
	    isShown: false
	  };
	  var instance = {
	    id: id,
	    reference: reference,
	    popper: popper,
	    popperChildren: popperChildren,
	    popperInstance: popperInstance,
	    props: props,
	    state: state,
	    clearDelayTimeouts: clearDelayTimeouts,
	    set: set,
	    setContent: setContent,
	    show: show,
	    hide: hide,
	    enable: enable,
	    disable: disable,
	    destroy: destroy
	  };
	  reference._tippy = instance;
	  popper._tippy = instance;
	  addTriggersToReference();
	  if (!props.lazy) {
	    createPopperInstance();
	  }
	  if (props.showOnInit) {
	    scheduleShow();
	  }
	  if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
	    getEventListenersTarget().setAttribute('tabindex', '0');
	  }
	  popper.addEventListener('mouseenter', function (event) {
	    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
	      scheduleShow(event, true);
	    }
	  });
	  popper.addEventListener('mouseleave', function () {
	    if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	    }
	  });
	  return instance;
	  function removeFollowCursorListener() {
	    document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
	  }
	  function cleanupInteractiveMouseListeners() {
	    document.body.removeEventListener('mouseleave', scheduleHide);
	    document.removeEventListener('mousemove', debouncedOnMouseMove);
	    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
	      return listener !== debouncedOnMouseMove;
	    });
	  }
	  function getEventListenersTarget() {
	    return instance.props.triggerTarget || reference;
	  }
	  function addDocumentClickListener() {
	    document.addEventListener('click', onDocumentClick, true);
	  }
	  function removeDocumentClickListener() {
	    document.removeEventListener('click', onDocumentClick, true);
	  }
	  function getTransitionableElements() {
	    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
	  }
	  function getIsInLooseFollowCursorMode() {
	    var followCursor = instance.props.followCursor;
	    return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
	  }
	  function makeSticky() {
	    setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);
	    function updatePosition() {
	      instance.popperInstance.scheduleUpdate();
	      if (instance.state.isMounted) {
	        requestAnimationFrame(updatePosition);
	      } else {
	        setTransitionDuration([popper], 0);
	      }
	    }
	    updatePosition();
	  }
	  function onTransitionedOut(duration, callback) {
	    onTransitionEnd(duration, function () {
	      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
	        callback();
	      }
	    });
	  }
	  function onTransitionedIn(duration, callback) {
	    onTransitionEnd(duration, callback);
	  }
	  function onTransitionEnd(duration, callback) {
	    var tooltip = instance.popperChildren.tooltip;
	    function listener(event) {
	      if (event.target === tooltip) {
	        updateTransitionEndListener(tooltip, 'remove', listener);
	        callback();
	      }
	    }
	    if (duration === 0) {
	      return callback();
	    }
	    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
	    updateTransitionEndListener(tooltip, 'add', listener);
	    currentTransitionEndListener = listener;
	  }
	  function on(eventType, handler) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    getEventListenersTarget().addEventListener(eventType, handler, options);
	    listeners.push({
	      eventType: eventType,
	      handler: handler,
	      options: options
	    });
	  }
	  function addTriggersToReference() {
	    if (instance.props.touchHold && !instance.props.target) {
	      on('touchstart', onTrigger, PASSIVE);
	      on('touchend', onMouseLeave, PASSIVE);
	    }
	    instance.props.trigger.trim().split(' ').forEach(function (eventType) {
	      if (eventType === 'manual') {
	        return;
	      }
	      if (!instance.props.target) {
	        on(eventType, onTrigger);
	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseleave', onMouseLeave);
	            break;
	          case 'focus':
	            on(isIE$1 ? 'focusout' : 'blur', onBlur);
	            break;
	        }
	      } else {
	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseover', onDelegateShow);
	            on('mouseout', onDelegateHide);
	            break;
	          case 'focus':
	            on('focusin', onDelegateShow);
	            on('focusout', onDelegateHide);
	            break;
	          case 'click':
	            on(eventType, onDelegateShow);
	            break;
	        }
	      }
	    });
	  }
	  function removeTriggersFromReference() {
	    listeners.forEach(function (_ref) {
	      var eventType = _ref.eventType,
	          handler = _ref.handler,
	          options = _ref.options;
	      getEventListenersTarget().removeEventListener(eventType, handler, options);
	    });
	    listeners = [];
	  }
	  function positionVirtualReferenceNearCursor(event) {
	    var _lastMouseMoveEvent = lastMouseMoveEvent = event,
	        x = _lastMouseMoveEvent.clientX,
	        y = _lastMouseMoveEvent.clientY;
	    if (!currentComputedPadding) {
	      return;
	    }
	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });
	    var rect = reference.getBoundingClientRect();
	    var followCursor = instance.props.followCursor;
	    var isHorizontal = followCursor === 'horizontal';
	    var isVertical = followCursor === 'vertical';
	    var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
	    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	    var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
	    var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
	    var halfSize = size / 2;
	    var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
	    var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
	    if (isCursorOverReference || !instance.props.interactive) {
	      instance.popperInstance.reference = _extends$2({}, instance.popperInstance.reference, {
	        clientWidth: 0,
	        clientHeight: 0,
	        getBoundingClientRect: function getBoundingClientRect() {
	          return {
	            width: isVerticalPlacement ? size : 0,
	            height: isVerticalPlacement ? 0 : size,
	            top: (isHorizontal ? rect.top : y) - verticalIncrease,
	            bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
	            left: (isVertical ? rect.left : x) - horizontalIncrease,
	            right: (isVertical ? rect.right : x) + horizontalIncrease
	          };
	        }
	      });
	      instance.popperInstance.update();
	    }
	    if (followCursor === 'initial' && instance.state.isVisible) {
	      removeFollowCursorListener();
	    }
	  }
	  function createDelegateChildTippy(event) {
	    if (event) {
	      var targetEl = closest(event.target, instance.props.target);
	      if (targetEl && !targetEl._tippy) {
	        createTippy(targetEl, _extends$2({}, instance.props, {
	          content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
	          appendTo: collectionProps.appendTo,
	          target: '',
	          showOnInit: true
	        }));
	      }
	    }
	  }
	  function onTrigger(event) {
	    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
	      return;
	    }
	    if (!instance.state.isVisible) {
	      lastTriggerEventType = event.type;
	      if (event instanceof MouseEvent) {
	        lastMouseMoveEvent = event;
	        mouseMoveListeners.forEach(function (listener) {
	          return listener(event);
	        });
	      }
	    }
	    if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
	      scheduleHide();
	    } else {
	      scheduleShow(event);
	    }
	  }
	  function onMouseMove(event) {
	    var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });
	    if (isCursorOverPopper || isCursorOverReference) {
	      return;
	    }
	    if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
	      cleanupInteractiveMouseListeners();
	      scheduleHide();
	    }
	  }
	  function onMouseLeave(event) {
	    if (isEventListenerStopped(event)) {
	      return;
	    }
	    if (instance.props.interactive) {
	      document.body.addEventListener('mouseleave', scheduleHide);
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	      mouseMoveListeners.push(debouncedOnMouseMove);
	      return;
	    }
	    scheduleHide();
	  }
	  function onBlur(event) {
	    if (event.target !== getEventListenersTarget()) {
	      return;
	    }
	    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
	      return;
	    }
	    scheduleHide();
	  }
	  function onDelegateShow(event) {
	    if (closest(event.target, instance.props.target)) {
	      scheduleShow(event);
	    }
	  }
	  function onDelegateHide(event) {
	    if (closest(event.target, instance.props.target)) {
	      scheduleHide();
	    }
	  }
	  function isEventListenerStopped(event) {
	    var supportsTouch = ('ontouchstart' in window);
	    var isTouchEvent = includes(event.type, 'touch');
	    var touchHold = instance.props.touchHold;
	    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
	  }
	  function runMountCallback() {
	    if (!hasMountCallbackRun && currentMountCallback) {
	      hasMountCallbackRun = true;
	      reflow(popper);
	      currentMountCallback();
	    }
	  }
	  function createPopperInstance() {
	    var popperOptions = instance.props.popperOptions;
	    var _instance$popperChild = instance.popperChildren,
	        tooltip = _instance$popperChild.tooltip,
	        arrow = _instance$popperChild.arrow;
	    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
	    function applyMutations(data) {
	      if (instance.props.flip && !instance.props.flipOnUpdate) {
	        if (data.flipped) {
	          instance.popperInstance.options.placement = data.placement;
	        }
	        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
	      }
	      tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);
	      if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
	        tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
	      } else {
	        tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
	      }
	      if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
	        tooltip.style.transition = 'none';
	        requestAnimationFrame(function () {
	          tooltip.style.transition = '';
	        });
	      }
	      previousPlacement = data.placement;
	      wasVisibleDuringPreviousUpdate = instance.state.isVisible;
	      var basicPlacement = getBasicPlacement(popper);
	      var styles = tooltip.style;
	      styles.top = styles.bottom = styles.left = styles.right = '';
	      styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
	      var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
	      var isPaddingNumber = typeof padding === 'number';
	      var computedPadding = _extends$2({
	        top: isPaddingNumber ? padding : padding.top,
	        bottom: isPaddingNumber ? padding : padding.bottom,
	        left: isPaddingNumber ? padding : padding.left,
	        right: isPaddingNumber ? padding : padding.right
	      }, !isPaddingNumber && padding);
	      computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
	      instance.popperInstance.modifiers.filter(function (m) {
	        return m.name === 'preventOverflow';
	      })[0].padding = computedPadding;
	      currentComputedPadding = computedPadding;
	    }
	    var config = _extends$2({
	      eventsEnabled: false,
	      placement: instance.props.placement
	    }, popperOptions, {
	      modifiers: _extends$2({}, popperOptions ? popperOptions.modifiers : {}, {
	        preventOverflow: _extends$2({
	          boundariesElement: instance.props.boundary,
	          padding: PADDING
	        }, preventOverflowModifier),
	        arrow: _extends$2({
	          element: arrow,
	          enabled: !!arrow
	        }, getModifier(popperOptions, 'arrow')),
	        flip: _extends$2({
	          enabled: instance.props.flip,
	          padding: instance.props.distance + PADDING,
	          behavior: instance.props.flipBehavior
	        }, getModifier(popperOptions, 'flip')),
	        offset: _extends$2({
	          offset: instance.props.offset
	        }, getModifier(popperOptions, 'offset'))
	      }),
	      onCreate: function onCreate(data) {
	        applyMutations(data);
	        runMountCallback();
	        if (popperOptions && popperOptions.onCreate) {
	          popperOptions.onCreate(data);
	        }
	      },
	      onUpdate: function onUpdate(data) {
	        applyMutations(data);
	        runMountCallback();
	        if (popperOptions && popperOptions.onUpdate) {
	          popperOptions.onUpdate(data);
	        }
	      }
	    });
	    instance.popperInstance = new Popper(reference, popper, config);
	  }
	  function mount() {
	    hasMountCallbackRun = false;
	    var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
	    if (instance.popperInstance) {
	      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.reference = reference;
	        instance.popperInstance.enableEventListeners();
	      }
	      instance.popperInstance.scheduleUpdate();
	    } else {
	      createPopperInstance();
	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.enableEventListeners();
	      }
	    }
	    var appendTo = instance.props.appendTo;
	    var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);
	    if (!parentNode.contains(popper)) {
	      parentNode.appendChild(popper);
	      instance.props.onMount(instance);
	      instance.state.isMounted = true;
	    }
	  }
	  function scheduleShow(event, shouldAvoidCallingOnTrigger) {
	    clearDelayTimeouts();
	    if (instance.state.isVisible) {
	      return;
	    }
	    if (instance.props.target) {
	      return createDelegateChildTippy(event);
	    }
	    isScheduledToShow = true;
	    if (event && !shouldAvoidCallingOnTrigger) {
	      instance.props.onTrigger(instance, event);
	    }
	    if (instance.props.wait) {
	      return instance.props.wait(instance, event);
	    }
	    if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
	      if (!instance.popperInstance) {
	        createPopperInstance();
	      }
	      document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
	    }
	    addDocumentClickListener();
	    var delay = getValue(instance.props.delay, 0, defaultProps.delay);
	    if (delay) {
	      showTimeoutId = setTimeout(function () {
	        show();
	      }, delay);
	    } else {
	      show();
	    }
	  }
	  function scheduleHide() {
	    clearDelayTimeouts();
	    if (!instance.state.isVisible) {
	      return removeFollowCursorListener();
	    }
	    isScheduledToShow = false;
	    var delay = getValue(instance.props.delay, 1, defaultProps.delay);
	    if (delay) {
	      hideTimeoutId = setTimeout(function () {
	        if (instance.state.isVisible) {
	          hide();
	        }
	      }, delay);
	    } else {
	      scheduleHideAnimationFrameId = requestAnimationFrame(function () {
	        hide();
	      });
	    }
	  }
	  function onDocumentClick(event) {
	    if (instance.props.interactive && popper.contains(event.target)) {
	      return;
	    }
	    if (getEventListenersTarget().contains(event.target)) {
	      if (isUsingTouch) {
	        return;
	      }
	      if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
	        return;
	      }
	    }
	    if (instance.props.hideOnClick === true) {
	      clearDelayTimeouts();
	      hide();
	    }
	  }
	  function enable() {
	    instance.state.isEnabled = true;
	  }
	  function disable() {
	    instance.state.isEnabled = false;
	  }
	  function clearDelayTimeouts() {
	    clearTimeout(showTimeoutId);
	    clearTimeout(hideTimeoutId);
	    cancelAnimationFrame(scheduleHideAnimationFrameId);
	  }
	  function set(options) {
	    options = options || {};
	    validateOptions(options, defaultProps);
	    removeTriggersFromReference();
	    var prevProps = instance.props;
	    var nextProps = evaluateProps(reference, _extends$2({}, instance.props, options, {
	      ignoreAttributes: true
	    }));
	    nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
	    instance.props = nextProps;
	    addTriggersToReference();
	    cleanupInteractiveMouseListeners();
	    debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
	    updatePopperElement(popper, prevProps, nextProps);
	    instance.popperChildren = getChildren(popper);
	    if (instance.popperInstance) {
	      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
	        return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];
	      })) {
	        instance.popperInstance.destroy();
	        createPopperInstance();
	        if (instance.state.isVisible) {
	          instance.popperInstance.enableEventListeners();
	        }
	        if (instance.props.followCursor && lastMouseMoveEvent) {
	          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	        }
	      } else {
	        instance.popperInstance.update();
	      }
	    }
	  }
	  function setContent(content) {
	    set({
	      content: content
	    });
	  }
	  function show() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
	    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
	      return;
	    }
	    if (getEventListenersTarget().hasAttribute('disabled')) {
	      return;
	    }
	    if (instance.props.onShow(instance) === false) {
	      return;
	    }
	    addDocumentClickListener();
	    popper.style.visibility = 'visible';
	    instance.state.isVisible = true;
	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.add(ACTIVE_CLASS);
	    }
	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements.concat(popper), 0);
	    currentMountCallback = function currentMountCallback() {
	      if (!instance.state.isVisible) {
	        return;
	      }
	      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
	      if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
	        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	      } else if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.update();
	      }
	      if (instance.popperChildren.backdrop) {
	        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
	      }
	      if (instance.props.sticky) {
	        makeSticky();
	      }
	      setTransitionDuration([popper], instance.props.updateDuration);
	      setTransitionDuration(transitionableElements, duration);
	      setVisibilityState(transitionableElements, 'visible');
	      onTransitionedIn(duration, function () {
	        if (instance.props.aria) {
	          getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
	        }
	        instance.props.onShown(instance);
	        instance.state.isShown = true;
	      });
	    };
	    mount();
	  }
	  function hide() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
	    if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
	      return;
	    }
	    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
	      return;
	    }
	    removeDocumentClickListener();
	    popper.style.visibility = 'hidden';
	    instance.state.isVisible = false;
	    instance.state.isShown = false;
	    wasVisibleDuringPreviousUpdate = false;
	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.remove(ACTIVE_CLASS);
	    }
	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements, duration);
	    setVisibilityState(transitionableElements, 'hidden');
	    onTransitionedOut(duration, function () {
	      if (!isScheduledToShow) {
	        removeFollowCursorListener();
	      }
	      if (instance.props.aria) {
	        getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
	      }
	      instance.popperInstance.disableEventListeners();
	      instance.popperInstance.options.placement = instance.props.placement;
	      popper.parentNode.removeChild(popper);
	      instance.props.onHidden(instance);
	      instance.state.isMounted = false;
	    });
	  }
	  function destroy(destroyTargetInstances) {
	    if (instance.state.isDestroyed) {
	      return;
	    }
	    isBeingDestroyed = true;
	    if (instance.state.isMounted) {
	      hide(0);
	    }
	    removeTriggersFromReference();
	    delete reference._tippy;
	    var target = instance.props.target;
	    if (target && destroyTargetInstances && isRealElement(reference)) {
	      arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
	        if (child._tippy) {
	          child._tippy.destroy();
	        }
	      });
	    }
	    if (instance.popperInstance) {
	      instance.popperInstance.destroy();
	    }
	    isBeingDestroyed = false;
	    instance.state.isDestroyed = true;
	  }
	}
	function group(instances) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$delay = _ref.delay,
	      delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
	      _ref$duration = _ref.duration,
	      duration = _ref$duration === void 0 ? 0 : _ref$duration;
	  var isAnyTippyOpen = false;
	  instances.forEach(function (instance) {
	    if (instance._originalProps) {
	      instance.set(instance._originalProps);
	    } else {
	      instance._originalProps = _extends$2({}, instance.props);
	    }
	  });
	  function setIsAnyTippyOpen(value) {
	    isAnyTippyOpen = value;
	    updateInstances();
	  }
	  function onShow(instance) {
	    instance._originalProps.onShow(instance);
	    instances.forEach(function (instance) {
	      instance.set({
	        duration: duration
	      });
	      if (instance.state.isVisible) {
	        instance.hide();
	      }
	    });
	    setIsAnyTippyOpen(true);
	  }
	  function onHide(instance) {
	    instance._originalProps.onHide(instance);
	    setIsAnyTippyOpen(false);
	  }
	  function onShown(instance) {
	    instance._originalProps.onShown(instance);
	    instance.set({
	      duration: instance._originalProps.duration
	    });
	  }
	  function updateInstances() {
	    instances.forEach(function (instance) {
	      instance.set({
	        onShow: onShow,
	        onShown: onShown,
	        onHide: onHide,
	        delay: isAnyTippyOpen ? [0, isArray$1(delay) ? delay[1] : delay] : delay,
	        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
	      });
	    });
	  }
	  updateInstances();
	}
	var globalEventListenersBound = false;
	function tippy(targets, options) {
	  validateOptions(options || {}, defaultProps);
	  if (!globalEventListenersBound) {
	    bindGlobalEventListeners();
	    globalEventListenersBound = true;
	  }
	  var props = _extends$2({}, defaultProps, options);
	  if (isBareVirtualElement(targets)) {
	    polyfillElementPrototypeProperties(targets);
	  }
	  var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
	    var instance = reference && createTippy(reference, props);
	    if (instance) {
	      acc.push(instance);
	    }
	    return acc;
	  }, []);
	  return isSingular(targets) ? instances[0] : instances;
	}
	tippy.version = version;
	tippy.defaults = defaultProps;
	tippy.setDefaults = function (partialDefaults) {
	  keys$1(partialDefaults).forEach(function (key) {
	    defaultProps[key] = partialDefaults[key];
	  });
	};
	tippy.hideAll = hideAll;
	tippy.group = group;
	function autoInit() {
	  arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
	    var content = el.getAttribute('data-tippy');
	    if (content) {
	      tippy(el, {
	        content: content
	      });
	    }
	  });
	}
	if (isBrowser$1) {
	  setTimeout(autoInit);
	}
	var getValidTippyProps = function getValidTippyProps(props) {
	  var validProps = {};
	  for (var key in props) {
	    if (defaultProps.hasOwnProperty(key)) {
	      validProps[key] = props[key];
	    }
	  }
	  return validProps;
	};

	var defaultOptions = {
	  duration: 0,
	  arrow: true,
	  size: 'small',
	  trigger: 'mouseenter focus',
	  theme: 'dark',
	  interactive: true,
	  content: '',
	  allowHtml: false,
	  extCls: ''
	};
	var validPlacements$1 = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
	var createTippy$1 = function createTippy(el, binding) {
	  var value = binding.value;
	  var options = _objectSpread({}, defaultOptions);
	  if (_typeof(value) === 'object') {
	    _extends(options, value);
	  } else {
	    options.content = value;
	  }
	  var placement = validPlacements$1.find(function (placement) {
	    return binding.modifiers[placement];
	  });
	  options.placement = options.placement || placement || (options.placements || ['top'])[0];
	  var _binding$modifiers = binding.modifiers,
	      click = _binding$modifiers.click,
	      light = _binding$modifiers.light;
	  if (click) {
	    options.trigger = 'click';
	  }
	  if (light) {
	    options.theme = 'light';
	  }
	  if (options.allowHtml) {
	    var selector = options.content;
	    if (selector instanceof Vue) {
	      options.content = selector.$el;
	    } else if (typeof selector === 'string') {
	      var element = document.querySelector(selector);
	      if (element) {
	        options.content = element;
	      }
	    }
	  }
	  if (options.html) {
	    options.content = options.html;
	  }
	  if (typeof options.onClose === 'function') {
	    options.onHide = options.onClose;
	  }
	  var validOptions = getValidTippyProps(options);
	  return tippy(el, validOptions);
	};
	var bkTooltips = {
	  inserted: function inserted(el, binding) {
	    var disabled = _typeof(binding.value) === 'object' ? binding.value.disabled : false;
	    if (!disabled) {
	      el.tippyInstance = createTippy$1(el, binding);
	    }
	  },
	  unbind: function unbind(el) {
	    el._tippy && el._tippy.destroy();
	    el.tippyInstance = null;
	  },
	  update: function update(el, binding) {
	    var value = binding.value;
	    var isObject = _typeof(value) === 'object';
	    var content = isObject ? value.content : value;
	    var disabled = isObject ? value.disabled : false;
	    if (disabled || !content) {
	      el._tippy && el._tippy.destroy();
	      el.tippyInstance = null;
	    } else if (content) {
	      if (!el._tippy) {
	        el.tippyInstance = createTippy$1(el, binding);
	      } else {
	        if (_typeof(value) === 'object' && binding.value.allowHtml) {
	          el.tippyInstance = createTippy$1(el, binding);
	        } else {
	          el._tippy.setContent(content);
	        }
	      }
	    }
	  }
	};
	bkTooltips.install = function (Vue) {
	  Vue.directive('bkTooltips', bkTooltips);
	};

	Vue.use(bkTooltips);
	var script$1 = {
	  name: 'bk-slider-button',
	  props: {
	    vertical: {
	      type: Boolean,
	      default: false
	    },
	    value: {
	      type: Number,
	      default: 0
	    }
	  },
	  data: function data() {
	    return {
	      dragging: false,
	      isClick: false,
	      startY: 0,
	      startX: 0,
	      startPosition: 0,
	      newPosition: null,
	      oldValue: this.value
	    };
	  },
	  computed: {
	    showTip: function showTip() {
	      return this.$parent.showTip;
	    },
	    tip: function tip() {
	      var tip = '';
	      if (this.customContent && this.customContent[this.value]) {
	        var customContent = this.customContent[this.value];
	        tip = customContent.tip || customContent.label || '';
	      }
	      return {
	        content: this.showCustomTip ? tip : this.showTip ? this.value ? "".concat(this.value) : "".concat(0) : '',
	        placement: this.vertical ? 'right' : 'top'
	      };
	    },
	    disable: function disable() {
	      return this.$parent.disable;
	    },
	    maxValue: function maxValue() {
	      return this.$parent.maxValue;
	    },
	    minValue: function minValue() {
	      return this.$parent.minValue;
	    },
	    step: function step() {
	      return this.$parent.step;
	    },
	    precision: function precision() {
	      return this.$parent.precision;
	    },
	    currentPosition: function currentPosition() {
	      return "".concat((this.value - this.minValue) / (this.maxValue - this.minValue) * 100, "%");
	    },
	    wrapperStyle: function wrapperStyle() {
	      return this.vertical ? {
	        bottom: this.currentPosition
	      } : {
	        left: this.currentPosition
	      };
	    },
	    showButtonLabel: function showButtonLabel() {
	      return this.$parent.showButtonLabel;
	    },
	    buttonLabel: function buttonLabel() {
	      var unit = this.$parent.buttonLabelUnit;
	      return this.value ? "".concat(this.value).concat(unit) : "".concat(0, unit);
	    },
	    showIntervalLabel: function showIntervalLabel() {
	      return this.$parent.showIntervalLabel;
	    },
	    customContent: function customContent() {
	      return this.$parent.customContent;
	    },
	    showCustomTip: function showCustomTip() {
	      return this.$parent.showCustomTip;
	    }
	  },
	  methods: {
	    onButtonDown: function onButtonDown(event) {
	      if (this.disable) return;
	      event.preventDefault();
	      this.onDragStart(event);
	      this.$parent.on(window, 'mousemove', this.onDragging);
	      this.$parent.on(window, 'touchmove', this.onDragging);
	      this.$parent.on(window, 'mouseup', this.onDragEnd);
	      this.$parent.on(window, 'touchend', this.onDragEnd);
	    },
	    onDragStart: function onDragStart(event) {
	      this.dragging = true;
	      this.isClick = true;
	      if (event.type === 'touchstart') {
	        event.clientY = event.touches[0].clientY;
	        event.clientX = event.touches[0].clientX;
	      }
	      if (this.vertical) {
	        this.startY = event.clientY;
	      } else {
	        this.startX = event.clientX;
	      }
	      this.startPosition = _parseFloat$2(this.currentPosition);
	      this.newPosition = this.startPosition;
	    },
	    onDragging: function onDragging(event) {
	      if (this.dragging) {
	        this.isClick = false;
	        this.$parent.resetSize();
	        var diff = 0;
	        if (event.type === 'touchmove') {
	          event.clientY = event.touches[0].clientY;
	          event.clientX = event.touches[0].clientX;
	        }
	        if (this.vertical) {
	          this.currentY = event.clientY;
	          diff = (this.startY - this.currentY) / this.$parent.sliderSize * 100;
	        } else {
	          this.currentX = event.clientX;
	          diff = (this.currentX - this.startX) / this.$parent.sliderSize * 100;
	        }
	        this.newPosition = this.startPosition + diff;
	        this.setPosition(this.newPosition);
	      }
	    },
	    setPosition: function setPosition(newPosition) {
	      if (newPosition === null || isNaN(newPosition)) return;
	      if (newPosition < 0) {
	        newPosition = 0;
	      } else if (newPosition > 100) {
	        newPosition = 100;
	      }
	      var lengthPerStep = 100 / ((this.maxValue - this.minValue) / this.step);
	      var steps = Math.round(newPosition / lengthPerStep);
	      var value = steps * lengthPerStep * (this.maxValue - this.minValue) * 0.01 + this.minValue;
	      value = _parseFloat$2(value.toFixed(this.precision));
	      this.$emit('input', value);
	      if (!this.dragging && this.value !== this.oldValue) {
	        this.oldValue = this.value;
	      }
	    },
	    onDragEnd: function onDragEnd() {
	      var _this = this;
	      this.isMove = false;
	      if (this.dragging) {
	        setTimeout(function () {
	          _this.dragging = false;
	          if (!_this.isClick) {
	            _this.setPosition(_this.newPosition);
	            _this.$parent.emitChange();
	          }
	        }, 0);
	        this.$parent.off(window, 'mousemove', this.onDragging);
	        this.$parent.off(window, 'touchmove', this.onDragging);
	        this.$parent.off(window, 'mouseup', this.onDragEnd);
	        this.$parent.off(window, 'touchend', this.onDragEnd);
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    directives: [{
	      name: "bk-tooltips",
	      rawName: "v-bk-tooltips",
	      value: _vm.tip,
	      expression: "tip"
	    }],
	    ref: "button",
	    class: ['bk-slider-button', _vm.vertical ? 'vertical' : 'horizontal', {
	      'grabbing': _vm.dragging
	    }],
	    style: _vm.wrapperStyle,
	    attrs: {
	      "tabindex": "0"
	    },
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();
	      },
	      "mousedown": _vm.onButtonDown,
	      "touchstart": _vm.onButtonDown
	    }
	  }, [_c('div', {
	    class: ['slider-button', {
	      'slider-button-disable': _vm.disable
	    }]
	  }), _vm.showButtonLabel && !_vm.showIntervalLabel ? _c('div', {
	    class: ['slider-button-label', _vm.vertical ? 'vertical' : 'horizontal']
	  }, [_vm._v("\n        " + _vm._s(_vm.buttonLabel) + "\n    ")]) : _vm._e()]);
	};

	var __vue_staticRenderFns__$1 = [];
	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* module identifier */

	var __vue_module_identifier__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	var script$2 = {
	  name: 'bk-slider',
	  components: {
	    sliderButton: __vue_component__$1,
	    bkInput: __vue_component__
	  },
	  props: {
	    value: {
	      type: [Number, Array],
	      default: 0
	    },
	    vertical: {
	      type: Boolean,
	      default: false
	    },
	    showTip: {
	      type: Boolean,
	      default: true
	    },
	    disable: {
	      type: Boolean,
	      default: false
	    },
	    maxValue: {
	      type: [Number],
	      default: 100
	    },
	    minValue: {
	      type: [Number],
	      default: 0
	    },
	    step: {
	      type: [Number],
	      default: 1
	    },
	    range: {
	      type: Boolean,
	      default: false
	    },
	    showInterval: {
	      type: Boolean,
	      default: false
	    },
	    showIntervalLabel: {
	      type: Boolean,
	      default: false
	    },
	    intervalLabelUnit: {
	      type: String,
	      default: ''
	    },
	    height: {
	      type: String,
	      default: '200px'
	    },
	    showButtonLabel: {
	      type: Boolean,
	      default: false
	    },
	    buttonLabelUnit: {
	      type: String,
	      default: ''
	    },
	    showBetweenLabel: {
	      type: Boolean,
	      default: false
	    },
	    showInput: {
	      type: Boolean,
	      default: false
	    },
	    customContent: {
	      type: Object
	    },
	    showCustomLabel: {
	      type: Boolean,
	      default: false
	    },
	    showCustomTip: {
	      type: Boolean,
	      default: false
	    },
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  data: function data() {
	    return {
	      sliderSize: 1,
	      firstValue: null,
	      secondValue: null,
	      oldValue: null,
	      stepWidth: 0,
	      inputValue: 0,
	      firstInput: 0,
	      secondInput: 0
	    };
	  },
	  computed: {
	    precision: function precision() {
	      var precisions = [this.minValue, this.maxValue, this.step].map(function (item) {
	        var decimal = ('' + item).split('.')[1];
	        return decimal ? decimal.length : 0;
	      });
	      return Math.max.apply(null, precisions);
	    },
	    rangeMinValue: function rangeMinValue() {
	      return Math.min(this.firstValue, this.secondValue);
	    },
	    rangeMaxValue: function rangeMaxValue() {
	      return Math.max(this.firstValue, this.secondValue);
	    },
	    barSize: function barSize() {
	      return this.range ? "".concat(100 * (this.rangeMaxValue - this.rangeMinValue) / (this.maxValue - this.minValue), "%") : "".concat(100 * (this.firstValue - this.minValue) / (this.maxValue - this.minValue), "%");
	    },
	    barStart: function barStart() {
	      return this.range ? "".concat(100 * (this.rangeMinValue - this.minValue) / (this.maxValue - this.minValue), "%") : '0%';
	    },
	    barStyle: function barStyle() {
	      return this.vertical ? {
	        height: this.barSize,
	        bottom: this.barStart
	      } : {
	        width: this.barSize,
	        left: this.barStart
	      };
	    },
	    intervals: function intervals() {
	      var _this = this;
	      if (!this.showInterval || this.minValue > this.maxValue) return [];
	      if (this.step === 0) {
	        console.warn('WARNNING:step should not be 0');
	        return [];
	      }
	      var stopCount = (this.maxValue - this.minValue) / this.step;
	      var stepWidth = 100 * this.step / (this.maxValue - this.minValue);
	      var result = [];
	      for (var i = 1; i < stopCount; i++) {
	        result.push(i * stepWidth);
	      }
	      if (this.range) {
	        return result.filter(function (step) {
	          return step < 100 * (_this.rangeMinValue - _this.minValue) / (_this.maxValue - _this.minValue) || step > 100 * (_this.rangeMaxValue - _this.minValue) / (_this.maxValue - _this.minValue);
	        });
	      } else {
	        return result.filter(function (step) {
	          return step > 100 * (_this.firstValue - _this.minValue) / (_this.maxValue - _this.minValue);
	        });
	      }
	    },
	    runwayStyle: function runwayStyle() {
	      return this.vertical ? {
	        height: this.height,
	        width: '4px'
	      } : {};
	    },
	    intervalLabels: function intervalLabels() {
	      if (!this.showIntervalLabel) return [];
	      if (this.step === 0) {
	        console.warn('WARNNING:step should not be 0');
	        return [];
	      }
	      var stepCount = (this.maxValue - this.minValue) / this.step;
	      var stepWidth = 100 * this.step / (this.maxValue - this.minValue);
	      var result = [];
	      for (var i = 0; i <= stepCount; i++) {
	        var item = {
	          stepWidth: i * stepWidth,
	          stepLabel: "".concat(i * this.step).concat(this.intervalLabelUnit)
	        };
	        result.push(item);
	      }
	      return result;
	    },
	    showSecondInput: function showSecondInput() {
	      return isArray$1(this.value);
	    },
	    customList: function customList() {
	      var _this2 = this;
	      if (!this.customContent) {
	        return [];
	      }
	      return keys$1(this.customContent).sort(function (a, b) {
	        return a - b;
	      }).filter(function (value) {
	        return value >= _this2.minValue && value <= _this2.maxValue;
	      }).map(function (item) {
	        var tip = _this2.customContent[item].tip;
	        var label = _this2.customContent[item].label;
	        return {
	          tip: tip || label || '',
	          label: label || '',
	          percent: (item - _this2.minValue) / (_this2.maxValue - _this2.minValue) * 100
	        };
	      });
	    }
	  },
	  watch: {
	    value: function value() {
	      this.setValues();
	    },
	    firstValue: function firstValue(val) {
	      if (this.range) {
	        this.$emit('input', [this.rangeMinValue, this.rangeMaxValue]);
	      } else {
	        this.$emit('input', val);
	      }
	      this.firstInput = val;
	    },
	    secondValue: function secondValue(val) {
	      this.$emit('input', [this.rangeMinValue, this.rangeMaxValue]);
	      this.secondInput = val;
	    }
	  },
	  mounted: function mounted() {
	    if (this.range) {
	      if (isArray$1(this.value)) {
	        this.firstValue = Math.max(this.minValue, this.value[0]);
	        this.secondValue = Math.min(this.maxValue, this.value[1]);
	      } else {
	        this.firstValue = this.minValue;
	        this.secondValue = this.maxValue;
	      }
	      this.oldValue = [this.firstValue, this.secondValue];
	    } else {
	      if (typeof this.value !== 'number' || isNaN(this.value)) {
	        this.firstValue = this.minValue;
	      } else {
	        this.firstValue = Math.min(this.maxValue, Math.max(this.minValue, this.value));
	      }
	      this.oldValue = this.firstValue;
	    }
	    this.stepWidth = 100 * this.step / (this.maxValue - this.minValue);
	    this.resetSize();
	    this.on(window, 'resize', this.resetSize);
	  },
	  methods: {
	    valueChanged: function valueChanged() {
	      var _this3 = this;
	      if (this.range) {
	        return ![this.rangeMinValue, this.rangeMaxValue].every(function (item, index) {
	          return item === _this3.oldValue[index];
	        });
	      } else {
	        return this.value !== this.oldValue;
	      }
	    },
	    setValues: function setValues() {
	      if (this.minValue > this.maxValue) {
	        console.error('min should not be greater than max.');
	        return;
	      }
	      var val = this.value;
	      if (this.range && isArray$1(val)) {
	        if (val[1] < this.minValue) {
	          this.$emit('input', [this.minValue, this.minValue]);
	        } else if (val[0] > this.maxValue) {
	          this.$emit('input', [this.maxValue, this.maxValue]);
	        } else if (val[0] < this.minValue) {
	          this.$emit('input', [this.minValue, val[1]]);
	        } else if (val[1] > this.maxValue) {
	          this.$emit('input', [val[0], this.maxValue]);
	        } else {
	          this.firstValue = val[0];
	          this.secondValue = val[1];
	          if (this.valueChanged()) {
	            this.oldValue = val.slice();
	          }
	        }
	      } else if (!this.range && typeof val === 'number' && !isNaN(val)) {
	        if (val < this.minValue) {
	          this.$emit('input', this.minValue);
	        } else if (val > this.maxValue) {
	          this.$emit('input', this.maxValue);
	        } else {
	          this.firstValue = val;
	          if (this.valueChanged()) {
	            this.oldValue = val;
	          }
	        }
	      }
	    },
	    resetSize: function resetSize() {
	      if (this.$refs.slider) {
	        this.sliderSize = this.$refs.slider["client".concat(this.vertical ? 'Height' : 'Width')];
	      }
	    },
	    emitChange: function emitChange() {
	      var _this4 = this;
	      this.$nextTick(function () {
	        _this4.$emit('change', _this4.range ? [_this4.rangeMinValue, _this4.rangeMaxValue] : _this4.value);
	      });
	    },
	    getIntervalStyle: function getIntervalStyle(position) {
	      return this.vertical ? {
	        'bottom': position + '%'
	      } : {
	        'left': position + '%'
	      };
	    },
	    setPosition: function setPosition(percent) {
	      if (!this.range) {
	        this.$refs.firstbutton.setPosition(percent);
	        return;
	      }
	      var targetValue = this.minValue + percent * (this.maxValue - this.minValue) / 100;
	      var curButtonRef = '';
	      if (Math.abs(this.rangeMinValue - targetValue) < Math.abs(this.rangeMaxValue - targetValue)) {
	        curButtonRef = this.firstValue < this.secondValue ? 'firstbutton' : 'secondbutton';
	      } else {
	        curButtonRef = this.firstValue > this.secondValue ? 'firstbutton' : 'secondbutton';
	      }
	      this.$refs[curButtonRef].setPosition(percent);
	    },
	    setButtonPos: function setButtonPos(event) {
	      if (this.disable) return;
	      this.resetSize();
	      if (this.vertical) {
	        var offsetBottom = this.$refs.slider.getBoundingClientRect().bottom;
	        this.setPosition((offsetBottom - event.clientY) / this.sliderSize * 100);
	      } else {
	        var offsetLeft = this.$refs.slider.getBoundingClientRect().left;
	        this.setPosition((event.clientX - offsetLeft) / this.sliderSize * 100);
	      }
	      this.emitChange();
	    },
	    firstInputChange: function firstInputChange(v) {
	      if (v === '') {
	        return;
	      }
	      var val = _parseFloat$2(v);
	      if (val < this.minValue) {
	        this.firstInput = this.minValue;
	        this.firstValue = this.minValue;
	      } else if (val > this.maxValue) {
	        this.firstInput = this.maxValue;
	        this.firstValue = this.maxValue;
	      } else {
	        this.firstValue = val;
	      }
	    },
	    secondInputChange: function secondInputChange(v) {
	      if (v === '') {
	        return;
	      }
	      var val = _parseFloat$2(v);
	      if (val < this.minValue) {
	        this.secondInput = this.minValue;
	        this.secondValue = this.minValue;
	      } else if (val > this.maxValue) {
	        this.secondInput = this.maxValue;
	        this.secondValue = this.maxValue;
	      } else {
	        this.secondValue = val;
	      }
	    },
	    on: function on(element, event, handler) {
	      if (element && event && handler) {
	        element.addEventListener(event, handler, false);
	      }
	    },
	    off: function off(element, event, handler) {
	      if (element && event) {
	        element.removeEventListener(event, handler, false);
	      }
	    },
	    getInputWidth: function getInputWidth(num) {
	      var len = "".concat(num).length;
	      return len > 2 ? "".concat(56 + (len - 2) * 6, "px") : '56px';
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    class: ['bk-slider', _vm.extCls]
	  }, [_vm._t("start"), _c('div', {
	    ref: "slider",
	    staticClass: "bk-slider-runway",
	    style: _vm.runwayStyle,
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();
	        return _vm.setButtonPos($event);
	      }
	    }
	  }, [_c('div', {
	    class: ['bk-slider-bar', _vm.vertical ? 'vertical' : 'horizontal', {
	      'disable': _vm.disable
	    }],
	    style: _vm.barStyle
	  }), _vm.showInterval ? _vm._l(_vm.intervals, function (item, index) {
	    return _c('div', {
	      key: index,
	      class: ['bk-slider-interval', {
	        'vertical': _vm.vertical
	      }],
	      style: _vm.getIntervalStyle(item)
	    });
	  }) : _vm._e(), _vm.customContent ? _vm._l(_vm.customList, function (item, index) {
	    return _c('div', {
	      key: index,
	      class: ['bk-slider-interval', {
	        'vertical': _vm.vertical
	      }],
	      style: _vm.getIntervalStyle(item.percent)
	    });
	  }) : _vm._e(), _vm.showBetweenLabel || _vm.showIntervalLabel || _vm.showCustomLabel ? [_c('div', {
	    class: ['bk-slider-labels', _vm.vertical ? 'vertical' : 'horizontal']
	  }, [_vm.showBetweenLabel ? [_c('div', {
	    staticClass: "label-start",
	    style: [{
	      opacity: _vm.showButtonLabel ? [_vm.firstValue, _vm.secondValue].includes(_vm.vertical ? _vm.maxValue : _vm.minValue) ? '0' : '1' : '1'
	    }]
	  }, [_vm._v("\n                        " + _vm._s(_vm.minValue) + _vm._s(_vm.intervalLabelUnit) + "\n                    ")]), _c('div', {
	    staticClass: "label-end",
	    style: [{
	      opacity: _vm.showButtonLabel ? [_vm.firstValue, _vm.secondValue].includes(_vm.vertical ? _vm.minValue : _vm.maxValue) ? '0' : '1' : '1'
	    }]
	  }, [_vm._v("\n                        " + _vm._s(_vm.maxValue) + _vm._s(_vm.intervalLabelUnit) + "\n                    ")])] : _vm.showIntervalLabel ? _vm._l(_vm.intervalLabels, function (item, index) {
	    return _c('div', {
	      key: index,
	      class: ['bk-slider-label', _vm.vertical ? 'vertical' : 'horizontal'],
	      style: _vm.getIntervalStyle(item.stepWidth)
	    }, [_vm._v("\n                        " + _vm._s(item.stepLabel) + "\n                    ")]);
	  }) : _vm.showCustomLabel ? _vm._l(_vm.customList, function (item, index) {
	    return _c('div', {
	      key: index,
	      class: ['bk-slider-label', _vm.vertical ? 'vertical' : 'horizontal'],
	      style: _vm.getIntervalStyle(item.percent)
	    }, [_vm._v("\n                        " + _vm._s(item.label) + "\n                    ")]);
	  }) : _vm._e()], 2)] : _vm._e(), _c('slider-button', {
	    ref: "firstbutton",
	    attrs: {
	      "vertical": _vm.vertical
	    },
	    model: {
	      value: _vm.firstValue,
	      callback: function callback($$v) {
	        _vm.firstValue = $$v;
	      },
	      expression: "firstValue"
	    }
	  }), _vm.range ? _c('slider-button', {
	    ref: "secondbutton",
	    attrs: {
	      "vertical": _vm.vertical
	    },
	    model: {
	      value: _vm.secondValue,
	      callback: function callback($$v) {
	        _vm.secondValue = $$v;
	      },
	      expression: "secondValue"
	    }
	  }) : _vm._e()], 2), _vm.showInput && !_vm.vertical ? _c('div', {
	    staticClass: "bk-slider-input"
	  }, [_c('div', {
	    staticClass: "input-item",
	    style: {
	      width: _vm.getInputWidth(_vm.firstInput)
	    }
	  }, [_c('bk-input', {
	    attrs: {
	      "type": "number",
	      "max": _vm.maxValue,
	      "min": _vm.minValue
	    },
	    on: {
	      "change": _vm.firstInputChange,
	      "enter": _vm.firstInputChange,
	      "blur": _vm.firstInputChange
	    },
	    model: {
	      value: _vm.firstInput,
	      callback: function callback($$v) {
	        _vm.firstInput = $$v;
	      },
	      expression: "firstInput"
	    }
	  })], 1), _vm.showSecondInput && _vm.secondValue ? [_c('div', {
	    staticClass: "input-center"
	  }, [_vm._v("ï½")]), _c('div', {
	    staticClass: "input-item",
	    style: {
	      width: _vm.getInputWidth(_vm.secondInput)
	    }
	  }, [_c('bk-input', {
	    attrs: {
	      "type": "number",
	      "max": _vm.maxValue,
	      "min": _vm.minValue
	    },
	    on: {
	      "change": _vm.secondInputChange,
	      "enter": _vm.secondInputChange,
	      "blur": _vm.secondInputChange
	    },
	    model: {
	      value: _vm.secondInput,
	      callback: function callback($$v) {
	        _vm.secondInput = $$v;
	      },
	      expression: "secondInput"
	    }
	  })], 1)] : _vm._e()], 2) : _vm._e(), _vm._t("end")], 2);
	};

	var __vue_staticRenderFns__$2 = [];
	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* module identifier */

	var __vue_module_identifier__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$2);

	exports.default = __vue_component__$2;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
