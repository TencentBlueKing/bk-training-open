(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('bk-magic-vue/lib/locale'), require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'bk-magic-vue/lib/locale', 'vue'], factory) :
  (global = global || self, factory(global.library = {}, global.locale, global.Vue));
}(this, function (exports, locale, Vue) { 'use strict';

  locale = locale && locale.hasOwnProperty('default') ? locale['default'] : locale;
  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;

  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var toString = {}.toString;
  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.12' };
  if (typeof __e == 'number') __e = core;
  });
  var _core_1 = _core.version;

  var _global = createCommonjsModule(function (module) {
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    : Function('return this')();
  if (typeof __g == 'number') __g = global;
  });

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode:  'pure' ,
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var shared = _shared('keys');
  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');
  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) {  }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      : IS_BIND && own ? _ctx(out, _global)
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  var _export = $export;

  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
  };

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys = _core.Object.keys;

  var keys$1 = keys;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');
  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };
  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
  var _stringTrim = exporter;

  var $parseInt = _global.parseInt;
  var $trim = _stringTrim.trim;
  var hex = /^[-+]?0[xX]/;
  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
  } : $parseInt;

  _export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

  var _parseInt$1 = _core.parseInt;

  var _parseInt$2 = _parseInt$1;

  var runtime_1 = createCommonjsModule(function (module) {
  var runtime = (function (exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    define(Gp, "constructor", GeneratorFunctionPrototype);
    define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise =
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn)
        ? iter
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }
            next.value = undefined$1;
            next.done = true;
            return next;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !! caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
     module.exports 
  ));
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  });

  var regenerator = runtime_1;

  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  var _redefine = _hide;

  var _iterators = {};

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () {  };
  var PROTOTYPE$1 = 'prototype';
  var createDict = function () {
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };
  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');
  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';
  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };
  $exports.store = store;
  });

  var def = _objectDp.f;
  var TAG = _wks('toStringTag');
  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var IteratorPrototype = {};
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });
  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;
  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys());
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';
  var returnThis = function () { return this; };
  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        _setToStringTag(IteratorPrototype, TAG, true);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    if (( FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    }
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  var $at = _stringAt(true);
  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });

  var _iterStep = function (done, value) {
    return { value: value, done: !!done };
  };

  var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
    this._t = _toIobject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t;
    var kind = this._k;
    var index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return _iterStep(1);
    }
    if (kind == 'keys') return _iterStep(0, index);
    if (kind == 'values') return _iterStep(0, O[index]);
    return _iterStep(0, [index, O[index]]);
  }, 'values');
  _iterators.Arguments = _iterators.Array;

  var TO_STRING_TAG = _wks('toStringTag');
  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
    'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
    'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
    'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
    'TextTrackList,TouchList').split(',');
  for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i];
    var Collection = _global[NAME];
    var proto = Collection && Collection.prototype;
    if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = _iterators.Array;
  }

  var _redefineAll = function (target, src, safe) {
    for (var key in src) {
      if (safe && target[key]) target[key] = src[key];
      else _hide(target, key, src[key]);
    } return target;
  };

  var _anInstance = function (it, Constructor, name, forbiddenField) {
    if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
      throw TypeError(name + ': incorrect invocation!');
    } return it;
  };

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;
  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var TAG$1 = _wks('toStringTag');
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {  }
  };
  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      : ARG ? _cof(O)
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$2 = _wks('iterator');
  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
  });

  var SPECIES = _wks('species');
  var _setSpecies = function (KEY) {
    var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
    if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  };

  var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');
  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function (it) {
    setDesc(it, META, { value: {
      i: 'O' + ++id,
      w: {}
    } });
  };
  var fastKey = function (it, create) {
    if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      if (!isExtensible(it)) return 'F';
      if (!create) return 'E';
      setMeta(it);
    } return it[META].i;
  };
  var getWeak = function (it, create) {
    if (!_has(it, META)) {
      if (!isExtensible(it)) return true;
      if (!create) return false;
      setMeta(it);
    } return it[META].w;
  };
  var onFreeze = function (it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
  });
  var _meta_1 = _meta.KEY;
  var _meta_2 = _meta.NEED;
  var _meta_3 = _meta.fastKey;
  var _meta_4 = _meta.getWeak;
  var _meta_5 = _meta.onFreeze;

  var _validateCollection = function (it, TYPE) {
    if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
    return it;
  };

  var dP$1 = _objectDp.f;
  var fastKey = _meta.fastKey;
  var SIZE = _descriptors ? '_s' : 'size';
  var getEntry = function (that, key) {
    var index = fastKey(key);
    var entry;
    if (index !== 'F') return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  var _collectionStrong = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        _anInstance(that, C, NAME, '_i');
        that._t = NAME;
        that._i = _objectCreate(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
      });
      _redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function (key) {
          var that = _validateCollection(this, NAME);
          var entry = getEntry(that, key);
          if (entry) {
            var next = entry.n;
            var prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          } return !!entry;
        },
        forEach: function forEach(callbackfn ) {
          _validateCollection(this, NAME);
          var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
          var entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(_validateCollection(this, NAME), key);
        }
      });
      if (_descriptors) dP$1(C.prototype, 'size', {
        get: function () {
          return _validateCollection(this, NAME)[SIZE];
        }
      });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key);
      var prev, index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index !== 'F') that._i[index] = entry;
      } return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      _iterDefine(C, NAME, function (iterated, kind) {
        this._t = _validateCollection(iterated, NAME);
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this;
        var kind = that._k;
        var entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return _iterStep(1);
        }
        if (kind == 'keys') return _iterStep(0, entry.k);
        if (kind == 'values') return _iterStep(0, entry.v);
        return _iterStep(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      _setSpecies(NAME);
    }
  };

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  var SPECIES$1 = _wks('species');
  var _arraySpeciesConstructor = function (original) {
    var C;
    if (_isArray(original)) {
      C = original.constructor;
      if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
      if (_isObject(C)) {
        C = C[SPECIES$1];
        if (C === null) C = undefined;
      }
    } return C === undefined ? Array : C;
  };

  var _arraySpeciesCreate = function (original, length) {
    return new (_arraySpeciesConstructor(original))(length);
  };

  var _arrayMethods = function (TYPE, $create) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    var create = $create || _arraySpeciesCreate;
    return function ($this, callbackfn, that) {
      var O = _toObject($this);
      var self = _iobject(O);
      var f = _ctx(callbackfn, that, 3);
      var length = _toLength(self.length);
      var index = 0;
      var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
      var val, res;
      for (;length > index; index++) if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res;
          else if (res) switch (TYPE) {
            case 3: return true;
            case 5: return val;
            case 6: return index;
            case 2: result.push(val);
          } else if (IS_EVERY) return false;
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
    };
  };

  var dP$2 = _objectDp.f;
  var each = _arrayMethods(0);
  var _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = _global[NAME];
    var C = Base;
    var ADDER = IS_MAP ? 'set' : 'add';
    var proto = C && C.prototype;
    var O = {};
    if (!_descriptors || typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      _redefineAll(C.prototype, methods);
      _meta.NEED = true;
    } else {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME, '_c');
        target._c = new Base();
        if (iterable != undefined) _forOf(iterable, IS_MAP, target[ADDER], target);
      });
      each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) _hide(C.prototype, KEY, function (a, b) {
          _anInstance(this, C, KEY);
          if (!IS_ADDER && IS_WEAK && !_isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      IS_WEAK || dP$2(C.prototype, 'size', {
        get: function () {
          return this._c.size;
        }
      });
    }
    _setToStringTag(C, NAME);
    O[NAME] = C;
    _export(_export.G + _export.W + _export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };

  var SET = 'Set';
  var es6_set = _collection(SET, function (get) {
    return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
  }, {
    add: function add(value) {
      return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
    }
  }, _collectionStrong);

  var _arrayFromIterable = function (iter, ITERATOR) {
    var result = [];
    _forOf(iter, false, result.push, result, ITERATOR);
    return result;
  };

  var _collectionToJson = function (NAME) {
    return function toJSON() {
      if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      return _arrayFromIterable(this);
    };
  };

  _export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });

  var _setCollectionOf = function (COLLECTION) {
    _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = new Array(length);
      while (length--) A[length] = arguments[length];
      return new this(A);
    } });
  };

  _setCollectionOf('Set');

  var _setCollectionFrom = function (COLLECTION) {
    _export(_export.S, COLLECTION, { from: function from(source ) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
  };

  _setCollectionFrom('Set');

  var set = _core.Set;

  var set$1 = set;

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
    Array.from(riter, function () { throw 2; });
  } catch (e) {  }
  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) {  }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
    from: function from(arrayLike ) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  var from_1 = _core.Array.from;

  var from_1$1 = from_1;

  _export(_export.S, 'Array', { isArray: _isArray });

  var isArray = _core.Array.isArray;

  var isArray$1 = isArray;

  Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,value:function r(){var t=isNaN(arguments[0])?1:Number(arguments[0]);return t?Array.prototype.reduce.call(this,function(a,e){return Array.isArray(e)?a.push.apply(a,r.call(e,t-1)):a.push(e),a},[]):Array.prototype.slice.call(this)},writable:!0}),Array.prototype.flatMap||Object.defineProperty(Array.prototype,"flatMap",{configurable:!0,value:function(r){return Array.prototype.map.apply(this,arguments).flat()},writable:!0});

  var listRender = {
    name: 'render',
    functional: true,
    props: {
      node: Object,
      displayKey: String,
      searchKey: [String, Array],
      searchKeyword: String,
      tpl: Function
    },
    render: function render(h, ct) {
      var parentClass = 'bk-selector-node';
      var textClass = 'text';
      var _ct$props = ct.props,
          node = _ct$props.node,
          displayKey = _ct$props.displayKey,
          searchKeyword = _ct$props.searchKeyword,
          tpl = _ct$props.tpl;
      function highlightKeyword(value) {
        if (searchKeyword) {
          var keywordReg = new RegExp("(".concat(searchKeyword, ")"), 'i');
          return value.replace(keywordReg, '<strong class="highlight-text">$1</strong>');
        } else {
          return value;
        }
      }
      if (tpl) {
        var innerHtml = tpl(node, ct, highlightKeyword, h);
        return innerHtml;
      } else {
        return h("div", {
          "class": parentClass
        }, [h("span", {
          "domProps": {
            "innerHTML": highlightKeyword(node[displayKey])
          },
          "class": textClass
        })]);
      }
    }
  };

  var tagRender = {
    name: 'tag-render',
    functional: true,
    props: {
      node: Object,
      displayKey: String,
      tpl: Function
    },
    render: function render(h, ct) {
      var parentClass = 'tag';
      var textClass = 'text';
      if (ct.props.tpl) {
        return ct.props.tpl(ct.props.node, ct, h);
      }
      return h("div", {
        "class": parentClass
      }, [h("span", {
        "class": textClass
      }, [ct.props.node[ct.props.displayKey]])]);
    }
  };

  _export(_export.S, 'Number', {
    isNaN: function isNaN(number) {
      return number != number;
    }
  });

  var isNan = _core.Number.isNaN;

  var isNan$1 = isNan;

  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

  var $Object = _core.Object;
  var defineProperty = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };

  var defineProperty$1 = defineProperty;

  var hasInitZIndex = false;
  var zIndex;
  (function () {
    if (!window['__bk_zIndex_manager']) {
      var zIndexManager = {
        nextZIndex: function nextZIndex() {
          var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
          return zIndex === 'default' ? zIndexManager.zIndex++ : zIndex;
        },
        nextTickIndex: function nextTickIndex() {
          var tick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
          if (zIndex === 'default') {
            zIndexManager.zIndex += tick;
            return zIndexManager.zIndex;
          }
          return zIndex;
        }
      };
      defineProperty$1(zIndexManager, 'zIndex', {
        configurable: true,
        get: function get() {
          if (!hasInitZIndex) {
            zIndex = zIndex || (Vue.prototype.$BK_EL || {}).zIndex || 2000;
            hasInitZIndex = true;
          }
          return zIndex;
        },
        set: function set(value) {
          zIndex = value;
        }
      });
      window['__bk_zIndex_manager'] = zIndexManager;
    }
  })();
  var zIndexManager = window['__bk_zIndex_manager'];

  var script = {
    name: 'bk-loading',
    props: {
      isLoading: {
        type: Boolean,
        default: false
      },
      title: {
        type: [String, Object],
        default: ''
      },
      mode: {
        type: String,
        default: 'normal'
      },
      size: {
        type: String,
        default: 'large'
      },
      theme: {
        type: String,
        default: 'colorful'
      },
      delay: {
        type: Number,
        default: 0
      },
      immediate: {
        type: Boolean,
        default: false
      },
      opacity: {
        type: Number,
        default: 0.9
      },
      color: {
        type: String,
        default: '#ffffff'
      },
      zIndex: {
        type: Number
      },
      afterLeave: {
        type: Function
      },
      extCls: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'default'
      }
    },
    data: function data() {
      return {
        timer: 0,
        hide: false,
        duration: 500,
        isShow: false
      };
    },
    computed: {
      isSpin: function isSpin() {
        return this.mode === 'spin';
      },
      bgColor: function bgColor() {
        var color = this.color.replace(/\s/gm, '');
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(color)) {
          var colors = color.substring(1).split('');
          if (colors.length === 3) {
            colors = [colors[0], colors[0], colors[1], colors[1], colors[2], colors[2]];
          }
          colors = '0x' + colors.join('');
          return 'rgba(' + [colors >> 16 & 255, colors >> 8 & 255, colors & 255].join(',') + ",".concat(this.opacity, ")");
        } else if (/^rgba?\(([^\)]+)\)/.test(color)) {
          return color.replace(/^rgb\(([^\)]+)\)/, "rgba($1,".concat(this.opacity, ")"));
        }
        return this.color;
      },
      computedClass: function computedClass() {
        return this.isSpin ? "bk-spin-loading bk-spin-loading-".concat(this.size, " bk-spin-loading-").concat(this.theme) : "bk-loading1 bk-".concat(this.theme, " bk-size-").concat(this.size);
      },
      hasZIndexOption: function hasZIndexOption() {
        if (this.type === 'fixed') {
          return;
        }
        return typeof this.zIndex === 'number' && !isNan$1(this.zIndex);
      }
    },
    watch: {
      hide: function hide(newVal) {
        var _this = this;
        if (newVal) {
          var delay = isNaN(this.delay) ? 0 : Number(this.delay);
          clearTimeout(this.timer);
          if (delay > 0) {
            this.timer = setTimeout(function () {
              _this.hideLoading();
            }, delay);
          } else {
            this.hideLoading();
          }
        }
      },
      isShow: function isShow(newVal) {
        if (newVal && !this.hasZIndexOption) {
          this.zIndex = zIndexManager.nextZIndex();
        }
      },
      isLoading: {
        handler: function handler(newVal) {
          if (this.type === 'default') {
            if (newVal) {
              this.isShow = newVal;
            } else {
              this.hide = true;
            }
          }
        },
        immediate: true
      }
    },
    mounted: function mounted() {
      this.hide = false;
    },
    methods: {
      hideLoading: function hideLoading() {
        this.isShow = false;
        this.$el.addEventListener('transitionend', this.destroyEl);
      },
      destroyEl: function destroyEl() {
        this.$el.removeEventListener('transitionend', this.destroyEl);
        this.$destroy();
        this.$el.parentNode.removeChild(this.$el);
      },
      animationFinish: function animationFinish() {
        if (this.afterLeave && typeof this.afterLeave === 'function') {
          this.afterLeave();
        }
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    var options = typeof script === 'function' ? script.options : script;
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    if (scopeId) {
      options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      hook = function hook(context) {
        context = context ||
        this.$vnode && this.$vnode.ssrContext ||
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }
    if (hook) {
      if (options.functional) {
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script;
  }
  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _vm.type === 'default' ? _c('div', {
      staticClass: "bk-loading bk-default-loading",
      class: _vm.extCls,
      style: {
        position: 'relative'
      }
    }, [_c('div', {
      staticClass: "bk-loading-body"
    }, [_vm._t("default")], 2), _c('transition', {
      attrs: {
        "name": "fade",
        "duration": {
          enter: _vm.duration
        }
      },
      on: {
        "after-leave": _vm.animationFinish
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isShow,
        expression: "isShow"
      }],
      staticClass: "bk-loading-wrapper",
      style: {
        zIndex: _vm.zIndex,
        backgroundColor: _vm.bgColor
      }
    }, [_c('div', {
      class: _vm.computedClass
    }, [_vm.isSpin ? [_c('div', {
      staticClass: "rotate rotate1"
    }), _c('div', {
      staticClass: "rotate rotate2"
    }), _c('div', {
      staticClass: "rotate rotate3"
    }), _c('div', {
      staticClass: "rotate rotate4"
    }), _c('div', {
      staticClass: "rotate rotate5"
    }), _c('div', {
      staticClass: "rotate rotate6"
    }), _c('div', {
      staticClass: "rotate rotate7"
    }), _c('div', {
      staticClass: "rotate rotate8"
    })] : [_c('div', {
      staticClass: "point point1"
    }), _c('div', {
      staticClass: "point point2"
    }), _c('div', {
      staticClass: "point point3"
    }), _c('div', {
      staticClass: "point point4"
    })]], 2), _c('div', {
      staticClass: "bk-loading-title"
    }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])], 1) : _c('transition', {
      attrs: {
        "name": "fade",
        "duration": {
          enter: _vm.duration
        }
      },
      on: {
        "after-leave": _vm.animationFinish
      }
    }, [_c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isShow,
        expression: "isShow"
      }],
      staticClass: "bk-loading",
      class: _vm.extCls,
      style: {
        position: _vm.type,
        zIndex: _vm.zIndex,
        backgroundColor: _vm.bgColor
      }
    }, [_c('div', {
      staticClass: "bk-loading-wrapper"
    }, [_c('div', {
      class: _vm.computedClass
    }, [_vm.isSpin ? [_c('div', {
      staticClass: "rotate rotate1"
    }), _c('div', {
      staticClass: "rotate rotate2"
    }), _c('div', {
      staticClass: "rotate rotate3"
    }), _c('div', {
      staticClass: "rotate rotate4"
    }), _c('div', {
      staticClass: "rotate rotate5"
    }), _c('div', {
      staticClass: "rotate rotate6"
    }), _c('div', {
      staticClass: "rotate rotate7"
    }), _c('div', {
      staticClass: "rotate rotate8"
    })] : [_c('div', {
      staticClass: "point point1"
    }), _c('div', {
      staticClass: "point point2"
    }), _c('div', {
      staticClass: "point point3"
    }), _c('div', {
      staticClass: "point point4"
    })]], 2), _c('div', {
      staticClass: "bk-loading-title"
    }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])]);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

  var Model = Vue.extend(__vue_component__);
  function show(el, options) {
    if (!el.$vm) {
      el.$vm = el.viewmodel.$mount();
      el.appendChild(el.$vm.$el);
    }
    el.$vm.duration = 0;
    Vue.nextTick(function () {
      el.$vm.isShow = true;
    });
  }
  function toggle(el, options) {
    if (!el.$vm) {
      el.$vm = el.viewmodel.$mount();
      el.appendChild(el.$vm.$el);
    }
    clearTimeout(el.$vm.timer);
    if (options.isLoading) {
      Vue.nextTick(function () {
        el.$vm.isShow = true;
      });
    } else {
      var delay = isNaN(options.delay) ? 0 : Number(options.delay);
      if (delay > 0) {
        el.$vm.timer = setTimeout(function () {
          el.$vm.isShow = false;
        }, delay);
      } else {
        el.$vm.isShow = false;
      }
    }
    if (options.title) {
      el.$vm.title = options.title;
    }
  }
  var bkLoading = {
    inserted: function inserted(el, binding) {
      var value = binding.value;
      var position = getComputedStyle(el).position;
      var options = {};
      if (!position || position !== 'relative' || position !== 'absolute') {
        el.style.position = 'relative';
      }
      for (var key in value) {
        if (key !== 'isLoading') {
          options[key] = value[key];
        }
      }
      options.delay = 3000;
      options.type = 'absolute';
      options.opacity = options.opacity || 0.9;
      options.color = options.color || '#ffffff';
      el.viewmodel = new Model({
        propsData: options
      });
      if (options.immediate) {
        show(el, binding.value);
      } else {
        toggle(el, binding.value);
      }
    },
    update: function update(el, binding) {
      toggle(el, binding.value);
    }
  };

  var emitter = {
    methods: {
      dispatch: function dispatch(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!name || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, [eventName].concat(params));
        }
      }
    }
  };

  var f$1 = Object.getOwnPropertySymbols;
  var _objectGops = {
  	f: f$1
  };

  var f$2 = {}.propertyIsEnumerable;
  var _objectPie = {
  	f: f$2
  };

  var $assign = Object.assign;
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
      }
    } return T;
  } : $assign;

  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  var assign = _core.Object.assign;

  var assign$1 = assign;

  var $parseFloat = _global.parseFloat;
  var $trim$1 = _stringTrim.trim;
  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim$1(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  _export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

  var _parseFloat$1 = _core.parseFloat;

  var _parseFloat$2 = _parseFloat$1;

  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i$1 = 0; i$1 < longerTimeoutBrowsers.length; i$1 += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i$1]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser && window.Promise;
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent(getParentNode(element));
  }
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent(commonAncestorContainer);
    }
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return _parseFloat$2(styles["border".concat(sideA, "Width")], 10) + _parseFloat$2(styles["border".concat(sideB, "Width")], 10);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body["offset".concat(axis)], body["scroll".concat(axis)], html["client".concat(axis)], html["offset".concat(axis)], html["scroll".concat(axis)], isIE(10) ? _parseInt$2(html["offset".concat(axis)]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Top' : 'Left')]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }
  var _extends$1 = assign$1 || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect(offsets) {
    return _extends$1({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect(element) {
    var rect = {};
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = _parseFloat$2(styles.borderTopWidth, 10);
    var borderLeftWidth = _parseFloat$2(styles.borderLeftWidth, 10);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE10 && isHTML) {
      var marginTop = _parseFloat$2(styles.marginTop, 10);
      var marginLeft = _parseFloat$2(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }
  function getFixedPositionOffsetParent(element) {
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      var boundariesNode;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = keys$1(rects).map(function (key) {
      return _extends$1({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? "-".concat(variation) : '');
  }
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = _parseFloat$2(styles.marginTop || 0) + _parseFloat$2(styles.marginBottom || 0);
    var y = _parseFloat$2(styles.marginLeft || 0) + _parseFloat$2(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
    var popperRect = getOuterSizes(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
    return popperOffsets;
  }
  function find(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex(arr, prop, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function _update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
    data = runModifiers(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref3) {
      var name = _ref3.name,
          enabled = _ref3.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var _i = 0; _i < prefixes.length; _i++) {
      var prefix = prefixes[_i];
      var toCheck = prefix ? "".concat(prefix).concat(upperProp) : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  function _destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    });
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function _enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners(reference, state) {
    getWindow(reference).removeEventListener('resize', state.updateBound);
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function _disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  function isNumeric(n) {
    return n !== '' && !isNaN(_parseFloat$2(n)) && isFinite(n);
  }
  function setStyles(element, styles) {
    keys$1(styles).forEach(function (prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  function setAttributes(element, attributes) {
    keys$1(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  function applyStyle(data) {
    setStyles(data.instance.popper, data.styles);
    setAttributes(data.instance.popper, data.attributes);
    if (data.arrowElement && keys$1(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement);
    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
    var prefixedProperty = getSupportedPropertyName('transform');
    var left, top;
    if (sideA === 'bottom') {
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = "translate3d(".concat(left, "px, ").concat(top, "px, 0)");
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = "".concat(sideA, ", ").concat(sideB);
    }
    var attributes = {
      'x-placement': data.placement
    };
    data.attributes = _extends$1({}, attributes, data.attributes);
    data.styles = _extends$1({}, styles, data.styles);
    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref4) {
      var name = _ref4.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = "`".concat(requestingName, "`");
      var requested = "`".concat(requestedName, "`");
      console.warn("".concat(requested, " modifier is required by ").concat(_requesting, " modifier in order to work, be sure to include it before ").concat(_requesting, "!"));
    }
    return isRequired;
  }
  function arrow(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
    var placement = data.placement.split('-')[0];
    var _data$offsets2 = data.offsets,
        popper = _data$offsets2.popper,
        reference = _data$offsets2.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = _parseFloat$2(css["margin".concat(sideCapitalized)], 10);
    var popperBorderSide = _parseFloat$2(css["border".concat(sideCapitalized, "Width")], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var validPlacements = placements.slice(3);
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  function flip(data, options) {
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? '-' + variation : '');
        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  function keepTogether(data) {
    var _data$offsets3 = data.offsets,
        popper = _data$offsets3.popper,
        reference = _data$offsets3.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf('%') === 0) {
      var element;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      var size;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function (op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset(data, _ref5) {
    var offset = _ref5.offset;
    var placement = data.placement,
        _data$offsets4 = data.offsets,
        popper = _data$offsets4.popper,
        reference = _data$offsets4.reference;
    var basePlacement = placement.split('-')[0];
    var offsets;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style;
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return _defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return _defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$1({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
    if (shiftvariation) {
      var _data$offsets5 = data.offsets,
          reference = _data$offsets5.reference,
          popper = _data$offsets5.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: _defineProperty({}, side, reference[side]),
        end: _defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
    return data;
  }
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets6 = data.offsets,
        popper = _data$offsets6.popper,
        reference = _data$offsets6.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  var modifiers = {
    shift: {
      order: 100,
      enabled: true,
      fn: shift
    },
    offset: {
      order: 200,
      enabled: true,
      fn: offset,
      offset: 0
    },
    preventOverflow: {
      order: 300,
      enabled: true,
      fn: preventOverflow,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: {
      order: 400,
      enabled: true,
      fn: keepTogether
    },
    arrow: {
      order: 500,
      enabled: true,
      fn: arrow,
      element: '[x-arrow]'
    },
    flip: {
      order: 600,
      enabled: true,
      fn: flip,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: false,
      flipVariationsByContent: false
    },
    inner: {
      order: 700,
      enabled: false,
      fn: inner
    },
    hide: {
      order: 800,
      enabled: true,
      fn: hide
    },
    computeStyle: {
      order: 850,
      enabled: true,
      fn: computeStyle,
      gpuAcceleration: true,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: true,
      fn: applyStyle,
      onLoad: applyStyleOnLoad,
      gpuAcceleration: undefined
    }
  };
  var Defaults = {
    placement: 'bottom',
    positionFixed: false,
    eventsEnabled: true,
    removeOnDestroy: false,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: modifiers
  };
  var Popper = function () {
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce(this.update.bind(this));
      this.options = _extends$1({}, Popper.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      keys$1(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = keys$1(this.options.modifiers).map(function (name) {
        return _extends$1({
          name: name
        }, _this.options.modifiers[name]);
      })
      .sort(function (a, b) {
        return a.order - b.order;
      });
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    _createClass(Popper, [{
      key: "update",
      value: function update() {
        return _update.call(this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        return _destroy.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function enableEventListeners() {
        return _enableEventListeners.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function disableEventListeners() {
        return _disableEventListeners.call(this);
      }
    }]);
    return Popper;
  }();
  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  function _extends$2() {
    _extends$2 = assign$1 || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  var version = "4.3.4";
  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
  var ua = isBrowser$1 ? navigator.userAgent : '';
  var isIE$1 = /MSIE |Trident\//.test(ua);
  var isUCBrowser = /UCBrowser\//.test(ua);
  var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
  var defaultProps = {
    a11y: true,
    allowHTML: true,
    animateFill: true,
    animation: 'shift-away',
    appendTo: function appendTo() {
      return document.body;
    },
    aria: 'describedby',
    arrow: false,
    arrowType: 'sharp',
    boundary: 'scrollParent',
    content: '',
    delay: 0,
    distance: 10,
    duration: [325, 275],
    flip: true,
    flipBehavior: 'flip',
    flipOnUpdate: false,
    followCursor: false,
    hideOnClick: true,
    ignoreAttributes: false,
    inertia: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    lazy: true,
    width: 'auto',
    maxWidth: 'auto',
    multiple: false,
    offset: 0,
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    placement: 'top',
    popperOptions: {},
    role: 'tooltip',
    showOnInit: false,
    size: 'regular',
    sticky: false,
    target: '',
    theme: 'dark',
    touch: true,
    touchHold: false,
    trigger: 'mouseenter focus',
    triggerTarget: null,
    updateDuration: 0,
    wait: null,
    zIndex: 9999,
    extCls: ''
  };
  var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
  var elementProto = isBrowser$1 ? Element.prototype : {};
  var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function closest(element, selector) {
    return closestCallback(element, function (el) {
      return matches.call(el, selector);
    });
  }
  function closestCallback(element, callback) {
    while (element) {
      if (callback(element)) {
        return element;
      }
      element = element.parentElement;
    }
    return null;
  }
  var PASSIVE = {
    passive: true
  };
  var PADDING = 4;
  var PLACEMENT_ATTRIBUTE = 'x-placement';
  var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries';
  var IOS_CLASS = "tippy-iOS";
  var ACTIVE_CLASS = "tippy-active";
  var POPPER_CLASS = "tippy-popper";
  var TOOLTIP_CLASS = "tippy-tooltip";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var ROUND_ARROW_CLASS = "tippy-roundarrow";
  var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
  var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
  var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
  var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
  var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
  var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
  var isUsingTouch = false;
  function onDocumentTouch() {
    if (isUsingTouch) {
      return;
    }
    isUsingTouch = true;
    if (isIOS) {
      document.body.classList.add(IOS_CLASS);
    }
    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  var lastMouseMoveTime = 0;
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      isUsingTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
      if (!isIOS) {
        document.body.classList.remove(IOS_CLASS);
      }
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var _document = document,
        activeElement = _document.activeElement;
    if (activeElement && activeElement.blur && activeElement._tippy) {
      activeElement.blur();
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
    window.addEventListener('blur', onWindowBlur);
  }
  var keys$2 = keys$1(defaultProps);
  function getDataAttributeOptions(reference) {
    return keys$2.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
  }
  function polyfillElementPrototypeProperties(virtualReference) {
    var polyfills = {
      isVirtual: true,
      attributes: virtualReference.attributes || {},
      contains: function contains() {},
      setAttribute: function setAttribute(key, value) {
        virtualReference.attributes[key] = value;
      },
      getAttribute: function getAttribute(key) {
        return virtualReference.attributes[key];
      },
      removeAttribute: function removeAttribute(key) {
        delete virtualReference.attributes[key];
      },
      hasAttribute: function hasAttribute(key) {
        return key in virtualReference.attributes;
      },
      addEventListener: function addEventListener() {},
      removeEventListener: function removeEventListener() {},
      classList: {
        classNames: {},
        add: function add(key) {
          virtualReference.classList.classNames[key] = true;
        },
        remove: function remove(key) {
          delete virtualReference.classList.classNames[key];
        },
        contains: function contains(key) {
          return key in virtualReference.classList.classNames;
        }
      }
    };
    for (var key in polyfills) {
      virtualReference[key] = polyfills[key];
    }
  }
  function isBareVirtualElement(value) {
    return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
  }
  function isReferenceElement(value) {
    return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
  }
  function hasOwnProperty$1(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getArrayOfElements(value) {
    if (isSingular(value)) {
      return [value];
    }
    if (value instanceof NodeList) {
      return arrayFrom(value);
    }
    if (isArray$1(value)) {
      return value;
    }
    try {
      return arrayFrom(document.querySelectorAll(value));
    } catch (e) {
      return [];
    }
  }
  function getValue(value, index, defaultValue) {
    if (isArray$1(value)) {
      var v = value[index];
      return v == null ? defaultValue : v;
    }
    return value;
  }
  function debounce$1(fn, ms) {
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function getModifier(obj, key) {
    return obj && obj.modifiers && obj.modifiers[key];
  }
  function includes(a, b) {
    return a.indexOf(b) > -1;
  }
  function isRealElement(value) {
    return value instanceof Element;
  }
  function isSingular(value) {
    return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);
  }
  function innerHTML() {
    return 'innerHTML';
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(null, args) : value;
  }
  function setFlipModifierEnabled(modifiers, value) {
    modifiers.filter(function (m) {
      return m.name === 'flip';
    })[0].enabled = value;
  }
  function canReceiveFocus(element) {
    return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
  }
  function div() {
    return document.createElement('div');
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = "".concat(value, "ms");
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function evaluateProps(reference, props) {
    var out = _extends$2({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
    if (out.arrow || isUCBrowser) {
      out.animateFill = false;
    }
    return out;
  }
  function validateOptions(options, defaultProps) {
    keys$1(options).forEach(function (option) {
      if (!hasOwnProperty$1(defaultProps, option)) {
        throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
      }
    });
  }
  function setInnerHTML(element, html) {
    element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
  }
  function setContent(contentEl, props) {
    if (isRealElement(props.content)) {
      setInnerHTML(contentEl, '');
      contentEl.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      var key = props.allowHTML ? 'innerHTML' : 'textContent';
      contentEl[key] = props.content;
    }
  }
  function getChildren(popper) {
    return {
      tooltip: popper.querySelector(TOOLTIP_SELECTOR),
      backdrop: popper.querySelector(BACKDROP_SELECTOR),
      content: popper.querySelector(CONTENT_SELECTOR),
      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
    };
  }
  function addInertia(tooltip) {
    tooltip.setAttribute('data-inertia', '');
  }
  function removeInertia(tooltip) {
    tooltip.removeAttribute('data-inertia');
  }
  function createArrowElement(arrowType) {
    var arrow = div();
    if (arrowType === 'round') {
      arrow.className = ROUND_ARROW_CLASS;
      setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
    } else {
      arrow.className = ARROW_CLASS;
    }
    return arrow;
  }
  function createBackdropElement() {
    var backdrop = div();
    backdrop.className = BACKDROP_CLASS;
    backdrop.setAttribute('data-state', 'hidden');
    return backdrop;
  }
  function addInteractive(popper, tooltip) {
    popper.setAttribute('tabindex', '-1');
    tooltip.setAttribute('data-interactive', '');
  }
  function removeInteractive(popper, tooltip) {
    popper.removeAttribute('tabindex');
    tooltip.removeAttribute('data-interactive');
  }
  function updateTransitionEndListener(tooltip, action, listener) {
    var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
    tooltip[action + 'EventListener'](eventName, listener);
  }
  function getBasicPlacement(popper) {
    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
    return fullPlacement ? fullPlacement.split('-')[0] : '';
  }
  function reflow(popper) {
    void popper.offsetHeight;
  }
  function updateTheme(tooltip, action, theme) {
    theme.split(' ').forEach(function (themeName) {
      tooltip.classList[action](themeName + '-theme');
    });
  }
  function setWidth(tooltip, props, key) {
    var width = props[key];
    var parsedWidth = _parseInt$2(width);
    if (typeof width === 'number') {
      tooltip.style[key] = width + 'px';
    } else if (isNaN(parsedWidth)) {
      tooltip.style[key] = width;
    } else {
      tooltip.style[key] = parsedWidth + 'px';
    }
  }
  function createPopperElement(id, props) {
    var popper = div();
    popper.className = POPPER_CLASS + (props.extCls ? " ".concat(props.extCls) : '');
    popper.id = "tippy-".concat(id);
    popper.style.zIndex = '' + props.zIndex;
    popper.style.position = 'absolute';
    popper.style.top = '0';
    popper.style.left = '0';
    if (props.role) {
      popper.setAttribute('role', props.role);
    }
    var tooltip = div();
    tooltip.className = TOOLTIP_CLASS;
    setWidth(tooltip, props, 'maxWidth');
    setWidth(tooltip, props, 'width');
    tooltip.setAttribute('data-size', props.size);
    tooltip.setAttribute('data-animation', props.animation);
    tooltip.setAttribute('data-state', 'hidden');
    updateTheme(tooltip, 'add', props.theme);
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    if (props.interactive) {
      addInteractive(popper, tooltip);
    }
    if (props.arrow) {
      tooltip.appendChild(createArrowElement(props.arrowType));
    }
    if (props.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    }
    if (props.inertia) {
      addInertia(tooltip);
    }
    setContent(content, props);
    tooltip.appendChild(content);
    popper.appendChild(tooltip);
    return popper;
  }
  function updatePopperElement(popper, prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        tooltip = _getChildren.tooltip,
        content = _getChildren.content,
        backdrop = _getChildren.backdrop,
        arrow = _getChildren.arrow;
    popper.style.zIndex = '' + nextProps.zIndex;
    tooltip.setAttribute('data-size', nextProps.size);
    tooltip.setAttribute('data-animation', nextProps.animation);
    tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');
    if (nextProps.role) {
      popper.setAttribute('role', nextProps.role);
    } else {
      popper.removeAttribute('role');
    }
    if (prevProps.content !== nextProps.content) {
      setContent(content, nextProps);
    }
    if (!prevProps.animateFill && nextProps.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    } else if (prevProps.animateFill && !nextProps.animateFill) {
      tooltip.removeChild(backdrop);
      tooltip.removeAttribute('data-animatefill');
    }
    if (!prevProps.arrow && nextProps.arrow) {
      tooltip.appendChild(createArrowElement(nextProps.arrowType));
    } else if (prevProps.arrow && !nextProps.arrow) {
      tooltip.removeChild(arrow);
    }
    if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
      tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
    }
    if (!prevProps.interactive && nextProps.interactive) {
      addInteractive(popper, tooltip);
    } else if (prevProps.interactive && !nextProps.interactive) {
      removeInteractive(popper, tooltip);
    }
    if (!prevProps.inertia && nextProps.inertia) {
      addInertia(tooltip);
    } else if (prevProps.inertia && !nextProps.inertia) {
      removeInertia(tooltip);
    }
    if (prevProps.theme !== nextProps.theme) {
      updateTheme(tooltip, 'remove', prevProps.theme);
      updateTheme(tooltip, 'add', nextProps.theme);
    }
  }
  function hideAll() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        excludedReferenceOrInstance = _ref.exclude,
        duration = _ref.duration;
    arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
      var instance = popper._tippy;
      if (instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) {
          isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
        }
        if (!isExcluded) {
          instance.hide(duration);
        }
      }
    });
  }
  function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
    if (!popperPlacement) {
      return true;
    }
    var x = event.clientX,
        y = event.clientY;
    var interactiveBorder = props.interactiveBorder,
        distance = props.distance;
    var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
    var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
    var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
    var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  }
  function getOffsetDistanceInPx(distance) {
    return -(distance - 10) + 'px';
  }
  var idCounter = 1;
  var mouseMoveListeners = [];
  function createTippy(reference, collectionProps) {
    var props = evaluateProps(reference, collectionProps);
    if (!props.multiple && reference._tippy) {
      return null;
    }
    var lastTriggerEventType;
    var lastMouseMoveEvent;
    var showTimeoutId;
    var hideTimeoutId;
    var scheduleHideAnimationFrameId;
    var isScheduledToShow = false;
    var isBeingDestroyed = false;
    var previousPlacement;
    var wasVisibleDuringPreviousUpdate = false;
    var hasMountCallbackRun = false;
    var currentMountCallback;
    var currentTransitionEndListener;
    var listeners = [];
    var currentComputedPadding;
    var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
    var id = idCounter++;
    var popper = createPopperElement(id, props);
    var popperChildren = getChildren(popper);
    var popperInstance = null;
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id: id,
      reference: reference,
      popper: popper,
      popperChildren: popperChildren,
      popperInstance: popperInstance,
      props: props,
      state: state,
      clearDelayTimeouts: clearDelayTimeouts,
      set: set,
      setContent: setContent,
      show: show,
      hide: hide,
      enable: enable,
      disable: disable,
      destroy: destroy
    };
    reference._tippy = instance;
    popper._tippy = instance;
    addTriggersToReference();
    if (!props.lazy) {
      createPopperInstance();
    }
    if (props.showOnInit) {
      scheduleShow();
    }
    if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
      getEventListenersTarget().setAttribute('tabindex', '0');
    }
    popper.addEventListener('mouseenter', function (event) {
      if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
        scheduleShow(event, true);
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
        document.addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance;
    function removeFollowCursorListener() {
      document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
    }
    function cleanupInteractiveMouseListeners() {
      document.body.removeEventListener('mouseleave', scheduleHide);
      document.removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function getEventListenersTarget() {
      return instance.props.triggerTarget || reference;
    }
    function addDocumentClickListener() {
      document.addEventListener('click', onDocumentClick, true);
    }
    function removeDocumentClickListener() {
      document.removeEventListener('click', onDocumentClick, true);
    }
    function getTransitionableElements() {
      return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
    }
    function getIsInLooseFollowCursorMode() {
      var followCursor = instance.props.followCursor;
      return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
    }
    function makeSticky() {
      setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);
      function updatePosition() {
        instance.popperInstance.scheduleUpdate();
        if (instance.state.isMounted) {
          requestAnimationFrame(updatePosition);
        } else {
          setTransitionDuration([popper], 0);
        }
      }
      updatePosition();
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var tooltip = instance.popperChildren.tooltip;
      function listener(event) {
        if (event.target === tooltip) {
          updateTransitionEndListener(tooltip, 'remove', listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(tooltip, 'add', listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      getEventListenersTarget().addEventListener(eventType, handler, options);
      listeners.push({
        eventType: eventType,
        handler: handler,
        options: options
      });
    }
    function addTriggersToReference() {
      if (instance.props.touchHold && !instance.props.target) {
        on('touchstart', onTrigger, PASSIVE);
        on('touchend', onMouseLeave, PASSIVE);
      }
      instance.props.trigger.trim().split(' ').forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }
        if (!instance.props.target) {
          on(eventType, onTrigger);
          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;
            case 'focus':
              on(isIE$1 ? 'focusout' : 'blur', onBlur);
              break;
          }
        } else {
          switch (eventType) {
            case 'mouseenter':
              on('mouseover', onDelegateShow);
              on('mouseout', onDelegateHide);
              break;
            case 'focus':
              on('focusin', onDelegateShow);
              on('focusout', onDelegateHide);
              break;
            case 'click':
              on(eventType, onDelegateShow);
              break;
          }
        }
      });
    }
    function removeTriggersFromReference() {
      listeners.forEach(function (_ref) {
        var eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        getEventListenersTarget().removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function positionVirtualReferenceNearCursor(event) {
      var _lastMouseMoveEvent = lastMouseMoveEvent = event,
          x = _lastMouseMoveEvent.clientX,
          y = _lastMouseMoveEvent.clientY;
      if (!currentComputedPadding) {
        return;
      }
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      var rect = reference.getBoundingClientRect();
      var followCursor = instance.props.followCursor;
      var isHorizontal = followCursor === 'horizontal';
      var isVertical = followCursor === 'vertical';
      var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
      var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
      var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
      var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
      var halfSize = size / 2;
      var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
      var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.popperInstance.reference = _extends$2({}, instance.popperInstance.reference, {
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              width: isVerticalPlacement ? size : 0,
              height: isVerticalPlacement ? 0 : size,
              top: (isHorizontal ? rect.top : y) - verticalIncrease,
              bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
              left: (isVertical ? rect.left : x) - horizontalIncrease,
              right: (isVertical ? rect.right : x) + horizontalIncrease
            };
          }
        });
        instance.popperInstance.update();
      }
      if (followCursor === 'initial' && instance.state.isVisible) {
        removeFollowCursorListener();
      }
    }
    function createDelegateChildTippy(event) {
      if (event) {
        var targetEl = closest(event.target, instance.props.target);
        if (targetEl && !targetEl._tippy) {
          createTippy(targetEl, _extends$2({}, instance.props, {
            content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
            appendTo: collectionProps.appendTo,
            target: '',
            showOnInit: true
          }));
        }
      }
    }
    function onTrigger(event) {
      if (!instance.state.isEnabled || isEventListenerStopped(event)) {
        return;
      }
      if (!instance.state.isVisible) {
        lastTriggerEventType = event.type;
        if (event instanceof MouseEvent) {
          lastMouseMoveEvent = event;
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        }
      }
      if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
        scheduleHide();
      } else {
        scheduleShow(event);
      }
    }
    function onMouseMove(event) {
      var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      if (isCursorOverPopper || isCursorOverReference) {
        return;
      }
      if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
        cleanupInteractiveMouseListeners();
        scheduleHide();
      }
    }
    function onMouseLeave(event) {
      if (isEventListenerStopped(event)) {
        return;
      }
      if (instance.props.interactive) {
        document.body.addEventListener('mouseleave', scheduleHide);
        document.addEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners.push(debouncedOnMouseMove);
        return;
      }
      scheduleHide();
    }
    function onBlur(event) {
      if (event.target !== getEventListenersTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide();
    }
    function onDelegateShow(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleShow(event);
      }
    }
    function onDelegateHide(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleHide();
      }
    }
    function isEventListenerStopped(event) {
      var supportsTouch = ('ontouchstart' in window);
      var isTouchEvent = includes(event.type, 'touch');
      var touchHold = instance.props.touchHold;
      return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
    }
    function runMountCallback() {
      if (!hasMountCallbackRun && currentMountCallback) {
        hasMountCallbackRun = true;
        reflow(popper);
        currentMountCallback();
      }
    }
    function createPopperInstance() {
      var popperOptions = instance.props.popperOptions;
      var _instance$popperChild = instance.popperChildren,
          tooltip = _instance$popperChild.tooltip,
          arrow = _instance$popperChild.arrow;
      var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
      function applyMutations(data) {
        if (instance.props.flip && !instance.props.flipOnUpdate) {
          if (data.flipped) {
            instance.popperInstance.options.placement = data.placement;
          }
          setFlipModifierEnabled(instance.popperInstance.modifiers, false);
        }
        tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);
        if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
          tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
        } else {
          tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
        }
        if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
          tooltip.style.transition = 'none';
          requestAnimationFrame(function () {
            tooltip.style.transition = '';
          });
        }
        previousPlacement = data.placement;
        wasVisibleDuringPreviousUpdate = instance.state.isVisible;
        var basicPlacement = getBasicPlacement(popper);
        var styles = tooltip.style;
        styles.top = styles.bottom = styles.left = styles.right = '';
        styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
        var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
        var isPaddingNumber = typeof padding === 'number';
        var computedPadding = _extends$2({
          top: isPaddingNumber ? padding : padding.top,
          bottom: isPaddingNumber ? padding : padding.bottom,
          left: isPaddingNumber ? padding : padding.left,
          right: isPaddingNumber ? padding : padding.right
        }, !isPaddingNumber && padding);
        computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
        instance.popperInstance.modifiers.filter(function (m) {
          return m.name === 'preventOverflow';
        })[0].padding = computedPadding;
        currentComputedPadding = computedPadding;
      }
      var config = _extends$2({
        eventsEnabled: false,
        placement: instance.props.placement
      }, popperOptions, {
        modifiers: _extends$2({}, popperOptions ? popperOptions.modifiers : {}, {
          preventOverflow: _extends$2({
            boundariesElement: instance.props.boundary,
            padding: PADDING
          }, preventOverflowModifier),
          arrow: _extends$2({
            element: arrow,
            enabled: !!arrow
          }, getModifier(popperOptions, 'arrow')),
          flip: _extends$2({
            enabled: instance.props.flip,
            padding: instance.props.distance + PADDING,
            behavior: instance.props.flipBehavior
          }, getModifier(popperOptions, 'flip')),
          offset: _extends$2({
            offset: instance.props.offset
          }, getModifier(popperOptions, 'offset'))
        }),
        onCreate: function onCreate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onCreate) {
            popperOptions.onCreate(data);
          }
        },
        onUpdate: function onUpdate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onUpdate) {
            popperOptions.onUpdate(data);
          }
        }
      });
      instance.popperInstance = new Popper(reference, popper, config);
    }
    function mount() {
      hasMountCallbackRun = false;
      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
      if (instance.popperInstance) {
        setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.reference = reference;
          instance.popperInstance.enableEventListeners();
        }
        instance.popperInstance.scheduleUpdate();
      } else {
        createPopperInstance();
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.enableEventListeners();
        }
      }
      var appendTo = instance.props.appendTo;
      var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);
      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
        instance.props.onMount(instance);
        instance.state.isMounted = true;
      }
    }
    function scheduleShow(event, shouldAvoidCallingOnTrigger) {
      clearDelayTimeouts();
      if (instance.state.isVisible) {
        return;
      }
      if (instance.props.target) {
        return createDelegateChildTippy(event);
      }
      isScheduledToShow = true;
      if (event && !shouldAvoidCallingOnTrigger) {
        instance.props.onTrigger(instance, event);
      }
      if (instance.props.wait) {
        return instance.props.wait(instance, event);
      }
      if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
        if (!instance.popperInstance) {
          createPopperInstance();
        }
        document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
      }
      addDocumentClickListener();
      var delay = getValue(instance.props.delay, 0, defaultProps.delay);
      if (delay) {
        showTimeoutId = setTimeout(function () {
          show();
        }, delay);
      } else {
        show();
      }
    }
    function scheduleHide() {
      clearDelayTimeouts();
      if (!instance.state.isVisible) {
        return removeFollowCursorListener();
      }
      isScheduledToShow = false;
      var delay = getValue(instance.props.delay, 1, defaultProps.delay);
      if (delay) {
        hideTimeoutId = setTimeout(function () {
          if (instance.state.isVisible) {
            hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrameId = requestAnimationFrame(function () {
          hide();
        });
      }
    }
    function onDocumentClick(event) {
      if (instance.props.interactive && popper.contains(event.target)) {
        return;
      }
      if (getEventListenersTarget().contains(event.target)) {
        if (isUsingTouch) {
          return;
        }
        if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
          return;
        }
      }
      if (instance.props.hideOnClick === true) {
        clearDelayTimeouts();
        hide();
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeoutId);
      clearTimeout(hideTimeoutId);
      cancelAnimationFrame(scheduleHideAnimationFrameId);
    }
    function set(options) {
      options = options || {};
      validateOptions(options, defaultProps);
      removeTriggersFromReference();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, _extends$2({}, instance.props, options, {
        ignoreAttributes: true
      }));
      nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
      instance.props = nextProps;
      addTriggersToReference();
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
      updatePopperElement(popper, prevProps, nextProps);
      instance.popperChildren = getChildren(popper);
      if (instance.popperInstance) {
        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
          return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];
        })) {
          instance.popperInstance.destroy();
          createPopperInstance();
          if (instance.state.isVisible) {
            instance.popperInstance.enableEventListeners();
          }
          if (instance.props.followCursor && lastMouseMoveEvent) {
            positionVirtualReferenceNearCursor(lastMouseMoveEvent);
          }
        } else {
          instance.popperInstance.update();
        }
      }
    }
    function setContent(content) {
      set({
        content: content
      });
    }
    function show() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
        return;
      }
      if (getEventListenersTarget().hasAttribute('disabled')) {
        return;
      }
      if (instance.props.onShow(instance) === false) {
        return;
      }
      addDocumentClickListener();
      popper.style.visibility = 'visible';
      instance.state.isVisible = true;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.add(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements.concat(popper), 0);
      currentMountCallback = function currentMountCallback() {
        if (!instance.state.isVisible) {
          return;
        }
        var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
        if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        } else if (!isInLooseFollowCursorMode) {
          instance.popperInstance.update();
        }
        if (instance.popperChildren.backdrop) {
          instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
        }
        if (instance.props.sticky) {
          makeSticky();
        }
        setTransitionDuration([popper], instance.props.updateDuration);
        setTransitionDuration(transitionableElements, duration);
        setVisibilityState(transitionableElements, 'visible');
        onTransitionedIn(duration, function () {
          if (instance.props.aria) {
            getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
          }
          instance.props.onShown(instance);
          instance.state.isShown = true;
        });
      };
      mount();
    }
    function hide() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
        return;
      }
      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
        return;
      }
      removeDocumentClickListener();
      popper.style.visibility = 'hidden';
      instance.state.isVisible = false;
      instance.state.isShown = false;
      wasVisibleDuringPreviousUpdate = false;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.remove(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'hidden');
      onTransitionedOut(duration, function () {
        if (!isScheduledToShow) {
          removeFollowCursorListener();
        }
        if (instance.props.aria) {
          getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
        }
        instance.popperInstance.disableEventListeners();
        instance.popperInstance.options.placement = instance.props.placement;
        popper.parentNode.removeChild(popper);
        instance.props.onHidden(instance);
        instance.state.isMounted = false;
      });
    }
    function destroy(destroyTargetInstances) {
      if (instance.state.isDestroyed) {
        return;
      }
      isBeingDestroyed = true;
      if (instance.state.isMounted) {
        hide(0);
      }
      removeTriggersFromReference();
      delete reference._tippy;
      var target = instance.props.target;
      if (target && destroyTargetInstances && isRealElement(reference)) {
        arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
          if (child._tippy) {
            child._tippy.destroy();
          }
        });
      }
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
      }
      isBeingDestroyed = false;
      instance.state.isDestroyed = true;
    }
  }
  function group(instances) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration;
    var isAnyTippyOpen = false;
    instances.forEach(function (instance) {
      if (instance._originalProps) {
        instance.set(instance._originalProps);
      } else {
        instance._originalProps = _extends$2({}, instance.props);
      }
    });
    function setIsAnyTippyOpen(value) {
      isAnyTippyOpen = value;
      updateInstances();
    }
    function onShow(instance) {
      instance._originalProps.onShow(instance);
      instances.forEach(function (instance) {
        instance.set({
          duration: duration
        });
        if (instance.state.isVisible) {
          instance.hide();
        }
      });
      setIsAnyTippyOpen(true);
    }
    function onHide(instance) {
      instance._originalProps.onHide(instance);
      setIsAnyTippyOpen(false);
    }
    function onShown(instance) {
      instance._originalProps.onShown(instance);
      instance.set({
        duration: instance._originalProps.duration
      });
    }
    function updateInstances() {
      instances.forEach(function (instance) {
        instance.set({
          onShow: onShow,
          onShown: onShown,
          onHide: onHide,
          delay: isAnyTippyOpen ? [0, isArray$1(delay) ? delay[1] : delay] : delay,
          duration: isAnyTippyOpen ? duration : instance._originalProps.duration
        });
      });
    }
    updateInstances();
  }
  var globalEventListenersBound = false;
  function tippy(targets, options) {
    validateOptions(options || {}, defaultProps);
    if (!globalEventListenersBound) {
      bindGlobalEventListeners();
      globalEventListenersBound = true;
    }
    var props = _extends$2({}, defaultProps, options);
    if (isBareVirtualElement(targets)) {
      polyfillElementPrototypeProperties(targets);
    }
    var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, props);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isSingular(targets) ? instances[0] : instances;
  }
  tippy.version = version;
  tippy.defaults = defaultProps;
  tippy.setDefaults = function (partialDefaults) {
    keys$1(partialDefaults).forEach(function (key) {
      defaultProps[key] = partialDefaults[key];
    });
  };
  tippy.hideAll = hideAll;
  tippy.group = group;
  function autoInit() {
    arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
      var content = el.getAttribute('data-tippy');
      if (content) {
        tippy(el, {
          content: content
        });
      }
    });
  }
  if (isBrowser$1) {
    setTimeout(autoInit);
  }
  var getValidTippyProps = function getValidTippyProps(props) {
    var validProps = {};
    for (var key in props) {
      if (defaultProps.hasOwnProperty(key)) {
        validProps[key] = props[key];
      }
    }
    return validProps;
  };

  var zIndex$1 = {
    props: {
      zIndex: {
        type: [Number, String],
        default: 'default'
      }
    },
    methods: {
      getLocalZIndex: function getLocalZIndex(zIndex) {
        return zIndexManager.nextTickIndex(2, zIndex);
      }
    }
  };

  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function uuid() {
    var id = '';
    var randomNum = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    for (var i = 0; i < 7; i++) {
      id += randomNum;
    }
    return id;
  }

  (function () {
    if (!window['__bk_pop_manager']) {
      var __containerId = "bk_pop_".concat(new Date().getTime());
      var __maskId = "bk_pop_mask_".concat(new Date().getTime());
      var __defaultKey = "bk_pop_key_".concat(new Date().getTime());
      var __popInstances = [];
      var popManager = {
        containerId: __containerId,
        maskId: __maskId,
        defaultKey: __defaultKey,
        formatKey: function formatKey(key) {
          return String(key).replace(/#/g, '_');
        },
        show: function show(key, instance) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
            tplAction: 'keepAll',
            zIndex: '',
            beforeHide: function beforeHide() {},
            ignoreExistMask: false,
            appendToBody: false
          };
          key = key === undefined || key === null || isNan$1(key) ? this.defaultKey : key;
          key = this.formatKey(key);
          var uid = uuid();
          var isAppendToBody = false;
          if (options.tplAction === 'onlyone') {
            this.clearByTpl(key);
          }
          if (this.shouldAppendToBody(key)) {
            isAppendToBody = true;
            this.showModalMask(options.zIndex);
            !options.appendToBody && this.container.append(instance);
          } else {
            isAppendToBody = false;
            var lastInsZindex = options.zIndex;
            this.showModalMask(lastInsZindex);
          }
          var beforeHide = options.beforeHide,
              zIndex = options.zIndex,
              ignoreExistMask = options.ignoreExistMask;
          this.instances.push({
            uid: uid,
            ins: instance,
            tplName: key,
            beforeHide: beforeHide,
            zIndex: zIndex,
            ignoreExistMask: ignoreExistMask,
            isAppendToBody: isAppendToBody
          });
          return "".concat(uid, "#").concat(key);
        },
        shouldAppendToBody: function shouldAppendToBody(tplName) {
          return this.instances.some(function (item) {
            return item.tplName === tplName;
          });
        },
        hide: function hide(popId, options) {
          options = options || {
            action: 'hideUid'
          };
          switch (options.action) {
            case 'hideAll':
              this.clearAll();
              break;
            case 'hideUid':
              this.clearByUid(popId);
              break;
            case 'hideSameTpl':
              this.clearByTpl(popId);
              break;
            default:
              this.autoClear(popId);
              break;
          }
          this.updateModalMaskIndex();
        },
        updateModalMaskIndex: function updateModalMaskIndex() {
          if (this.instances.length) {
            var lastIns = this.instances.slice(-1)[0];
            var lastInsZindex = lastIns.isAppendToBody ? lastIns.zIndex : lastIns.zIndex - 1;
            this.showModalMask(lastInsZindex);
          } else {
            this.hideModalMask();
          }
        },
        autoClear: function autoClear() {
          var uid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          if (uid.indexOf('#') > 0) {
            this.clearByUid(uid);
          } else {
            this.clearByTpl();
          }
        },
        clearByTpl: function clearByTpl(uid) {
          var _this = this;
          var keyStr = uid.split('#');
          var tplName = keyStr.slice(-1)[0];
          this.instances = this.instances.filter(function (item) {
            if (item.tplName === tplName) {
              _this.__hideInstance(item);
              return false;
            } else {
              return true;
            }
          });
        },
        clearByUid: function clearByUid(uid) {
          var keyStr = uid.split('#');
          var instanceUid = keyStr[0];
          var tplName = keyStr[1];
          var index = this.instances.findIndex(function (ins) {
            return ins.uid === instanceUid && ins.tplName === tplName;
          });
          if (index >= 0) {
            this.__hideInstance(this.instances[index]);
            this.instances.splice(index, 1);
          } else {
            console.warn('Can not find pop instance with index ' + index);
          }
        },
        clearAll: function clearAll() {
          var _this2 = this;
          this.instances.forEach(function (item) {
            return _this2.__hideInstance(item);
          });
          this.instances = [];
        },
        showModalMask: function showModalMask(zIndex) {
          this.dialogMask.setAttribute('style', "z-index:".concat(zIndex, ";"));
          document.body.style.overflow = 'hidden';
          this.dialogMask.classList.remove('hide-active');
          this.dialogMask.classList.add('show-active');
        },
        hideModalMask: function hideModalMask() {
          this.dialogMask.classList.remove('show-active');
          this.dialogMask.classList.add('hide-active');
          document.body.style.overflow = '';
        },
        __hideInstance: function __hideInstance(instance) {
          if (typeof instance.beforeHide === 'function') {
            instance.beforeHide();
            setTimeout(function () {
              if (instance.isAppendToBody) {
                instance.ins.remove();
              }
            });
          } else {
            if (instance.isAppendToBody) {
              instance.ins.remove();
            }
          }
        }
      };
      defineProperty$1(popManager, 'container', {
        get: function get() {
          var container = document.querySelector('[data-bkpop-container]');
          if (!container) {
            container = document.createElement('div');
            container.setAttribute('id', this.containerId);
            container.setAttribute('data-bkpop-container', 'true');
            document.body.append(container);
          }
          return container;
        }
      });
      defineProperty$1(popManager, 'dialogMask', {
        get: function get() {
          var mask = document.querySelector('[data-bkpop-mask]');
          if (!mask) {
            mask = document.createElement('div');
            mask.setAttribute('id', this.maskId);
            mask.setAttribute('class', 'bk-dialog-mask');
            mask.setAttribute('data-bkpop-mask', 'true');
            this.container.append(mask);
          }
          return mask;
        }
      });
      defineProperty$1(popManager, 'instances', {
        get: function get() {
          return __popInstances;
        },
        set: function set(val) {
          __popInstances = val;
        }
      });
      window['__bk_pop_manager'] = popManager;
      window['__bk_pop_manager'].__container = popManager.container;
    }
  })();
  var popManager = window['__bk_pop_manager'];

  var script$1 = {
    name: 'bk-popover',
    mixins: [zIndex$1],
    props: {
      placement: {
        type: String,
        default: 'top'
      },
      content: {
        type: String,
        default: ''
      },
      theme: {
        type: String,
        default: 'dark'
      },
      interactive: {
        type: [Boolean, String],
        default: true
      },
      arrow: {
        type: [Boolean, String],
        default: true
      },
      arrowType: {
        type: String,
        default: 'sharp'
      },
      boundary: {
        type: String,
        default: 'window'
      },
      showOnInit: {
        type: Boolean,
        default: false
      },
      arrowTransform: {
        type: String,
        default: ''
      },
      trigger: {
        type: String,
        default: 'mouseenter focus'
      },
      animation: {
        type: String,
        default: 'shift-away'
      },
      distance: {
        type: Number,
        default: 10
      },
      width: {
        type: [String, Number],
        default: 'auto'
      },
      maxWidth: {
        type: [String, Number],
        default: 'auto'
      },
      offset: {
        type: [Number, String],
        default: 0
      },
      always: {
        type: Boolean,
        default: false
      },
      followCursor: {
        type: [Boolean, String],
        default: false
      },
      sticky: {
        type: [Boolean, String],
        default: false
      },
      delay: {
        type: Number,
        default: 100
      },
      size: {
        type: String,
        default: 'small'
      },
      onShow: {
        type: Function,
        default: function _default() {}
      },
      onHide: {
        type: Function,
        default: function _default() {}
      },
      tippyOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      disabled: Boolean
    },
    data: function data() {
      return {
        instance: null
      };
    },
    watch: {
      disabled: function disabled(_disabled) {
        if (this.instance) {
          _disabled ? this.instance.disable() : this.instance.enable();
        }
      },
      tippyOptions: function tippyOptions(v) {
        this.instance && this.instance.set(v);
      }
    },
    mounted: function mounted() {
      var _this = this;
      var options = getValidTippyProps(_extends({}, {
        appendTo: popManager.container
      }, this.$props, this.tippyOptions));
      var onShow = options.onShow;
      var onHide = options.onHide;
      options.onShow = function (tip) {
        tip.set({
          zIndex: _this.getLocalZIndex(_this.zIndex)
        });
        onShow && onShow(tip);
        _this.$emit('show');
      };
      options.onHide = function (tip) {
        onHide && onHide(tip);
        _this.$emit('hide');
      };
      options.content = this.$refs.html;
      if (this.always) {
        options.showOnInit = true;
        options.hideOnClick = false;
        options.trigger = 'manual';
      }
      this.instance = tippy(this.$refs.reference, options);
      if (this.disabled) {
        this.instance.disable();
      }
    },
    updated: function updated() {
      this.instance.setContent(this.$refs.html);
      if (this.instance.popperInstance) {
        this.instance.popperInstance.update();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.instance.destroy();
    },
    methods: {
      showHandler: function showHandler() {
        this.instance.show();
      },
      hideHandler: function hideHandler() {
        this.instance.hide();
      }
    }
  };

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-tooltip"
    }, [_c('div', {
      ref: "html",
      staticClass: "bk-tooltip-content"
    }, [_vm._t("content", [_vm._v(_vm._s(_vm.content))])], 2), _c('div', {
      ref: "reference",
      staticClass: "bk-tooltip-ref",
      attrs: {
        "tabindex": "-1"
      }
    }, [_vm._t("default")], 2)]);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$1 = undefined;
  /* scoped */

  var __vue_scope_id__$1 = undefined;
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

  function setInstaller (component, afterInstall) {
    component.install = function (Vue) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = component.props || {};
      keys$1(options).forEach(function (key) {
        if (props.hasOwnProperty(key)) {
          if (typeof props[key] === 'function' || props[key] instanceof Array) {
            props[key] = {
              type: props[key],
              default: options[key]
            };
          } else {
            props[key].default = options[key];
          }
        }
      });
      component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
      Vue.component(component.name, component);
      typeof afterInstall === 'function' && afterInstall(Vue, options);
    };
  }

  setInstaller(__vue_component__$1, function (Vue, options) {
    Vue.prototype.$bkPopover = function (el, options) {
      return tippy(el, options);
    };
  });

  var defaultOptions = {
    duration: 0,
    arrow: true,
    size: 'small',
    trigger: 'mouseenter focus',
    theme: 'dark',
    interactive: true,
    content: '',
    allowHtml: false,
    extCls: ''
  };
  var validPlacements$1 = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var createTippy$1 = function createTippy(el, binding) {
    var value = binding.value;
    var options = _objectSpread({}, defaultOptions);
    if (_typeof(value) === 'object') {
      _extends(options, value);
    } else {
      options.content = value;
    }
    var placement = validPlacements$1.find(function (placement) {
      return binding.modifiers[placement];
    });
    options.placement = options.placement || placement || (options.placements || ['top'])[0];
    var _binding$modifiers = binding.modifiers,
        click = _binding$modifiers.click,
        light = _binding$modifiers.light;
    if (click) {
      options.trigger = 'click';
    }
    if (light) {
      options.theme = 'light';
    }
    if (options.allowHtml) {
      var selector = options.content;
      if (selector instanceof Vue) {
        options.content = selector.$el;
      } else if (typeof selector === 'string') {
        var element = document.querySelector(selector);
        if (element) {
          options.content = element;
        }
      }
    }
    if (options.html) {
      options.content = options.html;
    }
    if (typeof options.onClose === 'function') {
      options.onHide = options.onClose;
    }
    var validOptions = getValidTippyProps(options);
    return tippy(el, validOptions);
  };
  var bkTooltips = {
    inserted: function inserted(el, binding) {
      var disabled = _typeof(binding.value) === 'object' ? binding.value.disabled : false;
      if (!disabled) {
        el.tippyInstance = createTippy$1(el, binding);
      }
    },
    unbind: function unbind(el) {
      el._tippy && el._tippy.destroy();
      el.tippyInstance = null;
    },
    update: function update(el, binding) {
      var value = binding.value;
      var isObject = _typeof(value) === 'object';
      var content = isObject ? value.content : value;
      var disabled = isObject ? value.disabled : false;
      if (disabled || !content) {
        el._tippy && el._tippy.destroy();
        el.tippyInstance = null;
      } else if (content) {
        if (!el._tippy) {
          el.tippyInstance = createTippy$1(el, binding);
        } else {
          if (_typeof(value) === 'object' && binding.value.allowHtml) {
            el.tippyInstance = createTippy$1(el, binding);
          } else {
            el._tippy.setContent(content);
          }
        }
      }
    }
  };
  bkTooltips.install = function (Vue) {
    Vue.directive('bkTooltips', bkTooltips);
  };

  var script$2 = {
    name: 'bk-tag-input',
    components: {
      listRender: listRender,
      tagRender: tagRender,
      bkPopover: __vue_component__$1
    },
    directives: {
      bkloading: bkLoading,
      bkTooltips: bkTooltips
    },
    mixins: [locale.mixin, emitter],
    props: {
      showClearOnlyHover: {
        type: Boolean,
        default: false
      },
      placeholder: {
        type: String,
        default: ''
      },
      value: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      leftSpace: {
        type: Number,
        default: 0
      },
      disabled: {
        type: Boolean,
        default: false
      },
      hasDeleteIcon: {
        type: Boolean,
        default: false
      },
      separator: {
        type: String,
        default: ''
      },
      maxData: {
        type: Number,
        default: -1
      },
      maxResult: {
        type: Number,
        default: 10
      },
      isBlurTrigger: {
        type: Boolean,
        default: true
      },
      saveKey: {
        type: String,
        default: 'id'
      },
      displayKey: {
        type: String,
        default: 'name'
      },
      tooltipKey: {
        type: String,
        default: ''
      },
      searchKey: {
        type: [String, Array],
        default: 'name'
      },
      useGroup: {
        type: Boolean,
        default: false
      },
      list: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      contentWidth: {
        type: Number,
        default: 190
      },
      contentMaxHeight: {
        type: Number,
        default: 300
      },
      allowCreate: {
        type: Boolean,
        default: false
      },
      clearable: {
        type: Boolean,
        default: true
      },
      tpl: Function,
      tagTpl: Function,
      pasteFn: Function,
      filterCallback: {
        type: Function,
        default: null
      },
      popoverOptions: {
        type: Object,
        default: function _default() {
          return {
            distance: 0
          };
        }
      },
      trigger: {
        type: String,
        default: 'search',
        validator: function validator(value) {
          if (['focus', 'search'].indexOf(value) < 0) {
            console.error("size property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      allowNextFocus: {
        type: Boolean,
        default: true
      },
      allowAutoMatch: {
        type: Boolean,
        default: false
      },
      createTagValidator: {
        type: Function,
        default: null
      }
    },
    data: function data() {
      return {
        curInputValue: '',
        cacheVal: '',
        timer: 0,
        focusItemIndex: this.allowCreate ? -1 : 0,
        isEdit: false,
        showList: false,
        isCanRemoveTag: false,
        tagList: [],
        localTagList: [],
        tagListCache: [],
        localTagListCache: [],
        renderList: [],
        renderListShadow: [],
        renderListPaged: [],
        renderListAll: [],
        initData: [],
        curPage: 1,
        totalSize: 0,
        totalPage: 0,
        pageSize: 0,
        showScrollLoading: false,
        isBeforeDestroy: false,
        bkTagSelector: null,
        popoverInstance: null,
        isSingleSelect: false,
        INPUT_MIN_WIDTH: 12,
        popoverWidth: 190,
        hover: false
      };
    },
    computed: {
      isShowClear: function isShowClear() {
        return this.clearable && !this.disabled && this.localTagList.length !== 0 && (this.showClearOnlyHover ? this.hover : true);
      },
      resultList: function resultList() {
        if (this.useGroup) {
          var result = {};
          this.renderList.forEach(function (item, index) {
            item.index = index;
            if (!result[item.group.groupId]) {
              result[item.group.groupId] = {
                id: item.group.groupId,
                name: item.group.groupName,
                children: []
              };
            }
            result[item.group.groupId].children.push(item);
          });
          return result;
        } else {
          return this.renderList;
        }
      },
      defaultPlaceholder: function defaultPlaceholder() {
        return this.placeholder || this.t('bk.tagInput.placeholder');
      }
    },
    watch: {
      curInputValue: function curInputValue(newVal, oldVal) {
        var _this = this;
        if (newVal !== '' && this.renderList.length) {
          this.showList = true;
        } else if (this.trigger !== 'focus') {
          setTimeout(function () {
            _this.showList = false;
          }, 100);
        }
      },
      showList: function showList(val) {
        var _this2 = this;
        if (val) {
          this.$nextTick(function () {
            _this2.showPopover();
          });
        }
      },
      list: function list(val) {
        if (val) {
          this.getData();
        }
      },
      value: function value() {
        this.getData();
      },
      maxData: function maxData(val) {
        this.isSingleSelect = val === 1;
      }
    },
    created: function created() {
      this.isSingleSelect = this.maxData === 1;
      this.pageSize = this.maxResult;
      this.getData();
    },
    mounted: function mounted() {
      this.bkTagSelector = this.$refs.bkTagSelector;
      this.popoverInstance = this.$refs['tagInputDropdown'];
    },
    beforeDestroy: function beforeDestroy() {
      this.isBeforeDestroy = true;
      var selectorList = this.$refs.selectorList;
      selectorList && selectorList.removeEventListener('scroll', this.scrollHandler);
      clearTimeout(this.timer);
    },
    methods: {
      mouseEnterHandler: function mouseEnterHandler() {
        this.hover = true;
      },
      handlerClear: function handlerClear() {
        this.tagList = [];
        this.localTagList = [];
        this.handlerChange('removeAll');
      },
      showPopover: function showPopover() {
        var inputLeft = this.isSingleSelect ? 0 : this.$refs.staffInput.offsetLeft;
        this.popoverInstance.instance.set({
          offset: "".concat(inputLeft, ", 0")
        });
        if (this.popoverInstance.instance.popperInstance) {
          this.popoverInstance.instance.popperInstance.update();
        }
        var selectorList = this.$refs.selectorList;
        if (selectorList) {
          selectorList.scrollTop = 0;
          selectorList.removeEventListener('scroll', this.scrollHandler);
          selectorList.addEventListener('scroll', this.scrollHandler);
        }
        this.popoverInstance.instance.show();
      },
      getCharLength: function getCharLength(str) {
        var len = str.length;
        var bitLen = 0;
        for (var i = 0; i < len; i++) {
          if ((str.charCodeAt(i) & 0xff00) !== 0) {
            bitLen++;
          }
          bitLen++;
        }
        return bitLen;
      },
      filterData: function filterData() {
        var _this3 = this;
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        val = val.toLowerCase();
        var filterData;
        if (typeof this.filterCallback === 'function') {
          filterData = this.filterCallback(val, this.searchKey, this.initData) || [];
        } else {
          if (isArray$1(this.searchKey)) {
            var filterDataList = this.searchKey.map(function (searchKey) {
              return _this3.initData.filter(function (item) {
                return item[searchKey].toLowerCase().indexOf(val) !== -1;
              });
            });
            filterData = from_1$1(new set$1(filterDataList.flat()));
          } else {
            filterData = this.initData.filter(function (item) {
              return item[_this3.searchKey].toLowerCase().indexOf(val) !== -1;
            });
          }
        }
        this.renderListAll = filterData.slice(0);
        this.renderListShadow = filterData.slice(0);
        this.initPageConf(this.renderListAll.length);
      },
      initPageConf: function initPageConf(count) {
        var _this$renderList;
        this.curPage = 1;
        this.totalSize = count;
        this.totalPage = Math.ceil(this.totalSize / this.pageSize) || 1;
        var list = [];
        for (var i = 0; i < this.totalSize; i += this.pageSize) {
          list.push(this.renderListShadow.slice(i, i + this.pageSize));
        }
        this.renderListPaged = list;
        (_this$renderList = this.renderList).splice.apply(_this$renderList, [0, this.renderList.length].concat(_toConsumableArray(this.renderListPaged[this.curPage - 1] || [])));
      },
      pageChange: function pageChange(page) {
        var _this$renderList2;
        this.curPage = page;
        (_this$renderList2 = this.renderList).splice.apply(_this$renderList2, [this.renderList.length, 0].concat(_toConsumableArray(this.renderListPaged[this.curPage - 1])));
        this.showScrollLoading = false;
      },
      scrollHandler: function scrollHandler(e) {
        var _this4 = this;
        if (this.showScrollLoading || this.isBeforeDestroy) {
          return;
        }
        var scrollContainer = this.$refs.selectorList;
        if (scrollContainer.scrollTop === 0) {
          return;
        }
        if (scrollContainer.scrollTop + scrollContainer.offsetHeight >= scrollContainer.scrollHeight) {
          var curPage = ++this.curPage;
          if (curPage <= this.totalPage) {
            this.showScrollLoading = true;
            setTimeout( _asyncToGenerator( regenerator.mark(function _callee() {
              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return _this4.pageChange(curPage);
                    case 2:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })), 500);
          }
        }
      },
      transitionAfterLeave: function transitionAfterLeave() {
        var _this$renderList3;
        (_this$renderList3 = this.renderList).splice.apply(_this$renderList3, [0, this.renderList.length].concat([]));
      },
      activeClass: function activeClass(data, i) {
        var style = {
          'bk-selector-actived': false,
          'bk-selector-selected': this.localTagList.includes(data[this.saveKey])
        };
        if (this.useGroup) {
          style['bk-selector-actived'] = data.index === this.focusItemIndex;
        } else {
          style['bk-selector-actived'] = i === this.focusItemIndex;
        }
        return style;
      },
      getSiteInfo: function getSiteInfo() {
        var res = {
          index: 0,
          temp: []
        };
        var nodes = this.$refs.tagList.childNodes;
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (!(node.nodeType === 3 && !/\S/.test(node.nodeValue))) {
            res.temp.push(node);
          }
        }
        if (this.isSingleSelect) {
          res.index = 0;
        } else {
          keys$1(res.temp).forEach(function (key) {
            if (res.temp[key].id === 'staffInput') {
              res.index = key;
            }
          });
        }
        return res;
      },
      getInputIndex: function getInputIndex() {
        var nodes = this.$refs.tagList.childNodes;
        var index = -1;
        for (var i = 0; i < nodes.length; i++) {
          var currentNode = nodes[i];
          if (currentNode.getAttribute && currentNode.getAttribute('role') === 'input') {
            index = i;
          }
        }
        return index;
      },
      formatGroupList: function formatGroupList() {
        var _this5 = this;
        var allList = [];
        this.list.forEach(function (item) {
          if (item.children) {
            item.children.forEach(function (child) {
              var params = _objectSpread({}, child);
              params.group = {
                groupId: item[_this5.saveKey],
                groupName: item[_this5.displayKey]
              };
              allList.push(params);
            });
          }
        });
        return allList;
      },
      getData: function getData() {
        var _this6 = this;
        this.tagList = [];
        this.localTagList = [];
        this.initData = [];
        if (this.useGroup) {
          this.allList = this.formatGroupList();
          this.allList.forEach(function (item) {
            _this6.initData.push(item);
          });
        } else {
          this.list.forEach(function (item) {
            _this6.initData.push(item);
          });
        }
        if (this.value.length) {
          this.value.forEach(function (tag) {
            var val = _this6.initData.find(function (val) {
              return tag === val[_this6.saveKey];
            });
            if (val !== undefined) {
              _this6.localTagList.push(val);
              _this6.tagList.push(val[_this6.saveKey]);
            } else if (_this6.allowCreate && !_this6.tagList.includes(tag)) {
              var _temp;
              var temp = (_temp = {}, _defineProperty(_temp, _this6.saveKey, tag), _defineProperty(_temp, _this6.displayKey, tag), _temp);
              _this6.localTagList.splice(_this6.localTagList.length, 0, temp);
              _this6.tagList.splice(_this6.tagList.length, 0, tag);
            }
          });
          if (!this.isSingleSelect) {
            this.initData = this.initData.filter(function (val) {
              return !_this6.value.includes(val[_this6.saveKey]);
            });
          }
        }
        if (this.trigger === 'focus') {
          this.filterData();
        }
      },
      selectTag: function selectTag(event, tag) {
        if (this.disabled) {
          return;
        }
        this.insertAfter(this.$refs.staffInput, event.currentTarget);
        this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
      },
      handleInput: function handleInput(event) {
        if (this.maxData === -1 || this.maxData > this.tagList.length) {
          var value = event.target.value;
          var charLen = this.getCharLength(value);
          this.cacheVal = value;
          if (charLen) {
            this.isCanRemoveTag = false;
            this.filterData(value);
            this.$refs.input.style.width = charLen * this.INPUT_MIN_WIDTH + 'px';
          } else {
            this.isCanRemoveTag = true;
            if (this.trigger === 'focus') {
              this.filterData();
            }
          }
        } else {
          this.handleBlur();
          this.curInputValue = '';
          this.showList = false;
        }
        this.isEdit = true;
        this.focusItemIndex = this.allowCreate ? -1 : 0;
      },
      handleFocus: function handleFocus(event) {
        this.isCanRemoveTag = true;
        this.dispatch('bk-form-item', 'form-focus');
        this.popoverWidth = this.isSingleSelect ? this.bkTagSelector.clientWidth : this.contentWidth;
        event.currentTarget.select();
      },
      handlePaste: function handlePaste(event) {
        var _this7 = this;
        if (this.isSingleSelect) {
          return false;
        }
        event.preventDefault();
        var value = event.clipboardData.getData('text');
        var valArr = this.pasteFn ? this.pasteFn(value) : this.defaultPasteFn(value);
        var tags = [];
        valArr.map(function (val) {
          return tags.push(val[_this7.saveKey]);
        });
        if (tags.length) {
          var nodes = this.$refs.tagList.childNodes;
          var result = this.getSiteInfo();
          var localTags = [];
          var localInitDara = [];
          this.initData.map(function (data) {
            localInitDara.push(data[_this7.saveKey]);
          });
          tags = tags.filter(function (tag) {
            return tag && tag.trim() && !_this7.tagList.includes(tag) && localInitDara.includes(tag);
          });
          if (this.maxData !== -1) {
            if (this.tagList.length < this.maxData) {
              var differ = this.maxData - this.tagList.length;
              if (tags.length > differ) {
                tags = _toConsumableArray(tags.slice(0, differ));
              }
            } else {
              tags = [];
            }
          }
          tags.map(function (tag) {
            var temp = {};
            temp[_this7.saveKey] = tag;
            temp[_this7.displayKey] = tag;
            localTags.push(temp);
          });
          if (tags.length) {
            var _this$tagList, _this$localTagList;
            (_this$tagList = this.tagList).splice.apply(_this$tagList, [result.index, 0].concat(_toConsumableArray(tags)));
            (_this$localTagList = this.localTagList).splice.apply(_this$localTagList, [result.index, 0].concat(localTags));
            var site = nodes[_parseInt$2(result.index)];
            this.insertAfter(this.$refs.staffInput, site);
            this.focusInputer();
            this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
            this.initData = this.initData.filter(function (val) {
              return !tags.includes(val[_this7.saveKey]);
            });
            this.handlerChange('select');
          }
        }
      },
      defaultPasteFn: function defaultPasteFn(val) {
        var _this8 = this;
        var target = [];
        var textArr = val.split(';');
        textArr.map(function (item) {
          if (item.match(/^[a-zA-Z][a-zA-Z_]+/g)) {
            var finalItem = item.match(/^[a-zA-Z][a-zA-Z_]+/g).join('');
            var temp = {};
            temp[_this8.saveKey] = finalItem;
            temp[_this8.displayKey] = finalItem;
            target.push(temp);
          }
        });
        return target;
      },
      updateScrollTop: function updateScrollTop() {
        var _this9 = this;
        var panelObj = this.$refs.selectorList;
        var panelInfo = {
          height: panelObj.clientHeight,
          yAxis: panelObj.getBoundingClientRect().y
        };
        this.$nextTick(function () {
          var activeObj = _this9.$refs.selectorList.querySelector('.bk-selector-actived');
          if (!activeObj) {
            return;
          }
          var activeInfo = {
            height: activeObj.clientHeight,
            yAxis: activeObj.getBoundingClientRect().y
          };
          if (activeInfo.yAxis < panelInfo.yAxis) {
            var currentScTop = panelObj.scrollTop;
            panelObj.scrollTop = currentScTop - (panelInfo.yAxis - activeInfo.yAxis);
          }
          var distanceToBottom = activeInfo.yAxis + activeInfo.height - panelInfo.yAxis;
          if (distanceToBottom > panelInfo.height) {
            var _currentScTop = panelObj.scrollTop;
            panelObj.scrollTop = _currentScTop + distanceToBottom - panelInfo.height;
          }
        });
      },
      handleKeydown: function handleKeydown(event) {
        if (this.showScrollLoading) {
          return;
        }
        var target;
        var val = event.target.value;
        var valLen = this.getCharLength(val);
        var result = this.getSiteInfo();
        var inputIndex = this.getInputIndex();
        var nodes = this.$refs.tagList.childNodes;
        switch (event.code) {
          case 'ArrowUp':
            event.preventDefault();
            if (!this.showList) {
              return;
            }
            this.focusItemIndex--;
            this.focusItemIndex = this.focusItemIndex < 0 ? -1 : this.focusItemIndex;
            if (this.focusItemIndex === -1) {
              this.focusItemIndex = this.renderList.length - 1;
            }
            this.updateScrollTop();
            break;
          case 'ArrowDown':
            event.preventDefault();
            if (!this.showList) {
              return;
            }
            this.focusItemIndex++;
            this.focusItemIndex = this.focusItemIndex > this.renderList.length - 1 ? this.renderList.length : this.focusItemIndex;
            if (this.focusItemIndex === this.renderList.length) {
              this.focusItemIndex = 0;
            }
            this.updateScrollTop();
            break;
          case 'ArrowLeft':
            this.isEdit = true;
            if (!valLen) {
              if (inputIndex < 1) {
                return;
              }
              this.$refs.tagList.insertBefore(this.$refs.staffInput, nodes[inputIndex - 1]);
              this.$refs.input.value = '';
              this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
              this.focusInputer();
            }
            break;
          case 'ArrowRight':
            this.isEdit = true;
            if (!valLen) {
              if (inputIndex === nodes.length - 1) {
                return;
              }
              this.insertAfter(this.$refs.staffInput, nodes[inputIndex + 1]);
              this.focusInputer();
            }
            break;
          case 'Enter':
          case 'NumpadEnter':
            if (!this.allowCreate && this.showList || this.allowCreate && this.focusItemIndex >= 0 && this.showList) {
              this.handlerResultSelect(this.renderList[this.focusItemIndex], 'select');
              this.showList = false;
            } else if (this.allowCreate) {
              event.preventDefault();
              var tag = this.curInputValue;
              this.handlerResultSelect(tag, 'custom');
            }
            this.cacheVal = '';
            event.preventDefault();
            break;
          case 'Backspace':
            if (_parseInt$2(result.index, 10) !== 0 && !this.curInputValue.length) {
              target = this.localTagList[result.index - 1];
              this.backspaceHandler(result.index, target);
            }
            break;
          default:
            break;
        }
      },
      handlerResultSelect: function handlerResultSelect(item, type) {
        if (!item || item.disabled) {
          return;
        }
        if (this.isSingleSelect) {
          this.clearSingleCache();
        }
        this.addTag(item, type);
        this.handlerChange('select');
        this.clearInput();
        this.showList = false;
      },
      backspaceHandler: function backspaceHandler(index, target) {
        var _this10 = this;
        if (!this.curInputValue) {
          if (this.isCanRemoveTag) {
            this.tagList.splice(index - 1, 1);
            this.localTagList.splice(index - 1, 1);
            var nodes = this.$refs.tagList.childNodes;
            var result = this.getSiteInfo();
            var key = _parseInt$2(result.index, 10) === 1 ? 1 : _parseInt$2(result.index, 10) - 2;
            var site = nodes[key];
            this.insertAfter(this.$refs.staffInput, site);
            this.focusInputer();
            var localList = this.useGroup ? this.allList : this.list;
            var isExistInit = localList.some(function (item) {
              return item === target[_this10.saveKey];
            });
            if ((this.allowCreate && isExistInit || !this.allowCreate) && !this.isSingleSelect) {
              this.initData.push(target);
            }
            this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
            this.handlerChange('remove');
          }
          this.isCanRemoveTag = true;
        }
      },
      handlerTagRemove: function handlerTagRemove(data, index) {
        this.removeTag(data, index);
        this.$refs.input.style.width = this.INPUT_MIN_WIDTH + 'px';
        this.resetInput();
        this.handlerChange('remove');
      },
      removeTag: function removeTag(data, index) {
        var _this11 = this;
        this.tagList.splice(index, 1);
        this.localTagList.splice(index, 1);
        var localList = this.useGroup ? this.allList : this.list;
        var isExistInit = localList.some(function (item) {
          return item === data[_this11.saveKey];
        });
        if ((this.allowCreate && isExistInit || !this.allowCreate) && !this.isSingleSelect) {
          this.initData.push(data);
        }
      },
      addTag: function addTag(item, type) {
        var _this12 = this;
        var nodes = this.$refs.tagList.childNodes;
        var result = this.getSiteInfo();
        var isSelected = false;
        var tags = [];
        var newVal;
        if (type === 'custom') {
          if (this.separator) {
            var localTags = [];
            tags = item.split(this.separator);
            tags = tags.filter(function (tag) {
              var validate = typeof _this12.createTagValidator === 'function' ? _this12.createTagValidator(tag) : true;
              return tag && tag.trim() && !_this12.tagList.includes(tag) && validate;
            });
            tags.forEach(function (tag) {
              var temp = {};
              temp[_this12.saveKey] = tag;
              temp[_this12.displayKey] = tag;
              localTags.push(temp);
            });
            if (tags.length) {
              var _this$tagList2, _this$localTagList2;
              (_this$tagList2 = this.tagList).splice.apply(_this$tagList2, [result.index, 0].concat(_toConsumableArray(tags)));
              (_this$localTagList2 = this.localTagList).splice.apply(_this$localTagList2, [result.index, 0].concat(localTags));
              isSelected = true;
            }
          } else {
            if (_typeof(item) === 'object') {
              newVal = item[this.saveKey];
              var validate = typeof this.createTagValidator === 'function' ? this.createTagValidator(newVal) : true;
              if (newVal && !this.tagList.includes(newVal) && validate) {
                newVal = newVal.replace(/\s+/g, '');
                if (newVal !== undefined) {
                  this.tagList.splice(result.index, 0, newVal);
                  this.localTagList.splice(result.index, 0, item);
                  isSelected = true;
                }
              }
            } else {
              var localItem = {};
              newVal = item.trim();
              localItem[this.saveKey] = newVal;
              localItem[this.displayKey] = newVal;
              var _validate = typeof this.createTagValidator === 'function' ? this.createTagValidator(newVal) : true;
              if (newVal !== undefined && !this.tagList.includes(newVal) && _validate) {
                this.tagList.splice(result.index, 0, newVal);
                this.localTagList.splice(result.index, 0, localItem);
                isSelected = true;
              }
            }
          }
        } else if (item) {
          newVal = item[this.saveKey];
          if (newVal !== undefined && !this.tagList.includes(newVal)) {
            this.tagList.splice(result.index, 0, newVal);
            this.localTagList.splice(result.index, 0, item);
            isSelected = true;
          }
        }
        if (isSelected) {
          this.$nextTick(function () {
            var site = nodes[_parseInt$2(result.index, 10) + 1];
            _this12.insertAfter(_this12.$refs.staffInput, site);
            _this12.$refs.input.style.width = _this12.INPUT_MIN_WIDTH + 'px';
            if (!_this12.isSingleSelect && _this12.allowNextFocus) {
              _this12.focusInputer();
            }
            if (!_this12.isSingleSelect) {
              _this12.initData = _this12.initData.filter(function (val) {
                return !_this12.tagList.includes(val[_this12.saveKey]);
              });
            }
          });
        }
      },
      handlerChange: function handlerChange(type) {
        this.$emit('input', this.tagList);
        this.$emit('change', this.tagList);
        this.dispatch('bk-form-item', 'form-change');
        this.$emit(type);
        this.$emit('update:tags', this.tagList);
      },
      clearInput: function clearInput() {
        this.curInputValue = '';
        this.cacheVal = '';
      },
      handleBlur: function handleBlur(inputValue) {
        var _this13 = this;
        this.timer = setTimeout(function () {
          var inputValue = _this13.curInputValue;
          _this13.clearInput();
          _this13.dispatch('bk-form-item', 'form-blur');
          _this13.isEdit = false;
          if (_this13.isSingleSelect) {
            var _this13$tagListCache = _slicedToArray(_this13.tagListCache, 1),
                oldVal = _this13$tagListCache[0];
            if (inputValue && inputValue === oldVal && _this13.localTagListCache.length) {
              _this13.addTag(_this13.localTagListCache[0], 'select');
            } else {
              _this13.handlerChange('remove');
            }
          } else if (_this13.allowAutoMatch && inputValue) {
            var matchItem = _this13.renderList.find(function (item) {
              return item[_this13.searchKey] === inputValue;
            });
            if (matchItem) {
              _this13.handlerResultSelect(matchItem, 'select');
            } else if (_this13.allowCreate) {
              _this13.handlerResultSelect(inputValue, 'custom');
            }
          }
          _this13.$emit('blur', inputValue, _this13.tagList);
        }, 200);
      },
      focusInputer: function focusInputer(event) {
        var _this14 = this;
        if (this.disabled) {
          return;
        }
        if (event && event.target) {
          var className = event.target.className;
          if (className.indexOf('bk-tag-input') > -1 || className.indexOf('tag-list') > -1) {
            this.curInputValue = this.cacheVal;
            this.$refs.tagList.appendChild(this.$refs.staffInput);
          }
        }
        clearTimeout(this.timer);
        if (this.isSingleSelect && this.tagList.length) {
          this.tagListCache = _toConsumableArray(this.tagList);
          this.localTagListCache = _toConsumableArray(this.localTagList);
          this.curInputValue = this.localTagListCache[0][this.saveKey];
          this.removeTag(this.localTagList[0], 0);
          this.handleInput({
            target: {
              value: this.curInputValue
            }
          });
        }
        this.isEdit = true;
        this.$nextTick(function () {
          _this14.$refs.input.focus();
          if (_this14.trigger === 'focus') {
            _this14.showList = true;
            _this14.filterData();
            _this14.showPopover();
          }
        });
      },
      clearSingleCache: function clearSingleCache() {
        this.tagListCache = [];
        this.localTagListCache = [];
        this.tagList = [];
        this.localTagList = [];
      },
      insertAfter: function insertAfter(newElement, targetElement) {
        if (newElement.nextSibling === newElement) {
          return false;
        }
        targetElement.parentNode.insertBefore(newElement, targetElement ? targetElement.nextSibling : null);
      },
      resetInput: function resetInput() {
        var nodes = this.$refs.tagList.childNodes;
        var result = this.getSiteInfo();
        if (result.index !== result.temp.length) {
          this.clearInput();
          var site = nodes[nodes.length - 1];
          this.insertAfter(this.$refs.staffInput, site);
        }
      }
    }
  };

  var __vue_script__$2 = script$2;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      ref: "bkTagSelector",
      staticClass: "bk-tag-selector",
      class: _vm.extCls,
      on: {
        "click": function click($event) {
          _vm.focusInputer($event);
        },
        "mouseenter": _vm.mouseEnterHandler,
        "mouseleave": function mouseleave($event) {
          _vm.hover = false;
        }
      }
    }, [_c('div', {
      class: ['bk-tag-input', {
        'active': _vm.isEdit,
        'disabled': _vm.disabled
      }]
    }, [_c('ul', {
      ref: "tagList",
      staticClass: "tag-list",
      class: !_vm.localTagList.length ? 'no-item' : '',
      style: {
        'margin-left': _vm.leftSpace + "px"
      }
    }, [_vm._l(_vm.localTagList, function (tag, index) {
      return _c('li', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips.light",
          value: {
            boundary: 'window',
            content: tag[_vm.tooltipKey],
            disabled: !_vm.tooltipKey
          },
          expression: "{ boundary: 'window', content: tag[tooltipKey], disabled: !tooltipKey }",
          modifiers: {
            "light": true
          }
        }],
        key: tag[_vm.saveKey] !== undefined ? tag[_vm.saveKey] : index,
        staticClass: "key-node",
        on: {
          "click": function click($event) {
            _vm.selectTag($event, tag);
          }
        }
      }, [_c('tag-render', {
        attrs: {
          "node": tag,
          "display-key": _vm.displayKey,
          "tpl": _vm.tagTpl
        }
      }), !_vm.disabled && _vm.hasDeleteIcon ? _c('i', {
        staticClass: "bk-icon icon-close remove-key",
        on: {
          "click": function click($event) {
            $event.stopPropagation();

            _vm.handlerTagRemove(tag, index);
          }
        }
      }) : _vm._e()], 1);
    }), _c('li', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.isEdit,
        expression: "isEdit"
      }],
      ref: "staffInput",
      staticClass: "staff-input",
      attrs: {
        "id": "staffInput",
        "role": "input"
      }
    }, [!_vm.disabled ? _c('input', {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: _vm.curInputValue,
        expression: "curInputValue"
      }],
      ref: "input",
      staticClass: "input",
      attrs: {
        "type": "text"
      },
      domProps: {
        "value": _vm.curInputValue
      },
      on: {
        "input": [function ($event) {
          if ($event.target.composing) {
            return;
          }

          _vm.curInputValue = $event.target.value;
        }, _vm.handleInput],
        "focus": _vm.handleFocus,
        "paste": _vm.handlePaste,
        "blur": function blur($event) {
          _vm.handleBlur(_vm.curInputValue);
        },
        "keydown": _vm.handleKeydown
      }
    }) : _vm._e()])], 2), _c('p', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: !_vm.isEdit && !_vm.localTagList.length && !_vm.curInputValue.length,
        expression: "!isEdit && !localTagList.length && !curInputValue.length"
      }],
      staticClass: "placeholder"
    }, [_vm._v(_vm._s(_vm.defaultPlaceholder))]), _vm.isShowClear ? _c('i', {
      staticClass: "bk-icon icon-close-circle-shape clear-icon",
      on: {
        "click": function click($event) {
          $event.stopPropagation();
          return _vm.handlerClear($event);
        }
      }
    }) : _vm._e()]), _c('bk-popover', {
      ref: "tagInputDropdown",
      staticClass: "bk-select-dropdown",
      attrs: {
        "placement": "bottom-start",
        "trigger": "manual",
        "theme": "light bk-select-dropdown"
      }
    }, [_c('div', {
      staticClass: "bk-tag-popover-trigger"
    }), _c('div', {
      attrs: {
        "slot": "content"
      },
      slot: "content"
    }, [_vm.showList ? _c('div', {
      staticClass: "bk-selector-list",
      style: {
        'width': _vm.popoverWidth + "px"
      }
    }, [_vm.useGroup ? [_c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: keys$1(_vm.resultList).length,
        expression: "Object.keys(resultList).length"
      }],
      ref: "selectorList",
      staticClass: "outside-ul",
      style: {
        'max-height': _vm.contentMaxHeight + "px"
      }
    }, [_vm._l(_vm.resultList, function (group, key) {
      return _c('li', {
        key: key,
        staticClass: "bk-selector-group-item"
      }, [_c('span', {
        staticClass: "group-name"
      }, [_vm._v(_vm._s(group.name) + " (" + _vm._s(group.children.length) + ")")]), _c('ul', {
        staticClass: "bk-selector-group-list-item"
      }, _vm._l(group.children, function (data, index) {
        return _c('li', {
          key: index,
          class: ['bk-selector-list-item', {
            disabled: data.disabled
          }, _vm.activeClass(data, index)],
          on: {
            "mousedown": function mousedown($event) {
              _vm.handlerResultSelect(data, 'select');
            }
          }
        }, [_c('list-render', {
          attrs: {
            "node": data,
            "display-key": _vm.displayKey,
            "tpl": _vm.tpl,
            "search-key": _vm.searchKey,
            "search-keyword": _vm.curInputValue
          }
        })], 1);
      }), 0)]);
    }), _vm.showScrollLoading ? _c('li', {
      staticClass: "bk-selector-list-item"
    }, [_c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: true,
          size: 'mini',
          theme: 'black'
        },
        expression: "{ isLoading: true, size: 'mini', theme: 'black' }"
      }],
      staticClass: "loading"
    })]) : _vm._e()], 2)] : [_c('ul', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.resultList.length,
        expression: "resultList.length"
      }],
      ref: "selectorList",
      staticClass: "outside-ul",
      style: {
        'max-height': _vm.contentMaxHeight + "px"
      }
    }, [_vm._l(_vm.resultList, function (data, index) {
      return _c('li', {
        key: index,
        class: ['bk-selector-list-item', {
          disabled: data.disabled
        }, _vm.activeClass(data, index)],
        on: {
          "click": function click($event) {
            _vm.handlerResultSelect(data, 'select');
          }
        }
      }, [_c('list-render', {
        attrs: {
          "node": data,
          "display-key": _vm.displayKey,
          "tpl": _vm.tpl,
          "search-key": _vm.searchKey,
          "search-keyword": _vm.curInputValue
        }
      })], 1);
    }), _vm.showScrollLoading ? _c('li', {
      staticClass: "bk-selector-list-item"
    }, [_c('div', {
      directives: [{
        name: "bkloading",
        rawName: "v-bkloading",
        value: {
          isLoading: true,
          size: 'mini',
          theme: 'black'
        },
        expression: "{ isLoading: true, size: 'mini', theme: 'black' }"
      }],
      staticClass: "loading"
    })]) : _vm._e()], 2)]], 2) : _vm._e()])])], 1);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

  setInstaller(__vue_component__$2);

  exports.default = __vue_component__$2;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
