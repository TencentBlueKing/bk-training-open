(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('bk-magic-vue/lib/locale')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', 'bk-magic-vue/lib/locale'], factory) :
  (global = global || self, factory(global.library = {}, global.Vue, global.locale));
}(this, function (exports, Vue, locale) { 'use strict';

  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
  locale = locale && locale.hasOwnProperty('default') ? locale['default'] : locale;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function findChildComponents(context, componentName) {
    return context.$children.reduce(function (components, child) {
      if (child.$options.name === componentName) {
        components.push(child);
      }
      var foundChilds = findChildComponents(child, componentName);
      return components.concat(foundChilds);
    }, []);
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  var camelCase = function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  };
  var getStyle = Number(document.documentMode) < 9 ? function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);
    if (styleName === 'float') {
      styleName = 'styleFloat';
    }
    try {
      switch (styleName) {
        case 'opacity':
          try {
            return element.filters.item('alpha').opacity / 100;
          } catch (e) {
            return 1.0;
          }
        default:
          return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
      }
    } catch (e) {
      return element.style[styleName];
    }
  } : function (element, styleName) {
    if (!element || !styleName) return null;
    styleName = camelCase(styleName);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    try {
      var computed = document.defaultView.getComputedStyle(element, '');
      return element.style[styleName] || computed ? computed[styleName] : null;
    } catch (e) {
      return element.style[styleName];
    }
  };
  function scrollTop(el) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var to = arguments.length > 2 ? arguments[2] : undefined;
    var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 500;
    var endCallback = arguments.length > 4 ? arguments[4] : undefined;
    var difference = Math.abs(from - to);
    var step = Math.ceil(difference / duration * 50);
    function scroll(start, end, step) {
      if (start === end) {
        endCallback && endCallback();
        return;
      }
      var d = start + step > end ? end : start + step;
      if (start > end) {
        d = start - step < end ? end : start - step;
      }
      if (el === window) {
        window.scrollTo(d, d);
      } else {
        el.scrollTop = d;
      }
      window.requestAnimationFrame(function () {
        return scroll(d, end, step);
      });
    }
    scroll(from, to, step);
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.12' };
  if (typeof __e == 'number') __e = core;
  });
  var _core_1 = _core.version;

  var $JSON = _core.JSON || (_core.JSON = { stringify: JSON.stringify });
  var stringify = function stringify(it) {
    return $JSON.stringify.apply($JSON, arguments);
  };

  var stringify$1 = stringify;

  var _global = createCommonjsModule(function (module) {
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    : Function('return this')();
  if (typeof __g == 'number') __g = global;
  });

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) {  }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      : IS_BIND && own ? _ctx(out, _global)
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  var _export = $export;

  var toString = {}.toString;
  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  _export(_export.S, 'Array', { isArray: _isArray });

  var isArray = _core.Array.isArray;

  var isArray$1 = isArray;

  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');
  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };
  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
  var _stringTrim = exporter;

  var $parseInt = _global.parseInt;
  var $trim = _stringTrim.trim;
  var hex = /^[-+]?0[xX]/;
  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim(String(str), 3);
    return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
  } : $parseInt;

  _export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

  var _parseInt$1 = _core.parseInt;

  var _parseInt$2 = _parseInt$1;

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = /\d\d?/;
  var threeDigits = /\d{3}/;
  var fourDigits = /\d{4}/;
  var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
  var noop = function noop() {};
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
      if (~index) {
        d.month = index;
      }
    };
  }
  function pad(val, len) {
    val = String(val);
    len = len || 2;
    while (val.length < len) {
      val = '0' + val;
    }
    return val;
  }
  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  var formatFlags = {
    D: function D(dateObj) {
      return dateObj.getDay();
    },
    DD: function DD(dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function Do(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function d(dateObj) {
      return dateObj.getDate();
    },
    dd: function dd(dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function ddd(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function dddd(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function M(dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function MM(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function MMM(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function MMMM(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function yy(dateObj) {
      return String(dateObj.getFullYear()).substr(2);
    },
    yyyy: function yyyy(dateObj) {
      return dateObj.getFullYear();
    },
    h: function h(dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function hh(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function H(dateObj) {
      return dateObj.getHours();
    },
    HH: function HH(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function m(dateObj) {
      return dateObj.getMinutes();
    },
    mm: function mm(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function s(dateObj) {
      return dateObj.getSeconds();
    },
    ss: function ss(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function S(dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function SS(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function SSS(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function a(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function A(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function ZZ(dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date();
      var cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: [/\d/, function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: [/\d{2}/, function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
      var parts = (v + '').match(/([\+\-]|\d\d)/gi);
      var minutes;
      if (parts) {
        minutes = +(parts[1] * 60) + _parseInt$2(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.DD = parseFlags.D;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.Do = parseFlags.dd = parseFlags.d;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a;
  fecha.masks = {
    'default': 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }
    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    return mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    });
  };
  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;
    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }
    format = fecha.masks[format] || format;
    if (dateStr.length > 1000) {
      return false;
    }
    var isValid = true;
    var dateInfo = {};
    format.replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        var index = dateStr.search(info[0]);
        if (!~index) {
          isValid = false;
        } else {
          dateStr.replace(info[0], function (result) {
            info[1](dateInfo, result, i18n);
            dateStr = dateStr.substr(index + result.length);
            return result;
          });
        }
      }
      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
    });
    if (!isValid) {
      return false;
    }
    var today = new Date();
    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }
    var date;
    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }
    return date;
  };

  var initTime = function initTime() {
    var date = new Date();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    return date;
  };
  var mergeDateHMS = function mergeDateHMS(date, h, m, s) {
    var newDate = new Date(date.getTime());
    newDate.setHours(h);
    newDate.setMinutes(m);
    newDate.setSeconds(s);
    return newDate;
  };
  var getDayCountOfMonth = function getDayCountOfMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  };
  var toDate = function toDate(date) {
    var _date = new Date(date);
    if (isNaN(_date.getTime()) && typeof date === 'string') {
      _date = date.split('-').map(Number);
      _date[1] += 1;
      _date = _construct(Date, _toConsumableArray(_date));
    }
    if (isNaN(_date.getTime())) {
      return null;
    }
    return _date;
  };
  var formatDate = function formatDate(date, format) {
    date = toDate(date);
    if (!date) {
      return '';
    }
    return fecha.format(date, format || 'yyyy-MM-dd');
  };
  var parseDate = function parseDate(string, format) {
    return fecha.parse(string, format || 'yyyy-MM-dd');
  };
  var DEFAULT_FORMATS = {
    date: 'yyyy-MM-dd',
    month: 'yyyy-MM',
    year: 'yyyy',
    datetime: 'yyyy-MM-dd HH:mm:ss',
    time: 'HH:mm:ss',
    timerange: 'HH:mm:ss',
    daterange: 'yyyy-MM-dd',
    datetimerange: 'yyyy-MM-dd HH:mm:ss'
  };
  var DATE_FORMATTER = function DATE_FORMATTER(value, format) {
    return formatDate(value, format);
  };
  var DATE_PARSER = function DATE_PARSER(text, format) {
    return parseDate(text, format);
  };
  var RANGE_SEPARATOR = ' - ';
  var RANGE_FORMATTER = function RANGE_FORMATTER(value, format) {
    if (isArray$1(value) && value.length === 2) {
      var start = value[0];
      var end = value[1];
      if (start && end) {
        return formatDate(start, format) + RANGE_SEPARATOR + formatDate(end, format);
      }
    } else if (!isArray$1(value) && value instanceof Date) {
      return formatDate(value, format);
    }
    return '';
  };
  var RANGE_PARSER = function RANGE_PARSER(text, format) {
    var array = isArray$1(text) ? text : text.split(RANGE_SEPARATOR);
    if (array.length === 2) {
      var range1 = array[0];
      var range2 = array[1];
      return [range1 instanceof Date ? range1 : parseDate(range1, format), range2 instanceof Date ? range2 : parseDate(range2, format)];
    }
    return [];
  };
  var TYPE_VALUE_RESOLVER_MAP = {
    default: {
      formatter: function formatter(value) {
        if (!value) {
          return '';
        }
        return '' + value;
      },
      parser: function parser(text) {
        if (text === undefined || text === '') {
          return null;
        }
        return text;
      }
    },
    date: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    datetime: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    daterange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    datetimerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    timerange: {
      formatter: RANGE_FORMATTER,
      parser: RANGE_PARSER
    },
    time: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    month: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    year: {
      formatter: DATE_FORMATTER,
      parser: DATE_PARSER
    },
    multiple: {
      formatter: function formatter(value, format) {
        return value.filter(Boolean).map(function (date) {
          return formatDate(date, format);
        }).join(',');
      },
      parser: function parser(value, format) {
        var values = typeof value === 'string' ? value.split(',') : value;
        return values.map(function (value) {
          if (value instanceof Date) {
            return value;
          }
          if (typeof value === 'string') {
            value = value.trim();
          } else if (typeof value !== 'number' && !value) {
            value = '';
          }
          return parseDate(value, format);
        });
      }
    },
    number: {
      formatter: function formatter(value) {
        if (!value) {
          return '';
        }
        return '' + value;
      },
      parser: function parser(text) {
        var result = Number(text);
        if (!isNaN(text)) {
          return result;
        }
        return null;
      }
    }
  };

  var nodeList = [];
  var clickctx = '$clickoutsideCtx';
  var beginClick;
  document.addEventListener('mousedown', function (event) {
    return beginClick = event;
  });
  document.addEventListener('mouseup', function (event) {
    nodeList.forEach(function (node) {
      node[clickctx].clickoutsideHandler(event, beginClick);
    });
  });
  var bkClickoutside = {
    bind: function bind(el, binding, vnode) {
      var id = nodeList.push(el) - 1;
      var clickoutsideHandler = function clickoutsideHandler() {
        var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        if (!vnode.context
        || !mouseup.target || !mousedown.target || el.contains(mouseup.target)
        || el.contains(mousedown.target)
        || el === mouseup.target
        || vnode.context.popup
        && (vnode.context.popup.contains(mouseup.target)
        || vnode.context.popup.contains(mousedown.target)
        )) {
          return;
        }
        if (binding.expression
        && el[clickctx].callbackName
        && vnode.context[el[clickctx].callbackName]
        ) {
          vnode.context[el[clickctx].callbackName](mouseup, mousedown, el);
        } else {
          el[clickctx].bindingFn && el[clickctx].bindingFn(mouseup, mousedown, el);
        }
      };
      el[clickctx] = {
        id: id,
        clickoutsideHandler: clickoutsideHandler,
        callbackName: binding.expression,
        callbackFn: binding.value
      };
    },
    update: function update(el, binding) {
      el[clickctx].callbackName = binding.expression;
      el[clickctx].callbackFn = binding.value;
    },
    unbind: function unbind(el) {
      for (var i = 0, len = nodeList.length; i < len; i++) {
        if (nodeList[i][clickctx].id === el[clickctx].id) {
          nodeList.splice(i, 1);
          break;
        }
      }
    }
  };
  bkClickoutside.install = function (Vue) {
    Vue.directive('bkClickoutside', bkClickoutside);
  };

  function getTarget(node) {
    if (node === void 0) {
      node = document.body;
    }
    if (node === true) {
      return document.body;
    }
    return node instanceof window.Node ? node : document.querySelector(node);
  }
  var transferDom = {
    inserted: function inserted(el, _ref, vnode) {
      var value = _ref.value;
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      el.className = el.className ? el.className + ' v-transfer-dom' : 'v-transfer-dom';
      var parentNode = el.parentNode;
      if (!parentNode) {
        return;
      }
      var home = document.createComment('');
      var hasMovedOut = false;
      if (value !== false) {
        parentNode.replaceChild(home, el);
        getTarget(value).appendChild(el);
        hasMovedOut = true;
      }
      if (!el.__transferDomData) {
        el.__transferDomData = {
          parentNode: parentNode,
          home: home,
          target: getTarget(value),
          hasMovedOut: hasMovedOut
        };
      }
    },
    componentUpdated: function componentUpdated(el, _ref2) {
      var value = _ref2.value;
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      var ref$1 = el.__transferDomData;
      if (!ref$1) {
        return;
      }
      var parentNode = ref$1.parentNode;
      var home = ref$1.home;
      var hasMovedOut = ref$1.hasMovedOut;
      if (!hasMovedOut && value) {
        parentNode.replaceChild(home, el);
        getTarget(value).appendChild(el);
        el.__transferDomData = _extends({}, el.__transferDomData, {
          hasMovedOut: true,
          target: getTarget(value)
        });
      } else if (hasMovedOut && value === false) {
        parentNode.replaceChild(el, home);
        el.__transferDomData = _extends({}, el.__transferDomData, {
          hasMovedOut: false,
          target: getTarget(value)
        });
      } else if (value) {
        getTarget(value).appendChild(el);
      }
    },
    unbind: function unbind(el) {
      if (el.dataset.transfer !== 'true') {
        return false;
      }
      el.className = el.className.replace('v-transfer-dom', '');
      var ref$1 = el.__transferDomData;
      if (!ref$1) {
        return;
      }
      if (el.__transferDomData.hasMovedOut === true) {
        el.__transferDomData.parentNode && el.__transferDomData.parentNode.appendChild(el);
      }
      el.__transferDomData = null;
    }
  };
  transferDom.install = function (Vue) {
    Vue.directive('bk-transfer-dom', transferDom);
  };

  var emitter = {
    methods: {
      dispatch: function dispatch(componentName, eventName, params) {
        var parent = this.$parent || this.$root;
        var name = parent.$options.name;
        while (parent && (!name || name !== componentName)) {
          parent = parent.$parent;
          if (parent) {
            name = parent.$options.name;
          }
        }
        if (parent) {
          parent.$emit.apply(parent, [eventName].concat(params));
        }
      }
    }
  };

  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser && window.Promise;
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent(getParentNode(element));
  }
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent(commonAncestorContainer);
    }
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect(offsets) {
    return _extends$1({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect(element) {
    var rect = {};
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }
  function getFixedPositionOffsetParent(element) {
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends$1({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? '-' + variation : '');
  }
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
    var popperRect = getOuterSizes(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
    return popperOffsets;
  }
  function find(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex(arr, prop, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
    data = runModifiers(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  function destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners(reference, state) {
    getWindow(reference).removeEventListener('resize', state.updateBound);
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  function applyStyle(data) {
    setStyles(data.instance.popper, data.styles);
    setAttributes(data.instance.popper, data.attributes);
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement);
    setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });
    return options;
  }
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
    var prefixedProperty = getSupportedPropertyName('transform');
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }
    var attributes = {
      'x-placement': data.placement
    };
    data.attributes = _extends$1({}, attributes, data.attributes);
    data.styles = _extends$1({}, styles, data.styles);
    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }
  function arrow(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var validPlacements = placements.slice(3);
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  function flip(data, options) {
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? '-' + variation : '');
        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function (op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var basePlacement = placement.split('-')[0];
    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style;
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$1({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
    return data;
  }
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  var modifiers = {
    shift: {
      order: 100,
      enabled: true,
      fn: shift
    },
    offset: {
      order: 200,
      enabled: true,
      fn: offset,
      offset: 0
    },
    preventOverflow: {
      order: 300,
      enabled: true,
      fn: preventOverflow,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: {
      order: 400,
      enabled: true,
      fn: keepTogether
    },
    arrow: {
      order: 500,
      enabled: true,
      fn: arrow,
      element: '[x-arrow]'
    },
    flip: {
      order: 600,
      enabled: true,
      fn: flip,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: false,
      flipVariationsByContent: false
    },
    inner: {
      order: 700,
      enabled: false,
      fn: inner
    },
    hide: {
      order: 800,
      enabled: true,
      fn: hide
    },
    computeStyle: {
      order: 850,
      enabled: true,
      fn: computeStyle,
      gpuAcceleration: true,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: true,
      fn: applyStyle,
      onLoad: applyStyleOnLoad,
      gpuAcceleration: undefined
    }
  };
  var Defaults = {
    placement: 'bottom',
    positionFixed: false,
    eventsEnabled: true,
    removeOnDestroy: false,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: modifiers
  };
  var Popper = function () {
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce(this.update.bind(this));
      this.options = _extends$1({}, Popper.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends$1({
          name: name
        }, _this.options.modifiers[name]);
      })
      .sort(function (a, b) {
        return a.order - b.order;
      });
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
    }]);
    return Popper;
  }();
  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  _export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

  var $Object = _core.Object;
  var defineProperty$1 = function defineProperty(it, key, desc) {
    return $Object.defineProperty(it, key, desc);
  };

  var defineProperty$2 = defineProperty$1;

  var hasInitZIndex = false;
  var zIndex;
  (function () {
    if (!window['__bk_zIndex_manager']) {
      var zIndexManager = {
        nextZIndex: function nextZIndex() {
          var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
          return zIndex === 'default' ? zIndexManager.zIndex++ : zIndex;
        },
        nextTickIndex: function nextTickIndex() {
          var tick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
          if (zIndex === 'default') {
            zIndexManager.zIndex += tick;
            return zIndexManager.zIndex;
          }
          return zIndex;
        }
      };
      defineProperty$2(zIndexManager, 'zIndex', {
        configurable: true,
        get: function get() {
          if (!hasInitZIndex) {
            zIndex = zIndex || (Vue.prototype.$BK_EL || {}).zIndex || 2000;
            hasInitZIndex = true;
          }
          return zIndex;
        },
        set: function set(value) {
          zIndex = value;
        }
      });
      window['__bk_zIndex_manager'] = zIndexManager;
    }
  })();
  var zIndexManager = window['__bk_zIndex_manager'];

  var transferIndex = 0;
  function transferIncrease() {
    transferIndex = zIndexManager.nextZIndex();
  }

  var script = {
    name: 'DatePickerDropdown',
    props: {
      placement: {
        type: String,
        default: 'bottom-start'
      },
      className: {
        type: String
      },
      extPopoverCls: {
        type: String
      },
      transfer: {
        type: Boolean
      }
    },
    data: function data() {
      return {
        popper: null,
        popperStatus: false,
        tIndex: this.handleGetIndex()
      };
    },
    computed: {
      styles: function styles() {
        var style = {};
        if (this.transfer) {
          style['z-index'] = 1060 + this.tIndex;
        }
        return style;
      }
    },
    created: function created() {
      this.$on('on-update-popper', this.update);
      this.$on('on-destroy-popper', this.destroy);
    },
    beforeDestroy: function beforeDestroy() {
      if (this.popper) {
        this.popper.destroy();
      }
    },
    methods: {
      update: function update() {
        var _this = this;
        if (this.popper) {
          this.$nextTick(function () {
            _this.popper.update();
            _this.popperStatus = true;
          });
        } else {
          this.$nextTick(function () {
            _this.popper = new Popper(_this.$parent.$refs.reference, _this.$el, {
              placement: _this.placement,
              modifiers: {
                computeStyle: {
                  gpuAcceleration: false
                },
                preventOverflow: {
                  boundariesElement: 'window'
                }
              },
              onCreate: function onCreate() {
                _this.resetTransformOrigin();
                _this.$nextTick(_this.popper.update());
              },
              onUpdate: function onUpdate() {
                _this.resetTransformOrigin();
              }
            });
          });
        }
        this.tIndex = this.handleGetIndex();
      },
      destroy: function destroy() {
        var _this2 = this;
        if (this.popper) {
          setTimeout(function () {
            if (_this2.popper && !_this2.popperStatus) {
              _this2.popper.destroy();
              _this2.popper = null;
            }
            _this2.popperStatus = false;
          }, 300);
        }
      },
      resetTransformOrigin: function resetTransformOrigin() {
        if (!this.popper) {
          return;
        }
        var xPlacement = this.popper.popper.getAttribute('x-placement');
        var placementStart = xPlacement.split('-')[0];
        var placementEnd = xPlacement.split('-')[1];
        var leftOrRight = xPlacement === 'left' || xPlacement === 'right';
        if (!leftOrRight) {
          this.popper.popper.style.transformOrigin = placementStart === 'bottom' || placementStart !== 'top' && placementEnd === 'start' ? 'center top' : 'center bottom';
        }
      },
      handleGetIndex: function handleGetIndex() {
        transferIncrease();
        return transferIndex;
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    var options = typeof script === 'function' ? script.options : script;
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    if (scopeId) {
      options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      hook = function hook(context) {
        context = context ||
        this.$vnode && this.$vnode.ssrContext ||
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }
    if (hook) {
      if (options.functional) {
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script;
  }
  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-date-picker-dropdown",
      class: [_vm.className, _vm.extPopoverCls],
      style: _vm.styles
    }, [_vm._t("default")], 2);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

  var isEmptyArray = function isEmptyArray(val) {
    return val.reduce(function (isEmpty, str) {
      return isEmpty && !str || typeof str === 'string' && str.trim() === '';
    }, true);
  };
  var keyValueMapper = {
    40: 'up',
    39: 'right',
    38: 'down',
    37: 'left'
  };
  var mapPossibleValues = function mapPossibleValues(key, horizontal, vertical) {
    if (key === 'left') {
      return horizontal * -1;
    }
    if (key === 'right') {
      return horizontal * 1;
    }
    if (key === 'up') {
      return vertical * 1;
    }
    if (key === 'down') {
      return vertical * -1;
    }
  };
  var extractTime = function extractTime(date) {
    if (!date) {
      return [0, 0, 0];
    }
    return [date.getHours(), date.getMinutes(), date.getSeconds()];
  };
  var script$1 = {
    components: {
      DatePickerDropdown: __vue_component__
    },
    directives: {
      clickoutside: bkClickoutside,
      transferDom: transferDom
    },
    mixins: [emitter],
    props: {
      extCls: {
        type: String,
        default: ''
      },
      extPopoverCls: {
        type: String,
        default: ''
      },
      format: {
        type: String
      },
      readonly: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      editable: {
        type: Boolean,
        default: true
      },
      clearable: {
        type: Boolean,
        default: true
      },
      open: {
        type: Boolean,
        default: null
      },
      multiple: {
        type: Boolean,
        default: false
      },
      timePickerOptions: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      splitPanels: {
        type: Boolean,
        default: true
      },
      startDate: {
        type: Date
      },
      placeholder: {
        type: String,
        default: ''
      },
      placement: {
        type: String,
        default: 'bottom-start',
        validator: function validator(value) {
          var validList = ['top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end', 'right', 'right-start', 'right-end'];
          if (validList.indexOf(value) < 0) {
            console.error("placement property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      transfer: {
        type: Boolean,
        default: false
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcuts: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      shortcutClose: {
        type: Boolean,
        default: false
      },
      value: {
        type: [Date, String, Array]
      },
      options: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      fontSize: {
        type: String,
        default: 'normal'
      },
      upToNow: {
        type: Boolean,
        default: false
      },
      useShortcutText: {
        type: Boolean,
        default: false
      },
      shortcutSelectedIndex: {
        type: Number,
        default: -1
      },
      headerSlotCls: {
        type: String,
        default: ''
      },
      footerSlotCls: {
        type: String,
        default: ''
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      },
      behavior: {
        type: String,
        default: 'normal',
        validate: function validate(v) {
          return ['simplicity', 'normal'].indexOf(v) > -1;
        }
      }
    },
    data: function data() {
      var isRange = this.type.includes('range');
      var emptyArray = isRange ? [null, null] : [null];
      var initialValue = isEmptyArray((isRange ? this.value : [this.value]) || []) ? emptyArray : this.parseDate(this.value);
      var shortcut = null;
      if (this.shortcutSelectedIndex !== -1) {
        shortcut = this.shortcuts[this.shortcutSelectedIndex] || null;
        if (shortcut) {
          initialValue = shortcut.value();
        }
      }
      var focusedTime = initialValue.map(extractTime);
      return {
        showClose: false,
        visible: false,
        internalValue: initialValue,
        disableClickOutSide: false,
        disableCloseUnderTransfer: false,
        selectionMode: this.onSelectionModeChange(this.type),
        forceInputRerender: 1,
        isFocused: false,
        focusedDate: initialValue[0] || this.startDate || new Date(),
        focusedTime: {
          column: 0,
          picker: 0,
          time: focusedTime,
          active: false
        },
        internalFocus: false,
        timeEnterMode: true,
        shortcut: shortcut
      };
    },
    computed: {
      publicVModelValue: function publicVModelValue() {
        if (this.multiple) {
          return this.internalValue.slice();
        }
        var isRange = this.type.includes('range');
        var val = this.internalValue.map(function (date) {
          return date instanceof Date ? new Date(date) : date || '';
        });
        if (this.type.match(/^time/)) {
          val = val.map(this.formatDate);
        }
        return isRange || this.multiple ? val : val[0];
      },
      publicStringValue: function publicStringValue() {
        var formatDate = this.formatDate,
            publicVModelValue = this.publicVModelValue,
            type = this.type;
        if (type.match(/^time/)) {
          return publicVModelValue;
        }
        if (this.multiple) {
          return formatDate(publicVModelValue);
        }
        return isArray$1(publicVModelValue) ? publicVModelValue.map(formatDate) : formatDate(publicVModelValue);
      },
      opened: function opened() {
        return this.open === null ? this.visible : this.open;
      },
      transition: function transition() {
        var bottomPlaced = this.placement.match(/^bottom/);
        return bottomPlaced ? 'slide-up' : 'slide-down';
      },
      visualValue: function visualValue() {
        return this.formatDate(this.internalValue);
      },
      displayValue: function displayValue() {
        if (this.shortcut && this.shortcut.text && this.useShortcutText) {
          return this.shortcut.text;
        }
        return this.visualValue;
      },
      isConfirm: function isConfirm() {
        return !!this.$slots.trigger || this.type === 'datetime' || this.type === 'datetimerange' || this.multiple;
      },
      fontSizeCls: function fontSizeCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-font';
        } else if (this.fontSize === 'large') {
          cls = 'large-font';
        }
        return cls;
      },
      longWidthCls: function longWidthCls() {
        var cls = '';
        if (this.fontSize === 'medium') {
          cls = 'medium-width';
        } else if (this.fontSize === 'large') {
          cls = 'large-width';
        }
        return cls;
      },
      localReadonly: function localReadonly() {
        if (this.shortcut && this.shortcut.text && this.useShortcutText) {
          return true;
        }
        return !this.editable || this.readonly;
      },
      hasFooter: function hasFooter() {
        return !!this.$slots.footer || !!this.$scopedSlots.footer;
      },
      hasHeader: function hasHeader() {
        return !!this.$slots.header || !!this.$scopedSlots.header;
      },
      allowCrossDayProp: function allowCrossDayProp() {
        return this.panel === 'RangeTimePickerPanel' ? this.allowCrossDay : false;
      }
    },
    watch: {
      visible: function visible(state) {
        if (state === false) {
          this.$refs.drop.destroy();
        }
        this.$refs.drop.update();
        if (!state) {
          this.dispatch('bk-form-item', 'form-blur');
        }
        this.$emit('open-change', state);
      },
      value: function value(val) {
        this.internalValue = this.parseDate(val);
      },
      open: function open(val) {
        this.visible = val === true;
      },
      type: function type(_type) {
        this.onSelectionModeChange(_type);
      },
      publicVModelValue: function publicVModelValue(now, before) {
        var newValue = stringify$1(now);
        var oldValue = stringify$1(before);
        var shouldEmitInput = newValue !== oldValue || _typeof(now) !== _typeof(before);
        if (shouldEmitInput) {
          this.$emit('input', now);
        }
      }
    },
    mounted: function mounted() {
      var _this = this;
      if (this.type.indexOf('date') > -1) {
        this.timeEnterMode = true;
      } else {
        this.timeEnterMode = this.enterMode;
      }
      var initialValue = this.value;
      var parsedValue = this.publicVModelValue;
      if (_typeof(initialValue) !== _typeof(parsedValue) || stringify$1(initialValue) !== stringify$1(parsedValue)) {
        this.$emit('input', this.publicVModelValue);
      }
      if (this.open !== null) {
        this.visible = this.open;
      }
      this.$on('focus-input', function () {
        return _this.focus();
      });
    },
    methods: {
      handleIconClick: function handleIconClick() {
        this.$refs.input.focus();
        this.$refs.input.click();
      },
      onSelectionModeChange: function onSelectionModeChange(type) {
        if (type.match(/^date/)) {
          type = 'date';
        }
        this.selectionMode = ['year', 'month', 'date', 'time'].indexOf(type) > -1 && type;
        return this.selectionMode;
      },
      handleTransferClick: function handleTransferClick() {
        if (this.transfer) {
          this.disableCloseUnderTransfer = true;
        }
      },
      handleClose: function handleClose(e) {
        if (this.disableCloseUnderTransfer) {
          this.disableCloseUnderTransfer = false;
          return false;
        }
        if (e && e.type === 'mousedown' && this.visible) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (this.visible) {
          var pickerPanel = this.$refs.pickerPanel && this.$refs.pickerPanel.$el;
          if (e && pickerPanel && pickerPanel.contains(e.target)) {
            return;
          }
          this.visible = false;
          e && e.preventDefault();
          e && e.stopPropagation();
          return;
        }
        this.isFocused = false;
        this.disableClickOutSide = false;
      },
      handleFocus: function handleFocus(e) {
        if (this.readonly) {
          return;
        }
        this.isFocused = true;
        if (e && e.type === 'focus') {
          return;
        }
        if (!this.disabled) {
          this.visible = true;
        }
      },
      handleBlur: function handleBlur(e) {
        if (this.internalFocus) {
          this.internalFocus = false;
          return;
        }
        if (this.visible) {
          e.preventDefault();
          return;
        }
        this.isFocused = false;
        this.onSelectionModeChange(this.type);
        this.internalValue = this.internalValue.slice();
        this.reset();
        this.$refs.pickerPanel.onToggleVisibility(false);
      },
      handleKeydown: function handleKeydown(e) {
        var keyCode = e.keyCode;
        if (keyCode === 9) {
          if (this.visible) {
            e.stopPropagation();
            e.preventDefault();
            if (this.isConfirm) {
              var selector = '.bk-picker-confirm > *';
              var tabbable = this.$refs.drop.$el.querySelectorAll(selector);
              this.internalFocus = true;
              var element = _toConsumableArray(tabbable)[e.shiftKey ? 'pop' : 'shift']();
              element.focus();
            } else {
              this.handleClose();
            }
          } else {
            this.focused = false;
          }
        }
        var arrows = [37, 38, 39, 40];
        if (!this.visible && arrows.includes(keyCode)) {
          this.visible = true;
          return;
        }
        if (keyCode === 27) {
          if (this.visible) {
            e.stopPropagation();
            this.handleClose();
          }
        }
        if (keyCode === 13 && this.timeEnterMode) {
          var _timePickers = findChildComponents(this, 'TimeSpinner');
          if (_timePickers.length > 0) {
            var columnsPerPicker = _timePickers[0].showSeconds ? 3 : 2;
            var pickerIndex = Math.floor(this.focusedTime.column / columnsPerPicker);
            var value = this.focusedTime.time[pickerIndex];
            _timePickers[pickerIndex].chooseValue(value);
            return;
          }
        }
        if (!arrows.includes(keyCode)) {
          return;
        }
        if (this.focusedTime.active) {
          e.preventDefault();
        }
        var timePickers = findChildComponents(this, 'TimeSpinner');
        if (timePickers.length > 0) {
          this.navigateTimePanel(keyValueMapper[keyCode]);
        }
      },
      reset: function reset() {
        this.$refs.pickerPanel.reset && this.$refs.pickerPanel.reset();
      },
      navigateTimePanel: function navigateTimePanel(direction) {
        var _this2 = this;
        this.focusedTime.active = true;
        var horizontal = direction.match(/left|right/);
        var vertical = direction.match(/up|down/);
        var timePickers = findChildComponents(this, 'TimeSpinner');
        var maxNrOfColumns = (timePickers[0].showSeconds ? 3 : 2) * timePickers.length;
        var column = function (currentColumn) {
          var incremented = currentColumn + (horizontal ? direction === 'left' ? -1 : 1 : 0);
          return (incremented + maxNrOfColumns) % maxNrOfColumns;
        }(this.focusedTime.column);
        var columnsPerPicker = maxNrOfColumns / timePickers.length;
        var pickerIndex = Math.floor(column / columnsPerPicker);
        var col = column % columnsPerPicker;
        if (horizontal) {
          var time = this.internalValue.map(extractTime);
          this.focusedTime = _objectSpread({}, this.focusedTime, {
            column: column,
            time: time
          });
          timePickers.forEach(function (instance, i) {
            if (i === pickerIndex) {
              instance.updateFocusedTime(col, time[pickerIndex]);
            } else {
              instance.updateFocusedTime(-1, instance.focusedTime);
            }
          });
        }
        if (vertical) {
          var increment = direction === 'up' ? 1 : -1;
          var timeParts = ['hours', 'minutes', 'seconds'];
          var pickerPossibleValues = timePickers[pickerIndex]["".concat(timeParts[col], "List")];
          var nextIndex = pickerPossibleValues.findIndex(function (_ref) {
            var text = _ref.text;
            return _this2.focusedTime.time[pickerIndex][col] === text;
          }) + increment;
          if (nextIndex === -1) {
            return;
          }
          var nextValue = pickerPossibleValues[nextIndex % pickerPossibleValues.length].text;
          var times = this.focusedTime.time.map(function (time, i) {
            if (i !== pickerIndex) {
              return time;
            }
            time[col] = nextValue;
            return time;
          });
          this.focusedTime = _objectSpread({}, this.focusedTime, {
            time: times
          });
          timePickers.forEach(function (instance, i) {
            if (i === pickerIndex) {
              instance.updateFocusedTime(col, times[i]);
              if (!_this2.timeEnterMode) {
                instance.chooseValue(_this2.focusedTime.time[pickerIndex]);
              }
            } else {
              instance.updateFocusedTime(-1, instance.focusedTime);
            }
          });
        }
      },
      navigateDatePanel: function navigateDatePanel(direction) {
        var timePickers = findChildComponents(this, 'TimeSpinner');
        if (timePickers.length > 0) {
          this.navigateTimePanel(direction);
          return;
        }
        var initialDate = this.focusedDate || this.internalValue && this.internalValue[0] || new Date();
        var focusedDate = new Date(initialDate);
        if (this.type.match(/^date/)) {
          var lastOfMonth = getDayCountOfMonth(initialDate.getFullYear(), initialDate.getMonth());
          var startDay = initialDate.getDate();
          var nextDay = focusedDate.getDate() + mapPossibleValues(direction, 1, 7);
          if (nextDay < 1) {
            if (direction.match(/left|right/)) {
              focusedDate.setMonth(focusedDate.getMonth() + 1);
              focusedDate.setDate(nextDay);
            } else {
              focusedDate.setDate(startDay + Math.floor((lastOfMonth - startDay) / 7) * 7);
            }
          } else if (nextDay > lastOfMonth) {
            if (direction.match(/left|right/)) {
              focusedDate.setMonth(focusedDate.getMonth() - 1);
              focusedDate.setDate(nextDay);
            } else {
              focusedDate.setDate(startDay % 7);
            }
          } else {
            focusedDate.setDate(nextDay);
          }
        }
        if (this.type.match(/^month/)) {
          focusedDate.setMonth(focusedDate.getMonth() + mapPossibleValues(direction, 1, 3));
        }
        if (this.type.match(/^year/)) {
          focusedDate.setFullYear(focusedDate.getFullYear() + mapPossibleValues(direction, 1, 3));
        }
        this.focusedDate = focusedDate;
      },
      handleInputChange: function handleInputChange(e) {
        var isArrayValue = this.type.includes('range') || this.multiple;
        var oldValue = this.visualValue;
        var newValue = e.target.value;
        var newDate = this.parseDate(newValue);
        var disabledDateFn = this.options && typeof this.options.disabledDate === 'function' && this.options.disabledDate;
        var valueToTest = isArrayValue ? newDate : newDate[0];
        var isDisabled = disabledDateFn && disabledDateFn(valueToTest);
        var isValidDate = newDate.reduce(function (valid, date) {
          return valid && date instanceof Date;
        }, true);
        if (newValue !== oldValue && !isDisabled && isValidDate) {
          this.emitChange(this.type);
          this.internalValue = newDate;
        } else {
          this.forceInputRerender++;
        }
      },
      handleInputMouseenter: function handleInputMouseenter() {
        if (this.readonly || this.disabled) {
          return;
        }
        if (this.visualValue) {
          this.showClose = true;
        }
      },
      handleInputMouseleave: function handleInputMouseleave(e) {
        if (e.toElement && e.toElement.classList.contains('clear-action')) {
          return;
        }
        this.showClose = false;
      },
      handleClear: function handleClear(e) {
        var _this3 = this;
        this.visible = false;
        this.internalValue = this.internalValue.map(function () {
          return null;
        });
        this.$emit('clear');
        this.emitChange(this.type);
        this.reset();
        this.showClose = false;
        this.shortcut = null;
        setTimeout(function () {
          return _this3.onSelectionModeChange(_this3.type);
        }, 500);
      },
      emitChange: function emitChange(type) {
        var _this4 = this;
        this.$nextTick(function () {
          _this4.$emit('change', _this4.publicStringValue, type);
          _this4.dispatch('bk-form-item', 'form-change');
          if (_this4.type.indexOf('time') < 0) {
            _this4.$refs.input && _this4.$refs.input.blur();
          }
        });
      },
      parseDate: function parseDate(val) {
        var isRange = this.type.includes('range');
        var type = this.type;
        var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP['default']).parser;
        var format = this.format || DEFAULT_FORMATS[type];
        var multipleParser = TYPE_VALUE_RESOLVER_MAP['multiple'].parser;
        if (val && type === 'time' && !(val instanceof Date)) {
          val = parser(val, format);
        } else if (this.multiple && val) {
          val = multipleParser(val, format);
        } else if (isRange) {
          if (!val) {
            val = [null, null];
          } else {
            if (typeof val === 'string') {
              val = parser(val, format);
            } else if (type === 'timerange') {
              val = parser(val, format).map(function (v) {
                return v || '';
              });
            } else {
              var _val = val,
                  _val2 = _slicedToArray(_val, 2),
                  start = _val2[0],
                  end = _val2[1];
              if (start instanceof Date && end instanceof Date) {
                val = val.map(function (date) {
                  return new Date(date);
                });
              } else if (typeof start === 'string' && typeof end === 'string') {
                val = parser(val.join(RANGE_SEPARATOR), format);
              } else if (!start || !end) {
                val = [null, null];
              }
            }
          }
        } else if (typeof val === 'string' && type.indexOf('time') !== 0) {
          val = parser(val, format) || null;
        }
        return isRange || this.multiple ? val || [] : [val];
      },
      formatDate: function formatDate(value) {
        var format = DEFAULT_FORMATS[this.type];
        if (this.multiple) {
          var formatter = TYPE_VALUE_RESOLVER_MAP.multiple.formatter;
          return formatter(value, this.format || format);
        } else {
          var _ref2 = TYPE_VALUE_RESOLVER_MAP[this.type] || TYPE_VALUE_RESOLVER_MAP['default'],
              _formatter = _ref2.formatter;
          return _formatter(value, this.format || format);
        }
      },
      onPick: function onPick(dates) {
        var _this5 = this;
        var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var type = arguments.length > 2 ? arguments[2] : undefined;
        var shortcut = arguments.length > 3 ? arguments[3] : undefined;
        if (this.multiple) {
          var pickedTimeStamp = dates.getTime();
          var indexOfPickedDate = this.internalValue.findIndex(function (date) {
            return date && date.getTime() === pickedTimeStamp;
          });
          var allDates = [].concat(_toConsumableArray(this.internalValue), [dates]).filter(Boolean);
          var timeStamps = allDates.map(function (date) {
            return date.getTime();
          }).filter(function (ts, i, arr) {
            return arr.indexOf(ts) === i && i !== indexOfPickedDate;
          });
          this.internalValue = timeStamps.map(function (ts) {
            return new Date(ts);
          });
        } else {
          dates = this.parseDate(dates);
          this.internalValue = isArray$1(dates) ? dates : [dates];
        }
        if (this.internalValue[0]) {
          this.focusedDate = this.internalValue[0];
        }
        this.focusedTime = _objectSpread({}, this.focusedTime, {
          time: this.internalValue.map(extractTime)
        });
        if (!this.isConfirm) {
          this.onSelectionModeChange(this.type);
          this.visible = visible;
        }
        if (type === 'upToNow' && this.type === 'daterange') {
          this.onPickSuccess();
        }
        this.shortcut = shortcut;
        this.emitChange(type);
        var shortcutIndex = this.shortcuts.findIndex(function (item) {
          return item === _this5.shortcut;
        });
        this.$emit('shortcut-change', this.shortcut, shortcutIndex);
      },
      onPickSuccess: function onPickSuccess() {
        var _this6 = this;
        this.visible = false;
        this.$nextTick(function () {
          _this6.$emit('pick-success');
        });
        this.$refs.input && this.$refs.input.blur();
        this.reset();
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      }
    }
  };

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      directives: [{
        name: "clickoutside",
        rawName: "v-clickoutside",
        value: _vm.handleClose,
        expression: "handleClose"
      }],
      staticClass: "bk-date-picker",
      class: [_vm.type === 'datetimerange' ? 'long' : '', _vm.longWidthCls, _vm.extCls]
    }, [_c('div', {
      ref: "reference",
      staticClass: "bk-date-picker-rel"
    }, [_vm._t("trigger", [_c('span', {
      staticClass: "icon-wrapper",
      class: _vm.disabled ? 'disabled' : '',
      on: {
        "click": _vm.handleIconClick,
        "mouseenter": _vm.handleInputMouseenter,
        "mouseleave": _vm.handleInputMouseleave
      }
    }, [_vm.type === 'time' || _vm.type === 'timerange' ? _c('svg', {
      staticClass: "picker-icon",
      attrs: {
        "x": "0px",
        "y": "0px",
        "viewBox": "0 0 1024 1024"
      }
    }, [_c('g', {
      attrs: {
        "id": "time"
      }
    }, [_c('path', {
      attrs: {
        "fill": "#c4c6cc",
        "d": "M512,128c51.9,0,102.2,10.1,149.5,30.2c45.7,19.3,86.8,47,122.1,82.3s63,76.4,82.3,122.1\n                            c20,47.3,30.2,97.6,30.2,149.5S886,614.3,865.9,661.6c-19.3,45.7-47,86.8-82.3,122.1s-76.4,63-122.1,82.3\n                            c-47.3,20-97.6,30.2-149.5,30.2S409.8,886.1,362.5,866c-45.7-19.3-86.8-47-122.1-82.3s-63-76.4-82.3-122.1\n                            c-20-47.3-30.2-97.6-30.2-149.5s10.1-102.2,30.2-149.5c19.3-45.7,47-86.8,82.3-122.1s76.4-63,122.1-82.3\n                            C409.8,138.1,460.1,128,512,128 M512,64C264.6,64,64,264.6,64,512s200.6,448,448,448s448-200.6,448-448S759.4,64,512,64L512,64z"
      }
    }), _c('polygon', {
      attrs: {
        "fill": "#c4c6cc",
        "points": "512,512 512,256 448,256 448,512 448,576 512,576 768,576 768,512"
      }
    })])]) : _c('svg', {
      staticClass: "picker-icon",
      attrs: {
        "x": "0px",
        "y": "0px",
        "viewBox": "0 0 1024 1024"
      }
    }, [_c('g', {
      attrs: {
        "id": "date"
      }
    }, [_c('path', {
      attrs: {
        "fill": "#c4c6cc",
        "d": "M896,128h-96v64h64v112H160V192h64v-64h-96c-17.7,0-32,14.3-32,32v736c0,17.7,14.3,32,32,32h768\n                            c17.7,0,32-14.3,32-32V160C928,142.3,913.7,128,896,128z M160,864V368h704v496H160z"
      }
    }), _c('rect', {
      attrs: {
        "x": "416",
        "y": "128",
        "fill": "#c4c6cc",
        "width": "192",
        "height": "64"
      }
    }), _c('rect', {
      attrs: {
        "x": "288",
        "y": "96",
        "fill": "#c4c6cc",
        "width": "64",
        "height": "128"
      }
    }), _c('rect', {
      attrs: {
        "x": "672",
        "y": "96",
        "fill": "#c4c6cc",
        "width": "64",
        "height": "128"
      }
    }), _c('polygon', {
      attrs: {
        "fill": "#c4c6cc",
        "points": "403.7,514.4 557.1,514.4 557.1,515.3 420.1,765.5 483.5,765.5 620.3,504.3 620.3,466.5 403.7,466.5"
      }
    })])])]), _c('input', {
      key: _vm.forceInputRerender,
      ref: "input",
      staticClass: "bk-date-picker-editor",
      class: [_vm.readonly ? 'readonly' : '', _vm.fontSizeCls, {
        'only-bottom-border': _vm.behavior === 'simplicity'
      }],
      attrs: {
        "type": "text",
        "readonly": _vm.localReadonly,
        "disabled": _vm.disabled,
        "placeholder": _vm.placeholder
      },
      domProps: {
        "value": _vm.displayValue
      },
      on: {
        "focus": _vm.handleFocus,
        "blur": _vm.handleBlur,
        "click": _vm.handleFocus,
        "change": _vm.handleInputChange,
        "keydown": _vm.handleKeydown,
        "mouseenter": _vm.handleInputMouseenter,
        "mouseleave": _vm.handleInputMouseleave
      }
    }), _vm.clearable && _vm.showClose ? _c('i', {
      staticClass: "bk-icon icon-close-circle-shape clear-action",
      on: {
        "click": _vm.handleClear
      }
    }) : _vm._e()])], 2), _c('transition', {
      attrs: {
        "name": "transition-drop"
      }
    }, [_c('DatePickerDropdown', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.opened,
        expression: "opened"
      }, {
        name: "transfer-dom",
        rawName: "v-transfer-dom"
      }],
      ref: "drop",
      class: _vm.transfer ? 'bk-date-picker-transfer' : '',
      attrs: {
        "placement": _vm.placement,
        "ext-popover-cls": _vm.extPopoverCls,
        "data-transfer": _vm.transfer,
        "transfer": _vm.transfer
      },
      nativeOn: {
        "click": function click($event) {
          return _vm.handleTransferClick($event);
        }
      }
    }, [_vm.hasHeader ? [_c('div', {
      staticClass: "bk-date-picker-top-wrapper",
      class: _vm.headerSlotCls
    }, [_vm._t("header")], 2)] : _vm._e(), _c(_vm.panel, _vm._b({
      ref: "pickerPanel",
      tag: "component",
      attrs: {
        "clearable": _vm.clearable,
        "visible": _vm.visible,
        "show-time": _vm.type === 'datetime' || _vm.type === 'datetimerange',
        "confirm": _vm.isConfirm,
        "selection-mode": _vm.selectionMode,
        "steps": _vm.steps,
        "format": _vm.format,
        "value": _vm.internalValue,
        "start-date": _vm.startDate,
        "split-panels": _vm.splitPanels,
        "shortcuts": _vm.shortcuts,
        "picker-type": _vm.type,
        "multiple": _vm.multiple,
        "focused-date": _vm.focusedDate,
        "width": _vm.type === 'time' || _vm.type === 'timerange' ? _vm.width : 261,
        "time-picker-options": _vm.timePickerOptions,
        "shortcut-close": _vm.shortcutClose,
        "up-to-now": _vm.upToNow,
        "allow-cross-day": _vm.allowCrossDayProp
      },
      on: {
        "pick": _vm.onPick,
        "pick-clear": _vm.handleClear,
        "pick-success": _vm.onPickSuccess,
        "pick-click": function pickClick($event) {
          _vm.disableClickOutSide = true;
        },
        "selection-mode-change": _vm.onSelectionModeChange
      }
    }, 'component', _vm.ownPickerProps, false), [_vm.$slots.shortcuts || _vm.$scopedSlots.shortcuts ? _c('div', {
      attrs: {
        "slot": "shortcuts"
      },
      slot: "shortcuts"
    }, [_vm._t("shortcuts")], 2) : _vm._e()]), _vm.hasFooter ? [_c('div', {
      staticClass: "bk-date-picker-footer-wrapper",
      class: _vm.footerSlotCls
    }, [_vm._t("footer")], 2)] : _vm._e()], 2)], 1)], 1);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$1 = undefined;
  /* scoped */

  var __vue_scope_id__$1 = undefined;
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode:  'pure' ,
    copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var shared = _shared('keys');
  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');
  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
  };

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys = _core.Object.keys;

  var keys$1 = keys;

  var $parseFloat = _global.parseFloat;
  var $trim$1 = _stringTrim.trim;
  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim$1(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  _export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

  var _parseFloat$1 = _core.parseFloat;

  var requestAnimationFrame$2 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$2 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function debounce$1(cb) {
    var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
    for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      params[_key2 - 2] = arguments[_key2];
    }
    var timer = null;
    return function (e) {
      clearTimeout(timer);
      timer = setTimeout(function () {
        cb.apply(void 0, [e].concat(params));
      }, interval);
    };
  }

  var timeMixins = {
    props: {
      disabledHours: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      disabledMinutes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      disabledSeconds: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      hideDisabledOptions: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 261
      },
      enterMode: {
        type: Boolean,
        default: true
      }
    },
    methods: {
      firstUpperCase: function firstUpperCase(str) {
        return str.toString()[0].toUpperCase() + str.toString().slice(1);
      }
    }
  };

  var timeParts = ['hours', 'minutes', 'seconds'];
  var script$2 = {
    name: 'TimeSpinner',
    mixins: [timeMixins, locale.mixin],
    props: {
      hours: {
        type: [Number, String],
        default: NaN
      },
      minutes: {
        type: [Number, String],
        default: NaN
      },
      seconds: {
        type: [Number, String],
        default: NaN
      },
      showSeconds: {
        type: Boolean,
        default: true
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      var _this = this;
      return {
        spinerSteps: [1, 1, 1].map(function (one, i) {
          return Math.abs(_this.steps[i]) || one;
        }),
        compiled: false,
        focusedColumn: -1,
        focusedTime: [0, 0, 0]
      };
    },
    computed: {
      hoursList: function hoursList() {
        var hours = [];
        var step = this.spinerSteps[0];
        var focusedHour = this.focusedColumn === 0 && this.focusedTime[0];
        var hourTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 24; i += step) {
          var hour = JSON.parse(stringify$1(hourTmpl));
          hour.text = i;
          hour.focused = i === focusedHour;
          if (this.disabledHours.length && this.disabledHours.indexOf(i) > -1) {
            hour.disabled = true;
            if (this.hideDisabledOptions) {
              hour.hide = true;
            }
          }
          if (this.hours === i) {
            hour.selected = true;
          }
          hours.push(hour);
        }
        return hours;
      },
      minutesList: function minutesList() {
        var minutes = [];
        var step = this.spinerSteps[1];
        var focusedMinute = this.focusedColumn === 1 && this.focusedTime[1];
        var minuteTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 60; i += step) {
          var minute = JSON.parse(stringify$1(minuteTmpl));
          minute.text = i;
          minute.focused = i === focusedMinute;
          if (this.disabledMinutes.length && this.disabledMinutes.indexOf(i) > -1) {
            minute.disabled = true;
            if (this.hideDisabledOptions) {
              minute.hide = true;
            }
          }
          if (this.minutes === i) {
            minute.selected = true;
          }
          minutes.push(minute);
        }
        return minutes;
      },
      secondsList: function secondsList() {
        var seconds = [];
        var step = this.spinerSteps[2];
        var focusedMinute = this.focusedColumn === 2 && this.focusedTime[2];
        var secondTmpl = {
          text: 0,
          selected: false,
          disabled: false,
          hide: false
        };
        for (var i = 0; i < 60; i += step) {
          var second = JSON.parse(stringify$1(secondTmpl));
          second.text = i;
          second.focused = i === focusedMinute;
          if (this.disabledSeconds.length && this.disabledSeconds.indexOf(i) > -1) {
            second.disabled = true;
            if (this.hideDisabledOptions) {
              second.hide = true;
            }
          }
          if (this.seconds === i) {
            second.selected = true;
          }
          seconds.push(second);
        }
        return seconds;
      },
      styles: function styles() {
        return {
          width: this.showSeconds ? '33.33%' : '50%'
        };
      }
    },
    watch: {
      hours: function hours(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('hours', this.hoursList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      minutes: function minutes(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('minutes', this.minutesList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      seconds: function seconds(val) {
        if (!this.compiled) {
          return;
        }
        this.scroll('seconds', this.secondsList.findIndex(function (obj) {
          return obj.text === val;
        }));
      },
      focusedTime: function focusedTime(updated, old) {
        var _this2 = this;
        timeParts.forEach(function (part, i) {
          if (updated[i] === old[i] || typeof updated[i] === 'undefined') {
            return;
          }
          var valueIndex = _this2["".concat(part, "List")].findIndex(function (obj) {
            return obj.text === updated[i];
          });
          _this2.scroll(part, valueIndex);
        });
      }
    },
    mounted: function mounted() {
      var _this3 = this;
      this.$nextTick(function () {
        _this3.compiled = true;
        _this3.bindWheelEvent();
      });
    },
    methods: {
      getCellCls: function getCellCls(cell) {
        var _ref;
        return ['bk-time-picker-cells-cell', (_ref = {}, _defineProperty(_ref, "bk-time-picker-cells-cell-selected", cell.selected), _defineProperty(_ref, "bk-time-picker-cells-cell-focused", cell.focused), _defineProperty(_ref, "bk-time-picker-cells-cell-disabled", cell.disabled), _ref)];
      },
      chooseValue: function chooseValue(values) {
        var _this4 = this;
        var changes = timeParts.reduce(function (obj, part, i) {
          var value = values[i];
          if (_this4[part] === value) {
            return obj;
          }
          return _objectSpread({}, obj, _defineProperty({}, part, value));
        }, {});
        if (keys$1(changes).length > 0) {
          this.emitChange(changes);
        }
      },
      bindWheelEvent: function bindWheelEvent() {
        var _this5 = this;
        var bindFunction = function bindFunction(type) {
          _this5.$refs[type].addEventListener('wheel', debounce$1(_this5.handleWheel, 32, type), {
            passive: true
          });
        };
        bindFunction('hours');
        bindFunction('minutes');
        bindFunction('seconds');
      },
      typeItemHeight: function typeItemHeight(type) {
        return this.$refs[type].querySelector('li').offsetHeight;
      },
      scrollBarHeight: function scrollBarHeight(type) {
        return this.$refs[type].offsetHeight;
      },
      handleWheel: function handleWheel(e, type) {
        var _this6 = this;
        var value = Math.min(Math.round((this.$refs[type].scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === 'hours' ? 23 : 59);
        var list = this["".concat(type, "List")];
        var item = list.find(function (data) {
          return data.text === value;
        });
        if (item.disabled) {
          return false;
        }
        this.$nextTick(function () {
          _this6.emitChange(_defineProperty({}, type, value));
        });
      },
      handleClick: function handleClick(type, cell) {
        if (cell.disabled) {
          return;
        }
        var data = _defineProperty({}, type, cell.text);
        this.emitChange(data);
      },
      emitChange: function emitChange(changes) {
        this.$emit('change', changes);
        this.$emit('pick-click');
      },
      scroll: function scroll(type, index) {
        var from = this.$refs[type].scrollTop;
        var to = 32 * this.getScrollIndex(type, index);
        scrollTop(this.$refs[type], from, to, 500);
      },
      getScrollIndex: function getScrollIndex(type, index) {
        var t = this.firstUpperCase(type);
        var disabled = this["disabled".concat(t)];
        if (disabled.length && this.hideDisabledOptions) {
          var _count = 0;
          disabled.forEach(function (item) {
            return item <= index ? _count++ : '';
          });
          index -= _count;
        }
        return index;
      },
      updateScroll: function updateScroll() {
        var _this7 = this;
        this.$nextTick(function () {
          timeParts.forEach(function (type) {
            _this7.$refs[type].scrollTop = 32 * _this7["".concat(type, "List")].findIndex(function (obj) {
              return obj.text === _this7[type];
            });
          });
        });
      },
      padTime: function padTime(text) {
        return text < 10 ? '0' + text : text;
      },
      updateFocusedTime: function updateFocusedTime(col, time) {
        this.focusedColumn = col;
        this.focusedTime = time.slice();
      }
    }
  };

  /* script */
  var __vue_script__$2 = script$2;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-time-picker-cells",
      class: _vm.showSeconds ? 'bk-time-picker-cells-with-seconds' : ''
    }, [_c('div', {
      staticClass: "bk-time-picker-cells-title-wrapper"
    }, [_c('div', {
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 0 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.hour')))]), _c('div', {
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 1 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.min')))]), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showSeconds,
        expression: "showSeconds"
      }],
      staticClass: "bk-time-picker-cells-title",
      class: _vm.focusedColumn === 2 ? 'active' : '',
      style: _vm.styles
    }, [_vm._v(_vm._s(_vm.t('bk.datePicker.sec')))])]), _c('div', {
      ref: "hours",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.hoursList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('hours', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)]), _c('div', {
      ref: "minutes",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.minutesList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('minutes', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)]), _c('div', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.showSeconds,
        expression: "showSeconds"
      }],
      ref: "seconds",
      staticClass: "bk-time-picker-cells-list",
      style: _vm.styles
    }, [_c('ul', {
      staticClass: "bk-time-picker-cells-ul"
    }, _vm._l(_vm.secondsList, function (item, index) {
      return _c('li', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !item.hide,
          expression: "!item.hide"
        }],
        key: index,
        class: _vm.getCellCls(item),
        on: {
          "click": function click($event) {
            _vm.handleClick('seconds', item);
          }
        }
      }, [_vm._v(_vm._s(_vm.padTime(item.text)))]);
    }), 0)])]);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

  var panelMixins = {
    props: {
      confirm: {
        type: Boolean,
        default: false
      }
    },
    methods: {
      capitalize: function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      },
      iconBtnCls: function iconBtnCls(direction) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        return ['bk-picker-panel-icon-btn', "bk-date-picker-".concat(direction, "-btn"), "bk-date-picker-".concat(direction, "-btn-arrow").concat(type)];
      },
      handleShortcutClick: function handleShortcutClick(shortcut) {
        if (shortcut.value) {
          this.$emit('pick', shortcut.value(), false, undefined, shortcut);
        }
        if (shortcut.onClick) {
          shortcut.onClick(this);
        }
        if (this.shortcutClose) {
          this.handlePickSuccess();
        }
      },
      handlePickClear: function handlePickClear() {
        this.resetView();
        this.$emit('pick-clear');
      },
      handlePickSuccess: function handlePickSuccess() {
        this.resetView();
        this.$emit('pick-success');
      },
      handlePickClick: function handlePickClick() {
        this.$emit('pick-click');
      },
      resetView: function resetView() {
        var _this = this;
        setTimeout(function () {
          _this.currentView = _this.selectionMode;
        }, 500);
      },
      handleClear: function handleClear() {
        this.dates = this.dates.map(function () {
          return null;
        });
        this.rangeState = {};
        this.$emit('pick', this.dates);
        this.handleConfirm();
      },
      handleConfirm: function handleConfirm(visible, type) {
        this.$emit('pick', this.dates, visible, type || this.type);
      },
      onToggleVisibility: function onToggleVisibility(open) {
        var _this$$refs = this.$refs,
            timeSpinner = _this$$refs.timeSpinner,
            timeSpinnerEnd = _this$$refs.timeSpinnerEnd;
        if (open && timeSpinner) {
          timeSpinner.updateScroll();
        }
        if (open && timeSpinnerEnd) {
          timeSpinnerEnd.updateScroll();
        }
      }
    }
  };

  var script$3 = {
    name: 'TimePickerPanel',
    components: {
      TimeSpinner: __vue_component__$2
    },
    mixins: [timeMixins, panelMixins],
    props: {
      disabledDate: {
        type: Function,
        default: function _default() {
          return false;
        }
      },
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      format: {
        type: String,
        default: 'HH:mm:ss'
      },
      value: {
        type: Array,
        required: true
      }
    },
    data: function data() {
      return {
        date: this.value[0] || initTime(),
        showDate: false
      };
    },
    computed: {
      showSeconds: function showSeconds() {
        return !(this.format || '').match(/mm$/);
      },
      visibleDate: function visibleDate() {
        return fecha.format(this.$parent.panelDate, this.$parent.format);
      },
      timeSlots: function timeSlots() {
        var _this = this;
        if (!this.value[0]) {
          return [];
        }
        return ['getHours', 'getMinutes', 'getSeconds'].map(function (slot) {
          return _this.date[slot]();
        });
      },
      disabledHMS: function disabledHMS() {
        var _this2 = this;
        var disabledTypes = ['disabledHours', 'disabledMinutes', 'disabledSeconds'];
        if (this.disabledDate === function () {
          return  !_this2.value[0];
        }) {
          var disabled = disabledTypes.reduce(function (obj, type) {
            obj[type] = _this2[type];
            return obj;
          }, {});
          return disabled;
        } else {
          var slots = [24, 60, 60];
          var _disabled = ['Hours', 'Minutes', 'Seconds'].map(function (type) {
            return _this2["disabled".concat(type)];
          });
          var disabledHMS = _disabled.map(function (preDisabled, j) {
            var slot = slots[j];
            var toDisable = preDisabled;
            var _loop = function _loop(i) {
              var hms = _this2.timeSlots.map(function (slot, x) {
                return x === j ? i : slot;
              });
              var testDateTime = mergeDateHMS.apply(void 0, [_this2.date].concat(_toConsumableArray(hms)));
              if (_this2.disabledDate(testDateTime, true)) {
                toDisable.push(i);
              }
            };
            for (var i = 0; i < slot; i += _this2.steps[j] || 1) {
              _loop(i);
            }
            return toDisable.filter(function (el, i, arr) {
              return arr.indexOf(el) === i;
            });
          });
          return disabledTypes.reduce(function (obj, type, i) {
            obj[type] = disabledHMS[i];
            return obj;
          }, {});
        }
      }
    },
    watch: {
      value: function value(dates) {
        var newVal = dates[0] || initTime();
        newVal = new Date(newVal);
        this.date = newVal;
      }
    },
    mounted: function mounted() {
      if (this.$parent && this.$parent.$options.name === 'DatePanel') {
        this.showDate = true;
      }
    },
    methods: {
      handleChange: function handleChange(date) {
        var _this3 = this;
        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var newDate = new Date(this.date);
        keys$1(date).forEach(function (type) {
          return newDate["set".concat(_this3.capitalize(type))](date[type]);
        });
        if (emit) {
          this.$emit('pick', newDate, 'time');
        }
      }
    }
  };

  /* script */
  var __vue_script__$3 = script$3;
  /* template */

  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper",
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-body",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [_vm._v(_vm._s(_vm.visibleDate))]) : _vm._e(), _c('div', {
      staticClass: "bk-picker-panel-content"
    }, [_c('time-spinner', {
      ref: "timeSpinner",
      attrs: {
        "show-seconds": _vm.showSeconds,
        "steps": _vm.steps,
        "hours": _vm.timeSlots[0],
        "minutes": _vm.timeSlots[1],
        "seconds": _vm.timeSlots[2],
        "disabled-hours": _vm.disabledHMS.disabledHours,
        "disabled-minutes": _vm.disabledHMS.disabledMinutes,
        "disabled-seconds": _vm.disabledHMS.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1)])]);
  };

  var __vue_staticRenderFns__$3 = [];
  /* style */

  var __vue_inject_styles__$3 = undefined;
  /* scoped */

  var __vue_scope_id__$3 = undefined;
  /* module identifier */

  var __vue_module_identifier__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$3 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$3 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$3,
    staticRenderFns: __vue_staticRenderFns__$3
  }, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

  var script$4 = {
    name: 'RangeTimePickerPanel',
    components: {
      TimeSpinner: __vue_component__$2
    },
    mixins: [timeMixins, panelMixins],
    props: {
      steps: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      format: {
        type: String,
        default: 'HH:mm:ss'
      },
      value: {
        type: Array,
        required: true
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      var _this$value$slice = this.value.slice(),
          _this$value$slice2 = _slicedToArray(_this$value$slice, 2),
          dateStart = _this$value$slice2[0],
          dateEnd = _this$value$slice2[1];
      return {
        showDate: false,
        dateStart: dateStart || initTime(),
        dateEnd: dateEnd || initTime()
      };
    },
    computed: {
      showSeconds: function showSeconds() {
        return !(this.format || '').match(/mm$/);
      },
      leftDatePanelLabel: function leftDatePanelLabel() {
        return fecha.format(this.$parent.dates[0], this.$parent.format);
      },
      rightDatePanelLabel: function rightDatePanelLabel() {
        return fecha.format(this.$parent.dates[1], this.$parent.format);
      }
    },
    watch: {
      value: function value(dates) {
        var _dates$slice = dates.slice(),
            _dates$slice2 = _slicedToArray(_dates$slice, 2),
            dateStart = _dates$slice2[0],
            dateEnd = _dates$slice2[1];
        this.dateStart = dateStart || initTime();
        this.dateEnd = dateEnd || initTime();
      }
    },
    mounted: function mounted() {
      if (this.$parent && this.$parent.$options.name === 'DateRangePanel') {
        this.showDate = true;
      }
    },
    methods: {
      handleChange: function handleChange(idx, start, end) {
        var _this = this;
        var emit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var dateStart = new Date(this.dateStart);
        var dateEnd = new Date(this.dateEnd);
        keys$1(start).forEach(function (type) {
          dateStart["set".concat(_this.capitalize(type))](start[type]);
        });
        keys$1(end).forEach(function (type) {
          dateEnd["set".concat(_this.capitalize(type))](end[type]);
        });
        if (!this.allowCrossDay && dateEnd < dateStart) {
          if (idx === 'start') {
            dateEnd = dateStart;
          }
          if (idx === 'end') {
            dateStart = dateEnd;
          }
        }
        if (emit) {
          this.$emit('pick', [dateStart, dateEnd], 'time');
        }
      },
      handleStartChange: function handleStartChange(date) {
        this.handleChange('start', date, {});
      },
      handleEndChange: function handleEndChange(date) {
        this.handleChange('end', {}, date);
      },
      updateScroll: function updateScroll() {
        this.$refs.timeSpinner.updateScroll();
        this.$refs.timeSpinnerEnd.updateScroll();
      }
    }
  };

  /* script */
  var __vue_script__$4 = script$4;
  /* template */

  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      staticClass: "bk-picker-panel-body-wrapper bk-time-picker-with-range",
      class: _vm.showSeconds ? 'bk-time-picker-with-seconds' : '',
      on: {
        "mousedown": function mousedown($event) {
          $event.preventDefault();
        }
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-body",
      style: {
        width: _vm.width * 2 + "px"
      }
    }, [_c('div', {
      staticClass: "bk-picker-panel-content bk-picker-panel-content-left",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [[_vm._v(_vm._s(_vm.leftDatePanelLabel))]], 2) : _vm._e(), _c('time-spinner', {
      ref: "timeSpinner",
      attrs: {
        "steps": _vm.steps,
        "show-seconds": _vm.showSeconds,
        "hours": _vm.value[0] && _vm.dateStart.getHours(),
        "minutes": _vm.value[0] && _vm.dateStart.getMinutes(),
        "seconds": _vm.value[0] && _vm.dateStart.getSeconds(),
        "disabled-hours": _vm.disabledHours,
        "disabled-minutes": _vm.disabledMinutes,
        "disabled-seconds": _vm.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleStartChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1), _c('div', {
      staticClass: "bk-picker-panel-content bk-picker-panel-content-right",
      style: {
        width: _vm.width + "px"
      }
    }, [_vm.showDate ? _c('div', {
      staticClass: "bk-time-picker-header"
    }, [[_vm._v(_vm._s(_vm.rightDatePanelLabel))]], 2) : _vm._e(), _c('time-spinner', {
      ref: "timeSpinnerEnd",
      attrs: {
        "steps": _vm.steps,
        "show-seconds": _vm.showSeconds,
        "hours": _vm.value[1] && _vm.dateEnd.getHours(),
        "minutes": _vm.value[1] && _vm.dateEnd.getMinutes(),
        "seconds": _vm.value[1] && _vm.dateEnd.getSeconds(),
        "disabled-hours": _vm.disabledHours,
        "disabled-minutes": _vm.disabledMinutes,
        "disabled-seconds": _vm.disabledSeconds,
        "hide-disabled-options": _vm.hideDisabledOptions
      },
      on: {
        "change": _vm.handleEndChange,
        "pick-click": _vm.handlePickClick
      }
    })], 1)])]);
  };

  var __vue_staticRenderFns__$4 = [];
  /* style */

  var __vue_inject_styles__$4 = undefined;
  /* scoped */

  var __vue_scope_id__$4 = undefined;
  /* module identifier */

  var __vue_module_identifier__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$4 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$4 = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__$4,
    staticRenderFns: __vue_staticRenderFns__$4
  }, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

  var bkTimePicker = {
    name: 'bk-time-picker',
    mixins: [__vue_component__$1, timeMixins],
    components: {
      TimePickerPanel: __vue_component__$3,
      RangeTimePickerPanel: __vue_component__$4
    },
    props: {
      type: {
        type: String,
        default: 'time',
        validator: function validator(value) {
          if (['time', 'timerange'].indexOf(value) < 0) {
            console.error("type property is not valid: '".concat(value, "'"));
            return false;
          }
          return true;
        }
      },
      allowCrossDay: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      panel: function panel() {
        var isRange = this.type === 'timerange';
        return isRange ? 'RangeTimePickerPanel' : 'TimePickerPanel';
      },
      ownPickerProps: function ownPickerProps() {
        return {
          disabledHours: this.disabledHours,
          disabledMinutes: this.disabledMinutes,
          disabledSeconds: this.disabledSeconds,
          hideDisabledOptions: this.hideDisabledOptions
        };
      }
    },
    watch: {
      visible: function visible(_visible) {
        var _this = this;
        if (_visible) {
          this.$nextTick(function () {
            var spinners = findChildComponents(_this, 'TimeSpinner');
            spinners.forEach(function (instance) {
              return instance.updateScroll();
            });
          });
        }
      }
    }
  };

  function setInstaller (component, afterInstall) {
    component.install = function (Vue) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = component.props || {};
      keys$1(options).forEach(function (key) {
        if (props.hasOwnProperty(key)) {
          if (typeof props[key] === 'function' || props[key] instanceof Array) {
            props[key] = {
              type: props[key],
              default: options[key]
            };
          } else {
            props[key].default = options[key];
          }
        }
      });
      component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
      Vue.component(component.name, component);
      typeof afterInstall === 'function' && afterInstall(Vue, options);
    };
  }

  setInstaller(bkTimePicker);

  exports.default = bkTimePicker;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
