(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('path')) :
	typeof define === 'function' && define.amd ? define(['exports', 'path'], factory) :
	(global = global || self, factory(global.library = {}, global.path));
}(this, function (exports, path) { 'use strict';

	path = path && path.hasOwnProperty('default') ? path['default'] : path;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var diff = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	   factory(exports) ;
	}(commonjsGlobal, function (exports) {  function Diff() {}
	  Diff.prototype = {
	    diff: function diff(oldString, newString) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var callback = options.callback;
	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }
	      this.options = options;
	      var self = this;
	      function done(value) {
	        if (callback) {
	          setTimeout(function () {
	            callback(undefined, value);
	          }, 0);
	          return true;
	        } else {
	          return value;
	        }
	      }
	      oldString = this.castInput(oldString);
	      newString = this.castInput(newString);
	      oldString = this.removeEmpty(this.tokenize(oldString));
	      newString = this.removeEmpty(this.tokenize(newString));
	      var newLen = newString.length,
	          oldLen = oldString.length;
	      var editLength = 1;
	      var maxEditLength = newLen + oldLen;
	      var bestPath = [{
	        newPos: -1,
	        components: []
	      }];
	      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
	      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
	        return done([{
	          value: this.join(newString),
	          count: newString.length
	        }]);
	      }
	      function execEditLength() {
	        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
	          var basePath = void 0;
	          var addPath = bestPath[diagonalPath - 1],
	              removePath = bestPath[diagonalPath + 1],
	              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
	          if (addPath) {
	            bestPath[diagonalPath - 1] = undefined;
	          }
	          var canAdd = addPath && addPath.newPos + 1 < newLen,
	              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
	          if (!canAdd && !canRemove) {
	            bestPath[diagonalPath] = undefined;
	            continue;
	          }
	          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
	            basePath = clonePath(removePath);
	            self.pushComponent(basePath.components, undefined, true);
	          } else {
	            basePath = addPath;
	            basePath.newPos++;
	            self.pushComponent(basePath.components, true, undefined);
	          }
	          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
	          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
	            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
	          } else {
	            bestPath[diagonalPath] = basePath;
	          }
	        }
	        editLength++;
	      }
	      if (callback) {
	        (function exec() {
	          setTimeout(function () {
	            if (editLength > maxEditLength) {
	              return callback();
	            }
	            if (!execEditLength()) {
	              exec();
	            }
	          }, 0);
	        })();
	      } else {
	        while (editLength <= maxEditLength) {
	          var ret = execEditLength();
	          if (ret) {
	            return ret;
	          }
	        }
	      }
	    },
	    pushComponent: function pushComponent(components, added, removed) {
	      var last = components[components.length - 1];
	      if (last && last.added === added && last.removed === removed) {
	        components[components.length - 1] = {
	          count: last.count + 1,
	          added: added,
	          removed: removed
	        };
	      } else {
	        components.push({
	          count: 1,
	          added: added,
	          removed: removed
	        });
	      }
	    },
	    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
	      var newLen = newString.length,
	          oldLen = oldString.length,
	          newPos = basePath.newPos,
	          oldPos = newPos - diagonalPath,
	          commonCount = 0;
	      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
	        newPos++;
	        oldPos++;
	        commonCount++;
	      }
	      if (commonCount) {
	        basePath.components.push({
	          count: commonCount
	        });
	      }
	      basePath.newPos = newPos;
	      return oldPos;
	    },
	    equals: function equals(left, right) {
	      if (this.options.comparator) {
	        return this.options.comparator(left, right);
	      } else {
	        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
	      }
	    },
	    removeEmpty: function removeEmpty(array) {
	      var ret = [];
	      for (var i = 0; i < array.length; i++) {
	        if (array[i]) {
	          ret.push(array[i]);
	        }
	      }
	      return ret;
	    },
	    castInput: function castInput(value) {
	      return value;
	    },
	    tokenize: function tokenize(value) {
	      return value.split('');
	    },
	    join: function join(chars) {
	      return chars.join('');
	    }
	  };
	  function buildValues(diff, components, newString, oldString, useLongestToken) {
	    var componentPos = 0,
	        componentLen = components.length,
	        newPos = 0,
	        oldPos = 0;
	    for (; componentPos < componentLen; componentPos++) {
	      var component = components[componentPos];
	      if (!component.removed) {
	        if (!component.added && useLongestToken) {
	          var value = newString.slice(newPos, newPos + component.count);
	          value = value.map(function (value, i) {
	            var oldValue = oldString[oldPos + i];
	            return oldValue.length > value.length ? oldValue : value;
	          });
	          component.value = diff.join(value);
	        } else {
	          component.value = diff.join(newString.slice(newPos, newPos + component.count));
	        }
	        newPos += component.count;
	        if (!component.added) {
	          oldPos += component.count;
	        }
	      } else {
	        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
	        oldPos += component.count;
	        if (componentPos && components[componentPos - 1].added) {
	          var tmp = components[componentPos - 1];
	          components[componentPos - 1] = components[componentPos];
	          components[componentPos] = tmp;
	        }
	      }
	    }
	    var lastComponent = components[componentLen - 1];
	    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
	      components[componentLen - 2].value += lastComponent.value;
	      components.pop();
	    }
	    return components;
	  }
	  function clonePath(path) {
	    return {
	      newPos: path.newPos,
	      components: path.components.slice(0)
	    };
	  }
	  var characterDiff = new Diff();
	  function diffChars(oldStr, newStr, options) {
	    return characterDiff.diff(oldStr, newStr, options);
	  }
	  function generateOptions(options, defaults) {
	    if (typeof options === 'function') {
	      defaults.callback = options;
	    } else if (options) {
	      for (var name in options) {
	        if (options.hasOwnProperty(name)) {
	          defaults[name] = options[name];
	        }
	      }
	    }
	    return defaults;
	  }
	  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
	  var reWhitespace = /\S/;
	  var wordDiff = new Diff();
	  wordDiff.equals = function (left, right) {
	    if (this.options.ignoreCase) {
	      left = left.toLowerCase();
	      right = right.toLowerCase();
	    }
	    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
	  };
	  wordDiff.tokenize = function (value) {
	    var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/);
	    for (var i = 0; i < tokens.length - 1; i++) {
	      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
	        tokens[i] += tokens[i + 2];
	        tokens.splice(i + 1, 2);
	        i--;
	      }
	    }
	    return tokens;
	  };
	  function diffWords(oldStr, newStr, options) {
	    options = generateOptions(options, {
	      ignoreWhitespace: true
	    });
	    return wordDiff.diff(oldStr, newStr, options);
	  }
	  function diffWordsWithSpace(oldStr, newStr, options) {
	    return wordDiff.diff(oldStr, newStr, options);
	  }
	  var lineDiff = new Diff();
	  lineDiff.tokenize = function (value) {
	    var retLines = [],
	        linesAndNewlines = value.split(/(\n|\r\n)/);
	    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
	      linesAndNewlines.pop();
	    }
	    for (var i = 0; i < linesAndNewlines.length; i++) {
	      var line = linesAndNewlines[i];
	      if (i % 2 && !this.options.newlineIsToken) {
	        retLines[retLines.length - 1] += line;
	      } else {
	        if (this.options.ignoreWhitespace) {
	          line = line.trim();
	        }
	        retLines.push(line);
	      }
	    }
	    return retLines;
	  };
	  function diffLines(oldStr, newStr, callback) {
	    return lineDiff.diff(oldStr, newStr, callback);
	  }
	  function diffTrimmedLines(oldStr, newStr, callback) {
	    var options = generateOptions(callback, {
	      ignoreWhitespace: true
	    });
	    return lineDiff.diff(oldStr, newStr, options);
	  }
	  var sentenceDiff = new Diff();
	  sentenceDiff.tokenize = function (value) {
	    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
	  };
	  function diffSentences(oldStr, newStr, callback) {
	    return sentenceDiff.diff(oldStr, newStr, callback);
	  }
	  var cssDiff = new Diff();
	  cssDiff.tokenize = function (value) {
	    return value.split(/([{}:;,]|\s+)/);
	  };
	  function diffCss(oldStr, newStr, callback) {
	    return cssDiff.diff(oldStr, newStr, callback);
	  }
	  function _typeof(obj) {
	    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	      _typeof = function (obj) {
	        return typeof obj;
	      };
	    } else {
	      _typeof = function (obj) {
	        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	      };
	    }
	    return _typeof(obj);
	  }
	  function _toConsumableArray(arr) {
	    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	  }
	  function _arrayWithoutHoles(arr) {
	    if (Array.isArray(arr)) {
	      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
	      return arr2;
	    }
	  }
	  function _iterableToArray(iter) {
	    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	  }
	  function _nonIterableSpread() {
	    throw new TypeError("Invalid attempt to spread non-iterable instance");
	  }
	  var objectPrototypeToString = Object.prototype.toString;
	  var jsonDiff = new Diff();
	  jsonDiff.useLongestToken = true;
	  jsonDiff.tokenize = lineDiff.tokenize;
	  jsonDiff.castInput = function (value) {
	    var _this$options = this.options,
	        undefinedReplacement = _this$options.undefinedReplacement,
	        _this$options$stringi = _this$options.stringifyReplacer,
	        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
	      return typeof v === 'undefined' ? undefinedReplacement : v;
	    } : _this$options$stringi;
	    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
	  };
	  jsonDiff.equals = function (left, right) {
	    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
	  };
	  function diffJson(oldObj, newObj, options) {
	    return jsonDiff.diff(oldObj, newObj, options);
	  }
	  function canonicalize(obj, stack, replacementStack, replacer, key) {
	    stack = stack || [];
	    replacementStack = replacementStack || [];
	    if (replacer) {
	      obj = replacer(key, obj);
	    }
	    var i;
	    for (i = 0; i < stack.length; i += 1) {
	      if (stack[i] === obj) {
	        return replacementStack[i];
	      }
	    }
	    var canonicalizedObj;
	    if ('[object Array]' === objectPrototypeToString.call(obj)) {
	      stack.push(obj);
	      canonicalizedObj = new Array(obj.length);
	      replacementStack.push(canonicalizedObj);
	      for (i = 0; i < obj.length; i += 1) {
	        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
	      }
	      stack.pop();
	      replacementStack.pop();
	      return canonicalizedObj;
	    }
	    if (obj && obj.toJSON) {
	      obj = obj.toJSON();
	    }
	    if (_typeof(obj) === 'object' && obj !== null) {
	      stack.push(obj);
	      canonicalizedObj = {};
	      replacementStack.push(canonicalizedObj);
	      var sortedKeys = [],
	          _key;
	      for (_key in obj) {
	        if (obj.hasOwnProperty(_key)) {
	          sortedKeys.push(_key);
	        }
	      }
	      sortedKeys.sort();
	      for (i = 0; i < sortedKeys.length; i += 1) {
	        _key = sortedKeys[i];
	        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
	      }
	      stack.pop();
	      replacementStack.pop();
	    } else {
	      canonicalizedObj = obj;
	    }
	    return canonicalizedObj;
	  }
	  var arrayDiff = new Diff();
	  arrayDiff.tokenize = function (value) {
	    return value.slice();
	  };
	  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
	    return value;
	  };
	  function diffArrays(oldArr, newArr, callback) {
	    return arrayDiff.diff(oldArr, newArr, callback);
	  }
	  function parsePatch(uniDiff) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
	        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	        list = [],
	        i = 0;
	    function parseIndex() {
	      var index = {};
	      list.push(index);
	      while (i < diffstr.length) {
	        var line = diffstr[i];
	        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
	          break;
	        }
	        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
	        if (header) {
	          index.index = header[1];
	        }
	        i++;
	      }
	      parseFileHeader(index);
	      parseFileHeader(index);
	      index.hunks = [];
	      while (i < diffstr.length) {
	        var _line = diffstr[i];
	        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
	          break;
	        } else if (/^@@/.test(_line)) {
	          index.hunks.push(parseHunk());
	        } else if (_line && options.strict) {
	          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
	        } else {
	          i++;
	        }
	      }
	    }
	    function parseFileHeader(index) {
	      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
	      if (fileHeader) {
	        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
	        var data = fileHeader[2].split('\t', 2);
	        var fileName = data[0].replace(/\\\\/g, '\\');
	        if (/^".*"$/.test(fileName)) {
	          fileName = fileName.substr(1, fileName.length - 2);
	        }
	        index[keyPrefix + 'FileName'] = fileName;
	        index[keyPrefix + 'Header'] = (data[1] || '').trim();
	        i++;
	      }
	    }
	    function parseHunk() {
	      var chunkHeaderIndex = i,
	          chunkHeaderLine = diffstr[i++],
	          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
	      var hunk = {
	        oldStart: +chunkHeader[1],
	        oldLines: +chunkHeader[2] || 1,
	        newStart: +chunkHeader[3],
	        newLines: +chunkHeader[4] || 1,
	        lines: [],
	        linedelimiters: []
	      };
	      var addCount = 0,
	          removeCount = 0;
	      for (; i < diffstr.length; i++) {
	        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
	          break;
	        }
	        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];
	        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
	          hunk.lines.push(diffstr[i]);
	          hunk.linedelimiters.push(delimiters[i] || '\n');
	          if (operation === '+') {
	            addCount++;
	          } else if (operation === '-') {
	            removeCount++;
	          } else if (operation === ' ') {
	            addCount++;
	            removeCount++;
	          }
	        } else {
	          break;
	        }
	      }
	      if (!addCount && hunk.newLines === 1) {
	        hunk.newLines = 0;
	      }
	      if (!removeCount && hunk.oldLines === 1) {
	        hunk.oldLines = 0;
	      }
	      if (options.strict) {
	        if (addCount !== hunk.newLines) {
	          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	        }
	        if (removeCount !== hunk.oldLines) {
	          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
	        }
	      }
	      return hunk;
	    }
	    while (i < diffstr.length) {
	      parseIndex();
	    }
	    return list;
	  }
	  function distanceIterator (start, minLine, maxLine) {
	    var wantForward = true,
	        backwardExhausted = false,
	        forwardExhausted = false,
	        localOffset = 1;
	    return function iterator() {
	      if (wantForward && !forwardExhausted) {
	        if (backwardExhausted) {
	          localOffset++;
	        } else {
	          wantForward = false;
	        }
	        if (start + localOffset <= maxLine) {
	          return localOffset;
	        }
	        forwardExhausted = true;
	      }
	      if (!backwardExhausted) {
	        if (!forwardExhausted) {
	          wantForward = true;
	        }
	        if (minLine <= start - localOffset) {
	          return -localOffset++;
	        }
	        backwardExhausted = true;
	        return iterator();
	      }
	    };
	  }
	  function applyPatch(source, uniDiff) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    if (typeof uniDiff === 'string') {
	      uniDiff = parsePatch(uniDiff);
	    }
	    if (Array.isArray(uniDiff)) {
	      if (uniDiff.length > 1) {
	        throw new Error('applyPatch only works with a single input.');
	      }
	      uniDiff = uniDiff[0];
	    }
	    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
	        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
	        hunks = uniDiff.hunks,
	        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
	      return line === patchContent;
	    },
	        errorCount = 0,
	        fuzzFactor = options.fuzzFactor || 0,
	        minLine = 0,
	        offset = 0,
	        removeEOFNL,
	        addEOFNL;
	    function hunkFits(hunk, toPos) {
	      for (var j = 0; j < hunk.lines.length; j++) {
	        var line = hunk.lines[j],
	            operation = line.length > 0 ? line[0] : ' ',
	            content = line.length > 0 ? line.substr(1) : line;
	        if (operation === ' ' || operation === '-') {
	          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
	            errorCount++;
	            if (errorCount > fuzzFactor) {
	              return false;
	            }
	          }
	          toPos++;
	        }
	      }
	      return true;
	    }
	    for (var i = 0; i < hunks.length; i++) {
	      var hunk = hunks[i],
	          maxLine = lines.length - hunk.oldLines,
	          localOffset = 0,
	          toPos = offset + hunk.oldStart - 1;
	      var iterator = distanceIterator(toPos, minLine, maxLine);
	      for (; localOffset !== undefined; localOffset = iterator()) {
	        if (hunkFits(hunk, toPos + localOffset)) {
	          hunk.offset = offset += localOffset;
	          break;
	        }
	      }
	      if (localOffset === undefined) {
	        return false;
	      }
	      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
	    }
	    var diffOffset = 0;
	    for (var _i = 0; _i < hunks.length; _i++) {
	      var _hunk = hunks[_i],
	          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
	      diffOffset += _hunk.newLines - _hunk.oldLines;
	      if (_toPos < 0) {
	        _toPos = 0;
	      }
	      for (var j = 0; j < _hunk.lines.length; j++) {
	        var line = _hunk.lines[j],
	            operation = line.length > 0 ? line[0] : ' ',
	            content = line.length > 0 ? line.substr(1) : line,
	            delimiter = _hunk.linedelimiters[j];
	        if (operation === ' ') {
	          _toPos++;
	        } else if (operation === '-') {
	          lines.splice(_toPos, 1);
	          delimiters.splice(_toPos, 1);
	        } else if (operation === '+') {
	          lines.splice(_toPos, 0, content);
	          delimiters.splice(_toPos, 0, delimiter);
	          _toPos++;
	        } else if (operation === '\\') {
	          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
	          if (previousOperation === '+') {
	            removeEOFNL = true;
	          } else if (previousOperation === '-') {
	            addEOFNL = true;
	          }
	        }
	      }
	    }
	    if (removeEOFNL) {
	      while (!lines[lines.length - 1]) {
	        lines.pop();
	        delimiters.pop();
	      }
	    } else if (addEOFNL) {
	      lines.push('');
	      delimiters.push('\n');
	    }
	    for (var _k = 0; _k < lines.length - 1; _k++) {
	      lines[_k] = lines[_k] + delimiters[_k];
	    }
	    return lines.join('');
	  }
	  function applyPatches(uniDiff, options) {
	    if (typeof uniDiff === 'string') {
	      uniDiff = parsePatch(uniDiff);
	    }
	    var currentIndex = 0;
	    function processIndex() {
	      var index = uniDiff[currentIndex++];
	      if (!index) {
	        return options.complete();
	      }
	      options.loadFile(index, function (err, data) {
	        if (err) {
	          return options.complete(err);
	        }
	        var updatedContent = applyPatch(data, index, options);
	        options.patched(index, updatedContent, function (err) {
	          if (err) {
	            return options.complete(err);
	          }
	          processIndex();
	        });
	      });
	    }
	    processIndex();
	  }
	  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	    if (!options) {
	      options = {};
	    }
	    if (typeof options.context === 'undefined') {
	      options.context = 4;
	    }
	    var diff = diffLines(oldStr, newStr, options);
	    diff.push({
	      value: '',
	      lines: []
	    });
	    function contextLines(lines) {
	      return lines.map(function (entry) {
	        return ' ' + entry;
	      });
	    }
	    var hunks = [];
	    var oldRangeStart = 0,
	        newRangeStart = 0,
	        curRange = [],
	        oldLine = 1,
	        newLine = 1;
	    var _loop = function _loop(i) {
	      var current = diff[i],
	          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
	      current.lines = lines;
	      if (current.added || current.removed) {
	        var _curRange;
	        if (!oldRangeStart) {
	          var prev = diff[i - 1];
	          oldRangeStart = oldLine;
	          newRangeStart = newLine;
	          if (prev) {
	            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
	            oldRangeStart -= curRange.length;
	            newRangeStart -= curRange.length;
	          }
	        }
	        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {
	          return (current.added ? '+' : '-') + entry;
	        })));
	        if (current.added) {
	          newLine += lines.length;
	        } else {
	          oldLine += lines.length;
	        }
	      } else {
	        if (oldRangeStart) {
	          if (lines.length <= options.context * 2 && i < diff.length - 2) {
	            var _curRange2;
	            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
	          } else {
	            var _curRange3;
	            var contextSize = Math.min(lines.length, options.context);
	            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
	            var hunk = {
	              oldStart: oldRangeStart,
	              oldLines: oldLine - oldRangeStart + contextSize,
	              newStart: newRangeStart,
	              newLines: newLine - newRangeStart + contextSize,
	              lines: curRange
	            };
	            if (i >= diff.length - 2 && lines.length <= options.context) {
	              var oldEOFNewline = /\n$/.test(oldStr);
	              var newEOFNewline = /\n$/.test(newStr);
	              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
	              if (!oldEOFNewline && noNlBeforeAdds) {
	                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
	              }
	              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
	                curRange.push('\\ No newline at end of file');
	              }
	            }
	            hunks.push(hunk);
	            oldRangeStart = 0;
	            newRangeStart = 0;
	            curRange = [];
	          }
	        }
	        oldLine += lines.length;
	        newLine += lines.length;
	      }
	    };
	    for (var i = 0; i < diff.length; i++) {
	      _loop(i);
	    }
	    return {
	      oldFileName: oldFileName,
	      newFileName: newFileName,
	      oldHeader: oldHeader,
	      newHeader: newHeader,
	      hunks: hunks
	    };
	  }
	  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
	    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
	    var ret = [];
	    if (oldFileName == newFileName) {
	      ret.push('Index: ' + oldFileName);
	    }
	    ret.push('===================================================================');
	    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
	    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));
	    for (var i = 0; i < diff.hunks.length; i++) {
	      var hunk = diff.hunks[i];
	      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
	      ret.push.apply(ret, hunk.lines);
	    }
	    return ret.join('\n') + '\n';
	  }
	  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
	    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
	  }
	  function arrayEqual(a, b) {
	    if (a.length !== b.length) {
	      return false;
	    }
	    return arrayStartsWith(a, b);
	  }
	  function arrayStartsWith(array, start) {
	    if (start.length > array.length) {
	      return false;
	    }
	    for (var i = 0; i < start.length; i++) {
	      if (start[i] !== array[i]) {
	        return false;
	      }
	    }
	    return true;
	  }
	  function calcLineCount(hunk) {
	    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
	        oldLines = _calcOldNewLineCount.oldLines,
	        newLines = _calcOldNewLineCount.newLines;
	    if (oldLines !== undefined) {
	      hunk.oldLines = oldLines;
	    } else {
	      delete hunk.oldLines;
	    }
	    if (newLines !== undefined) {
	      hunk.newLines = newLines;
	    } else {
	      delete hunk.newLines;
	    }
	  }
	  function merge(mine, theirs, base) {
	    mine = loadPatch(mine, base);
	    theirs = loadPatch(theirs, base);
	    var ret = {};
	    if (mine.index || theirs.index) {
	      ret.index = mine.index || theirs.index;
	    }
	    if (mine.newFileName || theirs.newFileName) {
	      if (!fileNameChanged(mine)) {
	        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
	        ret.newFileName = theirs.newFileName || mine.newFileName;
	        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
	        ret.newHeader = theirs.newHeader || mine.newHeader;
	      } else if (!fileNameChanged(theirs)) {
	        ret.oldFileName = mine.oldFileName;
	        ret.newFileName = mine.newFileName;
	        ret.oldHeader = mine.oldHeader;
	        ret.newHeader = mine.newHeader;
	      } else {
	        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
	        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
	        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
	        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
	      }
	    }
	    ret.hunks = [];
	    var mineIndex = 0,
	        theirsIndex = 0,
	        mineOffset = 0,
	        theirsOffset = 0;
	    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
	      var mineCurrent = mine.hunks[mineIndex] || {
	        oldStart: Infinity
	      },
	          theirsCurrent = theirs.hunks[theirsIndex] || {
	        oldStart: Infinity
	      };
	      if (hunkBefore(mineCurrent, theirsCurrent)) {
	        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
	        mineIndex++;
	        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
	      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
	        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
	        theirsIndex++;
	        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
	      } else {
	        var mergedHunk = {
	          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
	          oldLines: 0,
	          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
	          newLines: 0,
	          lines: []
	        };
	        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
	        theirsIndex++;
	        mineIndex++;
	        ret.hunks.push(mergedHunk);
	      }
	    }
	    return ret;
	  }
	  function loadPatch(param, base) {
	    if (typeof param === 'string') {
	      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
	        return parsePatch(param)[0];
	      }
	      if (!base) {
	        throw new Error('Must provide a base reference or pass in a patch');
	      }
	      return structuredPatch(undefined, undefined, base, param);
	    }
	    return param;
	  }
	  function fileNameChanged(patch) {
	    return patch.newFileName && patch.newFileName !== patch.oldFileName;
	  }
	  function selectField(index, mine, theirs) {
	    if (mine === theirs) {
	      return mine;
	    } else {
	      index.conflict = true;
	      return {
	        mine: mine,
	        theirs: theirs
	      };
	    }
	  }
	  function hunkBefore(test, check) {
	    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
	  }
	  function cloneHunk(hunk, offset) {
	    return {
	      oldStart: hunk.oldStart,
	      oldLines: hunk.oldLines,
	      newStart: hunk.newStart + offset,
	      newLines: hunk.newLines,
	      lines: hunk.lines
	    };
	  }
	  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
	    var mine = {
	      offset: mineOffset,
	      lines: mineLines,
	      index: 0
	    },
	        their = {
	      offset: theirOffset,
	      lines: theirLines,
	      index: 0
	    };
	    insertLeading(hunk, mine, their);
	    insertLeading(hunk, their, mine);
	    while (mine.index < mine.lines.length && their.index < their.lines.length) {
	      var mineCurrent = mine.lines[mine.index],
	          theirCurrent = their.lines[their.index];
	      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
	        mutualChange(hunk, mine, their);
	      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
	        var _hunk$lines;
	        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
	      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
	        var _hunk$lines2;
	        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
	      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
	        removal(hunk, mine, their);
	      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
	        removal(hunk, their, mine, true);
	      } else if (mineCurrent === theirCurrent) {
	        hunk.lines.push(mineCurrent);
	        mine.index++;
	        their.index++;
	      } else {
	        conflict(hunk, collectChange(mine), collectChange(their));
	      }
	    }
	    insertTrailing(hunk, mine);
	    insertTrailing(hunk, their);
	    calcLineCount(hunk);
	  }
	  function mutualChange(hunk, mine, their) {
	    var myChanges = collectChange(mine),
	        theirChanges = collectChange(their);
	    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
	      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
	        var _hunk$lines3;
	        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
	        return;
	      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
	        var _hunk$lines4;
	        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
	        return;
	      }
	    } else if (arrayEqual(myChanges, theirChanges)) {
	      var _hunk$lines5;
	      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
	      return;
	    }
	    conflict(hunk, myChanges, theirChanges);
	  }
	  function removal(hunk, mine, their, swap) {
	    var myChanges = collectChange(mine),
	        theirChanges = collectContext(their, myChanges);
	    if (theirChanges.merged) {
	      var _hunk$lines6;
	      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
	    } else {
	      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
	    }
	  }
	  function conflict(hunk, mine, their) {
	    hunk.conflict = true;
	    hunk.lines.push({
	      conflict: true,
	      mine: mine,
	      theirs: their
	    });
	  }
	  function insertLeading(hunk, insert, their) {
	    while (insert.offset < their.offset && insert.index < insert.lines.length) {
	      var line = insert.lines[insert.index++];
	      hunk.lines.push(line);
	      insert.offset++;
	    }
	  }
	  function insertTrailing(hunk, insert) {
	    while (insert.index < insert.lines.length) {
	      var line = insert.lines[insert.index++];
	      hunk.lines.push(line);
	    }
	  }
	  function collectChange(state) {
	    var ret = [],
	        operation = state.lines[state.index][0];
	    while (state.index < state.lines.length) {
	      var line = state.lines[state.index];
	      if (operation === '-' && line[0] === '+') {
	        operation = '+';
	      }
	      if (operation === line[0]) {
	        ret.push(line);
	        state.index++;
	      } else {
	        break;
	      }
	    }
	    return ret;
	  }
	  function collectContext(state, matchChanges) {
	    var changes = [],
	        merged = [],
	        matchIndex = 0,
	        contextChanges = false,
	        conflicted = false;
	    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
	      var change = state.lines[state.index],
	          match = matchChanges[matchIndex];
	      if (match[0] === '+') {
	        break;
	      }
	      contextChanges = contextChanges || change[0] !== ' ';
	      merged.push(match);
	      matchIndex++;
	      if (change[0] === '+') {
	        conflicted = true;
	        while (change[0] === '+') {
	          changes.push(change);
	          change = state.lines[++state.index];
	        }
	      }
	      if (match.substr(1) === change.substr(1)) {
	        changes.push(change);
	        state.index++;
	      } else {
	        conflicted = true;
	      }
	    }
	    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
	      conflicted = true;
	    }
	    if (conflicted) {
	      return changes;
	    }
	    while (matchIndex < matchChanges.length) {
	      merged.push(matchChanges[matchIndex++]);
	    }
	    return {
	      merged: merged,
	      changes: changes
	    };
	  }
	  function allRemoves(changes) {
	    return changes.reduce(function (prev, change) {
	      return prev && change[0] === '-';
	    }, true);
	  }
	  function skipRemoveSuperset(state, removeChanges, delta) {
	    for (var i = 0; i < delta; i++) {
	      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
	      if (state.lines[state.index + i] !== ' ' + changeContent) {
	        return false;
	      }
	    }
	    state.index += delta;
	    return true;
	  }
	  function calcOldNewLineCount(lines) {
	    var oldLines = 0;
	    var newLines = 0;
	    lines.forEach(function (line) {
	      if (typeof line !== 'string') {
	        var myCount = calcOldNewLineCount(line.mine);
	        var theirCount = calcOldNewLineCount(line.theirs);
	        if (oldLines !== undefined) {
	          if (myCount.oldLines === theirCount.oldLines) {
	            oldLines += myCount.oldLines;
	          } else {
	            oldLines = undefined;
	          }
	        }
	        if (newLines !== undefined) {
	          if (myCount.newLines === theirCount.newLines) {
	            newLines += myCount.newLines;
	          } else {
	            newLines = undefined;
	          }
	        }
	      } else {
	        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
	          newLines++;
	        }
	        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
	          oldLines++;
	        }
	      }
	    });
	    return {
	      oldLines: oldLines,
	      newLines: newLines
	    };
	  }
	  function convertChangesToDMP(changes) {
	    var ret = [],
	        change,
	        operation;
	    for (var i = 0; i < changes.length; i++) {
	      change = changes[i];
	      if (change.added) {
	        operation = 1;
	      } else if (change.removed) {
	        operation = -1;
	      } else {
	        operation = 0;
	      }
	      ret.push([operation, change.value]);
	    }
	    return ret;
	  }
	  function convertChangesToXML(changes) {
	    var ret = [];
	    for (var i = 0; i < changes.length; i++) {
	      var change = changes[i];
	      if (change.added) {
	        ret.push('<ins>');
	      } else if (change.removed) {
	        ret.push('<del>');
	      }
	      ret.push(escapeHTML(change.value));
	      if (change.added) {
	        ret.push('</ins>');
	      } else if (change.removed) {
	        ret.push('</del>');
	      }
	    }
	    return ret.join('');
	  }
	  function escapeHTML(s) {
	    var n = s;
	    n = n.replace(/&/g, '&amp;');
	    n = n.replace(/</g, '&lt;');
	    n = n.replace(/>/g, '&gt;');
	    n = n.replace(/"/g, '&quot;');
	    return n;
	  }
	  exports.Diff = Diff;
	  exports.diffChars = diffChars;
	  exports.diffWords = diffWords;
	  exports.diffWordsWithSpace = diffWordsWithSpace;
	  exports.diffLines = diffLines;
	  exports.diffTrimmedLines = diffTrimmedLines;
	  exports.diffSentences = diffSentences;
	  exports.diffCss = diffCss;
	  exports.diffJson = diffJson;
	  exports.diffArrays = diffArrays;
	  exports.structuredPatch = structuredPatch;
	  exports.createTwoFilesPatch = createTwoFilesPatch;
	  exports.createPatch = createPatch;
	  exports.applyPatch = applyPatch;
	  exports.applyPatches = applyPatches;
	  exports.parsePatch = parsePatch;
	  exports.merge = merge;
	  exports.convertChangesToDMP = convertChangesToDMP;
	  exports.convertChangesToXML = convertChangesToXML;
	  exports.canonicalize = canonicalize;
	  Object.defineProperty(exports, '__esModule', { value: true });
	}));
	});
	unwrapExports(diff);
	var diff_1 = diff.createPatch;

	var merge = createCommonjsModule(function (module) {
	(function(isNode) {
		var Public = function(clone) {
			return merge(clone === true, false, arguments);
		}, publicName = 'merge';
		Public.recursive = function(clone) {
			return merge(clone === true, true, arguments);
		};
		Public.clone = function(input) {
			var output = input,
				type = typeOf(input),
				index, size;
			if (type === 'array') {
				output = [];
				size = input.length;
				for (index=0;index<size;++index)
					output[index] = Public.clone(input[index]);
			} else if (type === 'object') {
				output = {};
				for (index in input)
					output[index] = Public.clone(input[index]);
			}
			return output;
		};
		function merge_recursive(base, extend) {
			if (typeOf(base) !== 'object')
				return extend;
			for (var key in extend) {
				if (typeOf(base[key]) === 'object' && typeOf(extend[key]) === 'object') {
					base[key] = merge_recursive(base[key], extend[key]);
				} else {
					base[key] = extend[key];
				}
			}
			return base;
		}
		function merge(clone, recursive, argv) {
			var result = argv[0],
				size = argv.length;
			if (clone || typeOf(result) !== 'object')
				result = {};
			for (var index=0;index<size;++index) {
				var item = argv[index],
					type = typeOf(item);
				if (type !== 'object') continue;
				for (var key in item) {
					if (key === '__proto__') continue;
					var sitem = clone ? Public.clone(item[key]) : item[key];
					if (recursive) {
						result[key] = merge_recursive(result[key], sitem);
					} else {
						result[key] = sitem;
					}
				}
			}
			return result;
		}
		function typeOf(input) {
			return ({}).toString.call(input).slice(8, -1).toLowerCase();
		}
		if (isNode) {
			module.exports = Public;
		} else {
			window[publicName] = Public;
		}
	})( module && 'object' === 'object' && module.exports);
	});

	var utils = createCommonjsModule(function (module) {
	(function() {
	  var merge$1 = merge;
	  function Utils() {
	  }
	  Utils.prototype.escape = function(str) {
	    return str.slice(0)
	      .replace(/&/g, '&amp;')
	      .replace(/</g, '&lt;')
	      .replace(/>/g, '&gt;')
	      .replace(/"/g, '&quot;')
	      .replace(/'/g, '&#x27;')
	      .replace(/\//g, '&#x2F;');
	  };
	  Utils.prototype.startsWith = function(str, start) {
	    if (typeof start === 'object') {
	      var result = false;
	      start.forEach(function(s) {
	        if (str.indexOf(s) === 0) {
	          result = true;
	        }
	      });
	      return result;
	    }
	    return str && str.indexOf(start) === 0;
	  };
	  Utils.prototype.valueOrEmpty = function(value) {
	    return value || '';
	  };
	  Utils.prototype.safeConfig = function(cfg, defaultConfig) {
	    return merge$1.recursive(true, defaultConfig, cfg);
	  };
	  module.exports.Utils = new Utils();
	})();
	});
	var utils_1 = utils.Utils;

	var diffParser = createCommonjsModule(function (module) {
	(function() {
	  var utils$1 = utils.Utils;
	  var LINE_TYPE = {
	    INSERTS: 'd2h-ins',
	    DELETES: 'd2h-del',
	    INSERT_CHANGES: 'd2h-ins d2h-change',
	    DELETE_CHANGES: 'd2h-del d2h-change',
	    CONTEXT: 'd2h-cntx',
	    INFO: 'd2h-info'
	  };
	  function DiffParser() {
	  }
	  DiffParser.prototype.LINE_TYPE = LINE_TYPE;
	  DiffParser.prototype.generateDiffJson = function(diffInput, configuration) {
	    var config = configuration || {};
	    var files = [];
	    var currentFile = null;
	    var currentBlock = null;
	    var oldLine = null;
	    var oldLine2 = null;
	    var newLine = null;
	    var possibleOldName;
	    var possibleNewName;
	    var oldFileNameHeader = '--- ';
	    var newFileNameHeader = '+++ ';
	    var hunkHeaderPrefix = '@@';
	    function saveBlock() {
	      if (currentBlock) {
	        currentFile.blocks.push(currentBlock);
	        currentBlock = null;
	      }
	    }
	    function saveFile() {
	      if (currentFile) {
	        if (!currentFile.oldName) {
	          currentFile.oldName = possibleOldName;
	        }
	        if (!currentFile.newName) {
	          currentFile.newName = possibleNewName;
	        }
	        if (currentFile.newName) {
	          files.push(currentFile);
	          currentFile = null;
	        }
	      }
	      possibleOldName = undefined;
	      possibleNewName = undefined;
	    }
	    function startFile() {
	      saveBlock();
	      saveFile();
	      currentFile = {};
	      currentFile.blocks = [];
	      currentFile.deletedLines = 0;
	      currentFile.addedLines = 0;
	    }
	    function startBlock(line) {
	      saveBlock();
	      var values;
	      if ((values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@.*/.exec(line))) {
	        currentFile.isCombined = false;
	        oldLine = values[1];
	        newLine = values[2];
	      } else if ((values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@.*/.exec(line))) {
	        currentFile.isCombined = true;
	        oldLine = values[1];
	        oldLine2 = values[2];
	        newLine = values[3];
	      } else {
	        if (utils$1.startsWith(line, hunkHeaderPrefix)) {
	          console.error('Failed to parse lines, starting in 0!');
	        }
	        oldLine = 0;
	        newLine = 0;
	        currentFile.isCombined = false;
	      }
	      currentBlock = {};
	      currentBlock.lines = [];
	      currentBlock.oldStartLine = oldLine;
	      currentBlock.oldStartLine2 = oldLine2;
	      currentBlock.newStartLine = newLine;
	      currentBlock.header = line;
	    }
	    function createLine(line) {
	      var currentLine = {};
	      currentLine.content = line;
	      var newLinePrefixes = !currentFile.isCombined ? ['+'] : ['+', ' +'];
	      var delLinePrefixes = !currentFile.isCombined ? ['-'] : ['-', ' -'];
	      if (utils$1.startsWith(line, newLinePrefixes)) {
	        currentFile.addedLines++;
	        currentLine.type = LINE_TYPE.INSERTS;
	        currentLine.oldNumber = null;
	        currentLine.newNumber = newLine++;
	        currentBlock.lines.push(currentLine);
	      } else if (utils$1.startsWith(line, delLinePrefixes)) {
	        currentFile.deletedLines++;
	        currentLine.type = LINE_TYPE.DELETES;
	        currentLine.oldNumber = oldLine++;
	        currentLine.newNumber = null;
	        currentBlock.lines.push(currentLine);
	      } else {
	        currentLine.type = LINE_TYPE.CONTEXT;
	        currentLine.oldNumber = oldLine++;
	        currentLine.newNumber = newLine++;
	        currentBlock.lines.push(currentLine);
	      }
	    }
	    function existHunkHeader(line, lineIdx) {
	      var idx = lineIdx;
	      while (idx < diffLines.length - 3) {
	        if (utils$1.startsWith(line, 'diff')) {
	          return false;
	        }
	        if (
	          utils$1.startsWith(diffLines[idx], oldFileNameHeader) &&
	          utils$1.startsWith(diffLines[idx + 1], newFileNameHeader) &&
	          utils$1.startsWith(diffLines[idx + 2], hunkHeaderPrefix)
	        ) {
	          return true;
	        }
	        idx++;
	      }
	      return false;
	    }
	    var diffLines =
	      diffInput.replace(/\\ No newline at end of file/g, '')
	        .replace(/\r\n?/g, '\n')
	        .split('\n');
	    var oldMode = /^old mode (\d{6})/;
	    var newMode = /^new mode (\d{6})/;
	    var deletedFileMode = /^deleted file mode (\d{6})/;
	    var newFileMode = /^new file mode (\d{6})/;
	    var copyFrom = /^copy from "?(.+)"?/;
	    var copyTo = /^copy to "?(.+)"?/;
	    var renameFrom = /^rename from "?(.+)"?/;
	    var renameTo = /^rename to "?(.+)"?/;
	    var similarityIndex = /^similarity index (\d+)%/;
	    var dissimilarityIndex = /^dissimilarity index (\d+)%/;
	    var index = /^index ([0-9a-z]+)\.\.([0-9a-z]+)\s*(\d{6})?/;
	    var binaryFiles = /^Binary files (.*) and (.*) differ/;
	    var binaryDiff = /^GIT binary patch/;
	    var combinedIndex = /^index ([0-9a-z]+),([0-9a-z]+)\.\.([0-9a-z]+)/;
	    var combinedMode = /^mode (\d{6}),(\d{6})\.\.(\d{6})/;
	    var combinedNewFile = /^new file mode (\d{6})/;
	    var combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
	    diffLines.forEach(function(line, lineIndex) {
	      if (!line || utils$1.startsWith(line, '*')) {
	        return;
	      }
	      var values;
	      var prevLine = diffLines[lineIndex - 1];
	      var nxtLine = diffLines[lineIndex + 1];
	      var afterNxtLine = diffLines[lineIndex + 2];
	      if (utils$1.startsWith(line, 'diff')) {
	        startFile();
	        var gitDiffStart = /^diff --git "?(.+)"? "?(.+)"?/;
	        if ((values = gitDiffStart.exec(line))) {
	          possibleOldName = _getFilename(null, values[1], config.dstPrefix);
	          possibleNewName = _getFilename(null, values[2], config.srcPrefix);
	        }
	        currentFile.isGitDiff = true;
	        return;
	      }
	      if (!currentFile ||
	        (
	          !currentFile.isGitDiff && currentFile &&
	          (
	            utils$1.startsWith(line, oldFileNameHeader) &&
	            utils$1.startsWith(nxtLine, newFileNameHeader) && utils$1.startsWith(afterNxtLine, hunkHeaderPrefix)
	          )
	        )
	      ) {
	        startFile();
	      }
	      if (
	        (utils$1.startsWith(line, oldFileNameHeader) &&
	        utils$1.startsWith(nxtLine, newFileNameHeader)) ||
	        (utils$1.startsWith(line, newFileNameHeader) &&
	        utils$1.startsWith(prevLine, oldFileNameHeader))
	      ) {
	        if (currentFile && !currentFile.oldName &&
	          utils$1.startsWith(line, '--- ') && (values = getSrcFilename(line, config))) {
	          currentFile.oldName = values;
	          currentFile.language = getExtension(currentFile.oldName, currentFile.language);
	          return;
	        }
	        if (currentFile && !currentFile.newName &&
	          utils$1.startsWith(line, '+++ ') && (values = getDstFilename(line, config))) {
	          currentFile.newName = values;
	          currentFile.language = getExtension(currentFile.newName, currentFile.language);
	          return;
	        }
	      }
	      if (
	        (currentFile && utils$1.startsWith(line, hunkHeaderPrefix)) ||
	        (currentFile.isGitDiff && currentFile && currentFile.oldName && currentFile.newName && !currentBlock)
	      ) {
	        startBlock(line);
	        return;
	      }
	      if (currentBlock && (utils$1.startsWith(line, '+') || utils$1.startsWith(line, '-') || utils$1.startsWith(line, ' '))) {
	        createLine(line);
	        return;
	      }
	      var doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
	      if ((values = oldMode.exec(line))) {
	        currentFile.oldMode = values[1];
	      } else if ((values = newMode.exec(line))) {
	        currentFile.newMode = values[1];
	      } else if ((values = deletedFileMode.exec(line))) {
	        currentFile.deletedFileMode = values[1];
	        currentFile.isDeleted = true;
	      } else if ((values = newFileMode.exec(line))) {
	        currentFile.newFileMode = values[1];
	        currentFile.isNew = true;
	      } else if ((values = copyFrom.exec(line))) {
	        if (doesNotExistHunkHeader) {
	          currentFile.oldName = values[1];
	        }
	        currentFile.isCopy = true;
	      } else if ((values = copyTo.exec(line))) {
	        if (doesNotExistHunkHeader) {
	          currentFile.newName = values[1];
	        }
	        currentFile.isCopy = true;
	      } else if ((values = renameFrom.exec(line))) {
	        if (doesNotExistHunkHeader) {
	          currentFile.oldName = values[1];
	        }
	        currentFile.isRename = true;
	      } else if ((values = renameTo.exec(line))) {
	        if (doesNotExistHunkHeader) {
	          currentFile.newName = values[1];
	        }
	        currentFile.isRename = true;
	      } else if ((values = binaryFiles.exec(line))) {
	        currentFile.isBinary = true;
	        currentFile.oldName = _getFilename(null, values[1], config.srcPrefix);
	        currentFile.newName = _getFilename(null, values[2], config.dstPrefix);
	        startBlock('Binary file');
	      } else if ((values = binaryDiff.exec(line))) {
	        currentFile.isBinary = true;
	        startBlock(line);
	      } else if ((values = similarityIndex.exec(line))) {
	        currentFile.unchangedPercentage = values[1];
	      } else if ((values = dissimilarityIndex.exec(line))) {
	        currentFile.changedPercentage = values[1];
	      } else if ((values = index.exec(line))) {
	        currentFile.checksumBefore = values[1];
	        currentFile.checksumAfter = values[2];
	        values[3] && (currentFile.mode = values[3]);
	      } else if ((values = combinedIndex.exec(line))) {
	        currentFile.checksumBefore = [values[2], values[3]];
	        currentFile.checksumAfter = values[1];
	      } else if ((values = combinedMode.exec(line))) {
	        currentFile.oldMode = [values[2], values[3]];
	        currentFile.newMode = values[1];
	      } else if ((values = combinedNewFile.exec(line))) {
	        currentFile.newFileMode = values[1];
	        currentFile.isNew = true;
	      } else if ((values = combinedDeletedFile.exec(line))) {
	        currentFile.deletedFileMode = values[1];
	        currentFile.isDeleted = true;
	      }
	    });
	    saveBlock();
	    saveFile();
	    return files;
	  };
	  function getExtension(filename, language) {
	    var nameSplit = filename.split('.');
	    if (nameSplit.length > 1) {
	      return nameSplit[nameSplit.length - 1];
	    }
	    return language;
	  }
	  function getSrcFilename(line, cfg) {
	    return _getFilename('---', line, cfg.srcPrefix);
	  }
	  function getDstFilename(line, cfg) {
	    return _getFilename('\\+\\+\\+', line, cfg.dstPrefix);
	  }
	  function _getFilename(linePrefix, line, extraPrefix) {
	    var prefixes = ['a/', 'b/', 'i/', 'w/', 'c/', 'o/'];
	    if (extraPrefix) {
	      prefixes.push(extraPrefix);
	    }
	    var FilenameRegExp;
	    if (linePrefix) {
	      FilenameRegExp = new RegExp('^' + linePrefix + ' "?(.+?)"?$');
	    } else {
	      FilenameRegExp = new RegExp('^"?(.+?)"?$');
	    }
	    var filename;
	    var values = FilenameRegExp.exec(line);
	    if (values && values[1]) {
	      filename = values[1];
	      var matchingPrefixes = prefixes.filter(function(p) {
	        return filename.indexOf(p) === 0;
	      });
	      if (matchingPrefixes[0]) {
	        filename = filename.slice(matchingPrefixes[0].length);
	      }
	      filename = filename.replace(/\s+\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)? [-+]\d{4}.*$/, '');
	    }
	    return filename;
	  }
	  module.exports.DiffParser = new DiffParser();
	})();
	});
	var diffParser_1 = diffParser.DiffParser;

	var rematch = createCommonjsModule(function (module) {
	(function() {
	  var Rematch = {};
	  function levenshtein(a, b) {
	    if (a.length === 0) {
	      return b.length;
	    }
	    if (b.length === 0) {
	      return a.length;
	    }
	    var matrix = [];
	    var i;
	    for (i = 0; i <= b.length; i++) {
	      matrix[i] = [i];
	    }
	    var j;
	    for (j = 0; j <= a.length; j++) {
	      matrix[0][j] = j;
	    }
	    for (i = 1; i <= b.length; i++) {
	      for (j = 1; j <= a.length; j++) {
	        if (b.charAt(i - 1) === a.charAt(j - 1)) {
	          matrix[i][j] = matrix[i - 1][j - 1];
	        } else {
	          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1,
	            Math.min(matrix[i][j - 1] + 1,
	              matrix[i - 1][j] + 1));
	        }
	      }
	    }
	    return matrix[b.length][a.length];
	  }
	  Rematch.levenshtein = levenshtein;
	  Rematch.distance = function distance(x, y) {
	    x = x.trim();
	    y = y.trim();
	    var lev = levenshtein(x, y);
	    var score = lev / (x.length + y.length);
	    return score;
	  };
	  Rematch.rematch = function rematch(distanceFunction) {
	    function findBestMatch(a, b, cache) {
	      var bestMatchDist = Infinity;
	      var bestMatch;
	      for (var i = 0; i < a.length; ++i) {
	        for (var j = 0; j < b.length; ++j) {
	          var cacheKey = JSON.stringify([a[i], b[j]]);
	          var md;
	          if (cache.hasOwnProperty(cacheKey)) {
	            md = cache[cacheKey];
	          } else {
	            md = distanceFunction(a[i], b[j]);
	            cache[cacheKey] = md;
	          }
	          if (md < bestMatchDist) {
	            bestMatchDist = md;
	            bestMatch = {indexA: i, indexB: j, score: bestMatchDist};
	          }
	        }
	      }
	      return bestMatch;
	    }
	    function group(a, b, level, cache) {
	      if (typeof (cache) === 'undefined') {
	        cache = {};
	      }
	      var bm = findBestMatch(a, b, cache);
	      if (!level) {
	        level = 0;
	      }
	      if (!bm || (a.length + b.length < 3)) {
	        return [[a, b]];
	      }
	      var a1 = a.slice(0, bm.indexA);
	      var b1 = b.slice(0, bm.indexB);
	      var aMatch = [a[bm.indexA]];
	      var bMatch = [b[bm.indexB]];
	      var tailA = bm.indexA + 1;
	      var tailB = bm.indexB + 1;
	      var a2 = a.slice(tailA);
	      var b2 = b.slice(tailB);
	      var group1 = group(a1, b1, level + 1, cache);
	      var groupMatch = group(aMatch, bMatch, level + 1, cache);
	      var group2 = group(a2, b2, level + 1, cache);
	      var result = groupMatch;
	      if (bm.indexA > 0 || bm.indexB > 0) {
	        result = group1.concat(result);
	      }
	      if (a.length > tailA || b.length > tailB) {
	        result = result.concat(group2);
	      }
	      return result;
	    }
	    return group;
	  };
	  module.exports.Rematch = Rematch;
	})();
	});
	var rematch_1 = rematch.Rematch;

	var printerUtils = createCommonjsModule(function (module) {
	(function() {
	  var jsDiff = diff;
	  var utils$1 = utils.Utils;
	  var Rematch = rematch.Rematch;
	  var separator = '/';
	  function PrinterUtils() {
	  }
	  PrinterUtils.prototype.separatePrefix = function(isCombined, line) {
	    var prefix;
	    var lineWithoutPrefix;
	    if (isCombined) {
	      prefix = line.substring(0, 2);
	      lineWithoutPrefix = line.substring(2);
	    } else {
	      prefix = line.substring(0, 1);
	      lineWithoutPrefix = line.substring(1);
	    }
	    return {
	      'prefix': prefix,
	      'line': lineWithoutPrefix
	    };
	  };
	  PrinterUtils.prototype.getHtmlId = function(file) {
	    var hashCode = function(text) {
	      var i, chr, len;
	      var hash = 0;
	      for (i = 0, len = text.length; i < len; i++) {
	        chr = text.charCodeAt(i);
	        hash = ((hash << 5) - hash) + chr;
	        hash |= 0;
	      }
	      return hash;
	    };
	    return 'd2h-' + hashCode(this.getDiffName(file)).toString().slice(-6);
	  };
	  PrinterUtils.prototype.getDiffName = function(file) {
	    var oldFilename = unifyPath(file.oldName);
	    var newFilename = unifyPath(file.newName);
	    if (oldFilename && newFilename && oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
	      var prefixPaths = [];
	      var suffixPaths = [];
	      var oldFilenameParts = oldFilename.split(separator);
	      var newFilenameParts = newFilename.split(separator);
	      var oldFilenamePartsSize = oldFilenameParts.length;
	      var newFilenamePartsSize = newFilenameParts.length;
	      var i = 0;
	      var j = oldFilenamePartsSize - 1;
	      var k = newFilenamePartsSize - 1;
	      while (i < j && i < k) {
	        if (oldFilenameParts[i] === newFilenameParts[i]) {
	          prefixPaths.push(newFilenameParts[i]);
	          i += 1;
	        } else {
	          break;
	        }
	      }
	      while (j > i && k > i) {
	        if (oldFilenameParts[j] === newFilenameParts[k]) {
	          suffixPaths.unshift(newFilenameParts[k]);
	          j -= 1;
	          k -= 1;
	        } else {
	          break;
	        }
	      }
	      var finalPrefix = prefixPaths.join(separator);
	      var finalSuffix = suffixPaths.join(separator);
	      var oldRemainingPath = oldFilenameParts.slice(i, j + 1).join(separator);
	      var newRemainingPath = newFilenameParts.slice(i, k + 1).join(separator);
	      if (finalPrefix.length && finalSuffix.length) {
	        return finalPrefix + separator + '{' + oldRemainingPath + ' → ' + newRemainingPath + '}' + separator + finalSuffix;
	      } else if (finalPrefix.length) {
	        return finalPrefix + separator + '{' + oldRemainingPath + ' → ' + newRemainingPath + '}';
	      } else if (finalSuffix.length) {
	        return '{' + oldRemainingPath + ' → ' + newRemainingPath + '}' + separator + finalSuffix;
	      }
	      return oldFilename + ' → ' + newFilename;
	    } else if (newFilename && !isDevNullName(newFilename)) {
	      return newFilename;
	    } else if (oldFilename) {
	      return oldFilename;
	    }
	    return 'unknown/file/path';
	  };
	  PrinterUtils.prototype.getFileTypeIcon = function(file) {
	    var templateName = 'file-changed';
	    if (file.isRename) {
	      templateName = 'file-renamed';
	    } else if (file.isCopy) {
	      templateName = 'file-renamed';
	    } else if (file.isNew) {
	      templateName = 'file-added';
	    } else if (file.isDeleted) {
	      templateName = 'file-deleted';
	    } else if (file.newName !== file.oldName) {
	      templateName = 'file-renamed';
	    }
	    return templateName;
	  };
	  PrinterUtils.prototype.diffHighlight = function(diffLine1, diffLine2, config) {
	    var linePrefix1, linePrefix2, unprefixedLine1, unprefixedLine2;
	    var prefixSize = 1;
	    if (config.isCombined) {
	      prefixSize = 2;
	    }
	    linePrefix1 = diffLine1.substr(0, prefixSize);
	    linePrefix2 = diffLine2.substr(0, prefixSize);
	    unprefixedLine1 = diffLine1.substr(prefixSize);
	    unprefixedLine2 = diffLine2.substr(prefixSize);
	    if (unprefixedLine1.length > config.maxLineLengthHighlight ||
	      unprefixedLine2.length > config.maxLineLengthHighlight) {
	      return {
	        first: {
	          prefix: linePrefix1,
	          line: utils$1.escape(unprefixedLine1)
	        },
	        second: {
	          prefix: linePrefix2,
	          line: utils$1.escape(unprefixedLine2)
	        }
	      };
	    }
	    var diff;
	    if (config.charByChar) {
	      diff = jsDiff.diffChars(unprefixedLine1, unprefixedLine2);
	    } else {
	      diff = jsDiff.diffWordsWithSpace(unprefixedLine1, unprefixedLine2);
	    }
	    var highlightedLine = '';
	    var changedWords = [];
	    if (!config.charByChar && config.matching === 'words') {
	      var treshold = 0.25;
	      if (typeof (config.matchWordsThreshold) !== 'undefined') {
	        treshold = config.matchWordsThreshold;
	      }
	      var matcher = Rematch.rematch(function(a, b) {
	        var amod = a.value;
	        var bmod = b.value;
	        return Rematch.distance(amod, bmod);
	      });
	      var removed = diff.filter(function isRemoved(element) {
	        return element.removed;
	      });
	      var added = diff.filter(function isAdded(element) {
	        return element.added;
	      });
	      var chunks = matcher(added, removed);
	      chunks.forEach(function(chunk) {
	        if (chunk[0].length === 1 && chunk[1].length === 1) {
	          var dist = Rematch.distance(chunk[0][0].value, chunk[1][0].value);
	          if (dist < treshold) {
	            changedWords.push(chunk[0][0]);
	            changedWords.push(chunk[1][0]);
	          }
	        }
	      });
	    }
	    diff.forEach(function(part) {
	      var addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : '';
	      var elemType = part.added ? 'ins' : part.removed ? 'del' : null;
	      var escapedValue = utils$1.escape(part.value);
	      if (elemType !== null) {
	        highlightedLine += '<' + elemType + addClass + '>' + escapedValue + '</' + elemType + '>';
	      } else {
	        highlightedLine += escapedValue;
	      }
	    });
	    return {
	      first: {
	        prefix: linePrefix1,
	        line: removeIns(highlightedLine)
	      },
	      second: {
	        prefix: linePrefix2,
	        line: removeDel(highlightedLine)
	      }
	    };
	  };
	  function unifyPath(path) {
	    if (path) {
	      return path.replace('\\', '/');
	    }
	    return path;
	  }
	  function isDevNullName(name) {
	    return name.indexOf('dev/null') !== -1;
	  }
	  function removeIns(line) {
	    return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, '');
	  }
	  function removeDel(line) {
	    return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, '');
	  }
	  module.exports.PrinterUtils = new PrinterUtils();
	})();
	});
	var printerUtils_1 = printerUtils.PrinterUtils;

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		'default': _nodeResolve_empty
	});

	var compiler = createCommonjsModule(function (module, exports) {
	(function (Hogan) {
	  var rIsWhitespace = /\S/,
	      rQuot = /\"/g,
	      rNewline =  /\n/g,
	      rCr = /\r/g,
	      rSlash = /\\/g,
	      rLineSep = /\u2028/,
	      rParagraphSep = /\u2029/;
	  Hogan.tags = {
	    '#': 1, '^': 2, '<': 3, '$': 4,
	    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
	    '{': 10, '&': 11, '_t': 12
	  };
	  Hogan.scan = function scan(text, delimiters) {
	    var len = text.length,
	        IN_TEXT = 0,
	        IN_TAG_TYPE = 1,
	        IN_TAG = 2,
	        state = IN_TEXT,
	        tagType = null,
	        tag = null,
	        buf = '',
	        tokens = [],
	        seenTag = false,
	        i = 0,
	        lineStart = 0,
	        otag = '{{',
	        ctag = '}}';
	    function addBuf() {
	      if (buf.length > 0) {
	        tokens.push({tag: '_t', text: new String(buf)});
	        buf = '';
	      }
	    }
	    function lineIsWhitespace() {
	      var isAllWhitespace = true;
	      for (var j = lineStart; j < tokens.length; j++) {
	        isAllWhitespace =
	          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||
	          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);
	        if (!isAllWhitespace) {
	          return false;
	        }
	      }
	      return isAllWhitespace;
	    }
	    function filterLine(haveSeenTag, noNewLine) {
	      addBuf();
	      if (haveSeenTag && lineIsWhitespace()) {
	        for (var j = lineStart, next; j < tokens.length; j++) {
	          if (tokens[j].text) {
	            if ((next = tokens[j+1]) && next.tag == '>') {
	              next.indent = tokens[j].text.toString();
	            }
	            tokens.splice(j, 1);
	          }
	        }
	      } else if (!noNewLine) {
	        tokens.push({tag:'\n'});
	      }
	      seenTag = false;
	      lineStart = tokens.length;
	    }
	    function changeDelimiters(text, index) {
	      var close = '=' + ctag,
	          closeIndex = text.indexOf(close, index),
	          delimiters = trim(
	            text.substring(text.indexOf('=', index) + 1, closeIndex)
	          ).split(' ');
	      otag = delimiters[0];
	      ctag = delimiters[delimiters.length - 1];
	      return closeIndex + close.length - 1;
	    }
	    if (delimiters) {
	      delimiters = delimiters.split(' ');
	      otag = delimiters[0];
	      ctag = delimiters[1];
	    }
	    for (i = 0; i < len; i++) {
	      if (state == IN_TEXT) {
	        if (tagChange(otag, text, i)) {
	          --i;
	          addBuf();
	          state = IN_TAG_TYPE;
	        } else {
	          if (text.charAt(i) == '\n') {
	            filterLine(seenTag);
	          } else {
	            buf += text.charAt(i);
	          }
	        }
	      } else if (state == IN_TAG_TYPE) {
	        i += otag.length - 1;
	        tag = Hogan.tags[text.charAt(i + 1)];
	        tagType = tag ? text.charAt(i + 1) : '_v';
	        if (tagType == '=') {
	          i = changeDelimiters(text, i);
	          state = IN_TEXT;
	        } else {
	          if (tag) {
	            i++;
	          }
	          state = IN_TAG;
	        }
	        seenTag = i;
	      } else {
	        if (tagChange(ctag, text, i)) {
	          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
	                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});
	          buf = '';
	          i += ctag.length - 1;
	          state = IN_TEXT;
	          if (tagType == '{') {
	            if (ctag == '}}') {
	              i++;
	            } else {
	              cleanTripleStache(tokens[tokens.length - 1]);
	            }
	          }
	        } else {
	          buf += text.charAt(i);
	        }
	      }
	    }
	    filterLine(seenTag, true);
	    return tokens;
	  };
	  function cleanTripleStache(token) {
	    if (token.n.substr(token.n.length - 1) === '}') {
	      token.n = token.n.substring(0, token.n.length - 1);
	    }
	  }
	  function trim(s) {
	    if (s.trim) {
	      return s.trim();
	    }
	    return s.replace(/^\s*|\s*$/g, '');
	  }
	  function tagChange(tag, text, index) {
	    if (text.charAt(index) != tag.charAt(0)) {
	      return false;
	    }
	    for (var i = 1, l = tag.length; i < l; i++) {
	      if (text.charAt(index + i) != tag.charAt(i)) {
	        return false;
	      }
	    }
	    return true;
	  }
	  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};
	  function buildTree(tokens, kind, stack, customTags) {
	    var instructions = [],
	        opener = null,
	        tail = null,
	        token = null;
	    tail = stack[stack.length - 1];
	    while (tokens.length > 0) {
	      token = tokens.shift();
	      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {
	        throw new Error('Illegal content in < super tag.');
	      }
	      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {
	        stack.push(token);
	        token.nodes = buildTree(tokens, token.tag, stack, customTags);
	      } else if (token.tag == '/') {
	        if (stack.length === 0) {
	          throw new Error('Closing tag without opener: /' + token.n);
	        }
	        opener = stack.pop();
	        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
	          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
	        }
	        opener.end = token.i;
	        return instructions;
	      } else if (token.tag == '\n') {
	        token.last = (tokens.length == 0) || (tokens[0].tag == '\n');
	      }
	      instructions.push(token);
	    }
	    if (stack.length > 0) {
	      throw new Error('missing closing tag: ' + stack.pop().n);
	    }
	    return instructions;
	  }
	  function isOpener(token, tags) {
	    for (var i = 0, l = tags.length; i < l; i++) {
	      if (tags[i].o == token.n) {
	        token.tag = '#';
	        return true;
	      }
	    }
	  }
	  function isCloser(close, open, tags) {
	    for (var i = 0, l = tags.length; i < l; i++) {
	      if (tags[i].c == close && tags[i].o == open) {
	        return true;
	      }
	    }
	  }
	  function stringifySubstitutions(obj) {
	    var items = [];
	    for (var key in obj) {
	      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
	    }
	    return "{ " + items.join(",") + " }";
	  }
	  function stringifyPartials(codeObj) {
	    var partials = [];
	    for (var key in codeObj.partials) {
	      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
	    }
	    return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
	  }
	  Hogan.stringify = function(codeObj, text, options) {
	    return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) +  "}";
	  };
	  var serialNo = 0;
	  Hogan.generate = function(tree, text, options) {
	    serialNo = 0;
	    var context = { code: '', subs: {}, partials: {} };
	    Hogan.walk(tree, context);
	    if (options.asString) {
	      return this.stringify(context, text, options);
	    }
	    return this.makeTemplate(context, text, options);
	  };
	  Hogan.wrapMain = function(code) {
	    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
	  };
	  Hogan.template = Hogan.Template;
	  Hogan.makeTemplate = function(codeObj, text, options) {
	    var template = this.makePartials(codeObj);
	    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));
	    return new this.template(template, text, this, options);
	  };
	  Hogan.makePartials = function(codeObj) {
	    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
	    for (key in template.partials) {
	      template.partials[key] = this.makePartials(template.partials[key]);
	    }
	    for (key in codeObj.subs) {
	      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);
	    }
	    return template;
	  };
	  function esc(s) {
	    return s.replace(rSlash, '\\\\')
	            .replace(rQuot, '\\\"')
	            .replace(rNewline, '\\n')
	            .replace(rCr, '\\r')
	            .replace(rLineSep, '\\u2028')
	            .replace(rParagraphSep, '\\u2029');
	  }
	  function chooseMethod(s) {
	    return (~s.indexOf('.')) ? 'd' : 'f';
	  }
	  function createPartial(node, context) {
	    var prefix = "<" + (context.prefix || "");
	    var sym = prefix + node.n + serialNo++;
	    context.partials[sym] = {name: node.n, partials: {}};
	    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
	    return sym;
	  }
	  Hogan.codegen = {
	    '#': function(node, context) {
	      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
	                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + " " + node.ctag + '")){' +
	                      't.rs(c,p,' + 'function(c,p,t){';
	      Hogan.walk(node.nodes, context);
	      context.code += '});c.pop();}';
	    },
	    '^': function(node, context) {
	      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
	      Hogan.walk(node.nodes, context);
	      context.code += '};';
	    },
	    '>': createPartial,
	    '<': function(node, context) {
	      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
	      Hogan.walk(node.nodes, ctx);
	      var template = context.partials[createPartial(node, context)];
	      template.subs = ctx.subs;
	      template.partials = ctx.partials;
	    },
	    '$': function(node, context) {
	      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
	      Hogan.walk(node.nodes, ctx);
	      context.subs[node.n] = ctx.code;
	      if (!context.inPartial) {
	        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
	      }
	    },
	    '\n': function(node, context) {
	      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
	    },
	    '_v': function(node, context) {
	      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
	    },
	    '_t': function(node, context) {
	      context.code += write('"' + esc(node.text) + '"');
	    },
	    '{': tripleStache,
	    '&': tripleStache
	  };
	  function tripleStache(node, context) {
	    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
	  }
	  function write(s) {
	    return 't.b(' + s + ');';
	  }
	  Hogan.walk = function(nodelist, context) {
	    var func;
	    for (var i = 0, l = nodelist.length; i < l; i++) {
	      func = Hogan.codegen[nodelist[i].tag];
	      func && func(nodelist[i], context);
	    }
	    return context;
	  };
	  Hogan.parse = function(tokens, text, options) {
	    options = options || {};
	    return buildTree(tokens, '', [], options.sectionTags || []);
	  };
	  Hogan.cache = {};
	  Hogan.cacheKey = function(text, options) {
	    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
	  };
	  Hogan.compile = function(text, options) {
	    options = options || {};
	    var key = Hogan.cacheKey(text, options);
	    var template = this.cache[key];
	    if (template) {
	      var partials = template.partials;
	      for (var name in partials) {
	        delete partials[name].instance;
	      }
	      return template;
	    }
	    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
	    return this.cache[key] = template;
	  };
	})( exports );
	});

	var template = createCommonjsModule(function (module, exports) {
	(function (Hogan) {
	  Hogan.Template = function (codeObj, text, compiler, options) {
	    codeObj = codeObj || {};
	    this.r = codeObj.code || this.r;
	    this.c = compiler;
	    this.options = options || {};
	    this.text = text || '';
	    this.partials = codeObj.partials || {};
	    this.subs = codeObj.subs || {};
	    this.buf = '';
	  };
	  Hogan.Template.prototype = {
	    r: function (context, partials, indent) { return ''; },
	    v: hoganEscape,
	    t: coerceToString,
	    render: function render(context, partials, indent) {
	      return this.ri([context], partials || {}, indent);
	    },
	    ri: function (context, partials, indent) {
	      return this.r(context, partials, indent);
	    },
	    ep: function(symbol, partials) {
	      var partial = this.partials[symbol];
	      var template = partials[partial.name];
	      if (partial.instance && partial.base == template) {
	        return partial.instance;
	      }
	      if (typeof template == 'string') {
	        if (!this.c) {
	          throw new Error("No compiler available.");
	        }
	        template = this.c.compile(template, this.options);
	      }
	      if (!template) {
	        return null;
	      }
	      this.partials[symbol].base = template;
	      if (partial.subs) {
	        if (!partials.stackText) partials.stackText = {};
	        for (key in partial.subs) {
	          if (!partials.stackText[key]) {
	            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
	          }
	        }
	        template = createSpecializedPartial(template, partial.subs, partial.partials,
	          this.stackSubs, this.stackPartials, partials.stackText);
	      }
	      this.partials[symbol].instance = template;
	      return template;
	    },
	    rp: function(symbol, context, partials, indent) {
	      var partial = this.ep(symbol, partials);
	      if (!partial) {
	        return '';
	      }
	      return partial.ri(context, partials, indent);
	    },
	    rs: function(context, partials, section) {
	      var tail = context[context.length - 1];
	      if (!isArray(tail)) {
	        section(context, partials, this);
	        return;
	      }
	      for (var i = 0; i < tail.length; i++) {
	        context.push(tail[i]);
	        section(context, partials, this);
	        context.pop();
	      }
	    },
	    s: function(val, ctx, partials, inverted, start, end, tags) {
	      var pass;
	      if (isArray(val) && val.length === 0) {
	        return false;
	      }
	      if (typeof val == 'function') {
	        val = this.ms(val, ctx, partials, inverted, start, end, tags);
	      }
	      pass = !!val;
	      if (!inverted && pass && ctx) {
	        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
	      }
	      return pass;
	    },
	    d: function(key, ctx, partials, returnFound) {
	      var found,
	          names = key.split('.'),
	          val = this.f(names[0], ctx, partials, returnFound),
	          doModelGet = this.options.modelGet,
	          cx = null;
	      if (key === '.' && isArray(ctx[ctx.length - 2])) {
	        val = ctx[ctx.length - 1];
	      } else {
	        for (var i = 1; i < names.length; i++) {
	          found = findInScope(names[i], val, doModelGet);
	          if (found !== undefined) {
	            cx = val;
	            val = found;
	          } else {
	            val = '';
	          }
	        }
	      }
	      if (returnFound && !val) {
	        return false;
	      }
	      if (!returnFound && typeof val == 'function') {
	        ctx.push(cx);
	        val = this.mv(val, ctx, partials);
	        ctx.pop();
	      }
	      return val;
	    },
	    f: function(key, ctx, partials, returnFound) {
	      var val = false,
	          v = null,
	          found = false,
	          doModelGet = this.options.modelGet;
	      for (var i = ctx.length - 1; i >= 0; i--) {
	        v = ctx[i];
	        val = findInScope(key, v, doModelGet);
	        if (val !== undefined) {
	          found = true;
	          break;
	        }
	      }
	      if (!found) {
	        return (returnFound) ? false : "";
	      }
	      if (!returnFound && typeof val == 'function') {
	        val = this.mv(val, ctx, partials);
	      }
	      return val;
	    },
	    ls: function(func, cx, partials, text, tags) {
	      var oldTags = this.options.delimiters;
	      this.options.delimiters = tags;
	      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
	      this.options.delimiters = oldTags;
	      return false;
	    },
	    ct: function(text, cx, partials) {
	      if (this.options.disableLambda) {
	        throw new Error('Lambda features disabled.');
	      }
	      return this.c.compile(text, this.options).render(cx, partials);
	    },
	    b: function(s) { this.buf += s; },
	    fl: function() { var r = this.buf; this.buf = ''; return r; },
	    ms: function(func, ctx, partials, inverted, start, end, tags) {
	      var textSource,
	          cx = ctx[ctx.length - 1],
	          result = func.call(cx);
	      if (typeof result == 'function') {
	        if (inverted) {
	          return true;
	        } else {
	          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
	          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
	        }
	      }
	      return result;
	    },
	    mv: function(func, ctx, partials) {
	      var cx = ctx[ctx.length - 1];
	      var result = func.call(cx);
	      if (typeof result == 'function') {
	        return this.ct(coerceToString(result.call(cx)), cx, partials);
	      }
	      return result;
	    },
	    sub: function(name, context, partials, indent) {
	      var f = this.subs[name];
	      if (f) {
	        this.activeSub = name;
	        f(context, partials, this, indent);
	        this.activeSub = false;
	      }
	    }
	  };
	  function findInScope(key, scope, doModelGet) {
	    var val;
	    if (scope && typeof scope == 'object') {
	      if (scope[key] !== undefined) {
	        val = scope[key];
	      } else if (doModelGet && scope.get && typeof scope.get == 'function') {
	        val = scope.get(key);
	      }
	    }
	    return val;
	  }
	  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
	    function PartialTemplate() {}    PartialTemplate.prototype = instance;
	    function Substitutions() {}    Substitutions.prototype = instance.subs;
	    var key;
	    var partial = new PartialTemplate();
	    partial.subs = new Substitutions();
	    partial.subsText = {};
	    partial.buf = '';
	    stackSubs = stackSubs || {};
	    partial.stackSubs = stackSubs;
	    partial.subsText = stackText;
	    for (key in subs) {
	      if (!stackSubs[key]) stackSubs[key] = subs[key];
	    }
	    for (key in stackSubs) {
	      partial.subs[key] = stackSubs[key];
	    }
	    stackPartials = stackPartials || {};
	    partial.stackPartials = stackPartials;
	    for (key in partials) {
	      if (!stackPartials[key]) stackPartials[key] = partials[key];
	    }
	    for (key in stackPartials) {
	      partial.partials[key] = stackPartials[key];
	    }
	    return partial;
	  }
	  var rAmp = /&/g,
	      rLt = /</g,
	      rGt = />/g,
	      rApos = /\'/g,
	      rQuot = /\"/g,
	      hChars = /[&<>\"\']/;
	  function coerceToString(val) {
	    return String((val === null || val === undefined) ? '' : val);
	  }
	  function hoganEscape(str) {
	    str = coerceToString(str);
	    return hChars.test(str) ?
	      str
	        .replace(rAmp, '&amp;')
	        .replace(rLt, '&lt;')
	        .replace(rGt, '&gt;')
	        .replace(rApos, '&#39;')
	        .replace(rQuot, '&quot;') :
	      str;
	  }
	  var isArray = Array.isArray || function(a) {
	    return Object.prototype.toString.call(a) === '[object Array]';
	  };
	})( exports );
	});

	compiler.Template = template.Template;
	compiler.template = compiler.Template;
	var hogan = compiler;

	var diff2htmlTemplates = createCommonjsModule(function (module) {
	(function() {
	if (!!!commonjsGlobal.browserTemplates) commonjsGlobal.browserTemplates = {};
	var Hogan = hogan;commonjsGlobal.browserTemplates["file-summary-line"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<li class=\"d2h-file-list-line\">");t.b("\n" + i);t.b("    <span class=\"d2h-file-name-wrapper\">");t.b("\n" + i);t.b(t.rp("<fileIcon0",c,p,"      "));t.b("      <a href=\"#");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-name\">");t.b(t.v(t.f("fileName",c,p,0)));t.b("</a>");t.b("\n" + i);t.b("      <span class=\"d2h-file-stats\">");t.b("\n" + i);t.b("          <span class=\"d2h-lines-added\">");t.b(t.v(t.f("addedLines",c,p,0)));t.b("</span>");t.b("\n" + i);t.b("          <span class=\"d2h-lines-deleted\">");t.b(t.v(t.f("deletedLines",c,p,0)));t.b("</span>");t.b("\n" + i);t.b("      </span>");t.b("\n" + i);t.b("    </span>");t.b("\n" + i);t.b("</li>");return t.fl(); },partials: {"<fileIcon0":{name:"fileIcon", partials: {}, subs: {  }}}, subs: {  }});
	commonjsGlobal.browserTemplates["file-summary-wrapper"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"d2h-file-list-wrapper\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-list-header\">");t.b("\n" + i);t.b("        <span class=\"d2h-file-list-title\">Files changed (");t.b(t.v(t.f("filesNumber",c,p,0)));t.b(")</span>");t.b("\n" + i);t.b("        <a class=\"d2h-file-switch d2h-hide\">hide</a>");t.b("\n" + i);t.b("        <a class=\"d2h-file-switch d2h-show\">show</a>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <ol class=\"d2h-file-list\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("files",c,p,0)));t.b("\n" + i);t.b("    </ol>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["generic-column-line-number"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("lineClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\"></td>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b(t.t(t.f("blockHeader",c,p,0)));t.b("</div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["generic-empty-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.d("diffParser.LINE_TYPE.INFO",c,p,0)));t.b("\">");t.b("\n" + i);t.b("            File without changes");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["generic-file-path"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-file-name-wrapper\">");t.b("\n" + i);t.b(t.rp("<fileIcon0",c,p,"    "));t.b("    <span class=\"d2h-file-name\">");t.b(t.v(t.f("fileDiffName",c,p,0)));t.b("</span>");t.b("\n" + i);t.b(t.rp("<fileTag1",c,p,"    "));t.b("</span>");return t.fl(); },partials: {"<fileIcon0":{name:"fileIcon", partials: {}, subs: {  }},"<fileTag1":{name:"fileTag", partials: {}, subs: {  }}}, subs: {  }});
	commonjsGlobal.browserTemplates["generic-line"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<tr>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("lineClass",c,p,0)));t.b(" ");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);t.b("      ");t.b(t.t(t.f("lineNumber",c,p,0)));t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("    <td class=\"");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);t.b("        <div class=\"");t.b(t.v(t.f("contentClass",c,p,0)));t.b(" ");t.b(t.v(t.f("type",c,p,0)));t.b("\">");t.b("\n" + i);if(t.s(t.f("prefix",c,p,1),c,p,0,171,247,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("            <span class=\"d2h-code-line-prefix\">");t.b(t.t(t.f("prefix",c,p,0)));t.b("</span>");t.b("\n" + i);});c.pop();}if(t.s(t.f("content",c,p,1),c,p,0,279,353,"{{ }}")){t.rs(c,p,function(c,p,t){t.b("            <span class=\"d2h-code-line-ctn\">");t.b(t.t(t.f("content",c,p,0)));t.b("</span>");t.b("\n" + i);});c.pop();}t.b("        </div>");t.b("\n" + i);t.b("    </td>");t.b("\n" + i);t.b("</tr>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["generic-wrapper"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"d2h-wrapper\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("content",c,p,0)));t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["icon-file-added"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-added\" height=\"16\" title=\"added\" version=\"1.1\" viewBox=\"0 0 14 16\"");t.b("\n" + i);t.b("     width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM6 9H3V7h3V4h2v3h3v2H8v3H6V9z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["icon-file-changed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-changed\" height=\"16\" title=\"modified\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM4 8c0-1.66 1.34-3 3-3s3 1.34 3 3-1.34 3-3 3-3-1.34-3-3z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["icon-file-deleted"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-deleted\" height=\"16\" title=\"removed\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M13 1H1C0.45 1 0 1.45 0 2v12c0 0.55 0.45 1 1 1h12c0.55 0 1-0.45 1-1V2c0-0.55-0.45-1-1-1z m0 13H1V2h12v12zM11 9H3V7h8v2z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["icon-file-renamed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon d2h-moved\" height=\"16\" title=\"renamed\" version=\"1.1\"");t.b("\n" + i);t.b("     viewBox=\"0 0 14 16\" width=\"14\">");t.b("\n" + i);t.b("    <path d=\"M6 9H3V7h3V4l5 4-5 4V9z m8-7v12c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h12c0.55 0 1 0.45 1 1z m-1 0H1v12h12V2z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["icon-file"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<svg aria-hidden=\"true\" class=\"d2h-icon\" height=\"16\" version=\"1.1\" viewBox=\"0 0 12 16\" width=\"12\">");t.b("\n" + i);t.b("    <path d=\"M6 5H2v-1h4v1zM2 8h7v-1H2v1z m0 2h7v-1H2v1z m0 2h7v-1H2v1z m10-7.5v9.5c0 0.55-0.45 1-1 1H1c-0.55 0-1-0.45-1-1V2c0-0.55 0.45-1 1-1h7.5l3.5 3.5z m-1 0.5L8 2H1v12h10V5z\"></path>");t.b("\n" + i);t.b("</svg>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["line-by-line-file-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div id=\"");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-wrapper\" data-lang=\"");t.b(t.v(t.d("file.language",c,p,0)));t.b("\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-header\">");t.b("\n" + i);t.b("    ");t.b(t.t(t.f("filePath",c,p,0)));t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <div class=\"d2h-file-diff\">");t.b("\n" + i);t.b("        <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("            <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                ");t.b(t.t(t.f("diffs",c,p,0)));t.b("\n" + i);t.b("                </tbody>");t.b("\n" + i);t.b("            </table>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["line-by-line-numbers"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div class=\"line-num1\">");t.b(t.v(t.f("oldNumber",c,p,0)));t.b("</div>");t.b("\n" + i);t.b("<div class=\"line-num2\">");t.b(t.v(t.f("newNumber",c,p,0)));t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["side-by-side-file-diff"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<div id=\"");t.b(t.v(t.f("fileHtmlId",c,p,0)));t.b("\" class=\"d2h-file-wrapper\" data-lang=\"");t.b(t.v(t.d("file.language",c,p,0)));t.b("\">");t.b("\n" + i);t.b("    <div class=\"d2h-file-header\">");t.b("\n" + i);t.b("      ");t.b(t.t(t.f("filePath",c,p,0)));t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("    <div class=\"d2h-files-diff\">");t.b("\n" + i);t.b("        <div class=\"d2h-file-side-diff\">");t.b("\n" + i);t.b("            <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("                <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                    <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                    ");t.b(t.t(t.d("diffs.left",c,p,0)));t.b("\n" + i);t.b("                    </tbody>");t.b("\n" + i);t.b("                </table>");t.b("\n" + i);t.b("            </div>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("        <div class=\"d2h-file-side-diff\">");t.b("\n" + i);t.b("            <div class=\"d2h-code-wrapper\">");t.b("\n" + i);t.b("                <table class=\"d2h-diff-table\">");t.b("\n" + i);t.b("                    <tbody class=\"d2h-diff-tbody\">");t.b("\n" + i);t.b("                    ");t.b(t.t(t.d("diffs.right",c,p,0)));t.b("\n" + i);t.b("                    </tbody>");t.b("\n" + i);t.b("                </table>");t.b("\n" + i);t.b("            </div>");t.b("\n" + i);t.b("        </div>");t.b("\n" + i);t.b("    </div>");t.b("\n" + i);t.b("</div>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["tag-file-added"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-added d2h-added-tag\">ADDED</span>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["tag-file-changed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-changed d2h-changed-tag\">CHANGED</span>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["tag-file-deleted"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-deleted d2h-deleted-tag\">DELETED</span>");return t.fl(); },partials: {}, subs: {  }});
	commonjsGlobal.browserTemplates["tag-file-renamed"] = new Hogan.Template({code: function (c,p,i) { var t=this;t.b(i=i||"");t.b("<span class=\"d2h-tag d2h-moved d2h-moved-tag\">RENAMED</span>");return t.fl(); },partials: {}, subs: {  }});
	module.exports = commonjsGlobal.browserTemplates;
	})();
	});

	var require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);

	var hoganjsUtils = createCommonjsModule(function (module) {
	(function() {
	  var fs = require$$0;
	  var path$1 = path;
	  var hogan$1 = hogan;
	  var hoganTemplates = diff2htmlTemplates;
	  var extraTemplates;
	  function HoganJsUtils(configuration) {
	    this.config = configuration || {};
	    extraTemplates = this.config.templates || {};
	    var rawTemplates = this.config.rawTemplates || {};
	    for (var templateName in rawTemplates) {
	      if (rawTemplates.hasOwnProperty(templateName)) {
	        if (!extraTemplates[templateName]) extraTemplates[templateName] = this.compile(rawTemplates[templateName]);
	      }
	    }
	  }
	  HoganJsUtils.prototype.render = function(namespace, view, params) {
	    var template = this.template(namespace, view);
	    if (template) {
	      return template.render(params);
	    }
	    return null;
	  };
	  HoganJsUtils.prototype.template = function(namespace, view) {
	    var templateKey = this._templateKey(namespace, view);
	    return this._getTemplate(templateKey);
	  };
	  HoganJsUtils.prototype._getTemplate = function(templateKey) {
	    var template;
	    if (!this.config.noCache) {
	      template = this._readFromCache(templateKey);
	    }
	    if (!template) {
	      template = this._loadTemplate(templateKey);
	    }
	    return template;
	  };
	  HoganJsUtils.prototype._loadTemplate = function(templateKey) {
	    var template;
	    try {
	      if (fs.readFileSync) {
	        var templatesPath = path$1.resolve(__dirname, 'templates');
	        var templatePath = path$1.join(templatesPath, templateKey);
	        var templateContent = fs.readFileSync(templatePath + '.mustache', 'utf8');
	        template = hogan$1.compile(templateContent);
	        hoganTemplates[templateKey] = template;
	      }
	    } catch (e) {
	      console.error('Failed to read (template: ' + templateKey + ') from fs: ' + e.message);
	    }
	    return template;
	  };
	  HoganJsUtils.prototype._readFromCache = function(templateKey) {
	    return extraTemplates[templateKey] || hoganTemplates[templateKey];
	  };
	  HoganJsUtils.prototype._templateKey = function(namespace, view) {
	    return namespace + '-' + view;
	  };
	  HoganJsUtils.prototype.compile = function(templateStr) {
	    return hogan$1.compile(templateStr);
	  };
	  module.exports.HoganJsUtils = HoganJsUtils;
	})();
	});
	var hoganjsUtils_1 = hoganjsUtils.HoganJsUtils;

	var lineByLinePrinter = createCommonjsModule(function (module) {
	(function() {
	  var diffParser$1 = diffParser.DiffParser;
	  var printerUtils$1 = printerUtils.PrinterUtils;
	  var utils$1 = utils.Utils;
	  var Rematch = rematch.Rematch;
	  var hoganUtils;
	  var genericTemplatesPath = 'generic';
	  var baseTemplatesPath = 'line-by-line';
	  var iconsBaseTemplatesPath = 'icon';
	  var tagsBaseTemplatesPath = 'tag';
	  function LineByLinePrinter(config) {
	    this.config = config;
	    var HoganJsUtils = hoganjsUtils.HoganJsUtils;
	    hoganUtils = new HoganJsUtils(config);
	  }
	  LineByLinePrinter.prototype.makeFileDiffHtml = function(file, diffs) {
	    if (this.config.renderNothingWhenEmpty && file.blocks && !file.blocks.length) return '';
	    var fileDiffTemplate = hoganUtils.template(baseTemplatesPath, 'file-diff');
	    var filePathTemplate = hoganUtils.template(genericTemplatesPath, 'file-path');
	    var fileIconTemplate = hoganUtils.template(iconsBaseTemplatesPath, 'file');
	    var fileTagTemplate = hoganUtils.template(tagsBaseTemplatesPath, printerUtils$1.getFileTypeIcon(file));
	    return fileDiffTemplate.render({
	      file: file,
	      fileHtmlId: printerUtils$1.getHtmlId(file),
	      diffs: diffs,
	      filePath: filePathTemplate.render({
	        fileDiffName: printerUtils$1.getDiffName(file)
	      }, {
	        fileIcon: fileIconTemplate,
	        fileTag: fileTagTemplate
	      })
	    });
	  };
	  LineByLinePrinter.prototype.makeLineByLineHtmlWrapper = function(content) {
	    return hoganUtils.render(genericTemplatesPath, 'wrapper', {'content': content});
	  };
	  LineByLinePrinter.prototype.generateLineByLineJsonHtml = function(diffFiles) {
	    var that = this;
	    var htmlDiffs = diffFiles.map(function(file) {
	      var diffs;
	      if (file.blocks.length) {
	        diffs = that._generateFileHtml(file);
	      } else {
	        diffs = that._generateEmptyDiff();
	      }
	      return that.makeFileDiffHtml(file, diffs);
	    });
	    return this.makeLineByLineHtmlWrapper(htmlDiffs.join('\n'));
	  };
	  var matcher = Rematch.rematch(function(a, b) {
	    var amod = a.content.substr(1);
	    var bmod = b.content.substr(1);
	    return Rematch.distance(amod, bmod);
	  });
	  LineByLinePrinter.prototype.makeColumnLineNumberHtml = function(block) {
	    return hoganUtils.render(genericTemplatesPath, 'column-line-number', {
	      diffParser: diffParser$1,
	      blockHeader: utils$1.escape(block.header),
	      lineClass: 'd2h-code-linenumber',
	      contentClass: 'd2h-code-line'
	    });
	  };
	  LineByLinePrinter.prototype._generateFileHtml = function(file) {
	    var that = this;
	    return file.blocks.map(function(block) {
	      var lines = that.makeColumnLineNumberHtml(block);
	      var oldLines = [];
	      var newLines = [];
	      function processChangeBlock() {
	        var matches;
	        var insertType;
	        var deleteType;
	        var comparisons = oldLines.length * newLines.length;
	        var maxComparisons = that.config.matchingMaxComparisons || 2500;
	        var doMatching = comparisons < maxComparisons && (that.config.matching === 'lines' ||
	          that.config.matching === 'words');
	        if (doMatching) {
	          matches = matcher(oldLines, newLines);
	          insertType = diffParser$1.LINE_TYPE.INSERT_CHANGES;
	          deleteType = diffParser$1.LINE_TYPE.DELETE_CHANGES;
	        } else {
	          matches = [[oldLines, newLines]];
	          insertType = diffParser$1.LINE_TYPE.INSERTS;
	          deleteType = diffParser$1.LINE_TYPE.DELETES;
	        }
	        matches.forEach(function(match) {
	          oldLines = match[0];
	          newLines = match[1];
	          var processedOldLines = [];
	          var processedNewLines = [];
	          var common = Math.min(oldLines.length, newLines.length);
	          var oldLine, newLine;
	          for (var j = 0; j < common; j++) {
	            oldLine = oldLines[j];
	            newLine = newLines[j];
	            that.config.isCombined = file.isCombined;
	            var diff = printerUtils$1.diffHighlight(oldLine.content, newLine.content, that.config);
	            processedOldLines +=
	              that.makeLineHtml(file.isCombined, deleteType, oldLine.oldNumber, oldLine.newNumber,
	                diff.first.line, diff.first.prefix);
	            processedNewLines +=
	              that.makeLineHtml(file.isCombined, insertType, newLine.oldNumber, newLine.newNumber,
	                diff.second.line, diff.second.prefix);
	          }
	          lines += processedOldLines + processedNewLines;
	          lines += that._processLines(file.isCombined, oldLines.slice(common), newLines.slice(common));
	        });
	        oldLines = [];
	        newLines = [];
	      }
	      for (var i = 0; i < block.lines.length; i++) {
	        var line = block.lines[i];
	        var escapedLine = utils$1.escape(line.content);
	        if (line.type !== diffParser$1.LINE_TYPE.INSERTS &&
	          (newLines.length > 0 || (line.type !== diffParser$1.LINE_TYPE.DELETES && oldLines.length > 0))) {
	          processChangeBlock();
	        }
	        if (line.type === diffParser$1.LINE_TYPE.CONTEXT) {
	          lines += that.makeLineHtml(file.isCombined, line.type, line.oldNumber, line.newNumber, escapedLine);
	        } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && !oldLines.length) {
	          lines += that.makeLineHtml(file.isCombined, line.type, line.oldNumber, line.newNumber, escapedLine);
	        } else if (line.type === diffParser$1.LINE_TYPE.DELETES) {
	          oldLines.push(line);
	        } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && Boolean(oldLines.length)) {
	          newLines.push(line);
	        } else {
	          console.error('Unknown state in html line-by-line generator');
	          processChangeBlock();
	        }
	      }
	      processChangeBlock();
	      return lines;
	    }).join('\n');
	  };
	  LineByLinePrinter.prototype._processLines = function(isCombined, oldLines, newLines) {
	    var lines = '';
	    for (var i = 0; i < oldLines.length; i++) {
	      var oldLine = oldLines[i];
	      var oldEscapedLine = utils$1.escape(oldLine.content);
	      lines += this.makeLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldLine.newNumber, oldEscapedLine);
	    }
	    for (var j = 0; j < newLines.length; j++) {
	      var newLine = newLines[j];
	      var newEscapedLine = utils$1.escape(newLine.content);
	      lines += this.makeLineHtml(isCombined, newLine.type, newLine.oldNumber, newLine.newNumber, newEscapedLine);
	    }
	    return lines;
	  };
	  LineByLinePrinter.prototype.makeLineHtml = function(isCombined, type, oldNumber, newNumber, content, possiblePrefix) {
	    var lineNumberTemplate = hoganUtils.render(baseTemplatesPath, 'numbers', {
	      oldNumber: utils$1.valueOrEmpty(oldNumber),
	      newNumber: utils$1.valueOrEmpty(newNumber)
	    });
	    var lineWithoutPrefix = content;
	    var prefix = possiblePrefix;
	    if (!prefix) {
	      var lineWithPrefix = printerUtils$1.separatePrefix(isCombined, content);
	      prefix = lineWithPrefix.prefix;
	      lineWithoutPrefix = lineWithPrefix.line;
	    }
	    return hoganUtils.render(genericTemplatesPath, 'line',
	      {
	        type: type,
	        lineClass: 'd2h-code-linenumber',
	        contentClass: 'd2h-code-line',
	        prefix: prefix,
	        content: lineWithoutPrefix,
	        lineNumber: lineNumberTemplate
	      });
	  };
	  LineByLinePrinter.prototype._generateEmptyDiff = function() {
	    return hoganUtils.render(genericTemplatesPath, 'empty-diff', {
	      contentClass: 'd2h-code-line',
	      diffParser: diffParser$1
	    });
	  };
	  module.exports.LineByLinePrinter = LineByLinePrinter;
	})();
	});
	var lineByLinePrinter_1 = lineByLinePrinter.LineByLinePrinter;

	var sideBySidePrinter = createCommonjsModule(function (module) {
	(function() {
	  var diffParser$1 = diffParser.DiffParser;
	  var printerUtils$1 = printerUtils.PrinterUtils;
	  var utils$1 = utils.Utils;
	  var Rematch = rematch.Rematch;
	  var hoganUtils;
	  var genericTemplatesPath = 'generic';
	  var baseTemplatesPath = 'side-by-side';
	  var iconsBaseTemplatesPath = 'icon';
	  var tagsBaseTemplatesPath = 'tag';
	  var matcher = Rematch.rematch(function(a, b) {
	    var amod = a.content.substr(1);
	    var bmod = b.content.substr(1);
	    return Rematch.distance(amod, bmod);
	  });
	  function SideBySidePrinter(config) {
	    this.config = config;
	    var HoganJsUtils = hoganjsUtils.HoganJsUtils;
	    hoganUtils = new HoganJsUtils(config);
	  }
	  SideBySidePrinter.prototype.makeDiffHtml = function(file, diffs) {
	    var fileDiffTemplate = hoganUtils.template(baseTemplatesPath, 'file-diff');
	    var filePathTemplate = hoganUtils.template(genericTemplatesPath, 'file-path');
	    var fileIconTemplate = hoganUtils.template(iconsBaseTemplatesPath, 'file');
	    var fileTagTemplate = hoganUtils.template(tagsBaseTemplatesPath, printerUtils$1.getFileTypeIcon(file));
	    return fileDiffTemplate.render({
	      file: file,
	      fileHtmlId: printerUtils$1.getHtmlId(file),
	      diffs: diffs,
	      filePath: filePathTemplate.render({
	        fileDiffName: printerUtils$1.getDiffName(file)
	      }, {
	        fileIcon: fileIconTemplate,
	        fileTag: fileTagTemplate
	      })
	    });
	  };
	  SideBySidePrinter.prototype.generateSideBySideJsonHtml = function(diffFiles) {
	    var that = this;
	    var content = diffFiles.map(function(file) {
	      var diffs;
	      if (file.blocks.length) {
	        diffs = that.generateSideBySideFileHtml(file);
	      } else {
	        diffs = that.generateEmptyDiff();
	      }
	      return that.makeDiffHtml(file, diffs);
	    }).join('\n');
	    return hoganUtils.render(genericTemplatesPath, 'wrapper', {'content': content});
	  };
	  SideBySidePrinter.prototype.makeSideHtml = function(blockHeader) {
	    return hoganUtils.render(genericTemplatesPath, 'column-line-number', {
	      diffParser: diffParser$1,
	      blockHeader: utils$1.escape(blockHeader),
	      lineClass: 'd2h-code-side-linenumber',
	      contentClass: 'd2h-code-side-line'
	    });
	  };
	  SideBySidePrinter.prototype.generateSideBySideFileHtml = function(file) {
	    var that = this;
	    var fileHtml = {};
	    fileHtml.left = '';
	    fileHtml.right = '';
	    file.blocks.forEach(function(block) {
	      fileHtml.left += that.makeSideHtml(block.header);
	      fileHtml.right += that.makeSideHtml('');
	      var oldLines = [];
	      var newLines = [];
	      function processChangeBlock() {
	        var matches;
	        var insertType;
	        var deleteType;
	        var comparisons = oldLines.length * newLines.length;
	        var maxComparisons = that.config.matchingMaxComparisons || 2500;
	        var doMatching = comparisons < maxComparisons && (that.config.matching === 'lines' ||
	          that.config.matching === 'words');
	        if (doMatching) {
	          matches = matcher(oldLines, newLines);
	          insertType = diffParser$1.LINE_TYPE.INSERT_CHANGES;
	          deleteType = diffParser$1.LINE_TYPE.DELETE_CHANGES;
	        } else {
	          matches = [[oldLines, newLines]];
	          insertType = diffParser$1.LINE_TYPE.INSERTS;
	          deleteType = diffParser$1.LINE_TYPE.DELETES;
	        }
	        matches.forEach(function(match) {
	          oldLines = match[0];
	          newLines = match[1];
	          var common = Math.min(oldLines.length, newLines.length);
	          var max = Math.max(oldLines.length, newLines.length);
	          for (var j = 0; j < common; j++) {
	            var oldLine = oldLines[j];
	            var newLine = newLines[j];
	            that.config.isCombined = file.isCombined;
	            var diff = printerUtils$1.diffHighlight(oldLine.content, newLine.content, that.config);
	            fileHtml.left +=
	              that.generateSingleLineHtml(file.isCombined, deleteType, oldLine.oldNumber,
	                diff.first.line, diff.first.prefix);
	            fileHtml.right +=
	              that.generateSingleLineHtml(file.isCombined, insertType, newLine.newNumber,
	                diff.second.line, diff.second.prefix);
	          }
	          if (max > common) {
	            var oldSlice = oldLines.slice(common);
	            var newSlice = newLines.slice(common);
	            var tmpHtml = that.processLines(file.isCombined, oldSlice, newSlice);
	            fileHtml.left += tmpHtml.left;
	            fileHtml.right += tmpHtml.right;
	          }
	        });
	        oldLines = [];
	        newLines = [];
	      }
	      for (var i = 0; i < block.lines.length; i++) {
	        var line = block.lines[i];
	        var prefix = line.content[0];
	        var escapedLine = utils$1.escape(line.content.substr(1));
	        if (line.type !== diffParser$1.LINE_TYPE.INSERTS &&
	          (newLines.length > 0 || (line.type !== diffParser$1.LINE_TYPE.DELETES && oldLines.length > 0))) {
	          processChangeBlock();
	        }
	        if (line.type === diffParser$1.LINE_TYPE.CONTEXT) {
	          fileHtml.left += that.generateSingleLineHtml(file.isCombined, line.type, line.oldNumber, escapedLine, prefix);
	          fileHtml.right += that.generateSingleLineHtml(file.isCombined, line.type, line.newNumber, escapedLine, prefix);
	        } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && !oldLines.length) {
	          fileHtml.left += that.generateSingleLineHtml(file.isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
	          fileHtml.right += that.generateSingleLineHtml(file.isCombined, line.type, line.newNumber, escapedLine, prefix);
	        } else if (line.type === diffParser$1.LINE_TYPE.DELETES) {
	          oldLines.push(line);
	        } else if (line.type === diffParser$1.LINE_TYPE.INSERTS && Boolean(oldLines.length)) {
	          newLines.push(line);
	        } else {
	          console.error('unknown state in html side-by-side generator');
	          processChangeBlock();
	        }
	      }
	      processChangeBlock();
	    });
	    return fileHtml;
	  };
	  SideBySidePrinter.prototype.processLines = function(isCombined, oldLines, newLines) {
	    var that = this;
	    var fileHtml = {};
	    fileHtml.left = '';
	    fileHtml.right = '';
	    var maxLinesNumber = Math.max(oldLines.length, newLines.length);
	    for (var i = 0; i < maxLinesNumber; i++) {
	      var oldLine = oldLines[i];
	      var newLine = newLines[i];
	      var oldContent;
	      var newContent;
	      var oldPrefix;
	      var newPrefix;
	      if (oldLine) {
	        oldContent = utils$1.escape(oldLine.content.substr(1));
	        oldPrefix = oldLine.content[0];
	      }
	      if (newLine) {
	        newContent = utils$1.escape(newLine.content.substr(1));
	        newPrefix = newLine.content[0];
	      }
	      if (oldLine && newLine) {
	        fileHtml.left += that.generateSingleLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldContent, oldPrefix);
	        fileHtml.right += that.generateSingleLineHtml(isCombined, newLine.type, newLine.newNumber, newContent, newPrefix);
	      } else if (oldLine) {
	        fileHtml.left += that.generateSingleLineHtml(isCombined, oldLine.type, oldLine.oldNumber, oldContent, oldPrefix);
	        fileHtml.right += that.generateSingleLineHtml(isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
	      } else if (newLine) {
	        fileHtml.left += that.generateSingleLineHtml(isCombined, diffParser$1.LINE_TYPE.CONTEXT, '', '', '');
	        fileHtml.right += that.generateSingleLineHtml(isCombined, newLine.type, newLine.newNumber, newContent, newPrefix);
	      } else {
	        console.error('How did it get here?');
	      }
	    }
	    return fileHtml;
	  };
	  SideBySidePrinter.prototype.generateSingleLineHtml = function(isCombined, type, number, content, possiblePrefix) {
	    var lineWithoutPrefix = content;
	    var prefix = possiblePrefix;
	    var lineClass = 'd2h-code-side-linenumber';
	    var contentClass = 'd2h-code-side-line';
	    if (!number && !content) {
	      lineClass += ' d2h-code-side-emptyplaceholder';
	      contentClass += ' d2h-code-side-emptyplaceholder';
	      type += ' d2h-emptyplaceholder';
	    }
	    if (!prefix) {
	      var lineWithPrefix = printerUtils$1.separatePrefix(isCombined, content);
	      prefix = lineWithPrefix.prefix;
	      lineWithoutPrefix = lineWithPrefix.line;
	    }
	    return hoganUtils.render(genericTemplatesPath, 'line',
	      {
	        type: type,
	        lineClass: lineClass,
	        contentClass: contentClass,
	        prefix: prefix,
	        content: lineWithoutPrefix,
	        lineNumber: number
	      });
	  };
	  SideBySidePrinter.prototype.generateEmptyDiff = function() {
	    var fileHtml = {};
	    fileHtml.right = '';
	    fileHtml.left = hoganUtils.render(genericTemplatesPath, 'empty-diff', {
	      contentClass: 'd2h-code-side-line',
	      diffParser: diffParser$1
	    });
	    return fileHtml;
	  };
	  module.exports.SideBySidePrinter = SideBySidePrinter;
	})();
	});
	var sideBySidePrinter_1 = sideBySidePrinter.SideBySidePrinter;

	var fileListPrinter = createCommonjsModule(function (module) {
	(function() {
	  var printerUtils$1 = printerUtils.PrinterUtils;
	  var hoganUtils;
	  var baseTemplatesPath = 'file-summary';
	  var iconsBaseTemplatesPath = 'icon';
	  function FileListPrinter(config) {
	    this.config = config;
	    var HoganJsUtils = hoganjsUtils.HoganJsUtils;
	    hoganUtils = new HoganJsUtils(config);
	  }
	  FileListPrinter.prototype.generateFileList = function(diffFiles) {
	    var lineTemplate = hoganUtils.template(baseTemplatesPath, 'line');
	    var files = diffFiles.map(function(file) {
	      var fileTypeName = printerUtils$1.getFileTypeIcon(file);
	      var iconTemplate = hoganUtils.template(iconsBaseTemplatesPath, fileTypeName);
	      return lineTemplate.render({
	        fileHtmlId: printerUtils$1.getHtmlId(file),
	        fileName: printerUtils$1.getDiffName(file),
	        deletedLines: '-' + file.deletedLines,
	        addedLines: '+' + file.addedLines
	      }, {
	        fileIcon: iconTemplate
	      });
	    }).join('\n');
	    return hoganUtils.render(baseTemplatesPath, 'wrapper', {
	      filesNumber: diffFiles.length,
	      files: files
	    });
	  };
	  module.exports.FileListPrinter = FileListPrinter;
	})();
	});
	var fileListPrinter_1 = fileListPrinter.FileListPrinter;

	var htmlPrinter = createCommonjsModule(function (module) {
	(function() {
	  var LineByLinePrinter = lineByLinePrinter.LineByLinePrinter;
	  var SideBySidePrinter = sideBySidePrinter.SideBySidePrinter;
	  var FileListPrinter = fileListPrinter.FileListPrinter;
	  function HtmlPrinter() {
	  }
	  HtmlPrinter.prototype.generateLineByLineJsonHtml = function(diffFiles, config) {
	    var lineByLinePrinter = new LineByLinePrinter(config);
	    return lineByLinePrinter.generateLineByLineJsonHtml(diffFiles);
	  };
	  HtmlPrinter.prototype.generateSideBySideJsonHtml = function(diffFiles, config) {
	    var sideBySidePrinter = new SideBySidePrinter(config);
	    return sideBySidePrinter.generateSideBySideJsonHtml(diffFiles);
	  };
	  HtmlPrinter.prototype.generateFileListSummary = function(diffJson, config) {
	    var fileListPrinter = new FileListPrinter(config);
	    return fileListPrinter.generateFileList(diffJson);
	  };
	  module.exports.HtmlPrinter = new HtmlPrinter();
	})();
	});
	var htmlPrinter_1 = htmlPrinter.HtmlPrinter;

	var diff2html = createCommonjsModule(function (module) {
	(function() {
	  var diffParser$1 = diffParser.DiffParser;
	  var htmlPrinter$1 = htmlPrinter.HtmlPrinter;
	  var utils$1 = utils.Utils;
	  function Diff2Html() {
	  }
	  var defaultConfig = {
	    wordByWord: true,
	    outputFormat: 'line-by-line',
	    matching: 'none',
	    matchWordsThreshold: 0.25,
	    matchingMaxComparisons: 2500,
	    maxLineLengthHighlight: 10000,
	    renderNothingWhenEmpty: false
	  };
	  Diff2Html.prototype.getJsonFromDiff = function(diffInput, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    return diffParser$1.generateDiffJson(diffInput, cfg);
	  };
	  Diff2Html.prototype.getPrettyHtml = function(diffInput, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    var diffJson = diffInput;
	    if (!cfg.inputFormat || cfg.inputFormat === 'diff') {
	      diffJson = diffParser$1.generateDiffJson(diffInput, cfg);
	    }
	    var fileList = '';
	    if (cfg.showFiles === true) {
	      fileList = htmlPrinter$1.generateFileListSummary(diffJson, cfg);
	    }
	    var diffOutput = '';
	    if (cfg.outputFormat === 'side-by-side') {
	      diffOutput = htmlPrinter$1.generateSideBySideJsonHtml(diffJson, cfg);
	    } else {
	      diffOutput = htmlPrinter$1.generateLineByLineJsonHtml(diffJson, cfg);
	    }
	    return fileList + diffOutput;
	  };
	  Diff2Html.prototype.getPrettyHtmlFromDiff = function(diffInput, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    cfg.inputFormat = 'diff';
	    cfg.outputFormat = 'line-by-line';
	    return this.getPrettyHtml(diffInput, cfg);
	  };
	  Diff2Html.prototype.getPrettyHtmlFromJson = function(diffJson, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    cfg.inputFormat = 'json';
	    cfg.outputFormat = 'line-by-line';
	    return this.getPrettyHtml(diffJson, cfg);
	  };
	  Diff2Html.prototype.getPrettySideBySideHtmlFromDiff = function(diffInput, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    cfg.inputFormat = 'diff';
	    cfg.outputFormat = 'side-by-side';
	    return this.getPrettyHtml(diffInput, cfg);
	  };
	  Diff2Html.prototype.getPrettySideBySideHtmlFromJson = function(diffJson, config) {
	    var cfg = utils$1.safeConfig(config, defaultConfig);
	    cfg.inputFormat = 'json';
	    cfg.outputFormat = 'side-by-side';
	    return this.getPrettyHtml(diffJson, cfg);
	  };
	  var diffObject = new Diff2Html();
	  module.exports.Diff2Html = diffObject;
	  commonjsGlobal.Diff2Html = diffObject;
	})();
	});
	var diff2html_1 = diff2html.Diff2Html;

	function deepFreeze(obj) {
	    if (obj instanceof Map) {
	        obj.clear = obj.delete = obj.set = function () {
	            throw new Error('map is read-only');
	        };
	    } else if (obj instanceof Set) {
	        obj.add = obj.clear = obj.delete = function () {
	            throw new Error('set is read-only');
	        };
	    }
	    Object.freeze(obj);
	    Object.getOwnPropertyNames(obj).forEach(function (name) {
	        var prop = obj[name];
	        if (typeof prop == 'object' && !Object.isFrozen(prop)) {
	            deepFreeze(prop);
	        }
	    });
	    return obj;
	}
	var deepFreezeEs6 = deepFreeze;
	var _default = deepFreeze;
	deepFreezeEs6.default = _default;
	class Response {
	  constructor(mode) {
	    if (mode.data === undefined) mode.data = {};
	    this.data = mode.data;
	    this.isMatchIgnored = false;
	  }
	  ignoreMatch() {
	    this.isMatchIgnored = true;
	  }
	}
	function escapeHTML(value) {
	  return value
	    .replace(/&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;')
	    .replace(/"/g, '&quot;')
	    .replace(/'/g, '&#x27;');
	}
	function inherit(original, ...objects) {
	  const result = Object.create(null);
	  for (const key in original) {
	    result[key] = original[key];
	  }
	  objects.forEach(function(obj) {
	    for (const key in obj) {
	      result[key] = obj[key];
	    }
	  });
	  return  (result);
	}
	const SPAN_CLOSE = '</span>';
	const emitsWrappingTags = (node) => {
	  return !!node.kind;
	};
	class HTMLRenderer {
	  constructor(parseTree, options) {
	    this.buffer = "";
	    this.classPrefix = options.classPrefix;
	    parseTree.walk(this);
	  }
	  addText(text) {
	    this.buffer += escapeHTML(text);
	  }
	  openNode(node) {
	    if (!emitsWrappingTags(node)) return;
	    let className = node.kind;
	    if (!node.sublanguage) {
	      className = `${this.classPrefix}${className}`;
	    }
	    this.span(className);
	  }
	  closeNode(node) {
	    if (!emitsWrappingTags(node)) return;
	    this.buffer += SPAN_CLOSE;
	  }
	  value() {
	    return this.buffer;
	  }
	  span(className) {
	    this.buffer += `<span class="${className}">`;
	  }
	}
	class TokenTree {
	  constructor() {
	    this.rootNode = { children: [] };
	    this.stack = [this.rootNode];
	  }
	  get top() {
	    return this.stack[this.stack.length - 1];
	  }
	  get root() { return this.rootNode; }
	  add(node) {
	    this.top.children.push(node);
	  }
	  openNode(kind) {
	    const node = { kind, children: [] };
	    this.add(node);
	    this.stack.push(node);
	  }
	  closeNode() {
	    if (this.stack.length > 1) {
	      return this.stack.pop();
	    }
	    return undefined;
	  }
	  closeAllNodes() {
	    while (this.closeNode());
	  }
	  toJSON() {
	    return JSON.stringify(this.rootNode, null, 4);
	  }
	  walk(builder) {
	    return this.constructor._walk(builder, this.rootNode);
	  }
	  static _walk(builder, node) {
	    if (typeof node === "string") {
	      builder.addText(node);
	    } else if (node.children) {
	      builder.openNode(node);
	      node.children.forEach((child) => this._walk(builder, child));
	      builder.closeNode(node);
	    }
	    return builder;
	  }
	  static _collapse(node) {
	    if (typeof node === "string") return;
	    if (!node.children) return;
	    if (node.children.every(el => typeof el === "string")) {
	      node.children = [node.children.join("")];
	    } else {
	      node.children.forEach((child) => {
	        TokenTree._collapse(child);
	      });
	    }
	  }
	}
	class TokenTreeEmitter extends TokenTree {
	  constructor(options) {
	    super();
	    this.options = options;
	  }
	  addKeyword(text, kind) {
	    if (text === "") { return; }
	    this.openNode(kind);
	    this.addText(text);
	    this.closeNode();
	  }
	  addText(text) {
	    if (text === "") { return; }
	    this.add(text);
	  }
	  addSublanguage(emitter, name) {
	    const node = emitter.root;
	    node.kind = name;
	    node.sublanguage = true;
	    this.add(node);
	  }
	  toHTML() {
	    const renderer = new HTMLRenderer(this, this.options);
	    return renderer.value();
	  }
	  finalize() {
	    return true;
	  }
	}
	function escape(value) {
	  return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
	}
	function source(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function concat(...args) {
	  const joined = args.map((x) => source(x)).join("");
	  return joined;
	}
	function either(...args) {
	  const joined = '(' + args.map((x) => source(x)).join("|") + ")";
	  return joined;
	}
	function countMatchGroups(re) {
	  return (new RegExp(re.toString() + '|')).exec('').length - 1;
	}
	function startsWith(re, lexeme) {
	  const match = re && re.exec(lexeme);
	  return match && match.index === 0;
	}
	const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
	function join(regexps, separator = "|") {
	  let numCaptures = 0;
	  return regexps.map((regex) => {
	    numCaptures += 1;
	    const offset = numCaptures;
	    let re = source(regex);
	    let out = '';
	    while (re.length > 0) {
	      const match = BACKREF_RE.exec(re);
	      if (!match) {
	        out += re;
	        break;
	      }
	      out += re.substring(0, match.index);
	      re = re.substring(match.index + match[0].length);
	      if (match[0][0] === '\\' && match[1]) {
	        out += '\\' + String(Number(match[1]) + offset);
	      } else {
	        out += match[0];
	        if (match[0] === '(') {
	          numCaptures++;
	        }
	      }
	    }
	    return out;
	  }).map(re => `(${re})`).join(separator);
	}
	const MATCH_NOTHING_RE = /\b\B/;
	const IDENT_RE = '[a-zA-Z]\\w*';
	const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
	const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
	const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)';
	const BINARY_NUMBER_RE = '\\b(0b[01]+)';
	const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';
	const SHEBANG = (opts = {}) => {
	  const beginShebang = /^#![ ]*\//;
	  if (opts.binary) {
	    opts.begin = concat(
	      beginShebang,
	      /.*\b/,
	      opts.binary,
	      /\b.*/);
	  }
	  return inherit({
	    className: 'meta',
	    begin: beginShebang,
	    end: /$/,
	    relevance: 0,
	    "on:begin": (m, resp) => {
	      if (m.index !== 0) resp.ignoreMatch();
	    }
	  }, opts);
	};
	const BACKSLASH_ESCAPE = {
	  begin: '\\\\[\\s\\S]', relevance: 0
	};
	const APOS_STRING_MODE = {
	  className: 'string',
	  begin: '\'',
	  end: '\'',
	  illegal: '\\n',
	  contains: [BACKSLASH_ESCAPE]
	};
	const QUOTE_STRING_MODE = {
	  className: 'string',
	  begin: '"',
	  end: '"',
	  illegal: '\\n',
	  contains: [BACKSLASH_ESCAPE]
	};
	const PHRASAL_WORDS_MODE = {
	  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
	};
	const COMMENT = function(begin, end, modeOptions = {}) {
	  const mode = inherit(
	    {
	      className: 'comment',
	      begin,
	      end,
	      contains: []
	    },
	    modeOptions
	  );
	  mode.contains.push(PHRASAL_WORDS_MODE);
	  mode.contains.push({
	    className: 'doctag',
	    begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
	    relevance: 0
	  });
	  return mode;
	};
	const C_LINE_COMMENT_MODE = COMMENT('//', '$');
	const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
	const HASH_COMMENT_MODE = COMMENT('#', '$');
	const NUMBER_MODE = {
	  className: 'number',
	  begin: NUMBER_RE,
	  relevance: 0
	};
	const C_NUMBER_MODE = {
	  className: 'number',
	  begin: C_NUMBER_RE,
	  relevance: 0
	};
	const BINARY_NUMBER_MODE = {
	  className: 'number',
	  begin: BINARY_NUMBER_RE,
	  relevance: 0
	};
	const CSS_NUMBER_MODE = {
	  className: 'number',
	  begin: NUMBER_RE + '(' +
	    '%|em|ex|ch|rem' +
	    '|vw|vh|vmin|vmax' +
	    '|cm|mm|in|pt|pc|px' +
	    '|deg|grad|rad|turn' +
	    '|s|ms' +
	    '|Hz|kHz' +
	    '|dpi|dpcm|dppx' +
	    ')?',
	  relevance: 0
	};
	const REGEXP_MODE = {
	  begin: /(?=\/[^/\n]*\/)/,
	  contains: [{
	    className: 'regexp',
	    begin: /\//,
	    end: /\/[gimuy]*/,
	    illegal: /\n/,
	    contains: [
	      BACKSLASH_ESCAPE,
	      {
	        begin: /\[/,
	        end: /\]/,
	        relevance: 0,
	        contains: [BACKSLASH_ESCAPE]
	      }
	    ]
	  }]
	};
	const TITLE_MODE = {
	  className: 'title',
	  begin: IDENT_RE,
	  relevance: 0
	};
	const UNDERSCORE_TITLE_MODE = {
	  className: 'title',
	  begin: UNDERSCORE_IDENT_RE,
	  relevance: 0
	};
	const METHOD_GUARD = {
	  begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
	  relevance: 0
	};
	const END_SAME_AS_BEGIN = function(mode) {
	  return Object.assign(mode,
	    {
	      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
	      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
	    });
	};
	var MODES = Object.freeze({
	    __proto__: null,
	    MATCH_NOTHING_RE: MATCH_NOTHING_RE,
	    IDENT_RE: IDENT_RE,
	    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
	    NUMBER_RE: NUMBER_RE,
	    C_NUMBER_RE: C_NUMBER_RE,
	    BINARY_NUMBER_RE: BINARY_NUMBER_RE,
	    RE_STARTERS_RE: RE_STARTERS_RE,
	    SHEBANG: SHEBANG,
	    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
	    APOS_STRING_MODE: APOS_STRING_MODE,
	    QUOTE_STRING_MODE: QUOTE_STRING_MODE,
	    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
	    COMMENT: COMMENT,
	    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
	    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
	    HASH_COMMENT_MODE: HASH_COMMENT_MODE,
	    NUMBER_MODE: NUMBER_MODE,
	    C_NUMBER_MODE: C_NUMBER_MODE,
	    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
	    CSS_NUMBER_MODE: CSS_NUMBER_MODE,
	    REGEXP_MODE: REGEXP_MODE,
	    TITLE_MODE: TITLE_MODE,
	    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
	    METHOD_GUARD: METHOD_GUARD,
	    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
	});
	function skipIfhasPrecedingDot(match, response) {
	  const before = match.input[match.index - 1];
	  if (before === ".") {
	    response.ignoreMatch();
	  }
	}
	function beginKeywords(mode, parent) {
	  if (!parent) return;
	  if (!mode.beginKeywords) return;
	  mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
	  mode.__beforeBegin = skipIfhasPrecedingDot;
	  mode.keywords = mode.keywords || mode.beginKeywords;
	  delete mode.beginKeywords;
	  if (mode.relevance === undefined) mode.relevance = 0;
	}
	function compileIllegal(mode, _parent) {
	  if (!Array.isArray(mode.illegal)) return;
	  mode.illegal = either(...mode.illegal);
	}
	function compileMatch(mode, _parent) {
	  if (!mode.match) return;
	  if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
	  mode.begin = mode.match;
	  delete mode.match;
	}
	function compileRelevance(mode, _parent) {
	  if (mode.relevance === undefined) mode.relevance = 1;
	}
	const COMMON_KEYWORDS = [
	  'of',
	  'and',
	  'for',
	  'in',
	  'not',
	  'or',
	  'if',
	  'then',
	  'parent',
	  'list',
	  'value'
	];
	const DEFAULT_KEYWORD_CLASSNAME = "keyword";
	function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
	  const compiledKeywords = {};
	  if (typeof rawKeywords === 'string') {
	    compileList(className, rawKeywords.split(" "));
	  } else if (Array.isArray(rawKeywords)) {
	    compileList(className, rawKeywords);
	  } else {
	    Object.keys(rawKeywords).forEach(function(className) {
	      Object.assign(
	        compiledKeywords,
	        compileKeywords(rawKeywords[className], caseInsensitive, className)
	      );
	    });
	  }
	  return compiledKeywords;
	  function compileList(className, keywordList) {
	    if (caseInsensitive) {
	      keywordList = keywordList.map(x => x.toLowerCase());
	    }
	    keywordList.forEach(function(keyword) {
	      const pair = keyword.split('|');
	      compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
	    });
	  }
	}
	function scoreForKeyword(keyword, providedScore) {
	  if (providedScore) {
	    return Number(providedScore);
	  }
	  return commonKeyword(keyword) ? 0 : 1;
	}
	function commonKeyword(keyword) {
	  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
	}
	function compileLanguage(language, { plugins }) {
	  function langRe(value, global) {
	    return new RegExp(
	      source(value),
	      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
	    );
	  }
	  class MultiRegex {
	    constructor() {
	      this.matchIndexes = {};
	      this.regexes = [];
	      this.matchAt = 1;
	      this.position = 0;
	    }
	    addRule(re, opts) {
	      opts.position = this.position++;
	      this.matchIndexes[this.matchAt] = opts;
	      this.regexes.push([opts, re]);
	      this.matchAt += countMatchGroups(re) + 1;
	    }
	    compile() {
	      if (this.regexes.length === 0) {
	        this.exec = () => null;
	      }
	      const terminators = this.regexes.map(el => el[1]);
	      this.matcherRe = langRe(join(terminators), true);
	      this.lastIndex = 0;
	    }
	    exec(s) {
	      this.matcherRe.lastIndex = this.lastIndex;
	      const match = this.matcherRe.exec(s);
	      if (!match) { return null; }
	      const i = match.findIndex((el, i) => i > 0 && el !== undefined);
	      const matchData = this.matchIndexes[i];
	      match.splice(0, i);
	      return Object.assign(match, matchData);
	    }
	  }
	  class ResumableMultiRegex {
	    constructor() {
	      this.rules = [];
	      this.multiRegexes = [];
	      this.count = 0;
	      this.lastIndex = 0;
	      this.regexIndex = 0;
	    }
	    getMatcher(index) {
	      if (this.multiRegexes[index]) return this.multiRegexes[index];
	      const matcher = new MultiRegex();
	      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
	      matcher.compile();
	      this.multiRegexes[index] = matcher;
	      return matcher;
	    }
	    resumingScanAtSamePosition() {
	      return this.regexIndex !== 0;
	    }
	    considerAll() {
	      this.regexIndex = 0;
	    }
	    addRule(re, opts) {
	      this.rules.push([re, opts]);
	      if (opts.type === "begin") this.count++;
	    }
	    exec(s) {
	      const m = this.getMatcher(this.regexIndex);
	      m.lastIndex = this.lastIndex;
	      let result = m.exec(s);
	      if (this.resumingScanAtSamePosition()) {
	        if (result && result.index === this.lastIndex) ; else {
	          const m2 = this.getMatcher(0);
	          m2.lastIndex = this.lastIndex + 1;
	          result = m2.exec(s);
	        }
	      }
	      if (result) {
	        this.regexIndex += result.position + 1;
	        if (this.regexIndex === this.count) {
	          this.considerAll();
	        }
	      }
	      return result;
	    }
	  }
	  function buildModeRegex(mode) {
	    const mm = new ResumableMultiRegex();
	    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));
	    if (mode.terminatorEnd) {
	      mm.addRule(mode.terminatorEnd, { type: "end" });
	    }
	    if (mode.illegal) {
	      mm.addRule(mode.illegal, { type: "illegal" });
	    }
	    return mm;
	  }
	  function compileMode(mode, parent) {
	    const cmode =  (mode);
	    if (mode.isCompiled) return cmode;
	    [
	      compileMatch
	    ].forEach(ext => ext(mode, parent));
	    language.compilerExtensions.forEach(ext => ext(mode, parent));
	    mode.__beforeBegin = null;
	    [
	      beginKeywords,
	      compileIllegal,
	      compileRelevance
	    ].forEach(ext => ext(mode, parent));
	    mode.isCompiled = true;
	    let keywordPattern = null;
	    if (typeof mode.keywords === "object") {
	      keywordPattern = mode.keywords.$pattern;
	      delete mode.keywords.$pattern;
	    }
	    if (mode.keywords) {
	      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
	    }
	    if (mode.lexemes && keywordPattern) {
	      throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
	    }
	    keywordPattern = keywordPattern || mode.lexemes || /\w+/;
	    cmode.keywordPatternRe = langRe(keywordPattern, true);
	    if (parent) {
	      if (!mode.begin) mode.begin = /\B|\b/;
	      cmode.beginRe = langRe(mode.begin);
	      if (mode.endSameAsBegin) mode.end = mode.begin;
	      if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
	      if (mode.end) cmode.endRe = langRe(mode.end);
	      cmode.terminatorEnd = source(mode.end) || '';
	      if (mode.endsWithParent && parent.terminatorEnd) {
	        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
	      }
	    }
	    if (mode.illegal) cmode.illegalRe = langRe( (mode.illegal));
	    if (!mode.contains) mode.contains = [];
	    mode.contains = [].concat(...mode.contains.map(function(c) {
	      return expandOrCloneMode(c === 'self' ? mode : c);
	    }));
	    mode.contains.forEach(function(c) { compileMode( (c), cmode); });
	    if (mode.starts) {
	      compileMode(mode.starts, parent);
	    }
	    cmode.matcher = buildModeRegex(cmode);
	    return cmode;
	  }
	  if (!language.compilerExtensions) language.compilerExtensions = [];
	  if (language.contains && language.contains.includes('self')) {
	    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
	  }
	  language.classNameAliases = inherit(language.classNameAliases || {});
	  return compileMode( (language));
	}
	function dependencyOnParent(mode) {
	  if (!mode) return false;
	  return mode.endsWithParent || dependencyOnParent(mode.starts);
	}
	function expandOrCloneMode(mode) {
	  if (mode.variants && !mode.cachedVariants) {
	    mode.cachedVariants = mode.variants.map(function(variant) {
	      return inherit(mode, { variants: null }, variant);
	    });
	  }
	  if (mode.cachedVariants) {
	    return mode.cachedVariants;
	  }
	  if (dependencyOnParent(mode)) {
	    return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
	  }
	  if (Object.isFrozen(mode)) {
	    return inherit(mode);
	  }
	  return mode;
	}
	var version = "10.7.3";
	function hasValueOrEmptyAttribute(value) {
	  return Boolean(value || value === "");
	}
	function BuildVuePlugin(hljs) {
	  const Component = {
	    props: ["language", "code", "autodetect"],
	    data: function() {
	      return {
	        detectedLanguage: "",
	        unknownLanguage: false
	      };
	    },
	    computed: {
	      className() {
	        if (this.unknownLanguage) return "";
	        return "hljs " + this.detectedLanguage;
	      },
	      highlighted() {
	        if (!this.autoDetect && !hljs.getLanguage(this.language)) {
	          console.warn(`The language "${this.language}" you specified could not be found.`);
	          this.unknownLanguage = true;
	          return escapeHTML(this.code);
	        }
	        let result = {};
	        if (this.autoDetect) {
	          result = hljs.highlightAuto(this.code);
	          this.detectedLanguage = result.language;
	        } else {
	          result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
	          this.detectedLanguage = this.language;
	        }
	        return result.value;
	      },
	      autoDetect() {
	        return !this.language || hasValueOrEmptyAttribute(this.autodetect);
	      },
	      ignoreIllegals() {
	        return true;
	      }
	    },
	    render(createElement) {
	      return createElement("pre", {}, [
	        createElement("code", {
	          class: this.className,
	          domProps: { innerHTML: this.highlighted }
	        })
	      ]);
	    }
	  };
	  const VuePlugin = {
	    install(Vue) {
	      Vue.component('highlightjs', Component);
	    }
	  };
	  return { Component, VuePlugin };
	}
	const mergeHTMLPlugin = {
	  "after:highlightElement": ({ el, result, text }) => {
	    const originalStream = nodeStream(el);
	    if (!originalStream.length) return;
	    const resultNode = document.createElement('div');
	    resultNode.innerHTML = result.value;
	    result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
	  }
	};
	function tag(node) {
	  return node.nodeName.toLowerCase();
	}
	function nodeStream(node) {
	  const result = [];
	  (function _nodeStream(node, offset) {
	    for (let child = node.firstChild; child; child = child.nextSibling) {
	      if (child.nodeType === 3) {
	        offset += child.nodeValue.length;
	      } else if (child.nodeType === 1) {
	        result.push({
	          event: 'start',
	          offset: offset,
	          node: child
	        });
	        offset = _nodeStream(child, offset);
	        if (!tag(child).match(/br|hr|img|input/)) {
	          result.push({
	            event: 'stop',
	            offset: offset,
	            node: child
	          });
	        }
	      }
	    }
	    return offset;
	  })(node, 0);
	  return result;
	}
	function mergeStreams(original, highlighted, value) {
	  let processed = 0;
	  let result = '';
	  const nodeStack = [];
	  function selectStream() {
	    if (!original.length || !highlighted.length) {
	      return original.length ? original : highlighted;
	    }
	    if (original[0].offset !== highlighted[0].offset) {
	      return (original[0].offset < highlighted[0].offset) ? original : highlighted;
	    }
	    return highlighted[0].event === 'start' ? original : highlighted;
	  }
	  function open(node) {
	    function attributeString(attr) {
	      return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
	    }
	    result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
	  }
	  function close(node) {
	    result += '</' + tag(node) + '>';
	  }
	  function render(event) {
	    (event.event === 'start' ? open : close)(event.node);
	  }
	  while (original.length || highlighted.length) {
	    let stream = selectStream();
	    result += escapeHTML(value.substring(processed, stream[0].offset));
	    processed = stream[0].offset;
	    if (stream === original) {
	      nodeStack.reverse().forEach(close);
	      do {
	        render(stream.splice(0, 1)[0]);
	        stream = selectStream();
	      } while (stream === original && stream.length && stream[0].offset === processed);
	      nodeStack.reverse().forEach(open);
	    } else {
	      if (stream[0].event === 'start') {
	        nodeStack.push(stream[0].node);
	      } else {
	        nodeStack.pop();
	      }
	      render(stream.splice(0, 1)[0]);
	    }
	  }
	  return result + escapeHTML(value.substr(processed));
	}
	const seenDeprecations = {};
	const error = (message) => {
	  console.error(message);
	};
	const warn = (message, ...args) => {
	  console.log(`WARN: ${message}`, ...args);
	};
	const deprecated = (version, message) => {
	  if (seenDeprecations[`${version}/${message}`]) return;
	  console.log(`Deprecated as of ${version}. ${message}`);
	  seenDeprecations[`${version}/${message}`] = true;
	};
	const escape$1 = escapeHTML;
	const inherit$1 = inherit;
	const NO_MATCH = Symbol("nomatch");
	const HLJS = function(hljs) {
	  const languages = Object.create(null);
	  const aliases = Object.create(null);
	  const plugins = [];
	  let SAFE_MODE = true;
	  const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
	  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
	  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };
	  let options = {
	    noHighlightRe: /^(no-?highlight)$/i,
	    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
	    classPrefix: 'hljs-',
	    tabReplace: null,
	    useBR: false,
	    languages: null,
	    __emitter: TokenTreeEmitter
	  };
	  function shouldNotHighlight(languageName) {
	    return options.noHighlightRe.test(languageName);
	  }
	  function blockLanguage(block) {
	    let classes = block.className + ' ';
	    classes += block.parentNode ? block.parentNode.className : '';
	    const match = options.languageDetectRe.exec(classes);
	    if (match) {
	      const language = getLanguage(match[1]);
	      if (!language) {
	        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
	        warn("Falling back to no-highlight mode for this block.", block);
	      }
	      return language ? match[1] : 'no-highlight';
	    }
	    return classes
	      .split(/\s+/)
	      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
	  }
	  function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
	    let code = "";
	    let languageName = "";
	    if (typeof optionsOrCode === "object") {
	      code = codeOrlanguageName;
	      ignoreIllegals = optionsOrCode.ignoreIllegals;
	      languageName = optionsOrCode.language;
	      continuation = undefined;
	    } else {
	      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
	      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
	      languageName = codeOrlanguageName;
	      code = optionsOrCode;
	    }
	    const context = {
	      code,
	      language: languageName
	    };
	    fire("before:highlight", context);
	    const result = context.result
	      ? context.result
	      : _highlight(context.language, context.code, ignoreIllegals, continuation);
	    result.code = context.code;
	    fire("after:highlight", result);
	    return result;
	  }
	  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
	    function keywordData(mode, match) {
	      const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
	      return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
	    }
	    function processKeywords() {
	      if (!top.keywords) {
	        emitter.addText(modeBuffer);
	        return;
	      }
	      let lastIndex = 0;
	      top.keywordPatternRe.lastIndex = 0;
	      let match = top.keywordPatternRe.exec(modeBuffer);
	      let buf = "";
	      while (match) {
	        buf += modeBuffer.substring(lastIndex, match.index);
	        const data = keywordData(top, match);
	        if (data) {
	          const [kind, keywordRelevance] = data;
	          emitter.addText(buf);
	          buf = "";
	          relevance += keywordRelevance;
	          if (kind.startsWith("_")) {
	            buf += match[0];
	          } else {
	            const cssClass = language.classNameAliases[kind] || kind;
	            emitter.addKeyword(match[0], cssClass);
	          }
	        } else {
	          buf += match[0];
	        }
	        lastIndex = top.keywordPatternRe.lastIndex;
	        match = top.keywordPatternRe.exec(modeBuffer);
	      }
	      buf += modeBuffer.substr(lastIndex);
	      emitter.addText(buf);
	    }
	    function processSubLanguage() {
	      if (modeBuffer === "") return;
	      let result = null;
	      if (typeof top.subLanguage === 'string') {
	        if (!languages[top.subLanguage]) {
	          emitter.addText(modeBuffer);
	          return;
	        }
	        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
	        continuations[top.subLanguage] =  (result.top);
	      } else {
	        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
	      }
	      if (top.relevance > 0) {
	        relevance += result.relevance;
	      }
	      emitter.addSublanguage(result.emitter, result.language);
	    }
	    function processBuffer() {
	      if (top.subLanguage != null) {
	        processSubLanguage();
	      } else {
	        processKeywords();
	      }
	      modeBuffer = '';
	    }
	    function startNewMode(mode) {
	      if (mode.className) {
	        emitter.openNode(language.classNameAliases[mode.className] || mode.className);
	      }
	      top = Object.create(mode, { parent: { value: top } });
	      return top;
	    }
	    function endOfMode(mode, match, matchPlusRemainder) {
	      let matched = startsWith(mode.endRe, matchPlusRemainder);
	      if (matched) {
	        if (mode["on:end"]) {
	          const resp = new Response(mode);
	          mode["on:end"](match, resp);
	          if (resp.isMatchIgnored) matched = false;
	        }
	        if (matched) {
	          while (mode.endsParent && mode.parent) {
	            mode = mode.parent;
	          }
	          return mode;
	        }
	      }
	      if (mode.endsWithParent) {
	        return endOfMode(mode.parent, match, matchPlusRemainder);
	      }
	    }
	    function doIgnore(lexeme) {
	      if (top.matcher.regexIndex === 0) {
	        modeBuffer += lexeme[0];
	        return 1;
	      } else {
	        resumeScanAtSamePosition = true;
	        return 0;
	      }
	    }
	    function doBeginMatch(match) {
	      const lexeme = match[0];
	      const newMode = match.rule;
	      const resp = new Response(newMode);
	      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
	      for (const cb of beforeCallbacks) {
	        if (!cb) continue;
	        cb(match, resp);
	        if (resp.isMatchIgnored) return doIgnore(lexeme);
	      }
	      if (newMode && newMode.endSameAsBegin) {
	        newMode.endRe = escape(lexeme);
	      }
	      if (newMode.skip) {
	        modeBuffer += lexeme;
	      } else {
	        if (newMode.excludeBegin) {
	          modeBuffer += lexeme;
	        }
	        processBuffer();
	        if (!newMode.returnBegin && !newMode.excludeBegin) {
	          modeBuffer = lexeme;
	        }
	      }
	      startNewMode(newMode);
	      return newMode.returnBegin ? 0 : lexeme.length;
	    }
	    function doEndMatch(match) {
	      const lexeme = match[0];
	      const matchPlusRemainder = codeToHighlight.substr(match.index);
	      const endMode = endOfMode(top, match, matchPlusRemainder);
	      if (!endMode) { return NO_MATCH; }
	      const origin = top;
	      if (origin.skip) {
	        modeBuffer += lexeme;
	      } else {
	        if (!(origin.returnEnd || origin.excludeEnd)) {
	          modeBuffer += lexeme;
	        }
	        processBuffer();
	        if (origin.excludeEnd) {
	          modeBuffer = lexeme;
	        }
	      }
	      do {
	        if (top.className) {
	          emitter.closeNode();
	        }
	        if (!top.skip && !top.subLanguage) {
	          relevance += top.relevance;
	        }
	        top = top.parent;
	      } while (top !== endMode.parent);
	      if (endMode.starts) {
	        if (endMode.endSameAsBegin) {
	          endMode.starts.endRe = endMode.endRe;
	        }
	        startNewMode(endMode.starts);
	      }
	      return origin.returnEnd ? 0 : lexeme.length;
	    }
	    function processContinuations() {
	      const list = [];
	      for (let current = top; current !== language; current = current.parent) {
	        if (current.className) {
	          list.unshift(current.className);
	        }
	      }
	      list.forEach(item => emitter.openNode(item));
	    }
	    let lastMatch = {};
	    function processLexeme(textBeforeMatch, match) {
	      const lexeme = match && match[0];
	      modeBuffer += textBeforeMatch;
	      if (lexeme == null) {
	        processBuffer();
	        return 0;
	      }
	      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
	        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
	        if (!SAFE_MODE) {
	          const err = new Error('0 width match regex');
	          err.languageName = languageName;
	          err.badRule = lastMatch.rule;
	          throw err;
	        }
	        return 1;
	      }
	      lastMatch = match;
	      if (match.type === "begin") {
	        return doBeginMatch(match);
	      } else if (match.type === "illegal" && !ignoreIllegals) {
	        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
	        err.mode = top;
	        throw err;
	      } else if (match.type === "end") {
	        const processed = doEndMatch(match);
	        if (processed !== NO_MATCH) {
	          return processed;
	        }
	      }
	      if (match.type === "illegal" && lexeme === "") {
	        return 1;
	      }
	      if (iterations > 100000 && iterations > match.index * 3) {
	        const err = new Error('potential infinite loop, way more iterations than matches');
	        throw err;
	      }
	      modeBuffer += lexeme;
	      return lexeme.length;
	    }
	    const language = getLanguage(languageName);
	    if (!language) {
	      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
	      throw new Error('Unknown language: "' + languageName + '"');
	    }
	    const md = compileLanguage(language, { plugins });
	    let result = '';
	    let top = continuation || md;
	    const continuations = {};
	    const emitter = new options.__emitter(options);
	    processContinuations();
	    let modeBuffer = '';
	    let relevance = 0;
	    let index = 0;
	    let iterations = 0;
	    let resumeScanAtSamePosition = false;
	    try {
	      top.matcher.considerAll();
	      for (;;) {
	        iterations++;
	        if (resumeScanAtSamePosition) {
	          resumeScanAtSamePosition = false;
	        } else {
	          top.matcher.considerAll();
	        }
	        top.matcher.lastIndex = index;
	        const match = top.matcher.exec(codeToHighlight);
	        if (!match) break;
	        const beforeMatch = codeToHighlight.substring(index, match.index);
	        const processedCount = processLexeme(beforeMatch, match);
	        index = match.index + processedCount;
	      }
	      processLexeme(codeToHighlight.substr(index));
	      emitter.closeAllNodes();
	      emitter.finalize();
	      result = emitter.toHTML();
	      return {
	        relevance: Math.floor(relevance),
	        value: result,
	        language: languageName,
	        illegal: false,
	        emitter: emitter,
	        top: top
	      };
	    } catch (err) {
	      if (err.message && err.message.includes('Illegal')) {
	        return {
	          illegal: true,
	          illegalBy: {
	            msg: err.message,
	            context: codeToHighlight.slice(index - 100, index + 100),
	            mode: err.mode
	          },
	          sofar: result,
	          relevance: 0,
	          value: escape$1(codeToHighlight),
	          emitter: emitter
	        };
	      } else if (SAFE_MODE) {
	        return {
	          illegal: false,
	          relevance: 0,
	          value: escape$1(codeToHighlight),
	          emitter: emitter,
	          language: languageName,
	          top: top,
	          errorRaised: err
	        };
	      } else {
	        throw err;
	      }
	    }
	  }
	  function justTextHighlightResult(code) {
	    const result = {
	      relevance: 0,
	      emitter: new options.__emitter(options),
	      value: escape$1(code),
	      illegal: false,
	      top: PLAINTEXT_LANGUAGE
	    };
	    result.emitter.addText(code);
	    return result;
	  }
	  function highlightAuto(code, languageSubset) {
	    languageSubset = languageSubset || options.languages || Object.keys(languages);
	    const plaintext = justTextHighlightResult(code);
	    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
	      _highlight(name, code, false)
	    );
	    results.unshift(plaintext);
	    const sorted = results.sort((a, b) => {
	      if (a.relevance !== b.relevance) return b.relevance - a.relevance;
	      if (a.language && b.language) {
	        if (getLanguage(a.language).supersetOf === b.language) {
	          return 1;
	        } else if (getLanguage(b.language).supersetOf === a.language) {
	          return -1;
	        }
	      }
	      return 0;
	    });
	    const [best, secondBest] = sorted;
	    const result = best;
	    result.second_best = secondBest;
	    return result;
	  }
	  function fixMarkup(html) {
	    if (!(options.tabReplace || options.useBR)) {
	      return html;
	    }
	    return html.replace(fixMarkupRe, match => {
	      if (match === '\n') {
	        return options.useBR ? '<br>' : match;
	      } else if (options.tabReplace) {
	        return match.replace(/\t/g, options.tabReplace);
	      }
	      return match;
	    });
	  }
	  function updateClassName(element, currentLang, resultLang) {
	    const language = currentLang ? aliases[currentLang] : resultLang;
	    element.classList.add("hljs");
	    if (language) element.classList.add(language);
	  }
	  const brPlugin = {
	    "before:highlightElement": ({ el }) => {
	      if (options.useBR) {
	        el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
	      }
	    },
	    "after:highlightElement": ({ result }) => {
	      if (options.useBR) {
	        result.value = result.value.replace(/\n/g, "<br>");
	      }
	    }
	  };
	  const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
	  const tabReplacePlugin = {
	    "after:highlightElement": ({ result }) => {
	      if (options.tabReplace) {
	        result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
	          m.replace(/\t/g, options.tabReplace)
	        );
	      }
	    }
	  };
	  function highlightElement(element) {
	    let node = null;
	    const language = blockLanguage(element);
	    if (shouldNotHighlight(language)) return;
	    fire("before:highlightElement",
	      { el: element, language: language });
	    node = element;
	    const text = node.textContent;
	    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);
	    fire("after:highlightElement", { el: element, result, text });
	    element.innerHTML = result.value;
	    updateClassName(element, language, result.language);
	    element.result = {
	      language: result.language,
	      re: result.relevance,
	      relavance: result.relevance
	    };
	    if (result.second_best) {
	      element.second_best = {
	        language: result.second_best.language,
	        re: result.second_best.relevance,
	        relavance: result.second_best.relevance
	      };
	    }
	  }
	  function configure(userOptions) {
	    if (userOptions.useBR) {
	      deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
	      deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
	    }
	    options = inherit$1(options, userOptions);
	  }
	  const initHighlighting = () => {
	    if (initHighlighting.called) return;
	    initHighlighting.called = true;
	    deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
	    const blocks = document.querySelectorAll('pre code');
	    blocks.forEach(highlightElement);
	  };
	  function initHighlightingOnLoad() {
	    deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
	    wantsHighlight = true;
	  }
	  let wantsHighlight = false;
	  function highlightAll() {
	    if (document.readyState === "loading") {
	      wantsHighlight = true;
	      return;
	    }
	    const blocks = document.querySelectorAll('pre code');
	    blocks.forEach(highlightElement);
	  }
	  function boot() {
	    if (wantsHighlight) highlightAll();
	  }
	  if (typeof window !== 'undefined' && window.addEventListener) {
	    window.addEventListener('DOMContentLoaded', boot, false);
	  }
	  function registerLanguage(languageName, languageDefinition) {
	    let lang = null;
	    try {
	      lang = languageDefinition(hljs);
	    } catch (error$1) {
	      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
	      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
	      lang = PLAINTEXT_LANGUAGE;
	    }
	    if (!lang.name) lang.name = languageName;
	    languages[languageName] = lang;
	    lang.rawDefinition = languageDefinition.bind(null, hljs);
	    if (lang.aliases) {
	      registerAliases(lang.aliases, { languageName });
	    }
	  }
	  function unregisterLanguage(languageName) {
	    delete languages[languageName];
	    for (const alias of Object.keys(aliases)) {
	      if (aliases[alias] === languageName) {
	        delete aliases[alias];
	      }
	    }
	  }
	  function listLanguages() {
	    return Object.keys(languages);
	  }
	  function requireLanguage(name) {
	    deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
	    deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
	    const lang = getLanguage(name);
	    if (lang) { return lang; }
	    const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
	    throw err;
	  }
	  function getLanguage(name) {
	    name = (name || '').toLowerCase();
	    return languages[name] || languages[aliases[name]];
	  }
	  function registerAliases(aliasList, { languageName }) {
	    if (typeof aliasList === 'string') {
	      aliasList = [aliasList];
	    }
	    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
	  }
	  function autoDetection(name) {
	    const lang = getLanguage(name);
	    return lang && !lang.disableAutodetect;
	  }
	  function upgradePluginAPI(plugin) {
	    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
	      plugin["before:highlightElement"] = (data) => {
	        plugin["before:highlightBlock"](
	          Object.assign({ block: data.el }, data)
	        );
	      };
	    }
	    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
	      plugin["after:highlightElement"] = (data) => {
	        plugin["after:highlightBlock"](
	          Object.assign({ block: data.el }, data)
	        );
	      };
	    }
	  }
	  function addPlugin(plugin) {
	    upgradePluginAPI(plugin);
	    plugins.push(plugin);
	  }
	  function fire(event, args) {
	    const cb = event;
	    plugins.forEach(function(plugin) {
	      if (plugin[cb]) {
	        plugin[cb](args);
	      }
	    });
	  }
	  function deprecateFixMarkup(arg) {
	    deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
	    deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
	    return fixMarkup(arg);
	  }
	  function deprecateHighlightBlock(el) {
	    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
	    deprecated("10.7.0", "Please use highlightElement now.");
	    return highlightElement(el);
	  }
	  Object.assign(hljs, {
	    highlight,
	    highlightAuto,
	    highlightAll,
	    fixMarkup: deprecateFixMarkup,
	    highlightElement,
	    highlightBlock: deprecateHighlightBlock,
	    configure,
	    initHighlighting,
	    initHighlightingOnLoad,
	    registerLanguage,
	    unregisterLanguage,
	    listLanguages,
	    getLanguage,
	    registerAliases,
	    requireLanguage,
	    autoDetection,
	    inherit: inherit$1,
	    addPlugin,
	    vuePlugin: BuildVuePlugin(hljs).VuePlugin
	  });
	  hljs.debugMode = function() { SAFE_MODE = false; };
	  hljs.safeMode = function() { SAFE_MODE = true; };
	  hljs.versionString = version;
	  for (const key in MODES) {
	    if (typeof MODES[key] === "object") {
	      deepFreezeEs6(MODES[key]);
	    }
	  }
	  Object.assign(hljs, MODES);
	  hljs.addPlugin(brPlugin);
	  hljs.addPlugin(mergeHTMLPlugin);
	  hljs.addPlugin(tabReplacePlugin);
	  return hljs;
	};
	var highlight = HLJS({});
	var core = highlight;

	const MODES$1 = (hljs) => {
	  return {
	    IMPORTANT: {
	      className: 'meta',
	      begin: '!important'
	    },
	    HEXCOLOR: {
	      className: 'number',
	      begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
	    },
	    ATTRIBUTE_SELECTOR_MODE: {
	      className: 'selector-attr',
	      begin: /\[/,
	      end: /\]/,
	      illegal: '$',
	      contains: [
	        hljs.APOS_STRING_MODE,
	        hljs.QUOTE_STRING_MODE
	      ]
	    }
	  };
	};
	const TAGS = [
	  'a',
	  'abbr',
	  'address',
	  'article',
	  'aside',
	  'audio',
	  'b',
	  'blockquote',
	  'body',
	  'button',
	  'canvas',
	  'caption',
	  'cite',
	  'code',
	  'dd',
	  'del',
	  'details',
	  'dfn',
	  'div',
	  'dl',
	  'dt',
	  'em',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'header',
	  'hgroup',
	  'html',
	  'i',
	  'iframe',
	  'img',
	  'input',
	  'ins',
	  'kbd',
	  'label',
	  'legend',
	  'li',
	  'main',
	  'mark',
	  'menu',
	  'nav',
	  'object',
	  'ol',
	  'p',
	  'q',
	  'quote',
	  'samp',
	  'section',
	  'span',
	  'strong',
	  'summary',
	  'sup',
	  'table',
	  'tbody',
	  'td',
	  'textarea',
	  'tfoot',
	  'th',
	  'thead',
	  'time',
	  'tr',
	  'ul',
	  'var',
	  'video'
	];
	const MEDIA_FEATURES = [
	  'any-hover',
	  'any-pointer',
	  'aspect-ratio',
	  'color',
	  'color-gamut',
	  'color-index',
	  'device-aspect-ratio',
	  'device-height',
	  'device-width',
	  'display-mode',
	  'forced-colors',
	  'grid',
	  'height',
	  'hover',
	  'inverted-colors',
	  'monochrome',
	  'orientation',
	  'overflow-block',
	  'overflow-inline',
	  'pointer',
	  'prefers-color-scheme',
	  'prefers-contrast',
	  'prefers-reduced-motion',
	  'prefers-reduced-transparency',
	  'resolution',
	  'scan',
	  'scripting',
	  'update',
	  'width',
	  'min-width',
	  'max-width',
	  'min-height',
	  'max-height'
	];
	const PSEUDO_CLASSES = [
	  'active',
	  'any-link',
	  'blank',
	  'checked',
	  'current',
	  'default',
	  'defined',
	  'dir',
	  'disabled',
	  'drop',
	  'empty',
	  'enabled',
	  'first',
	  'first-child',
	  'first-of-type',
	  'fullscreen',
	  'future',
	  'focus',
	  'focus-visible',
	  'focus-within',
	  'has',
	  'host',
	  'host-context',
	  'hover',
	  'indeterminate',
	  'in-range',
	  'invalid',
	  'is',
	  'lang',
	  'last-child',
	  'last-of-type',
	  'left',
	  'link',
	  'local-link',
	  'not',
	  'nth-child',
	  'nth-col',
	  'nth-last-child',
	  'nth-last-col',
	  'nth-last-of-type',
	  'nth-of-type',
	  'only-child',
	  'only-of-type',
	  'optional',
	  'out-of-range',
	  'past',
	  'placeholder-shown',
	  'read-only',
	  'read-write',
	  'required',
	  'right',
	  'root',
	  'scope',
	  'target',
	  'target-within',
	  'user-invalid',
	  'valid',
	  'visited',
	  'where'
	];
	const PSEUDO_ELEMENTS = [
	  'after',
	  'backdrop',
	  'before',
	  'cue',
	  'cue-region',
	  'first-letter',
	  'first-line',
	  'grammar-error',
	  'marker',
	  'part',
	  'placeholder',
	  'selection',
	  'slotted',
	  'spelling-error'
	];
	const ATTRIBUTES = [
	  'align-content',
	  'align-items',
	  'align-self',
	  'animation',
	  'animation-delay',
	  'animation-direction',
	  'animation-duration',
	  'animation-fill-mode',
	  'animation-iteration-count',
	  'animation-name',
	  'animation-play-state',
	  'animation-timing-function',
	  'auto',
	  'backface-visibility',
	  'background',
	  'background-attachment',
	  'background-clip',
	  'background-color',
	  'background-image',
	  'background-origin',
	  'background-position',
	  'background-repeat',
	  'background-size',
	  'border',
	  'border-bottom',
	  'border-bottom-color',
	  'border-bottom-left-radius',
	  'border-bottom-right-radius',
	  'border-bottom-style',
	  'border-bottom-width',
	  'border-collapse',
	  'border-color',
	  'border-image',
	  'border-image-outset',
	  'border-image-repeat',
	  'border-image-slice',
	  'border-image-source',
	  'border-image-width',
	  'border-left',
	  'border-left-color',
	  'border-left-style',
	  'border-left-width',
	  'border-radius',
	  'border-right',
	  'border-right-color',
	  'border-right-style',
	  'border-right-width',
	  'border-spacing',
	  'border-style',
	  'border-top',
	  'border-top-color',
	  'border-top-left-radius',
	  'border-top-right-radius',
	  'border-top-style',
	  'border-top-width',
	  'border-width',
	  'bottom',
	  'box-decoration-break',
	  'box-shadow',
	  'box-sizing',
	  'break-after',
	  'break-before',
	  'break-inside',
	  'caption-side',
	  'clear',
	  'clip',
	  'clip-path',
	  'color',
	  'column-count',
	  'column-fill',
	  'column-gap',
	  'column-rule',
	  'column-rule-color',
	  'column-rule-style',
	  'column-rule-width',
	  'column-span',
	  'column-width',
	  'columns',
	  'content',
	  'counter-increment',
	  'counter-reset',
	  'cursor',
	  'direction',
	  'display',
	  'empty-cells',
	  'filter',
	  'flex',
	  'flex-basis',
	  'flex-direction',
	  'flex-flow',
	  'flex-grow',
	  'flex-shrink',
	  'flex-wrap',
	  'float',
	  'font',
	  'font-display',
	  'font-family',
	  'font-feature-settings',
	  'font-kerning',
	  'font-language-override',
	  'font-size',
	  'font-size-adjust',
	  'font-smoothing',
	  'font-stretch',
	  'font-style',
	  'font-variant',
	  'font-variant-ligatures',
	  'font-variation-settings',
	  'font-weight',
	  'height',
	  'hyphens',
	  'icon',
	  'image-orientation',
	  'image-rendering',
	  'image-resolution',
	  'ime-mode',
	  'inherit',
	  'initial',
	  'justify-content',
	  'left',
	  'letter-spacing',
	  'line-height',
	  'list-style',
	  'list-style-image',
	  'list-style-position',
	  'list-style-type',
	  'margin',
	  'margin-bottom',
	  'margin-left',
	  'margin-right',
	  'margin-top',
	  'marks',
	  'mask',
	  'max-height',
	  'max-width',
	  'min-height',
	  'min-width',
	  'nav-down',
	  'nav-index',
	  'nav-left',
	  'nav-right',
	  'nav-up',
	  'none',
	  'normal',
	  'object-fit',
	  'object-position',
	  'opacity',
	  'order',
	  'orphans',
	  'outline',
	  'outline-color',
	  'outline-offset',
	  'outline-style',
	  'outline-width',
	  'overflow',
	  'overflow-wrap',
	  'overflow-x',
	  'overflow-y',
	  'padding',
	  'padding-bottom',
	  'padding-left',
	  'padding-right',
	  'padding-top',
	  'page-break-after',
	  'page-break-before',
	  'page-break-inside',
	  'perspective',
	  'perspective-origin',
	  'pointer-events',
	  'position',
	  'quotes',
	  'resize',
	  'right',
	  'src',
	  'tab-size',
	  'table-layout',
	  'text-align',
	  'text-align-last',
	  'text-decoration',
	  'text-decoration-color',
	  'text-decoration-line',
	  'text-decoration-style',
	  'text-indent',
	  'text-overflow',
	  'text-rendering',
	  'text-shadow',
	  'text-transform',
	  'text-underline-position',
	  'top',
	  'transform',
	  'transform-origin',
	  'transform-style',
	  'transition',
	  'transition-delay',
	  'transition-duration',
	  'transition-property',
	  'transition-timing-function',
	  'unicode-bidi',
	  'vertical-align',
	  'visibility',
	  'white-space',
	  'widows',
	  'width',
	  'word-break',
	  'word-spacing',
	  'word-wrap',
	  'z-index'
	].reverse();
	function source$1(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead(re) {
	  return concat$1('(?=', re, ')');
	}
	function concat$1(...args) {
	  const joined = args.map((x) => source$1(x)).join("");
	  return joined;
	}
	function css(hljs) {
	  const modes = MODES$1(hljs);
	  const FUNCTION_DISPATCH = {
	    className: "built_in",
	    begin: /[\w-]+(?=\()/
	  };
	  const VENDOR_PREFIX = {
	    begin: /-(webkit|moz|ms|o)-(?=[a-z])/
	  };
	  const AT_MODIFIERS = "and or not only";
	  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/;
	  const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
	  const STRINGS = [
	    hljs.APOS_STRING_MODE,
	    hljs.QUOTE_STRING_MODE
	  ];
	  return {
	    name: 'CSS',
	    case_insensitive: true,
	    illegal: /[=|'\$]/,
	    keywords: {
	      keyframePosition: "from to"
	    },
	    classNameAliases: {
	      keyframePosition: "selector-tag"
	    },
	    contains: [
	      hljs.C_BLOCK_COMMENT_MODE,
	      VENDOR_PREFIX,
	      hljs.CSS_NUMBER_MODE,
	      {
	        className: 'selector-id',
	        begin: /#[A-Za-z0-9_-]+/,
	        relevance: 0
	      },
	      {
	        className: 'selector-class',
	        begin: '\\.' + IDENT_RE,
	        relevance: 0
	      },
	      modes.ATTRIBUTE_SELECTOR_MODE,
	      {
	        className: 'selector-pseudo',
	        variants: [
	          {
	            begin: ':(' + PSEUDO_CLASSES.join('|') + ')'
	          },
	          {
	            begin: '::(' + PSEUDO_ELEMENTS.join('|') + ')'
	          }
	        ]
	      },
	      {
	        className: 'attribute',
	        begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b'
	      },
	      {
	        begin: ':',
	        end: '[;}]',
	        contains: [
	          modes.HEXCOLOR,
	          modes.IMPORTANT,
	          hljs.CSS_NUMBER_MODE,
	          ...STRINGS,
	          {
	            begin: /(url|data-uri)\(/,
	            end: /\)/,
	            relevance: 0,
	            keywords: {
	              built_in: "url data-uri"
	            },
	            contains: [
	              {
	                className: "string",
	                begin: /[^)]/,
	                endsWithParent: true,
	                excludeEnd: true
	              }
	            ]
	          },
	          FUNCTION_DISPATCH
	        ]
	      },
	      {
	        begin: lookahead(/@/),
	        end: '[{;]',
	        relevance: 0,
	        illegal: /:/,
	        contains: [
	          {
	            className: 'keyword',
	            begin: AT_PROPERTY_RE
	          },
	          {
	            begin: /\s/,
	            endsWithParent: true,
	            excludeEnd: true,
	            relevance: 0,
	            keywords: {
	              $pattern: /[a-z-]+/,
	              keyword: AT_MODIFIERS,
	              attribute: MEDIA_FEATURES.join(" ")
	            },
	            contains: [
	              {
	                begin: /[a-z-]+(?=:)/,
	                className: "attribute"
	              },
	              ...STRINGS,
	              hljs.CSS_NUMBER_MODE
	            ]
	          }
	        ]
	      },
	      {
	        className: 'selector-tag',
	        begin: '\\b(' + TAGS.join('|') + ')\\b'
	      }
	    ]
	  };
	}
	var css_1 = css;

	var decimalDigits = '[0-9](_*[0-9])*';
	var frac = `\\.(${decimalDigits})`;
	var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
	var NUMERIC = {
	  className: 'number',
	  variants: [
	    { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
	      `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
	    { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
	    { begin: `(${frac})[fFdD]?\\b` },
	    { begin: `\\b(${decimalDigits})[fFdD]\\b` },
	    { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
	      `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },
	    { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
	    { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },
	    { begin: '\\b0(_*[0-7])*[lL]?\\b' },
	    { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
	  ],
	  relevance: 0
	};
	function java(hljs) {
	  var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
	  var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
	  var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
	    'for true while long strictfp finally protected import native final void ' +
	    'enum else break transient catch instanceof byte super volatile case assert short ' +
	    'package default double public try this switch continue throws protected public private ' +
	    'module requires exports do';
	  var ANNOTATION = {
	    className: 'meta',
	    begin: '@' + JAVA_IDENT_RE,
	    contains: [
	      {
	        begin: /\(/,
	        end: /\)/,
	        contains: ["self"]
	      },
	    ]
	  };
	  const NUMBER = NUMERIC;
	  return {
	    name: 'Java',
	    aliases: ['jsp'],
	    keywords: KEYWORDS,
	    illegal: /<\/|#/,
	    contains: [
	      hljs.COMMENT(
	        '/\\*\\*',
	        '\\*/',
	        {
	          relevance: 0,
	          contains: [
	            {
	              begin: /\w+@/, relevance: 0
	            },
	            {
	              className: 'doctag',
	              begin: '@[A-Za-z]+'
	            }
	          ]
	        }
	      ),
	      {
	        begin: /import java\.[a-z]+\./,
	        keywords: "import",
	        relevance: 2
	      },
	      hljs.C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      hljs.APOS_STRING_MODE,
	      hljs.QUOTE_STRING_MODE,
	      {
	        className: 'class',
	        beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
	        relevance: 1,
	        keywords: 'class interface enum',
	        illegal: /[:"\[\]]/,
	        contains: [
	          { beginKeywords: 'extends implements' },
	          hljs.UNDERSCORE_TITLE_MODE
	        ]
	      },
	      {
	        beginKeywords: 'new throw return else',
	        relevance: 0
	      },
	      {
	        className: 'class',
	        begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
	        returnBegin: true,
	        excludeEnd: true,
	        end: /[{;=]/,
	        keywords: KEYWORDS,
	        contains: [
	          { beginKeywords: "record" },
	          {
	            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
	            returnBegin: true,
	            relevance: 0,
	            contains: [hljs.UNDERSCORE_TITLE_MODE]
	          },
	          {
	            className: 'params',
	            begin: /\(/, end: /\)/,
	            keywords: KEYWORDS,
	            relevance: 0,
	            contains: [
	              hljs.C_BLOCK_COMMENT_MODE
	            ]
	          },
	          hljs.C_LINE_COMMENT_MODE,
	          hljs.C_BLOCK_COMMENT_MODE
	        ]
	      },
	      {
	        className: 'function',
	        begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
	        excludeEnd: true,
	        keywords: KEYWORDS,
	        contains: [
	          {
	            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
	            relevance: 0,
	            contains: [hljs.UNDERSCORE_TITLE_MODE]
	          },
	          {
	            className: 'params',
	            begin: /\(/, end: /\)/,
	            keywords: KEYWORDS,
	            relevance: 0,
	            contains: [
	              ANNOTATION,
	              hljs.APOS_STRING_MODE,
	              hljs.QUOTE_STRING_MODE,
	              NUMBER,
	              hljs.C_BLOCK_COMMENT_MODE
	            ]
	          },
	          hljs.C_LINE_COMMENT_MODE,
	          hljs.C_BLOCK_COMMENT_MODE
	        ]
	      },
	      NUMBER,
	      ANNOTATION
	    ]
	  };
	}
	var java_1 = java;

	const IDENT_RE$1 = '[A-Za-z$_][0-9A-Za-z$_]*';
	const KEYWORDS = [
	  "as",
	  "in",
	  "of",
	  "if",
	  "for",
	  "while",
	  "finally",
	  "var",
	  "new",
	  "function",
	  "do",
	  "return",
	  "void",
	  "else",
	  "break",
	  "catch",
	  "instanceof",
	  "with",
	  "throw",
	  "case",
	  "default",
	  "try",
	  "switch",
	  "continue",
	  "typeof",
	  "delete",
	  "let",
	  "yield",
	  "const",
	  "class",
	  "debugger",
	  "async",
	  "await",
	  "static",
	  "import",
	  "from",
	  "export",
	  "extends"
	];
	const LITERALS = [
	  "true",
	  "false",
	  "null",
	  "undefined",
	  "NaN",
	  "Infinity"
	];
	const TYPES = [
	  "Intl",
	  "DataView",
	  "Number",
	  "Math",
	  "Date",
	  "String",
	  "RegExp",
	  "Object",
	  "Function",
	  "Boolean",
	  "Error",
	  "Symbol",
	  "Set",
	  "Map",
	  "WeakSet",
	  "WeakMap",
	  "Proxy",
	  "Reflect",
	  "JSON",
	  "Promise",
	  "Float64Array",
	  "Int16Array",
	  "Int32Array",
	  "Int8Array",
	  "Uint16Array",
	  "Uint32Array",
	  "Float32Array",
	  "Array",
	  "Uint8Array",
	  "Uint8ClampedArray",
	  "ArrayBuffer",
	  "BigInt64Array",
	  "BigUint64Array",
	  "BigInt"
	];
	const ERROR_TYPES = [
	  "EvalError",
	  "InternalError",
	  "RangeError",
	  "ReferenceError",
	  "SyntaxError",
	  "TypeError",
	  "URIError"
	];
	const BUILT_IN_GLOBALS = [
	  "setInterval",
	  "setTimeout",
	  "clearInterval",
	  "clearTimeout",
	  "require",
	  "exports",
	  "eval",
	  "isFinite",
	  "isNaN",
	  "parseFloat",
	  "parseInt",
	  "decodeURI",
	  "decodeURIComponent",
	  "encodeURI",
	  "encodeURIComponent",
	  "escape",
	  "unescape"
	];
	const BUILT_IN_VARIABLES = [
	  "arguments",
	  "this",
	  "super",
	  "console",
	  "window",
	  "document",
	  "localStorage",
	  "module",
	  "global"
	];
	const BUILT_INS = [].concat(
	  BUILT_IN_GLOBALS,
	  BUILT_IN_VARIABLES,
	  TYPES,
	  ERROR_TYPES
	);
	function source$2(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$1(re) {
	  return concat$2('(?=', re, ')');
	}
	function concat$2(...args) {
	  const joined = args.map((x) => source$2(x)).join("");
	  return joined;
	}
	function javascript(hljs) {
	  const hasClosingTag = (match, { after }) => {
	    const tag = "</" + match[0].slice(1);
	    const pos = match.input.indexOf(tag, after);
	    return pos !== -1;
	  };
	  const IDENT_RE$1$1 = IDENT_RE$1;
	  const FRAGMENT = {
	    begin: '<>',
	    end: '</>'
	  };
	  const XML_TAG = {
	    begin: /<[A-Za-z0-9\\._:-]+/,
	    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
	    isTrulyOpeningTag: (match, response) => {
	      const afterMatchIndex = match[0].length + match.index;
	      const nextChar = match.input[afterMatchIndex];
	      if (nextChar === "<") {
	        response.ignoreMatch();
	        return;
	      }
	      if (nextChar === ">") {
	        if (!hasClosingTag(match, { after: afterMatchIndex })) {
	          response.ignoreMatch();
	        }
	      }
	    }
	  };
	  const KEYWORDS$1 = {
	    $pattern: IDENT_RE$1,
	    keyword: KEYWORDS,
	    literal: LITERALS,
	    built_in: BUILT_INS
	  };
	  const decimalDigits = '[0-9](_?[0-9])*';
	  const frac = `\\.(${decimalDigits})`;
	  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
	  const NUMBER = {
	    className: 'number',
	    variants: [
	      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
	        `[eE][+-]?(${decimalDigits})\\b` },
	      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
	      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
	      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
	      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
	      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
	      { begin: "\\b0[0-7]+n?\\b" },
	    ],
	    relevance: 0
	  };
	  const SUBST = {
	    className: 'subst',
	    begin: '\\$\\{',
	    end: '\\}',
	    keywords: KEYWORDS$1,
	    contains: []
	  };
	  const HTML_TEMPLATE = {
	    begin: 'html`',
	    end: '',
	    starts: {
	      end: '`',
	      returnEnd: false,
	      contains: [
	        hljs.BACKSLASH_ESCAPE,
	        SUBST
	      ],
	      subLanguage: 'xml'
	    }
	  };
	  const CSS_TEMPLATE = {
	    begin: 'css`',
	    end: '',
	    starts: {
	      end: '`',
	      returnEnd: false,
	      contains: [
	        hljs.BACKSLASH_ESCAPE,
	        SUBST
	      ],
	      subLanguage: 'css'
	    }
	  };
	  const TEMPLATE_STRING = {
	    className: 'string',
	    begin: '`',
	    end: '`',
	    contains: [
	      hljs.BACKSLASH_ESCAPE,
	      SUBST
	    ]
	  };
	  const JSDOC_COMMENT = hljs.COMMENT(
	    /\/\*\*(?!\/)/,
	    '\\*/',
	    {
	      relevance: 0,
	      contains: [
	        {
	          className: 'doctag',
	          begin: '@[A-Za-z]+',
	          contains: [
	            {
	              className: 'type',
	              begin: '\\{',
	              end: '\\}',
	              relevance: 0
	            },
	            {
	              className: 'variable',
	              begin: IDENT_RE$1$1 + '(?=\\s*(-)|$)',
	              endsParent: true,
	              relevance: 0
	            },
	            {
	              begin: /(?=[^\n])\s/,
	              relevance: 0
	            }
	          ]
	        }
	      ]
	    }
	  );
	  const COMMENT = {
	    className: "comment",
	    variants: [
	      JSDOC_COMMENT,
	      hljs.C_BLOCK_COMMENT_MODE,
	      hljs.C_LINE_COMMENT_MODE
	    ]
	  };
	  const SUBST_INTERNALS = [
	    hljs.APOS_STRING_MODE,
	    hljs.QUOTE_STRING_MODE,
	    HTML_TEMPLATE,
	    CSS_TEMPLATE,
	    TEMPLATE_STRING,
	    NUMBER,
	    hljs.REGEXP_MODE
	  ];
	  SUBST.contains = SUBST_INTERNALS
	    .concat({
	      begin: /\{/,
	      end: /\}/,
	      keywords: KEYWORDS$1,
	      contains: [
	        "self"
	      ].concat(SUBST_INTERNALS)
	    });
	  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
	  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
	    {
	      begin: /\(/,
	      end: /\)/,
	      keywords: KEYWORDS$1,
	      contains: ["self"].concat(SUBST_AND_COMMENTS)
	    }
	  ]);
	  const PARAMS = {
	    className: 'params',
	    begin: /\(/,
	    end: /\)/,
	    excludeBegin: true,
	    excludeEnd: true,
	    keywords: KEYWORDS$1,
	    contains: PARAMS_CONTAINS
	  };
	  return {
	    name: 'Javascript',
	    aliases: ['js', 'jsx', 'mjs', 'cjs'],
	    keywords: KEYWORDS$1,
	    exports: { PARAMS_CONTAINS },
	    illegal: /#(?![$_A-z])/,
	    contains: [
	      hljs.SHEBANG({
	        label: "shebang",
	        binary: "node",
	        relevance: 5
	      }),
	      {
	        label: "use_strict",
	        className: 'meta',
	        relevance: 10,
	        begin: /^\s*['"]use (strict|asm)['"]/
	      },
	      hljs.APOS_STRING_MODE,
	      hljs.QUOTE_STRING_MODE,
	      HTML_TEMPLATE,
	      CSS_TEMPLATE,
	      TEMPLATE_STRING,
	      COMMENT,
	      NUMBER,
	      {
	        begin: concat$2(/[{,\n]\s*/,
	          lookahead$1(concat$2(
	            /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
	            IDENT_RE$1$1 + '\\s*:'))),
	        relevance: 0,
	        contains: [
	          {
	            className: 'attr',
	            begin: IDENT_RE$1$1 + lookahead$1('\\s*:'),
	            relevance: 0
	          }
	        ]
	      },
	      {
	        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
	        keywords: 'return throw case',
	        contains: [
	          COMMENT,
	          hljs.REGEXP_MODE,
	          {
	            className: 'function',
	            begin: '(\\(' +
	            '[^()]*(\\(' +
	            '[^()]*(\\(' +
	            '[^()]*' +
	            '\\)[^()]*)*' +
	            '\\)[^()]*)*' +
	            '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
	            returnBegin: true,
	            end: '\\s*=>',
	            contains: [
	              {
	                className: 'params',
	                variants: [
	                  {
	                    begin: hljs.UNDERSCORE_IDENT_RE,
	                    relevance: 0
	                  },
	                  {
	                    className: null,
	                    begin: /\(\s*\)/,
	                    skip: true
	                  },
	                  {
	                    begin: /\(/,
	                    end: /\)/,
	                    excludeBegin: true,
	                    excludeEnd: true,
	                    keywords: KEYWORDS$1,
	                    contains: PARAMS_CONTAINS
	                  }
	                ]
	              }
	            ]
	          },
	          {
	            begin: /,/, relevance: 0
	          },
	          {
	            className: '',
	            begin: /\s/,
	            end: /\s*/,
	            skip: true
	          },
	          {
	            variants: [
	              { begin: FRAGMENT.begin, end: FRAGMENT.end },
	              {
	                begin: XML_TAG.begin,
	                'on:begin': XML_TAG.isTrulyOpeningTag,
	                end: XML_TAG.end
	              }
	            ],
	            subLanguage: 'xml',
	            contains: [
	              {
	                begin: XML_TAG.begin,
	                end: XML_TAG.end,
	                skip: true,
	                contains: ['self']
	              }
	            ]
	          }
	        ],
	        relevance: 0
	      },
	      {
	        className: 'function',
	        beginKeywords: 'function',
	        end: /[{;]/,
	        excludeEnd: true,
	        keywords: KEYWORDS$1,
	        contains: [
	          'self',
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
	          PARAMS
	        ],
	        illegal: /%/
	      },
	      {
	        beginKeywords: "while if switch catch for"
	      },
	      {
	        className: 'function',
	        begin: hljs.UNDERSCORE_IDENT_RE +
	          '\\(' +
	          '[^()]*(\\(' +
	            '[^()]*(\\(' +
	              '[^()]*' +
	            '\\)[^()]*)*' +
	          '\\)[^()]*)*' +
	          '\\)\\s*\\{',
	        returnBegin:true,
	        contains: [
	          PARAMS,
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
	        ]
	      },
	      {
	        variants: [
	          { begin: '\\.' + IDENT_RE$1$1 },
	          { begin: '\\$' + IDENT_RE$1$1 }
	        ],
	        relevance: 0
	      },
	      {
	        className: 'class',
	        beginKeywords: 'class',
	        end: /[{;=]/,
	        excludeEnd: true,
	        illegal: /[:"[\]]/,
	        contains: [
	          { beginKeywords: 'extends' },
	          hljs.UNDERSCORE_TITLE_MODE
	        ]
	      },
	      {
	        begin: /\b(?=constructor)/,
	        end: /[{;]/,
	        excludeEnd: true,
	        contains: [
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
	          'self',
	          PARAMS
	        ]
	      },
	      {
	        begin: '(get|set)\\s+(?=' + IDENT_RE$1$1 + '\\()',
	        end: /\{/,
	        keywords: "get set",
	        contains: [
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1$1 }),
	          { begin: /\(\)/ },
	          PARAMS
	        ]
	      },
	      {
	        begin: /\$[(.]/
	      }
	    ]
	  };
	}
	var javascript_1 = javascript;

	function json(hljs) {
	  const LITERALS = {
	    literal: 'true false null'
	  };
	  const ALLOWED_COMMENTS = [
	    hljs.C_LINE_COMMENT_MODE,
	    hljs.C_BLOCK_COMMENT_MODE
	  ];
	  const TYPES = [
	    hljs.QUOTE_STRING_MODE,
	    hljs.C_NUMBER_MODE
	  ];
	  const VALUE_CONTAINER = {
	    end: ',',
	    endsWithParent: true,
	    excludeEnd: true,
	    contains: TYPES,
	    keywords: LITERALS
	  };
	  const OBJECT = {
	    begin: /\{/,
	    end: /\}/,
	    contains: [
	      {
	        className: 'attr',
	        begin: /"/,
	        end: /"/,
	        contains: [hljs.BACKSLASH_ESCAPE],
	        illegal: '\\n'
	      },
	      hljs.inherit(VALUE_CONTAINER, {
	        begin: /:/
	      })
	    ].concat(ALLOWED_COMMENTS),
	    illegal: '\\S'
	  };
	  const ARRAY = {
	    begin: '\\[',
	    end: '\\]',
	    contains: [hljs.inherit(VALUE_CONTAINER)],
	    illegal: '\\S'
	  };
	  TYPES.push(OBJECT, ARRAY);
	  ALLOWED_COMMENTS.forEach(function(rule) {
	    TYPES.push(rule);
	  });
	  return {
	    name: 'JSON',
	    contains: TYPES,
	    keywords: LITERALS,
	    illegal: '\\S'
	  };
	}
	var json_1 = json;

	const MODES$2 = (hljs) => {
	  return {
	    IMPORTANT: {
	      className: 'meta',
	      begin: '!important'
	    },
	    HEXCOLOR: {
	      className: 'number',
	      begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
	    },
	    ATTRIBUTE_SELECTOR_MODE: {
	      className: 'selector-attr',
	      begin: /\[/,
	      end: /\]/,
	      illegal: '$',
	      contains: [
	        hljs.APOS_STRING_MODE,
	        hljs.QUOTE_STRING_MODE
	      ]
	    }
	  };
	};
	const TAGS$1 = [
	  'a',
	  'abbr',
	  'address',
	  'article',
	  'aside',
	  'audio',
	  'b',
	  'blockquote',
	  'body',
	  'button',
	  'canvas',
	  'caption',
	  'cite',
	  'code',
	  'dd',
	  'del',
	  'details',
	  'dfn',
	  'div',
	  'dl',
	  'dt',
	  'em',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'header',
	  'hgroup',
	  'html',
	  'i',
	  'iframe',
	  'img',
	  'input',
	  'ins',
	  'kbd',
	  'label',
	  'legend',
	  'li',
	  'main',
	  'mark',
	  'menu',
	  'nav',
	  'object',
	  'ol',
	  'p',
	  'q',
	  'quote',
	  'samp',
	  'section',
	  'span',
	  'strong',
	  'summary',
	  'sup',
	  'table',
	  'tbody',
	  'td',
	  'textarea',
	  'tfoot',
	  'th',
	  'thead',
	  'time',
	  'tr',
	  'ul',
	  'var',
	  'video'
	];
	const MEDIA_FEATURES$1 = [
	  'any-hover',
	  'any-pointer',
	  'aspect-ratio',
	  'color',
	  'color-gamut',
	  'color-index',
	  'device-aspect-ratio',
	  'device-height',
	  'device-width',
	  'display-mode',
	  'forced-colors',
	  'grid',
	  'height',
	  'hover',
	  'inverted-colors',
	  'monochrome',
	  'orientation',
	  'overflow-block',
	  'overflow-inline',
	  'pointer',
	  'prefers-color-scheme',
	  'prefers-contrast',
	  'prefers-reduced-motion',
	  'prefers-reduced-transparency',
	  'resolution',
	  'scan',
	  'scripting',
	  'update',
	  'width',
	  'min-width',
	  'max-width',
	  'min-height',
	  'max-height'
	];
	const PSEUDO_CLASSES$1 = [
	  'active',
	  'any-link',
	  'blank',
	  'checked',
	  'current',
	  'default',
	  'defined',
	  'dir',
	  'disabled',
	  'drop',
	  'empty',
	  'enabled',
	  'first',
	  'first-child',
	  'first-of-type',
	  'fullscreen',
	  'future',
	  'focus',
	  'focus-visible',
	  'focus-within',
	  'has',
	  'host',
	  'host-context',
	  'hover',
	  'indeterminate',
	  'in-range',
	  'invalid',
	  'is',
	  'lang',
	  'last-child',
	  'last-of-type',
	  'left',
	  'link',
	  'local-link',
	  'not',
	  'nth-child',
	  'nth-col',
	  'nth-last-child',
	  'nth-last-col',
	  'nth-last-of-type',
	  'nth-of-type',
	  'only-child',
	  'only-of-type',
	  'optional',
	  'out-of-range',
	  'past',
	  'placeholder-shown',
	  'read-only',
	  'read-write',
	  'required',
	  'right',
	  'root',
	  'scope',
	  'target',
	  'target-within',
	  'user-invalid',
	  'valid',
	  'visited',
	  'where'
	];
	const PSEUDO_ELEMENTS$1 = [
	  'after',
	  'backdrop',
	  'before',
	  'cue',
	  'cue-region',
	  'first-letter',
	  'first-line',
	  'grammar-error',
	  'marker',
	  'part',
	  'placeholder',
	  'selection',
	  'slotted',
	  'spelling-error'
	];
	const ATTRIBUTES$1 = [
	  'align-content',
	  'align-items',
	  'align-self',
	  'animation',
	  'animation-delay',
	  'animation-direction',
	  'animation-duration',
	  'animation-fill-mode',
	  'animation-iteration-count',
	  'animation-name',
	  'animation-play-state',
	  'animation-timing-function',
	  'auto',
	  'backface-visibility',
	  'background',
	  'background-attachment',
	  'background-clip',
	  'background-color',
	  'background-image',
	  'background-origin',
	  'background-position',
	  'background-repeat',
	  'background-size',
	  'border',
	  'border-bottom',
	  'border-bottom-color',
	  'border-bottom-left-radius',
	  'border-bottom-right-radius',
	  'border-bottom-style',
	  'border-bottom-width',
	  'border-collapse',
	  'border-color',
	  'border-image',
	  'border-image-outset',
	  'border-image-repeat',
	  'border-image-slice',
	  'border-image-source',
	  'border-image-width',
	  'border-left',
	  'border-left-color',
	  'border-left-style',
	  'border-left-width',
	  'border-radius',
	  'border-right',
	  'border-right-color',
	  'border-right-style',
	  'border-right-width',
	  'border-spacing',
	  'border-style',
	  'border-top',
	  'border-top-color',
	  'border-top-left-radius',
	  'border-top-right-radius',
	  'border-top-style',
	  'border-top-width',
	  'border-width',
	  'bottom',
	  'box-decoration-break',
	  'box-shadow',
	  'box-sizing',
	  'break-after',
	  'break-before',
	  'break-inside',
	  'caption-side',
	  'clear',
	  'clip',
	  'clip-path',
	  'color',
	  'column-count',
	  'column-fill',
	  'column-gap',
	  'column-rule',
	  'column-rule-color',
	  'column-rule-style',
	  'column-rule-width',
	  'column-span',
	  'column-width',
	  'columns',
	  'content',
	  'counter-increment',
	  'counter-reset',
	  'cursor',
	  'direction',
	  'display',
	  'empty-cells',
	  'filter',
	  'flex',
	  'flex-basis',
	  'flex-direction',
	  'flex-flow',
	  'flex-grow',
	  'flex-shrink',
	  'flex-wrap',
	  'float',
	  'font',
	  'font-display',
	  'font-family',
	  'font-feature-settings',
	  'font-kerning',
	  'font-language-override',
	  'font-size',
	  'font-size-adjust',
	  'font-smoothing',
	  'font-stretch',
	  'font-style',
	  'font-variant',
	  'font-variant-ligatures',
	  'font-variation-settings',
	  'font-weight',
	  'height',
	  'hyphens',
	  'icon',
	  'image-orientation',
	  'image-rendering',
	  'image-resolution',
	  'ime-mode',
	  'inherit',
	  'initial',
	  'justify-content',
	  'left',
	  'letter-spacing',
	  'line-height',
	  'list-style',
	  'list-style-image',
	  'list-style-position',
	  'list-style-type',
	  'margin',
	  'margin-bottom',
	  'margin-left',
	  'margin-right',
	  'margin-top',
	  'marks',
	  'mask',
	  'max-height',
	  'max-width',
	  'min-height',
	  'min-width',
	  'nav-down',
	  'nav-index',
	  'nav-left',
	  'nav-right',
	  'nav-up',
	  'none',
	  'normal',
	  'object-fit',
	  'object-position',
	  'opacity',
	  'order',
	  'orphans',
	  'outline',
	  'outline-color',
	  'outline-offset',
	  'outline-style',
	  'outline-width',
	  'overflow',
	  'overflow-wrap',
	  'overflow-x',
	  'overflow-y',
	  'padding',
	  'padding-bottom',
	  'padding-left',
	  'padding-right',
	  'padding-top',
	  'page-break-after',
	  'page-break-before',
	  'page-break-inside',
	  'perspective',
	  'perspective-origin',
	  'pointer-events',
	  'position',
	  'quotes',
	  'resize',
	  'right',
	  'src',
	  'tab-size',
	  'table-layout',
	  'text-align',
	  'text-align-last',
	  'text-decoration',
	  'text-decoration-color',
	  'text-decoration-line',
	  'text-decoration-style',
	  'text-indent',
	  'text-overflow',
	  'text-rendering',
	  'text-shadow',
	  'text-transform',
	  'text-underline-position',
	  'top',
	  'transform',
	  'transform-origin',
	  'transform-style',
	  'transition',
	  'transition-delay',
	  'transition-duration',
	  'transition-property',
	  'transition-timing-function',
	  'unicode-bidi',
	  'vertical-align',
	  'visibility',
	  'white-space',
	  'widows',
	  'width',
	  'word-break',
	  'word-spacing',
	  'word-wrap',
	  'z-index'
	].reverse();
	function scss(hljs) {
	  const modes = MODES$2(hljs);
	  const PSEUDO_ELEMENTS$1$1 = PSEUDO_ELEMENTS$1;
	  const PSEUDO_CLASSES$1$1 = PSEUDO_CLASSES$1;
	  const AT_IDENTIFIER = '@[a-z-]+';
	  const AT_MODIFIERS = "and or not only";
	  const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
	  const VARIABLE = {
	    className: 'variable',
	    begin: '(\\$' + IDENT_RE + ')\\b'
	  };
	  return {
	    name: 'SCSS',
	    case_insensitive: true,
	    illegal: '[=/|\']',
	    contains: [
	      hljs.C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      {
	        className: 'selector-id',
	        begin: '#[A-Za-z0-9_-]+',
	        relevance: 0
	      },
	      {
	        className: 'selector-class',
	        begin: '\\.[A-Za-z0-9_-]+',
	        relevance: 0
	      },
	      modes.ATTRIBUTE_SELECTOR_MODE,
	      {
	        className: 'selector-tag',
	        begin: '\\b(' + TAGS$1.join('|') + ')\\b',
	        relevance: 0
	      },
	      {
	        className: 'selector-pseudo',
	        begin: ':(' + PSEUDO_CLASSES$1$1.join('|') + ')'
	      },
	      {
	        className: 'selector-pseudo',
	        begin: '::(' + PSEUDO_ELEMENTS$1$1.join('|') + ')'
	      },
	      VARIABLE,
	      {
	        begin: /\(/,
	        end: /\)/,
	        contains: [ hljs.CSS_NUMBER_MODE ]
	      },
	      {
	        className: 'attribute',
	        begin: '\\b(' + ATTRIBUTES$1.join('|') + ')\\b'
	      },
	      {
	        begin: '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b'
	      },
	      {
	        begin: ':',
	        end: ';',
	        contains: [
	          VARIABLE,
	          modes.HEXCOLOR,
	          hljs.CSS_NUMBER_MODE,
	          hljs.QUOTE_STRING_MODE,
	          hljs.APOS_STRING_MODE,
	          modes.IMPORTANT
	        ]
	      },
	      {
	        begin: '@(page|font-face)',
	        lexemes: AT_IDENTIFIER,
	        keywords: '@page @font-face'
	      },
	      {
	        begin: '@',
	        end: '[{;]',
	        returnBegin: true,
	        keywords: {
	          $pattern: /[a-z-]+/,
	          keyword: AT_MODIFIERS,
	          attribute: MEDIA_FEATURES$1.join(" ")
	        },
	        contains: [
	          {
	            begin: AT_IDENTIFIER,
	            className: "keyword"
	          },
	          {
	            begin: /[a-z-]+(?=:)/,
	            className: "attribute"
	          },
	          VARIABLE,
	          hljs.QUOTE_STRING_MODE,
	          hljs.APOS_STRING_MODE,
	          modes.HEXCOLOR,
	          hljs.CSS_NUMBER_MODE
	        ]
	      }
	    ]
	  };
	}
	var scss_1 = scss;

	const MODES$3 = (hljs) => {
	  return {
	    IMPORTANT: {
	      className: 'meta',
	      begin: '!important'
	    },
	    HEXCOLOR: {
	      className: 'number',
	      begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
	    },
	    ATTRIBUTE_SELECTOR_MODE: {
	      className: 'selector-attr',
	      begin: /\[/,
	      end: /\]/,
	      illegal: '$',
	      contains: [
	        hljs.APOS_STRING_MODE,
	        hljs.QUOTE_STRING_MODE
	      ]
	    }
	  };
	};
	const TAGS$2 = [
	  'a',
	  'abbr',
	  'address',
	  'article',
	  'aside',
	  'audio',
	  'b',
	  'blockquote',
	  'body',
	  'button',
	  'canvas',
	  'caption',
	  'cite',
	  'code',
	  'dd',
	  'del',
	  'details',
	  'dfn',
	  'div',
	  'dl',
	  'dt',
	  'em',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'header',
	  'hgroup',
	  'html',
	  'i',
	  'iframe',
	  'img',
	  'input',
	  'ins',
	  'kbd',
	  'label',
	  'legend',
	  'li',
	  'main',
	  'mark',
	  'menu',
	  'nav',
	  'object',
	  'ol',
	  'p',
	  'q',
	  'quote',
	  'samp',
	  'section',
	  'span',
	  'strong',
	  'summary',
	  'sup',
	  'table',
	  'tbody',
	  'td',
	  'textarea',
	  'tfoot',
	  'th',
	  'thead',
	  'time',
	  'tr',
	  'ul',
	  'var',
	  'video'
	];
	const MEDIA_FEATURES$2 = [
	  'any-hover',
	  'any-pointer',
	  'aspect-ratio',
	  'color',
	  'color-gamut',
	  'color-index',
	  'device-aspect-ratio',
	  'device-height',
	  'device-width',
	  'display-mode',
	  'forced-colors',
	  'grid',
	  'height',
	  'hover',
	  'inverted-colors',
	  'monochrome',
	  'orientation',
	  'overflow-block',
	  'overflow-inline',
	  'pointer',
	  'prefers-color-scheme',
	  'prefers-contrast',
	  'prefers-reduced-motion',
	  'prefers-reduced-transparency',
	  'resolution',
	  'scan',
	  'scripting',
	  'update',
	  'width',
	  'min-width',
	  'max-width',
	  'min-height',
	  'max-height'
	];
	const PSEUDO_CLASSES$2 = [
	  'active',
	  'any-link',
	  'blank',
	  'checked',
	  'current',
	  'default',
	  'defined',
	  'dir',
	  'disabled',
	  'drop',
	  'empty',
	  'enabled',
	  'first',
	  'first-child',
	  'first-of-type',
	  'fullscreen',
	  'future',
	  'focus',
	  'focus-visible',
	  'focus-within',
	  'has',
	  'host',
	  'host-context',
	  'hover',
	  'indeterminate',
	  'in-range',
	  'invalid',
	  'is',
	  'lang',
	  'last-child',
	  'last-of-type',
	  'left',
	  'link',
	  'local-link',
	  'not',
	  'nth-child',
	  'nth-col',
	  'nth-last-child',
	  'nth-last-col',
	  'nth-last-of-type',
	  'nth-of-type',
	  'only-child',
	  'only-of-type',
	  'optional',
	  'out-of-range',
	  'past',
	  'placeholder-shown',
	  'read-only',
	  'read-write',
	  'required',
	  'right',
	  'root',
	  'scope',
	  'target',
	  'target-within',
	  'user-invalid',
	  'valid',
	  'visited',
	  'where'
	];
	const PSEUDO_ELEMENTS$2 = [
	  'after',
	  'backdrop',
	  'before',
	  'cue',
	  'cue-region',
	  'first-letter',
	  'first-line',
	  'grammar-error',
	  'marker',
	  'part',
	  'placeholder',
	  'selection',
	  'slotted',
	  'spelling-error'
	];
	const ATTRIBUTES$2 = [
	  'align-content',
	  'align-items',
	  'align-self',
	  'animation',
	  'animation-delay',
	  'animation-direction',
	  'animation-duration',
	  'animation-fill-mode',
	  'animation-iteration-count',
	  'animation-name',
	  'animation-play-state',
	  'animation-timing-function',
	  'auto',
	  'backface-visibility',
	  'background',
	  'background-attachment',
	  'background-clip',
	  'background-color',
	  'background-image',
	  'background-origin',
	  'background-position',
	  'background-repeat',
	  'background-size',
	  'border',
	  'border-bottom',
	  'border-bottom-color',
	  'border-bottom-left-radius',
	  'border-bottom-right-radius',
	  'border-bottom-style',
	  'border-bottom-width',
	  'border-collapse',
	  'border-color',
	  'border-image',
	  'border-image-outset',
	  'border-image-repeat',
	  'border-image-slice',
	  'border-image-source',
	  'border-image-width',
	  'border-left',
	  'border-left-color',
	  'border-left-style',
	  'border-left-width',
	  'border-radius',
	  'border-right',
	  'border-right-color',
	  'border-right-style',
	  'border-right-width',
	  'border-spacing',
	  'border-style',
	  'border-top',
	  'border-top-color',
	  'border-top-left-radius',
	  'border-top-right-radius',
	  'border-top-style',
	  'border-top-width',
	  'border-width',
	  'bottom',
	  'box-decoration-break',
	  'box-shadow',
	  'box-sizing',
	  'break-after',
	  'break-before',
	  'break-inside',
	  'caption-side',
	  'clear',
	  'clip',
	  'clip-path',
	  'color',
	  'column-count',
	  'column-fill',
	  'column-gap',
	  'column-rule',
	  'column-rule-color',
	  'column-rule-style',
	  'column-rule-width',
	  'column-span',
	  'column-width',
	  'columns',
	  'content',
	  'counter-increment',
	  'counter-reset',
	  'cursor',
	  'direction',
	  'display',
	  'empty-cells',
	  'filter',
	  'flex',
	  'flex-basis',
	  'flex-direction',
	  'flex-flow',
	  'flex-grow',
	  'flex-shrink',
	  'flex-wrap',
	  'float',
	  'font',
	  'font-display',
	  'font-family',
	  'font-feature-settings',
	  'font-kerning',
	  'font-language-override',
	  'font-size',
	  'font-size-adjust',
	  'font-smoothing',
	  'font-stretch',
	  'font-style',
	  'font-variant',
	  'font-variant-ligatures',
	  'font-variation-settings',
	  'font-weight',
	  'height',
	  'hyphens',
	  'icon',
	  'image-orientation',
	  'image-rendering',
	  'image-resolution',
	  'ime-mode',
	  'inherit',
	  'initial',
	  'justify-content',
	  'left',
	  'letter-spacing',
	  'line-height',
	  'list-style',
	  'list-style-image',
	  'list-style-position',
	  'list-style-type',
	  'margin',
	  'margin-bottom',
	  'margin-left',
	  'margin-right',
	  'margin-top',
	  'marks',
	  'mask',
	  'max-height',
	  'max-width',
	  'min-height',
	  'min-width',
	  'nav-down',
	  'nav-index',
	  'nav-left',
	  'nav-right',
	  'nav-up',
	  'none',
	  'normal',
	  'object-fit',
	  'object-position',
	  'opacity',
	  'order',
	  'orphans',
	  'outline',
	  'outline-color',
	  'outline-offset',
	  'outline-style',
	  'outline-width',
	  'overflow',
	  'overflow-wrap',
	  'overflow-x',
	  'overflow-y',
	  'padding',
	  'padding-bottom',
	  'padding-left',
	  'padding-right',
	  'padding-top',
	  'page-break-after',
	  'page-break-before',
	  'page-break-inside',
	  'perspective',
	  'perspective-origin',
	  'pointer-events',
	  'position',
	  'quotes',
	  'resize',
	  'right',
	  'src',
	  'tab-size',
	  'table-layout',
	  'text-align',
	  'text-align-last',
	  'text-decoration',
	  'text-decoration-color',
	  'text-decoration-line',
	  'text-decoration-style',
	  'text-indent',
	  'text-overflow',
	  'text-rendering',
	  'text-shadow',
	  'text-transform',
	  'text-underline-position',
	  'top',
	  'transform',
	  'transform-origin',
	  'transform-style',
	  'transition',
	  'transition-delay',
	  'transition-duration',
	  'transition-property',
	  'transition-timing-function',
	  'unicode-bidi',
	  'vertical-align',
	  'visibility',
	  'white-space',
	  'widows',
	  'width',
	  'word-break',
	  'word-spacing',
	  'word-wrap',
	  'z-index'
	].reverse();
	const PSEUDO_SELECTORS = PSEUDO_CLASSES$2.concat(PSEUDO_ELEMENTS$2);
	function less(hljs) {
	  const modes = MODES$3(hljs);
	  const PSEUDO_SELECTORS$1 = PSEUDO_SELECTORS;
	  const AT_MODIFIERS = "and or not only";
	  const IDENT_RE = '[\\w-]+';
	  const INTERP_IDENT_RE = '(' + IDENT_RE + '|@\\{' + IDENT_RE + '\\})';
	  const RULES = []; const VALUE_MODES = [];
	  const STRING_MODE = function(c) {
	    return {
	      className: 'string',
	      begin: '~?' + c + '.*?' + c
	    };
	  };
	  const IDENT_MODE = function(name, begin, relevance) {
	    return {
	      className: name,
	      begin: begin,
	      relevance: relevance
	    };
	  };
	  const AT_KEYWORDS = {
	    $pattern: /[a-z-]+/,
	    keyword: AT_MODIFIERS,
	    attribute: MEDIA_FEATURES$2.join(" ")
	  };
	  const PARENS_MODE = {
	    begin: '\\(',
	    end: '\\)',
	    contains: VALUE_MODES,
	    keywords: AT_KEYWORDS,
	    relevance: 0
	  };
	  VALUE_MODES.push(
	    hljs.C_LINE_COMMENT_MODE,
	    hljs.C_BLOCK_COMMENT_MODE,
	    STRING_MODE("'"),
	    STRING_MODE('"'),
	    hljs.CSS_NUMBER_MODE,
	    {
	      begin: '(url|data-uri)\\(',
	      starts: {
	        className: 'string',
	        end: '[\\)\\n]',
	        excludeEnd: true
	      }
	    },
	    modes.HEXCOLOR,
	    PARENS_MODE,
	    IDENT_MODE('variable', '@@?' + IDENT_RE, 10),
	    IDENT_MODE('variable', '@\\{' + IDENT_RE + '\\}'),
	    IDENT_MODE('built_in', '~?`[^`]*?`'),
	    {
	      className: 'attribute',
	      begin: IDENT_RE + '\\s*:',
	      end: ':',
	      returnBegin: true,
	      excludeEnd: true
	    },
	    modes.IMPORTANT
	  );
	  const VALUE_WITH_RULESETS = VALUE_MODES.concat({
	    begin: /\{/,
	    end: /\}/,
	    contains: RULES
	  });
	  const MIXIN_GUARD_MODE = {
	    beginKeywords: 'when',
	    endsWithParent: true,
	    contains: [
	      {
	        beginKeywords: 'and not'
	      }
	    ].concat(VALUE_MODES)
	  };
	  const RULE_MODE = {
	    begin: INTERP_IDENT_RE + '\\s*:',
	    returnBegin: true,
	    end: /[;}]/,
	    relevance: 0,
	    contains: [
	      {
	        begin: /-(webkit|moz|ms|o)-/
	      },
	      {
	        className: 'attribute',
	        begin: '\\b(' + ATTRIBUTES$2.join('|') + ')\\b',
	        end: /(?=:)/,
	        starts: {
	          endsWithParent: true,
	          illegal: '[<=$]',
	          relevance: 0,
	          contains: VALUE_MODES
	        }
	      }
	    ]
	  };
	  const AT_RULE_MODE = {
	    className: 'keyword',
	    begin: '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
	    starts: {
	      end: '[;{}]',
	      keywords: AT_KEYWORDS,
	      returnEnd: true,
	      contains: VALUE_MODES,
	      relevance: 0
	    }
	  };
	  const VAR_RULE_MODE = {
	    className: 'variable',
	    variants: [
	      {
	        begin: '@' + IDENT_RE + '\\s*:',
	        relevance: 15
	      },
	      {
	        begin: '@' + IDENT_RE
	      }
	    ],
	    starts: {
	      end: '[;}]',
	      returnEnd: true,
	      contains: VALUE_WITH_RULESETS
	    }
	  };
	  const SELECTOR_MODE = {
	    variants: [
	      {
	        begin: '[\\.#:&\\[>]',
	        end: '[;{}]'
	      },
	      {
	        begin: INTERP_IDENT_RE,
	        end: /\{/
	      }
	    ],
	    returnBegin: true,
	    returnEnd: true,
	    illegal: '[<=\'$"]',
	    relevance: 0,
	    contains: [
	      hljs.C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      MIXIN_GUARD_MODE,
	      IDENT_MODE('keyword', 'all\\b'),
	      IDENT_MODE('variable', '@\\{' + IDENT_RE + '\\}'),
	      {
	        begin: '\\b(' + TAGS$2.join('|') + ')\\b',
	        className: 'selector-tag'
	      },
	      IDENT_MODE('selector-tag', INTERP_IDENT_RE + '%?', 0),
	      IDENT_MODE('selector-id', '#' + INTERP_IDENT_RE),
	      IDENT_MODE('selector-class', '\\.' + INTERP_IDENT_RE, 0),
	      IDENT_MODE('selector-tag', '&', 0),
	      modes.ATTRIBUTE_SELECTOR_MODE,
	      {
	        className: 'selector-pseudo',
	        begin: ':(' + PSEUDO_CLASSES$2.join('|') + ')'
	      },
	      {
	        className: 'selector-pseudo',
	        begin: '::(' + PSEUDO_ELEMENTS$2.join('|') + ')'
	      },
	      {
	        begin: '\\(',
	        end: '\\)',
	        contains: VALUE_WITH_RULESETS
	      },
	      {
	        begin: '!important'
	      }
	    ]
	  };
	  const PSEUDO_SELECTOR_MODE = {
	    begin: IDENT_RE + ':(:)?' + `(${PSEUDO_SELECTORS$1.join('|')})`,
	    returnBegin: true,
	    contains: [ SELECTOR_MODE ]
	  };
	  RULES.push(
	    hljs.C_LINE_COMMENT_MODE,
	    hljs.C_BLOCK_COMMENT_MODE,
	    AT_RULE_MODE,
	    VAR_RULE_MODE,
	    PSEUDO_SELECTOR_MODE,
	    RULE_MODE,
	    SELECTOR_MODE
	  );
	  return {
	    name: 'Less',
	    case_insensitive: true,
	    illegal: '[=>\'/<($"]',
	    contains: RULES
	  };
	}
	var less_1 = less;

	const MODES$4 = (hljs) => {
	  return {
	    IMPORTANT: {
	      className: 'meta',
	      begin: '!important'
	    },
	    HEXCOLOR: {
	      className: 'number',
	      begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
	    },
	    ATTRIBUTE_SELECTOR_MODE: {
	      className: 'selector-attr',
	      begin: /\[/,
	      end: /\]/,
	      illegal: '$',
	      contains: [
	        hljs.APOS_STRING_MODE,
	        hljs.QUOTE_STRING_MODE
	      ]
	    }
	  };
	};
	const TAGS$3 = [
	  'a',
	  'abbr',
	  'address',
	  'article',
	  'aside',
	  'audio',
	  'b',
	  'blockquote',
	  'body',
	  'button',
	  'canvas',
	  'caption',
	  'cite',
	  'code',
	  'dd',
	  'del',
	  'details',
	  'dfn',
	  'div',
	  'dl',
	  'dt',
	  'em',
	  'fieldset',
	  'figcaption',
	  'figure',
	  'footer',
	  'form',
	  'h1',
	  'h2',
	  'h3',
	  'h4',
	  'h5',
	  'h6',
	  'header',
	  'hgroup',
	  'html',
	  'i',
	  'iframe',
	  'img',
	  'input',
	  'ins',
	  'kbd',
	  'label',
	  'legend',
	  'li',
	  'main',
	  'mark',
	  'menu',
	  'nav',
	  'object',
	  'ol',
	  'p',
	  'q',
	  'quote',
	  'samp',
	  'section',
	  'span',
	  'strong',
	  'summary',
	  'sup',
	  'table',
	  'tbody',
	  'td',
	  'textarea',
	  'tfoot',
	  'th',
	  'thead',
	  'time',
	  'tr',
	  'ul',
	  'var',
	  'video'
	];
	const MEDIA_FEATURES$3 = [
	  'any-hover',
	  'any-pointer',
	  'aspect-ratio',
	  'color',
	  'color-gamut',
	  'color-index',
	  'device-aspect-ratio',
	  'device-height',
	  'device-width',
	  'display-mode',
	  'forced-colors',
	  'grid',
	  'height',
	  'hover',
	  'inverted-colors',
	  'monochrome',
	  'orientation',
	  'overflow-block',
	  'overflow-inline',
	  'pointer',
	  'prefers-color-scheme',
	  'prefers-contrast',
	  'prefers-reduced-motion',
	  'prefers-reduced-transparency',
	  'resolution',
	  'scan',
	  'scripting',
	  'update',
	  'width',
	  'min-width',
	  'max-width',
	  'min-height',
	  'max-height'
	];
	const PSEUDO_CLASSES$3 = [
	  'active',
	  'any-link',
	  'blank',
	  'checked',
	  'current',
	  'default',
	  'defined',
	  'dir',
	  'disabled',
	  'drop',
	  'empty',
	  'enabled',
	  'first',
	  'first-child',
	  'first-of-type',
	  'fullscreen',
	  'future',
	  'focus',
	  'focus-visible',
	  'focus-within',
	  'has',
	  'host',
	  'host-context',
	  'hover',
	  'indeterminate',
	  'in-range',
	  'invalid',
	  'is',
	  'lang',
	  'last-child',
	  'last-of-type',
	  'left',
	  'link',
	  'local-link',
	  'not',
	  'nth-child',
	  'nth-col',
	  'nth-last-child',
	  'nth-last-col',
	  'nth-last-of-type',
	  'nth-of-type',
	  'only-child',
	  'only-of-type',
	  'optional',
	  'out-of-range',
	  'past',
	  'placeholder-shown',
	  'read-only',
	  'read-write',
	  'required',
	  'right',
	  'root',
	  'scope',
	  'target',
	  'target-within',
	  'user-invalid',
	  'valid',
	  'visited',
	  'where'
	];
	const PSEUDO_ELEMENTS$3 = [
	  'after',
	  'backdrop',
	  'before',
	  'cue',
	  'cue-region',
	  'first-letter',
	  'first-line',
	  'grammar-error',
	  'marker',
	  'part',
	  'placeholder',
	  'selection',
	  'slotted',
	  'spelling-error'
	];
	const ATTRIBUTES$3 = [
	  'align-content',
	  'align-items',
	  'align-self',
	  'animation',
	  'animation-delay',
	  'animation-direction',
	  'animation-duration',
	  'animation-fill-mode',
	  'animation-iteration-count',
	  'animation-name',
	  'animation-play-state',
	  'animation-timing-function',
	  'auto',
	  'backface-visibility',
	  'background',
	  'background-attachment',
	  'background-clip',
	  'background-color',
	  'background-image',
	  'background-origin',
	  'background-position',
	  'background-repeat',
	  'background-size',
	  'border',
	  'border-bottom',
	  'border-bottom-color',
	  'border-bottom-left-radius',
	  'border-bottom-right-radius',
	  'border-bottom-style',
	  'border-bottom-width',
	  'border-collapse',
	  'border-color',
	  'border-image',
	  'border-image-outset',
	  'border-image-repeat',
	  'border-image-slice',
	  'border-image-source',
	  'border-image-width',
	  'border-left',
	  'border-left-color',
	  'border-left-style',
	  'border-left-width',
	  'border-radius',
	  'border-right',
	  'border-right-color',
	  'border-right-style',
	  'border-right-width',
	  'border-spacing',
	  'border-style',
	  'border-top',
	  'border-top-color',
	  'border-top-left-radius',
	  'border-top-right-radius',
	  'border-top-style',
	  'border-top-width',
	  'border-width',
	  'bottom',
	  'box-decoration-break',
	  'box-shadow',
	  'box-sizing',
	  'break-after',
	  'break-before',
	  'break-inside',
	  'caption-side',
	  'clear',
	  'clip',
	  'clip-path',
	  'color',
	  'column-count',
	  'column-fill',
	  'column-gap',
	  'column-rule',
	  'column-rule-color',
	  'column-rule-style',
	  'column-rule-width',
	  'column-span',
	  'column-width',
	  'columns',
	  'content',
	  'counter-increment',
	  'counter-reset',
	  'cursor',
	  'direction',
	  'display',
	  'empty-cells',
	  'filter',
	  'flex',
	  'flex-basis',
	  'flex-direction',
	  'flex-flow',
	  'flex-grow',
	  'flex-shrink',
	  'flex-wrap',
	  'float',
	  'font',
	  'font-display',
	  'font-family',
	  'font-feature-settings',
	  'font-kerning',
	  'font-language-override',
	  'font-size',
	  'font-size-adjust',
	  'font-smoothing',
	  'font-stretch',
	  'font-style',
	  'font-variant',
	  'font-variant-ligatures',
	  'font-variation-settings',
	  'font-weight',
	  'height',
	  'hyphens',
	  'icon',
	  'image-orientation',
	  'image-rendering',
	  'image-resolution',
	  'ime-mode',
	  'inherit',
	  'initial',
	  'justify-content',
	  'left',
	  'letter-spacing',
	  'line-height',
	  'list-style',
	  'list-style-image',
	  'list-style-position',
	  'list-style-type',
	  'margin',
	  'margin-bottom',
	  'margin-left',
	  'margin-right',
	  'margin-top',
	  'marks',
	  'mask',
	  'max-height',
	  'max-width',
	  'min-height',
	  'min-width',
	  'nav-down',
	  'nav-index',
	  'nav-left',
	  'nav-right',
	  'nav-up',
	  'none',
	  'normal',
	  'object-fit',
	  'object-position',
	  'opacity',
	  'order',
	  'orphans',
	  'outline',
	  'outline-color',
	  'outline-offset',
	  'outline-style',
	  'outline-width',
	  'overflow',
	  'overflow-wrap',
	  'overflow-x',
	  'overflow-y',
	  'padding',
	  'padding-bottom',
	  'padding-left',
	  'padding-right',
	  'padding-top',
	  'page-break-after',
	  'page-break-before',
	  'page-break-inside',
	  'perspective',
	  'perspective-origin',
	  'pointer-events',
	  'position',
	  'quotes',
	  'resize',
	  'right',
	  'src',
	  'tab-size',
	  'table-layout',
	  'text-align',
	  'text-align-last',
	  'text-decoration',
	  'text-decoration-color',
	  'text-decoration-line',
	  'text-decoration-style',
	  'text-indent',
	  'text-overflow',
	  'text-rendering',
	  'text-shadow',
	  'text-transform',
	  'text-underline-position',
	  'top',
	  'transform',
	  'transform-origin',
	  'transform-style',
	  'transition',
	  'transition-delay',
	  'transition-duration',
	  'transition-property',
	  'transition-timing-function',
	  'unicode-bidi',
	  'vertical-align',
	  'visibility',
	  'white-space',
	  'widows',
	  'width',
	  'word-break',
	  'word-spacing',
	  'word-wrap',
	  'z-index'
	].reverse();
	function stylus(hljs) {
	  const modes = MODES$4(hljs);
	  const AT_MODIFIERS = "and or not only";
	  const VARIABLE = {
	    className: 'variable',
	    begin: '\\$' + hljs.IDENT_RE
	  };
	  const AT_KEYWORDS = [
	    'charset',
	    'css',
	    'debug',
	    'extend',
	    'font-face',
	    'for',
	    'import',
	    'include',
	    'keyframes',
	    'media',
	    'mixin',
	    'page',
	    'warn',
	    'while'
	  ];
	  const LOOKAHEAD_TAG_END = '(?=[.\\s\\n[:,(])';
	  const ILLEGAL = [
	    '\\?',
	    '(\\bReturn\\b)',
	    '(\\bEnd\\b)',
	    '(\\bend\\b)',
	    '(\\bdef\\b)',
	    ';',
	    '#\\s',
	    '\\*\\s',
	    '===\\s',
	    '\\|',
	    '%'
	  ];
	  return {
	    name: 'Stylus',
	    aliases: [ 'styl' ],
	    case_insensitive: false,
	    keywords: 'if else for in',
	    illegal: '(' + ILLEGAL.join('|') + ')',
	    contains: [
	      hljs.QUOTE_STRING_MODE,
	      hljs.APOS_STRING_MODE,
	      hljs.C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      modes.HEXCOLOR,
	      {
	        begin: '\\.[a-zA-Z][a-zA-Z0-9_-]*' + LOOKAHEAD_TAG_END,
	        className: 'selector-class'
	      },
	      {
	        begin: '#[a-zA-Z][a-zA-Z0-9_-]*' + LOOKAHEAD_TAG_END,
	        className: 'selector-id'
	      },
	      {
	        begin: '\\b(' + TAGS$3.join('|') + ')' + LOOKAHEAD_TAG_END,
	        className: 'selector-tag'
	      },
	      {
	        className: 'selector-pseudo',
	        begin: '&?:(' + PSEUDO_CLASSES$3.join('|') + ')' + LOOKAHEAD_TAG_END
	      },
	      {
	        className: 'selector-pseudo',
	        begin: '&?::(' + PSEUDO_ELEMENTS$3.join('|') + ')' + LOOKAHEAD_TAG_END
	      },
	      modes.ATTRIBUTE_SELECTOR_MODE,
	      {
	        className: "keyword",
	        begin: /@media/,
	        starts: {
	          end: /[{;}]/,
	          keywords: {
	            $pattern: /[a-z-]+/,
	            keyword: AT_MODIFIERS,
	            attribute: MEDIA_FEATURES$3.join(" ")
	          },
	          contains: [ hljs.CSS_NUMBER_MODE ]
	        }
	      },
	      {
	        className: 'keyword',
	        begin: '\@((-(o|moz|ms|webkit)-)?(' + AT_KEYWORDS.join('|') + '))\\b'
	      },
	      VARIABLE,
	      hljs.CSS_NUMBER_MODE,
	      {
	        className: 'function',
	        begin: '^[a-zA-Z][a-zA-Z0-9_\-]*\\(.*\\)',
	        illegal: '[\\n]',
	        returnBegin: true,
	        contains: [
	          {
	            className: 'title',
	            begin: '\\b[a-zA-Z][a-zA-Z0-9_\-]*'
	          },
	          {
	            className: 'params',
	            begin: /\(/,
	            end: /\)/,
	            contains: [
	              modes.HEXCOLOR,
	              VARIABLE,
	              hljs.APOS_STRING_MODE,
	              hljs.CSS_NUMBER_MODE,
	              hljs.QUOTE_STRING_MODE
	            ]
	          }
	        ]
	      },
	      {
	        className: 'attribute',
	        begin: '\\b(' + ATTRIBUTES$3.join('|') + ')\\b',
	        starts: {
	          end: /;|$/,
	          contains: [
	            modes.HEXCOLOR,
	            VARIABLE,
	            hljs.APOS_STRING_MODE,
	            hljs.QUOTE_STRING_MODE,
	            hljs.CSS_NUMBER_MODE,
	            hljs.C_BLOCK_COMMENT_MODE,
	            modes.IMPORTANT
	          ],
	          illegal: /\./,
	          relevance: 0
	        }
	      }
	    ]
	  };
	}
	var stylus_1 = stylus;

	function shell(hljs) {
	  return {
	    name: 'Shell Session',
	    aliases: [ 'console' ],
	    contains: [
	      {
	        className: 'meta',
	        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#]/,
	        starts: {
	          end: /[^\\](?=\s*$)/,
	          subLanguage: 'bash'
	        }
	      }
	    ]
	  };
	}
	var shell_1 = shell;

	function source$3(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function concat$3(...args) {
	  const joined = args.map((x) => source$3(x)).join("");
	  return joined;
	}
	function bash(hljs) {
	  const VAR = {};
	  const BRACED_VAR = {
	    begin: /\$\{/,
	    end:/\}/,
	    contains: [
	      "self",
	      {
	        begin: /:-/,
	        contains: [ VAR ]
	      }
	    ]
	  };
	  Object.assign(VAR,{
	    className: 'variable',
	    variants: [
	      {begin: concat$3(/\$[\w\d#@][\w\d_]*/,
	        `(?![\\w\\d])(?![$])`) },
	      BRACED_VAR
	    ]
	  });
	  const SUBST = {
	    className: 'subst',
	    begin: /\$\(/, end: /\)/,
	    contains: [hljs.BACKSLASH_ESCAPE]
	  };
	  const HERE_DOC = {
	    begin: /<<-?\s*(?=\w+)/,
	    starts: {
	      contains: [
	        hljs.END_SAME_AS_BEGIN({
	          begin: /(\w+)/,
	          end: /(\w+)/,
	          className: 'string'
	        })
	      ]
	    }
	  };
	  const QUOTE_STRING = {
	    className: 'string',
	    begin: /"/, end: /"/,
	    contains: [
	      hljs.BACKSLASH_ESCAPE,
	      VAR,
	      SUBST
	    ]
	  };
	  SUBST.contains.push(QUOTE_STRING);
	  const ESCAPED_QUOTE = {
	    className: '',
	    begin: /\\"/
	  };
	  const APOS_STRING = {
	    className: 'string',
	    begin: /'/, end: /'/
	  };
	  const ARITHMETIC = {
	    begin: /\$\(\(/,
	    end: /\)\)/,
	    contains: [
	      { begin: /\d+#[0-9a-f]+/, className: "number" },
	      hljs.NUMBER_MODE,
	      VAR
	    ]
	  };
	  const SH_LIKE_SHELLS = [
	    "fish",
	    "bash",
	    "zsh",
	    "sh",
	    "csh",
	    "ksh",
	    "tcsh",
	    "dash",
	    "scsh",
	  ];
	  const KNOWN_SHEBANG = hljs.SHEBANG({
	    binary: `(${SH_LIKE_SHELLS.join("|")})`,
	    relevance: 10
	  });
	  const FUNCTION = {
	    className: 'function',
	    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
	    returnBegin: true,
	    contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\w[\w\d_]*/})],
	    relevance: 0
	  };
	  return {
	    name: 'Bash',
	    aliases: ['sh', 'zsh'],
	    keywords: {
	      $pattern: /\b[a-z._-]+\b/,
	      keyword:
	        'if then else elif fi for while in do done case esac function',
	      literal:
	        'true false',
	      built_in:
	        'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' +
	        'trap umask unset ' +
	        'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' +
	        'read readarray source type typeset ulimit unalias ' +
	        'set shopt ' +
	        'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' +
	        'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' +
	        'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' +
	        'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' +
	        'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' +
	        'zpty zregexparse zsocket zstyle ztcp'
	    },
	    contains: [
	      KNOWN_SHEBANG,
	      hljs.SHEBANG(),
	      FUNCTION,
	      ARITHMETIC,
	      hljs.HASH_COMMENT_MODE,
	      HERE_DOC,
	      QUOTE_STRING,
	      ESCAPED_QUOTE,
	      APOS_STRING,
	      VAR
	    ]
	  };
	}
	var bash_1 = bash;

	function source$4(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$2(re) {
	  return concat$4('(?=', re, ')');
	}
	function optional(re) {
	  return concat$4('(', re, ')?');
	}
	function concat$4(...args) {
	  const joined = args.map((x) => source$4(x)).join("");
	  return joined;
	}
	function cpp(hljs) {
	  const C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$', {
	    contains: [
	      {
	        begin: /\\\n/
	      }
	    ]
	  });
	  const DECLTYPE_AUTO_RE = 'decltype\\(auto\\)';
	  const NAMESPACE_RE = '[a-zA-Z_]\\w*::';
	  const TEMPLATE_ARGUMENT_RE = '<[^<>]+>';
	  const FUNCTION_TYPE_RE = '(' +
	    DECLTYPE_AUTO_RE + '|' +
	    optional(NAMESPACE_RE) +
	    '[a-zA-Z_]\\w*' + optional(TEMPLATE_ARGUMENT_RE) +
	  ')';
	  const CPP_PRIMITIVE_TYPES = {
	    className: 'keyword',
	    begin: '\\b[a-z\\d_]*_t\\b'
	  };
	  const CHARACTER_ESCAPES = '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)';
	  const STRINGS = {
	    className: 'string',
	    variants: [
	      {
	        begin: '(u8?|U|L)?"',
	        end: '"',
	        illegal: '\\n',
	        contains: [ hljs.BACKSLASH_ESCAPE ]
	      },
	      {
	        begin: '(u8?|U|L)?\'(' + CHARACTER_ESCAPES + "|.)",
	        end: '\'',
	        illegal: '.'
	      },
	      hljs.END_SAME_AS_BEGIN({
	        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
	        end: /\)([^()\\ ]{0,16})"/
	      })
	    ]
	  };
	  const NUMBERS = {
	    className: 'number',
	    variants: [
	      {
	        begin: '\\b(0b[01\']+)'
	      },
	      {
	        begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)'
	      },
	      {
	        begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
	      }
	    ],
	    relevance: 0
	  };
	  const PREPROCESSOR = {
	    className: 'meta',
	    begin: /#\s*[a-z]+\b/,
	    end: /$/,
	    keywords: {
	      'meta-keyword':
	        'if else elif endif define undef warning error line ' +
	        'pragma _Pragma ifdef ifndef include'
	    },
	    contains: [
	      {
	        begin: /\\\n/,
	        relevance: 0
	      },
	      hljs.inherit(STRINGS, {
	        className: 'meta-string'
	      }),
	      {
	        className: 'meta-string',
	        begin: /<.*?>/
	      },
	      C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE
	    ]
	  };
	  const TITLE_MODE = {
	    className: 'title',
	    begin: optional(NAMESPACE_RE) + hljs.IDENT_RE,
	    relevance: 0
	  };
	  const FUNCTION_TITLE = optional(NAMESPACE_RE) + hljs.IDENT_RE + '\\s*\\(';
	  const COMMON_CPP_HINTS = [
	    'asin',
	    'atan2',
	    'atan',
	    'calloc',
	    'ceil',
	    'cosh',
	    'cos',
	    'exit',
	    'exp',
	    'fabs',
	    'floor',
	    'fmod',
	    'fprintf',
	    'fputs',
	    'free',
	    'frexp',
	    'auto_ptr',
	    'deque',
	    'list',
	    'queue',
	    'stack',
	    'vector',
	    'map',
	    'set',
	    'pair',
	    'bitset',
	    'multiset',
	    'multimap',
	    'unordered_set',
	    'fscanf',
	    'future',
	    'isalnum',
	    'isalpha',
	    'iscntrl',
	    'isdigit',
	    'isgraph',
	    'islower',
	    'isprint',
	    'ispunct',
	    'isspace',
	    'isupper',
	    'isxdigit',
	    'tolower',
	    'toupper',
	    'labs',
	    'ldexp',
	    'log10',
	    'log',
	    'malloc',
	    'realloc',
	    'memchr',
	    'memcmp',
	    'memcpy',
	    'memset',
	    'modf',
	    'pow',
	    'printf',
	    'putchar',
	    'puts',
	    'scanf',
	    'sinh',
	    'sin',
	    'snprintf',
	    'sprintf',
	    'sqrt',
	    'sscanf',
	    'strcat',
	    'strchr',
	    'strcmp',
	    'strcpy',
	    'strcspn',
	    'strlen',
	    'strncat',
	    'strncmp',
	    'strncpy',
	    'strpbrk',
	    'strrchr',
	    'strspn',
	    'strstr',
	    'tanh',
	    'tan',
	    'unordered_map',
	    'unordered_multiset',
	    'unordered_multimap',
	    'priority_queue',
	    'make_pair',
	    'array',
	    'shared_ptr',
	    'abort',
	    'terminate',
	    'abs',
	    'acos',
	    'vfprintf',
	    'vprintf',
	    'vsprintf',
	    'endl',
	    'initializer_list',
	    'unique_ptr',
	    'complex',
	    'imaginary',
	    'std',
	    'string',
	    'wstring',
	    'cin',
	    'cout',
	    'cerr',
	    'clog',
	    'stdin',
	    'stdout',
	    'stderr',
	    'stringstream',
	    'istringstream',
	    'ostringstream'
	  ];
	  const CPP_KEYWORDS = {
	    keyword: 'int float while private char char8_t char16_t char32_t catch import module export virtual operator sizeof ' +
	      'dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace ' +
	      'unsigned long volatile static protected bool template mutable if public friend ' +
	      'do goto auto void enum else break extern using asm case typeid wchar_t ' +
	      'short reinterpret_cast|10 default double register explicit signed typename try this ' +
	      'switch continue inline delete alignas alignof constexpr consteval constinit decltype ' +
	      'concept co_await co_return co_yield requires ' +
	      'noexcept static_assert thread_local restrict final override ' +
	      'atomic_bool atomic_char atomic_schar ' +
	      'atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong ' +
	      'atomic_ullong new throw return ' +
	      'and and_eq bitand bitor compl not not_eq or or_eq xor xor_eq',
	    built_in: '_Bool _Complex _Imaginary',
	    _relevance_hints: COMMON_CPP_HINTS,
	    literal: 'true false nullptr NULL'
	  };
	  const FUNCTION_DISPATCH = {
	    className: "function.dispatch",
	    relevance: 0,
	    keywords: CPP_KEYWORDS,
	    begin: concat$4(
	      /\b/,
	      /(?!decltype)/,
	      /(?!if)/,
	      /(?!for)/,
	      /(?!while)/,
	      hljs.IDENT_RE,
	      lookahead$2(/\s*\(/))
	  };
	  const EXPRESSION_CONTAINS = [
	    FUNCTION_DISPATCH,
	    PREPROCESSOR,
	    CPP_PRIMITIVE_TYPES,
	    C_LINE_COMMENT_MODE,
	    hljs.C_BLOCK_COMMENT_MODE,
	    NUMBERS,
	    STRINGS
	  ];
	  const EXPRESSION_CONTEXT = {
	    variants: [
	      {
	        begin: /=/,
	        end: /;/
	      },
	      {
	        begin: /\(/,
	        end: /\)/
	      },
	      {
	        beginKeywords: 'new throw return else',
	        end: /;/
	      }
	    ],
	    keywords: CPP_KEYWORDS,
	    contains: EXPRESSION_CONTAINS.concat([
	      {
	        begin: /\(/,
	        end: /\)/,
	        keywords: CPP_KEYWORDS,
	        contains: EXPRESSION_CONTAINS.concat([ 'self' ]),
	        relevance: 0
	      }
	    ]),
	    relevance: 0
	  };
	  const FUNCTION_DECLARATION = {
	    className: 'function',
	    begin: '(' + FUNCTION_TYPE_RE + '[\\*&\\s]+)+' + FUNCTION_TITLE,
	    returnBegin: true,
	    end: /[{;=]/,
	    excludeEnd: true,
	    keywords: CPP_KEYWORDS,
	    illegal: /[^\w\s\*&:<>.]/,
	    contains: [
	      {
	        begin: DECLTYPE_AUTO_RE,
	        keywords: CPP_KEYWORDS,
	        relevance: 0
	      },
	      {
	        begin: FUNCTION_TITLE,
	        returnBegin: true,
	        contains: [ TITLE_MODE ],
	        relevance: 0
	      },
	      {
	        begin: /::/,
	        relevance: 0
	      },
	      {
	        begin: /:/,
	        endsWithParent: true,
	        contains: [
	          STRINGS,
	          NUMBERS
	        ]
	      },
	      {
	        className: 'params',
	        begin: /\(/,
	        end: /\)/,
	        keywords: CPP_KEYWORDS,
	        relevance: 0,
	        contains: [
	          C_LINE_COMMENT_MODE,
	          hljs.C_BLOCK_COMMENT_MODE,
	          STRINGS,
	          NUMBERS,
	          CPP_PRIMITIVE_TYPES,
	          {
	            begin: /\(/,
	            end: /\)/,
	            keywords: CPP_KEYWORDS,
	            relevance: 0,
	            contains: [
	              'self',
	              C_LINE_COMMENT_MODE,
	              hljs.C_BLOCK_COMMENT_MODE,
	              STRINGS,
	              NUMBERS,
	              CPP_PRIMITIVE_TYPES
	            ]
	          }
	        ]
	      },
	      CPP_PRIMITIVE_TYPES,
	      C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      PREPROCESSOR
	    ]
	  };
	  return {
	    name: 'C++',
	    aliases: [
	      'cc',
	      'c++',
	      'h++',
	      'hpp',
	      'hh',
	      'hxx',
	      'cxx'
	    ],
	    keywords: CPP_KEYWORDS,
	    illegal: '</',
	    classNameAliases: {
	      "function.dispatch": "built_in"
	    },
	    contains: [].concat(
	      EXPRESSION_CONTEXT,
	      FUNCTION_DECLARATION,
	      FUNCTION_DISPATCH,
	      EXPRESSION_CONTAINS,
	      [
	        PREPROCESSOR,
	        {
	          begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<',
	          end: '>',
	          keywords: CPP_KEYWORDS,
	          contains: [
	            'self',
	            CPP_PRIMITIVE_TYPES
	          ]
	        },
	        {
	          begin: hljs.IDENT_RE + '::',
	          keywords: CPP_KEYWORDS
	        },
	        {
	          className: 'class',
	          beginKeywords: 'enum class struct union',
	          end: /[{;:<>=]/,
	          contains: [
	            {
	              beginKeywords: "final class struct"
	            },
	            hljs.TITLE_MODE
	          ]
	        }
	      ]),
	    exports: {
	      preprocessor: PREPROCESSOR,
	      strings: STRINGS,
	      keywords: CPP_KEYWORDS
	    }
	  };
	}
	var cpp_1 = cpp;

	function go(hljs) {
	  const GO_KEYWORDS = {
	    keyword:
	      'break default func interface select case map struct chan else goto package switch ' +
	      'const fallthrough if range type continue for import return var go defer ' +
	      'bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 ' +
	      'uint16 uint32 uint64 int uint uintptr rune',
	    literal:
	       'true false iota nil',
	    built_in:
	      'append cap close complex copy imag len make new panic print println real recover delete'
	  };
	  return {
	    name: 'Go',
	    aliases: ['golang'],
	    keywords: GO_KEYWORDS,
	    illegal: '</',
	    contains: [
	      hljs.C_LINE_COMMENT_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      {
	        className: 'string',
	        variants: [
	          hljs.QUOTE_STRING_MODE,
	          hljs.APOS_STRING_MODE,
	          {
	            begin: '`',
	            end: '`'
	          }
	        ]
	      },
	      {
	        className: 'number',
	        variants: [
	          {
	            begin: hljs.C_NUMBER_RE + '[i]',
	            relevance: 1
	          },
	          hljs.C_NUMBER_MODE
	        ]
	      },
	      {
	        begin: /:=/
	      },
	      {
	        className: 'function',
	        beginKeywords: 'func',
	        end: '\\s*(\\{|$)',
	        excludeEnd: true,
	        contains: [
	          hljs.TITLE_MODE,
	          {
	            className: 'params',
	            begin: /\(/,
	            end: /\)/,
	            keywords: GO_KEYWORDS,
	            illegal: /["']/
	          }
	        ]
	      }
	    ]
	  };
	}
	var go_1 = go;

	function source$5(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$3(re) {
	  return concat$5('(?=', re, ')');
	}
	function optional$1(re) {
	  return concat$5('(', re, ')?');
	}
	function concat$5(...args) {
	  const joined = args.map((x) => source$5(x)).join("");
	  return joined;
	}
	function either$1(...args) {
	  const joined = '(' + args.map((x) => source$5(x)).join("|") + ")";
	  return joined;
	}
	function xml(hljs) {
	  const TAG_NAME_RE = concat$5(/[A-Z_]/, optional$1(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
	  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
	  const XML_ENTITIES = {
	    className: 'symbol',
	    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
	  };
	  const XML_META_KEYWORDS = {
	    begin: /\s/,
	    contains: [
	      {
	        className: 'meta-keyword',
	        begin: /#?[a-z_][a-z1-9_-]+/,
	        illegal: /\n/
	      }
	    ]
	  };
	  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
	    begin: /\(/,
	    end: /\)/
	  });
	  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
	    className: 'meta-string'
	  });
	  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
	    className: 'meta-string'
	  });
	  const TAG_INTERNALS = {
	    endsWithParent: true,
	    illegal: /</,
	    relevance: 0,
	    contains: [
	      {
	        className: 'attr',
	        begin: XML_IDENT_RE,
	        relevance: 0
	      },
	      {
	        begin: /=\s*/,
	        relevance: 0,
	        contains: [
	          {
	            className: 'string',
	            endsParent: true,
	            variants: [
	              {
	                begin: /"/,
	                end: /"/,
	                contains: [ XML_ENTITIES ]
	              },
	              {
	                begin: /'/,
	                end: /'/,
	                contains: [ XML_ENTITIES ]
	              },
	              {
	                begin: /[^\s"'=<>`]+/
	              }
	            ]
	          }
	        ]
	      }
	    ]
	  };
	  return {
	    name: 'HTML, XML',
	    aliases: [
	      'html',
	      'xhtml',
	      'rss',
	      'atom',
	      'xjb',
	      'xsd',
	      'xsl',
	      'plist',
	      'wsf',
	      'svg'
	    ],
	    case_insensitive: true,
	    contains: [
	      {
	        className: 'meta',
	        begin: /<![a-z]/,
	        end: />/,
	        relevance: 10,
	        contains: [
	          XML_META_KEYWORDS,
	          QUOTE_META_STRING_MODE,
	          APOS_META_STRING_MODE,
	          XML_META_PAR_KEYWORDS,
	          {
	            begin: /\[/,
	            end: /\]/,
	            contains: [
	              {
	                className: 'meta',
	                begin: /<![a-z]/,
	                end: />/,
	                contains: [
	                  XML_META_KEYWORDS,
	                  XML_META_PAR_KEYWORDS,
	                  QUOTE_META_STRING_MODE,
	                  APOS_META_STRING_MODE
	                ]
	              }
	            ]
	          }
	        ]
	      },
	      hljs.COMMENT(
	        /<!--/,
	        /-->/,
	        {
	          relevance: 10
	        }
	      ),
	      {
	        begin: /<!\[CDATA\[/,
	        end: /\]\]>/,
	        relevance: 10
	      },
	      XML_ENTITIES,
	      {
	        className: 'meta',
	        begin: /<\?xml/,
	        end: /\?>/,
	        relevance: 10
	      },
	      {
	        className: 'tag',
	        begin: /<style(?=\s|>)/,
	        end: />/,
	        keywords: {
	          name: 'style'
	        },
	        contains: [ TAG_INTERNALS ],
	        starts: {
	          end: /<\/style>/,
	          returnEnd: true,
	          subLanguage: [
	            'css',
	            'xml'
	          ]
	        }
	      },
	      {
	        className: 'tag',
	        begin: /<script(?=\s|>)/,
	        end: />/,
	        keywords: {
	          name: 'script'
	        },
	        contains: [ TAG_INTERNALS ],
	        starts: {
	          end: /<\/script>/,
	          returnEnd: true,
	          subLanguage: [
	            'javascript',
	            'handlebars',
	            'xml'
	          ]
	        }
	      },
	      {
	        className: 'tag',
	        begin: /<>|<\/>/
	      },
	      {
	        className: 'tag',
	        begin: concat$5(
	          /</,
	          lookahead$3(concat$5(
	            TAG_NAME_RE,
	            either$1(/\/>/, />/, /\s/)
	          ))
	        ),
	        end: /\/?>/,
	        contains: [
	          {
	            className: 'name',
	            begin: TAG_NAME_RE,
	            relevance: 0,
	            starts: TAG_INTERNALS
	          }
	        ]
	      },
	      {
	        className: 'tag',
	        begin: concat$5(
	          /<\//,
	          lookahead$3(concat$5(
	            TAG_NAME_RE, />/
	          ))
	        ),
	        contains: [
	          {
	            className: 'name',
	            begin: TAG_NAME_RE,
	            relevance: 0
	          },
	          {
	            begin: />/,
	            relevance: 0,
	            endsParent: true
	          }
	        ]
	      }
	    ]
	  };
	}
	var xml_1 = xml;

	function source$6(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$4(re) {
	  return concat$6('(?=', re, ')');
	}
	function concat$6(...args) {
	  const joined = args.map((x) => source$6(x)).join("");
	  return joined;
	}
	function python(hljs) {
	  const RESERVED_WORDS = [
	    'and',
	    'as',
	    'assert',
	    'async',
	    'await',
	    'break',
	    'class',
	    'continue',
	    'def',
	    'del',
	    'elif',
	    'else',
	    'except',
	    'finally',
	    'for',
	    'from',
	    'global',
	    'if',
	    'import',
	    'in',
	    'is',
	    'lambda',
	    'nonlocal|10',
	    'not',
	    'or',
	    'pass',
	    'raise',
	    'return',
	    'try',
	    'while',
	    'with',
	    'yield'
	  ];
	  const BUILT_INS = [
	    '__import__',
	    'abs',
	    'all',
	    'any',
	    'ascii',
	    'bin',
	    'bool',
	    'breakpoint',
	    'bytearray',
	    'bytes',
	    'callable',
	    'chr',
	    'classmethod',
	    'compile',
	    'complex',
	    'delattr',
	    'dict',
	    'dir',
	    'divmod',
	    'enumerate',
	    'eval',
	    'exec',
	    'filter',
	    'float',
	    'format',
	    'frozenset',
	    'getattr',
	    'globals',
	    'hasattr',
	    'hash',
	    'help',
	    'hex',
	    'id',
	    'input',
	    'int',
	    'isinstance',
	    'issubclass',
	    'iter',
	    'len',
	    'list',
	    'locals',
	    'map',
	    'max',
	    'memoryview',
	    'min',
	    'next',
	    'object',
	    'oct',
	    'open',
	    'ord',
	    'pow',
	    'print',
	    'property',
	    'range',
	    'repr',
	    'reversed',
	    'round',
	    'set',
	    'setattr',
	    'slice',
	    'sorted',
	    'staticmethod',
	    'str',
	    'sum',
	    'super',
	    'tuple',
	    'type',
	    'vars',
	    'zip'
	  ];
	  const LITERALS = [
	    '__debug__',
	    'Ellipsis',
	    'False',
	    'None',
	    'NotImplemented',
	    'True'
	  ];
	  const TYPES = [
	    "Any",
	    "Callable",
	    "Coroutine",
	    "Dict",
	    "List",
	    "Literal",
	    "Generic",
	    "Optional",
	    "Sequence",
	    "Set",
	    "Tuple",
	    "Type",
	    "Union"
	  ];
	  const KEYWORDS = {
	    $pattern: /[A-Za-z]\w+|__\w+__/,
	    keyword: RESERVED_WORDS,
	    built_in: BUILT_INS,
	    literal: LITERALS,
	    type: TYPES
	  };
	  const PROMPT = {
	    className: 'meta',
	    begin: /^(>>>|\.\.\.) /
	  };
	  const SUBST = {
	    className: 'subst',
	    begin: /\{/,
	    end: /\}/,
	    keywords: KEYWORDS,
	    illegal: /#/
	  };
	  const LITERAL_BRACKET = {
	    begin: /\{\{/,
	    relevance: 0
	  };
	  const STRING = {
	    className: 'string',
	    contains: [ hljs.BACKSLASH_ESCAPE ],
	    variants: [
	      {
	        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
	        end: /'''/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          PROMPT
	        ],
	        relevance: 10
	      },
	      {
	        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
	        end: /"""/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          PROMPT
	        ],
	        relevance: 10
	      },
	      {
	        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
	        end: /'''/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          PROMPT,
	          LITERAL_BRACKET,
	          SUBST
	        ]
	      },
	      {
	        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
	        end: /"""/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          PROMPT,
	          LITERAL_BRACKET,
	          SUBST
	        ]
	      },
	      {
	        begin: /([uU]|[rR])'/,
	        end: /'/,
	        relevance: 10
	      },
	      {
	        begin: /([uU]|[rR])"/,
	        end: /"/,
	        relevance: 10
	      },
	      {
	        begin: /([bB]|[bB][rR]|[rR][bB])'/,
	        end: /'/
	      },
	      {
	        begin: /([bB]|[bB][rR]|[rR][bB])"/,
	        end: /"/
	      },
	      {
	        begin: /([fF][rR]|[rR][fF]|[fF])'/,
	        end: /'/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          LITERAL_BRACKET,
	          SUBST
	        ]
	      },
	      {
	        begin: /([fF][rR]|[rR][fF]|[fF])"/,
	        end: /"/,
	        contains: [
	          hljs.BACKSLASH_ESCAPE,
	          LITERAL_BRACKET,
	          SUBST
	        ]
	      },
	      hljs.APOS_STRING_MODE,
	      hljs.QUOTE_STRING_MODE
	    ]
	  };
	  const digitpart = '[0-9](_?[0-9])*';
	  const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
	  const NUMBER = {
	    className: 'number',
	    relevance: 0,
	    variants: [
	      {
	        begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?\\b`
	      },
	      {
	        begin: `(${pointfloat})[jJ]?`
	      },
	      {
	        begin: '\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b'
	      },
	      {
	        begin: '\\b0[bB](_?[01])+[lL]?\\b'
	      },
	      {
	        begin: '\\b0[oO](_?[0-7])+[lL]?\\b'
	      },
	      {
	        begin: '\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b'
	      },
	      {
	        begin: `\\b(${digitpart})[jJ]\\b`
	      }
	    ]
	  };
	  const COMMENT_TYPE = {
	    className: "comment",
	    begin: lookahead$4(/# type:/),
	    end: /$/,
	    keywords: KEYWORDS,
	    contains: [
	      {
	        begin: /# type:/
	      },
	      {
	        begin: /#/,
	        end: /\b\B/,
	        endsWithParent: true
	      }
	    ]
	  };
	  const PARAMS = {
	    className: 'params',
	    variants: [
	      {
	        className: "",
	        begin: /\(\s*\)/,
	        skip: true
	      },
	      {
	        begin: /\(/,
	        end: /\)/,
	        excludeBegin: true,
	        excludeEnd: true,
	        keywords: KEYWORDS,
	        contains: [
	          'self',
	          PROMPT,
	          NUMBER,
	          STRING,
	          hljs.HASH_COMMENT_MODE
	        ]
	      }
	    ]
	  };
	  SUBST.contains = [
	    STRING,
	    NUMBER,
	    PROMPT
	  ];
	  return {
	    name: 'Python',
	    aliases: [
	      'py',
	      'gyp',
	      'ipython'
	    ],
	    keywords: KEYWORDS,
	    illegal: /(<\/|->|\?)|=>/,
	    contains: [
	      PROMPT,
	      NUMBER,
	      {
	        begin: /\bself\b/
	      },
	      {
	        beginKeywords: "if",
	        relevance: 0
	      },
	      STRING,
	      COMMENT_TYPE,
	      hljs.HASH_COMMENT_MODE,
	      {
	        variants: [
	          {
	            className: 'function',
	            beginKeywords: 'def'
	          },
	          {
	            className: 'class',
	            beginKeywords: 'class'
	          }
	        ],
	        end: /:/,
	        illegal: /[${=;\n,]/,
	        contains: [
	          hljs.UNDERSCORE_TITLE_MODE,
	          PARAMS,
	          {
	            begin: /->/,
	            endsWithParent: true,
	            keywords: KEYWORDS
	          }
	        ]
	      },
	      {
	        className: 'meta',
	        begin: /^[\t ]*@/,
	        end: /(?=#)|$/,
	        contains: [
	          NUMBER,
	          PARAMS,
	          STRING
	        ]
	      }
	    ]
	  };
	}
	var python_1 = python;

	const IDENT_RE$2 = '[A-Za-z$_][0-9A-Za-z$_]*';
	const KEYWORDS$1 = [
	  "as",
	  "in",
	  "of",
	  "if",
	  "for",
	  "while",
	  "finally",
	  "var",
	  "new",
	  "function",
	  "do",
	  "return",
	  "void",
	  "else",
	  "break",
	  "catch",
	  "instanceof",
	  "with",
	  "throw",
	  "case",
	  "default",
	  "try",
	  "switch",
	  "continue",
	  "typeof",
	  "delete",
	  "let",
	  "yield",
	  "const",
	  "class",
	  "debugger",
	  "async",
	  "await",
	  "static",
	  "import",
	  "from",
	  "export",
	  "extends"
	];
	const LITERALS$1 = [
	  "true",
	  "false",
	  "null",
	  "undefined",
	  "NaN",
	  "Infinity"
	];
	const TYPES$1 = [
	  "Intl",
	  "DataView",
	  "Number",
	  "Math",
	  "Date",
	  "String",
	  "RegExp",
	  "Object",
	  "Function",
	  "Boolean",
	  "Error",
	  "Symbol",
	  "Set",
	  "Map",
	  "WeakSet",
	  "WeakMap",
	  "Proxy",
	  "Reflect",
	  "JSON",
	  "Promise",
	  "Float64Array",
	  "Int16Array",
	  "Int32Array",
	  "Int8Array",
	  "Uint16Array",
	  "Uint32Array",
	  "Float32Array",
	  "Array",
	  "Uint8Array",
	  "Uint8ClampedArray",
	  "ArrayBuffer",
	  "BigInt64Array",
	  "BigUint64Array",
	  "BigInt"
	];
	const ERROR_TYPES$1 = [
	  "EvalError",
	  "InternalError",
	  "RangeError",
	  "ReferenceError",
	  "SyntaxError",
	  "TypeError",
	  "URIError"
	];
	const BUILT_IN_GLOBALS$1 = [
	  "setInterval",
	  "setTimeout",
	  "clearInterval",
	  "clearTimeout",
	  "require",
	  "exports",
	  "eval",
	  "isFinite",
	  "isNaN",
	  "parseFloat",
	  "parseInt",
	  "decodeURI",
	  "decodeURIComponent",
	  "encodeURI",
	  "encodeURIComponent",
	  "escape",
	  "unescape"
	];
	const BUILT_IN_VARIABLES$1 = [
	  "arguments",
	  "this",
	  "super",
	  "console",
	  "window",
	  "document",
	  "localStorage",
	  "module",
	  "global"
	];
	const BUILT_INS$1 = [].concat(
	  BUILT_IN_GLOBALS$1,
	  BUILT_IN_VARIABLES$1,
	  TYPES$1,
	  ERROR_TYPES$1
	);
	function source$7(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$5(re) {
	  return concat$7('(?=', re, ')');
	}
	function concat$7(...args) {
	  const joined = args.map((x) => source$7(x)).join("");
	  return joined;
	}
	function javascript$1(hljs) {
	  const hasClosingTag = (match, { after }) => {
	    const tag = "</" + match[0].slice(1);
	    const pos = match.input.indexOf(tag, after);
	    return pos !== -1;
	  };
	  const IDENT_RE$1 = IDENT_RE$2;
	  const FRAGMENT = {
	    begin: '<>',
	    end: '</>'
	  };
	  const XML_TAG = {
	    begin: /<[A-Za-z0-9\\._:-]+/,
	    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
	    isTrulyOpeningTag: (match, response) => {
	      const afterMatchIndex = match[0].length + match.index;
	      const nextChar = match.input[afterMatchIndex];
	      if (nextChar === "<") {
	        response.ignoreMatch();
	        return;
	      }
	      if (nextChar === ">") {
	        if (!hasClosingTag(match, { after: afterMatchIndex })) {
	          response.ignoreMatch();
	        }
	      }
	    }
	  };
	  const KEYWORDS$1$1 = {
	    $pattern: IDENT_RE$2,
	    keyword: KEYWORDS$1,
	    literal: LITERALS$1,
	    built_in: BUILT_INS$1
	  };
	  const decimalDigits = '[0-9](_?[0-9])*';
	  const frac = `\\.(${decimalDigits})`;
	  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
	  const NUMBER = {
	    className: 'number',
	    variants: [
	      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
	        `[eE][+-]?(${decimalDigits})\\b` },
	      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
	      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
	      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
	      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
	      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
	      { begin: "\\b0[0-7]+n?\\b" },
	    ],
	    relevance: 0
	  };
	  const SUBST = {
	    className: 'subst',
	    begin: '\\$\\{',
	    end: '\\}',
	    keywords: KEYWORDS$1$1,
	    contains: []
	  };
	  const HTML_TEMPLATE = {
	    begin: 'html`',
	    end: '',
	    starts: {
	      end: '`',
	      returnEnd: false,
	      contains: [
	        hljs.BACKSLASH_ESCAPE,
	        SUBST
	      ],
	      subLanguage: 'xml'
	    }
	  };
	  const CSS_TEMPLATE = {
	    begin: 'css`',
	    end: '',
	    starts: {
	      end: '`',
	      returnEnd: false,
	      contains: [
	        hljs.BACKSLASH_ESCAPE,
	        SUBST
	      ],
	      subLanguage: 'css'
	    }
	  };
	  const TEMPLATE_STRING = {
	    className: 'string',
	    begin: '`',
	    end: '`',
	    contains: [
	      hljs.BACKSLASH_ESCAPE,
	      SUBST
	    ]
	  };
	  const JSDOC_COMMENT = hljs.COMMENT(
	    /\/\*\*(?!\/)/,
	    '\\*/',
	    {
	      relevance: 0,
	      contains: [
	        {
	          className: 'doctag',
	          begin: '@[A-Za-z]+',
	          contains: [
	            {
	              className: 'type',
	              begin: '\\{',
	              end: '\\}',
	              relevance: 0
	            },
	            {
	              className: 'variable',
	              begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
	              endsParent: true,
	              relevance: 0
	            },
	            {
	              begin: /(?=[^\n])\s/,
	              relevance: 0
	            }
	          ]
	        }
	      ]
	    }
	  );
	  const COMMENT = {
	    className: "comment",
	    variants: [
	      JSDOC_COMMENT,
	      hljs.C_BLOCK_COMMENT_MODE,
	      hljs.C_LINE_COMMENT_MODE
	    ]
	  };
	  const SUBST_INTERNALS = [
	    hljs.APOS_STRING_MODE,
	    hljs.QUOTE_STRING_MODE,
	    HTML_TEMPLATE,
	    CSS_TEMPLATE,
	    TEMPLATE_STRING,
	    NUMBER,
	    hljs.REGEXP_MODE
	  ];
	  SUBST.contains = SUBST_INTERNALS
	    .concat({
	      begin: /\{/,
	      end: /\}/,
	      keywords: KEYWORDS$1$1,
	      contains: [
	        "self"
	      ].concat(SUBST_INTERNALS)
	    });
	  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
	  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
	    {
	      begin: /\(/,
	      end: /\)/,
	      keywords: KEYWORDS$1$1,
	      contains: ["self"].concat(SUBST_AND_COMMENTS)
	    }
	  ]);
	  const PARAMS = {
	    className: 'params',
	    begin: /\(/,
	    end: /\)/,
	    excludeBegin: true,
	    excludeEnd: true,
	    keywords: KEYWORDS$1$1,
	    contains: PARAMS_CONTAINS
	  };
	  return {
	    name: 'Javascript',
	    aliases: ['js', 'jsx', 'mjs', 'cjs'],
	    keywords: KEYWORDS$1$1,
	    exports: { PARAMS_CONTAINS },
	    illegal: /#(?![$_A-z])/,
	    contains: [
	      hljs.SHEBANG({
	        label: "shebang",
	        binary: "node",
	        relevance: 5
	      }),
	      {
	        label: "use_strict",
	        className: 'meta',
	        relevance: 10,
	        begin: /^\s*['"]use (strict|asm)['"]/
	      },
	      hljs.APOS_STRING_MODE,
	      hljs.QUOTE_STRING_MODE,
	      HTML_TEMPLATE,
	      CSS_TEMPLATE,
	      TEMPLATE_STRING,
	      COMMENT,
	      NUMBER,
	      {
	        begin: concat$7(/[{,\n]\s*/,
	          lookahead$5(concat$7(
	            /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
	            IDENT_RE$1 + '\\s*:'))),
	        relevance: 0,
	        contains: [
	          {
	            className: 'attr',
	            begin: IDENT_RE$1 + lookahead$5('\\s*:'),
	            relevance: 0
	          }
	        ]
	      },
	      {
	        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
	        keywords: 'return throw case',
	        contains: [
	          COMMENT,
	          hljs.REGEXP_MODE,
	          {
	            className: 'function',
	            begin: '(\\(' +
	            '[^()]*(\\(' +
	            '[^()]*(\\(' +
	            '[^()]*' +
	            '\\)[^()]*)*' +
	            '\\)[^()]*)*' +
	            '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
	            returnBegin: true,
	            end: '\\s*=>',
	            contains: [
	              {
	                className: 'params',
	                variants: [
	                  {
	                    begin: hljs.UNDERSCORE_IDENT_RE,
	                    relevance: 0
	                  },
	                  {
	                    className: null,
	                    begin: /\(\s*\)/,
	                    skip: true
	                  },
	                  {
	                    begin: /\(/,
	                    end: /\)/,
	                    excludeBegin: true,
	                    excludeEnd: true,
	                    keywords: KEYWORDS$1$1,
	                    contains: PARAMS_CONTAINS
	                  }
	                ]
	              }
	            ]
	          },
	          {
	            begin: /,/, relevance: 0
	          },
	          {
	            className: '',
	            begin: /\s/,
	            end: /\s*/,
	            skip: true
	          },
	          {
	            variants: [
	              { begin: FRAGMENT.begin, end: FRAGMENT.end },
	              {
	                begin: XML_TAG.begin,
	                'on:begin': XML_TAG.isTrulyOpeningTag,
	                end: XML_TAG.end
	              }
	            ],
	            subLanguage: 'xml',
	            contains: [
	              {
	                begin: XML_TAG.begin,
	                end: XML_TAG.end,
	                skip: true,
	                contains: ['self']
	              }
	            ]
	          }
	        ],
	        relevance: 0
	      },
	      {
	        className: 'function',
	        beginKeywords: 'function',
	        end: /[{;]/,
	        excludeEnd: true,
	        keywords: KEYWORDS$1$1,
	        contains: [
	          'self',
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
	          PARAMS
	        ],
	        illegal: /%/
	      },
	      {
	        beginKeywords: "while if switch catch for"
	      },
	      {
	        className: 'function',
	        begin: hljs.UNDERSCORE_IDENT_RE +
	          '\\(' +
	          '[^()]*(\\(' +
	            '[^()]*(\\(' +
	              '[^()]*' +
	            '\\)[^()]*)*' +
	          '\\)[^()]*)*' +
	          '\\)\\s*\\{',
	        returnBegin:true,
	        contains: [
	          PARAMS,
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
	        ]
	      },
	      {
	        variants: [
	          { begin: '\\.' + IDENT_RE$1 },
	          { begin: '\\$' + IDENT_RE$1 }
	        ],
	        relevance: 0
	      },
	      {
	        className: 'class',
	        beginKeywords: 'class',
	        end: /[{;=]/,
	        excludeEnd: true,
	        illegal: /[:"[\]]/,
	        contains: [
	          { beginKeywords: 'extends' },
	          hljs.UNDERSCORE_TITLE_MODE
	        ]
	      },
	      {
	        begin: /\b(?=constructor)/,
	        end: /[{;]/,
	        excludeEnd: true,
	        contains: [
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
	          'self',
	          PARAMS
	        ]
	      },
	      {
	        begin: '(get|set)\\s+(?=' + IDENT_RE$1 + '\\()',
	        end: /\{/,
	        keywords: "get set",
	        contains: [
	          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
	          { begin: /\(\)/ },
	          PARAMS
	        ]
	      },
	      {
	        begin: /\$[(.]/
	      }
	    ]
	  };
	}
	function typescript(hljs) {
	  const IDENT_RE$1 = IDENT_RE$2;
	  const NAMESPACE = {
	    beginKeywords: 'namespace', end: /\{/, excludeEnd: true
	  };
	  const INTERFACE = {
	    beginKeywords: 'interface', end: /\{/, excludeEnd: true,
	    keywords: 'interface extends'
	  };
	  const USE_STRICT = {
	    className: 'meta',
	    relevance: 10,
	    begin: /^\s*['"]use strict['"]/
	  };
	  const TYPES = [
	    "any",
	    "void",
	    "number",
	    "boolean",
	    "string",
	    "object",
	    "never",
	    "enum"
	  ];
	  const TS_SPECIFIC_KEYWORDS = [
	    "type",
	    "namespace",
	    "typedef",
	    "interface",
	    "public",
	    "private",
	    "protected",
	    "implements",
	    "declare",
	    "abstract",
	    "readonly"
	  ];
	  const KEYWORDS$1$1 = {
	    $pattern: IDENT_RE$2,
	    keyword: KEYWORDS$1.concat(TS_SPECIFIC_KEYWORDS),
	    literal: LITERALS$1,
	    built_in: BUILT_INS$1.concat(TYPES)
	  };
	  const DECORATOR = {
	    className: 'meta',
	    begin: '@' + IDENT_RE$1,
	  };
	  const swapMode = (mode, label, replacement) => {
	    const indx = mode.contains.findIndex(m => m.label === label);
	    if (indx === -1) { throw new Error("can not find mode to replace"); }
	    mode.contains.splice(indx, 1, replacement);
	  };
	  const tsLanguage = javascript$1(hljs);
	  Object.assign(tsLanguage.keywords, KEYWORDS$1$1);
	  tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
	  tsLanguage.contains = tsLanguage.contains.concat([
	    DECORATOR,
	    NAMESPACE,
	    INTERFACE,
	  ]);
	  swapMode(tsLanguage, "shebang", hljs.SHEBANG());
	  swapMode(tsLanguage, "use_strict", USE_STRICT);
	  const functionDeclaration = tsLanguage.contains.find(m => m.className === "function");
	  functionDeclaration.relevance = 0;
	  Object.assign(tsLanguage, {
	    name: 'TypeScript',
	    aliases: ['ts', 'tsx']
	  });
	  return tsLanguage;
	}
	var typescript_1 = typescript;

	function source$8(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function concat$8(...args) {
	  const joined = args.map((x) => source$8(x)).join("");
	  return joined;
	}
	function either$2(...args) {
	  const joined = '(' + args.map((x) => source$8(x)).join("|") + ")";
	  return joined;
	}
	function sql(hljs) {
	  const COMMENT_MODE = hljs.COMMENT('--', '$');
	  const STRING = {
	    className: 'string',
	    variants: [
	      {
	        begin: /'/,
	        end: /'/,
	        contains: [
	          {begin: /''/ }
	        ]
	      }
	    ]
	  };
	  const QUOTED_IDENTIFIER = {
	    begin: /"/,
	    end: /"/,
	    contains: [ { begin: /""/ } ]
	  };
	  const LITERALS = [
	    "true",
	    "false",
	    "unknown"
	  ];
	  const MULTI_WORD_TYPES = [
	    "double precision",
	    "large object",
	    "with timezone",
	    "without timezone"
	  ];
	  const TYPES = [
	    'bigint',
	    'binary',
	    'blob',
	    'boolean',
	    'char',
	    'character',
	    'clob',
	    'date',
	    'dec',
	    'decfloat',
	    'decimal',
	    'float',
	    'int',
	    'integer',
	    'interval',
	    'nchar',
	    'nclob',
	    'national',
	    'numeric',
	    'real',
	    'row',
	    'smallint',
	    'time',
	    'timestamp',
	    'varchar',
	    'varying',
	    'varbinary'
	  ];
	  const NON_RESERVED_WORDS = [
	    "add",
	    "asc",
	    "collation",
	    "desc",
	    "final",
	    "first",
	    "last",
	    "view"
	  ];
	  const RESERVED_WORDS = [
	    "abs",
	    "acos",
	    "all",
	    "allocate",
	    "alter",
	    "and",
	    "any",
	    "are",
	    "array",
	    "array_agg",
	    "array_max_cardinality",
	    "as",
	    "asensitive",
	    "asin",
	    "asymmetric",
	    "at",
	    "atan",
	    "atomic",
	    "authorization",
	    "avg",
	    "begin",
	    "begin_frame",
	    "begin_partition",
	    "between",
	    "bigint",
	    "binary",
	    "blob",
	    "boolean",
	    "both",
	    "by",
	    "call",
	    "called",
	    "cardinality",
	    "cascaded",
	    "case",
	    "cast",
	    "ceil",
	    "ceiling",
	    "char",
	    "char_length",
	    "character",
	    "character_length",
	    "check",
	    "classifier",
	    "clob",
	    "close",
	    "coalesce",
	    "collate",
	    "collect",
	    "column",
	    "commit",
	    "condition",
	    "connect",
	    "constraint",
	    "contains",
	    "convert",
	    "copy",
	    "corr",
	    "corresponding",
	    "cos",
	    "cosh",
	    "count",
	    "covar_pop",
	    "covar_samp",
	    "create",
	    "cross",
	    "cube",
	    "cume_dist",
	    "current",
	    "current_catalog",
	    "current_date",
	    "current_default_transform_group",
	    "current_path",
	    "current_role",
	    "current_row",
	    "current_schema",
	    "current_time",
	    "current_timestamp",
	    "current_path",
	    "current_role",
	    "current_transform_group_for_type",
	    "current_user",
	    "cursor",
	    "cycle",
	    "date",
	    "day",
	    "deallocate",
	    "dec",
	    "decimal",
	    "decfloat",
	    "declare",
	    "default",
	    "define",
	    "delete",
	    "dense_rank",
	    "deref",
	    "describe",
	    "deterministic",
	    "disconnect",
	    "distinct",
	    "double",
	    "drop",
	    "dynamic",
	    "each",
	    "element",
	    "else",
	    "empty",
	    "end",
	    "end_frame",
	    "end_partition",
	    "end-exec",
	    "equals",
	    "escape",
	    "every",
	    "except",
	    "exec",
	    "execute",
	    "exists",
	    "exp",
	    "external",
	    "extract",
	    "false",
	    "fetch",
	    "filter",
	    "first_value",
	    "float",
	    "floor",
	    "for",
	    "foreign",
	    "frame_row",
	    "free",
	    "from",
	    "full",
	    "function",
	    "fusion",
	    "get",
	    "global",
	    "grant",
	    "group",
	    "grouping",
	    "groups",
	    "having",
	    "hold",
	    "hour",
	    "identity",
	    "in",
	    "indicator",
	    "initial",
	    "inner",
	    "inout",
	    "insensitive",
	    "insert",
	    "int",
	    "integer",
	    "intersect",
	    "intersection",
	    "interval",
	    "into",
	    "is",
	    "join",
	    "json_array",
	    "json_arrayagg",
	    "json_exists",
	    "json_object",
	    "json_objectagg",
	    "json_query",
	    "json_table",
	    "json_table_primitive",
	    "json_value",
	    "lag",
	    "language",
	    "large",
	    "last_value",
	    "lateral",
	    "lead",
	    "leading",
	    "left",
	    "like",
	    "like_regex",
	    "listagg",
	    "ln",
	    "local",
	    "localtime",
	    "localtimestamp",
	    "log",
	    "log10",
	    "lower",
	    "match",
	    "match_number",
	    "match_recognize",
	    "matches",
	    "max",
	    "member",
	    "merge",
	    "method",
	    "min",
	    "minute",
	    "mod",
	    "modifies",
	    "module",
	    "month",
	    "multiset",
	    "national",
	    "natural",
	    "nchar",
	    "nclob",
	    "new",
	    "no",
	    "none",
	    "normalize",
	    "not",
	    "nth_value",
	    "ntile",
	    "null",
	    "nullif",
	    "numeric",
	    "octet_length",
	    "occurrences_regex",
	    "of",
	    "offset",
	    "old",
	    "omit",
	    "on",
	    "one",
	    "only",
	    "open",
	    "or",
	    "order",
	    "out",
	    "outer",
	    "over",
	    "overlaps",
	    "overlay",
	    "parameter",
	    "partition",
	    "pattern",
	    "per",
	    "percent",
	    "percent_rank",
	    "percentile_cont",
	    "percentile_disc",
	    "period",
	    "portion",
	    "position",
	    "position_regex",
	    "power",
	    "precedes",
	    "precision",
	    "prepare",
	    "primary",
	    "procedure",
	    "ptf",
	    "range",
	    "rank",
	    "reads",
	    "real",
	    "recursive",
	    "ref",
	    "references",
	    "referencing",
	    "regr_avgx",
	    "regr_avgy",
	    "regr_count",
	    "regr_intercept",
	    "regr_r2",
	    "regr_slope",
	    "regr_sxx",
	    "regr_sxy",
	    "regr_syy",
	    "release",
	    "result",
	    "return",
	    "returns",
	    "revoke",
	    "right",
	    "rollback",
	    "rollup",
	    "row",
	    "row_number",
	    "rows",
	    "running",
	    "savepoint",
	    "scope",
	    "scroll",
	    "search",
	    "second",
	    "seek",
	    "select",
	    "sensitive",
	    "session_user",
	    "set",
	    "show",
	    "similar",
	    "sin",
	    "sinh",
	    "skip",
	    "smallint",
	    "some",
	    "specific",
	    "specifictype",
	    "sql",
	    "sqlexception",
	    "sqlstate",
	    "sqlwarning",
	    "sqrt",
	    "start",
	    "static",
	    "stddev_pop",
	    "stddev_samp",
	    "submultiset",
	    "subset",
	    "substring",
	    "substring_regex",
	    "succeeds",
	    "sum",
	    "symmetric",
	    "system",
	    "system_time",
	    "system_user",
	    "table",
	    "tablesample",
	    "tan",
	    "tanh",
	    "then",
	    "time",
	    "timestamp",
	    "timezone_hour",
	    "timezone_minute",
	    "to",
	    "trailing",
	    "translate",
	    "translate_regex",
	    "translation",
	    "treat",
	    "trigger",
	    "trim",
	    "trim_array",
	    "true",
	    "truncate",
	    "uescape",
	    "union",
	    "unique",
	    "unknown",
	    "unnest",
	    "update   ",
	    "upper",
	    "user",
	    "using",
	    "value",
	    "values",
	    "value_of",
	    "var_pop",
	    "var_samp",
	    "varbinary",
	    "varchar",
	    "varying",
	    "versioning",
	    "when",
	    "whenever",
	    "where",
	    "width_bucket",
	    "window",
	    "with",
	    "within",
	    "without",
	    "year",
	  ];
	  const RESERVED_FUNCTIONS = [
	    "abs",
	    "acos",
	    "array_agg",
	    "asin",
	    "atan",
	    "avg",
	    "cast",
	    "ceil",
	    "ceiling",
	    "coalesce",
	    "corr",
	    "cos",
	    "cosh",
	    "count",
	    "covar_pop",
	    "covar_samp",
	    "cume_dist",
	    "dense_rank",
	    "deref",
	    "element",
	    "exp",
	    "extract",
	    "first_value",
	    "floor",
	    "json_array",
	    "json_arrayagg",
	    "json_exists",
	    "json_object",
	    "json_objectagg",
	    "json_query",
	    "json_table",
	    "json_table_primitive",
	    "json_value",
	    "lag",
	    "last_value",
	    "lead",
	    "listagg",
	    "ln",
	    "log",
	    "log10",
	    "lower",
	    "max",
	    "min",
	    "mod",
	    "nth_value",
	    "ntile",
	    "nullif",
	    "percent_rank",
	    "percentile_cont",
	    "percentile_disc",
	    "position",
	    "position_regex",
	    "power",
	    "rank",
	    "regr_avgx",
	    "regr_avgy",
	    "regr_count",
	    "regr_intercept",
	    "regr_r2",
	    "regr_slope",
	    "regr_sxx",
	    "regr_sxy",
	    "regr_syy",
	    "row_number",
	    "sin",
	    "sinh",
	    "sqrt",
	    "stddev_pop",
	    "stddev_samp",
	    "substring",
	    "substring_regex",
	    "sum",
	    "tan",
	    "tanh",
	    "translate",
	    "translate_regex",
	    "treat",
	    "trim",
	    "trim_array",
	    "unnest",
	    "upper",
	    "value_of",
	    "var_pop",
	    "var_samp",
	    "width_bucket",
	  ];
	  const POSSIBLE_WITHOUT_PARENS = [
	    "current_catalog",
	    "current_date",
	    "current_default_transform_group",
	    "current_path",
	    "current_role",
	    "current_schema",
	    "current_transform_group_for_type",
	    "current_user",
	    "session_user",
	    "system_time",
	    "system_user",
	    "current_time",
	    "localtime",
	    "current_timestamp",
	    "localtimestamp"
	  ];
	  const COMBOS = [
	    "create table",
	    "insert into",
	    "primary key",
	    "foreign key",
	    "not null",
	    "alter table",
	    "add constraint",
	    "grouping sets",
	    "on overflow",
	    "character set",
	    "respect nulls",
	    "ignore nulls",
	    "nulls first",
	    "nulls last",
	    "depth first",
	    "breadth first"
	  ];
	  const FUNCTIONS = RESERVED_FUNCTIONS;
	  const KEYWORDS = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => {
	    return !RESERVED_FUNCTIONS.includes(keyword);
	  });
	  const VARIABLE = {
	    className: "variable",
	    begin: /@[a-z0-9]+/,
	  };
	  const OPERATOR = {
	    className: "operator",
	    begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
	    relevance: 0,
	  };
	  const FUNCTION_CALL = {
	    begin: concat$8(/\b/, either$2(...FUNCTIONS), /\s*\(/),
	    keywords: {
	      built_in: FUNCTIONS
	    }
	  };
	  function reduceRelevancy(list, {exceptions, when} = {}) {
	    const qualifyFn = when;
	    exceptions = exceptions || [];
	    return list.map((item) => {
	      if (item.match(/\|\d+$/) || exceptions.includes(item)) {
	        return item;
	      } else if (qualifyFn(item)) {
	        return `${item}|0`;
	      } else {
	        return item;
	      }
	    });
	  }
	  return {
	    name: 'SQL',
	    case_insensitive: true,
	    illegal: /[{}]|<\//,
	    keywords: {
	      $pattern: /\b[\w\.]+/,
	      keyword:
	        reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
	      literal: LITERALS,
	      type: TYPES,
	      built_in: POSSIBLE_WITHOUT_PARENS
	    },
	    contains: [
	      {
	        begin: either$2(...COMBOS),
	        keywords: {
	          $pattern: /[\w\.]+/,
	          keyword: KEYWORDS.concat(COMBOS),
	          literal: LITERALS,
	          type: TYPES
	        },
	      },
	      {
	        className: "type",
	        begin: either$2(...MULTI_WORD_TYPES)
	      },
	      FUNCTION_CALL,
	      VARIABLE,
	      STRING,
	      QUOTED_IDENTIFIER,
	      hljs.C_NUMBER_MODE,
	      hljs.C_BLOCK_COMMENT_MODE,
	      COMMENT_MODE,
	      OPERATOR
	    ]
	  };
	}
	var sql_1 = sql;

	function source$9(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function lookahead$6(re) {
	  return concat$9('(?=', re, ')');
	}
	function concat$9(...args) {
	  const joined = args.map((x) => source$9(x)).join("");
	  return joined;
	}
	function ruby(hljs) {
	  const RUBY_METHOD_RE = '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)';
	  const RUBY_KEYWORDS = {
	    keyword:
	      'and then defined module in return redo if BEGIN retry end for self when ' +
	      'next until do begin unless END rescue else break undef not super class case ' +
	      'require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor ' +
	      '__FILE__',
	    built_in: 'proc lambda',
	    literal:
	      'true false nil'
	  };
	  const YARDOCTAG = {
	    className: 'doctag',
	    begin: '@[A-Za-z]+'
	  };
	  const IRB_OBJECT = {
	    begin: '#<',
	    end: '>'
	  };
	  const COMMENT_MODES = [
	    hljs.COMMENT(
	      '#',
	      '$',
	      {
	        contains: [ YARDOCTAG ]
	      }
	    ),
	    hljs.COMMENT(
	      '^=begin',
	      '^=end',
	      {
	        contains: [ YARDOCTAG ],
	        relevance: 10
	      }
	    ),
	    hljs.COMMENT('^__END__', '\\n$')
	  ];
	  const SUBST = {
	    className: 'subst',
	    begin: /#\{/,
	    end: /\}/,
	    keywords: RUBY_KEYWORDS
	  };
	  const STRING = {
	    className: 'string',
	    contains: [
	      hljs.BACKSLASH_ESCAPE,
	      SUBST
	    ],
	    variants: [
	      {
	        begin: /'/,
	        end: /'/
	      },
	      {
	        begin: /"/,
	        end: /"/
	      },
	      {
	        begin: /`/,
	        end: /`/
	      },
	      {
	        begin: /%[qQwWx]?\(/,
	        end: /\)/
	      },
	      {
	        begin: /%[qQwWx]?\[/,
	        end: /\]/
	      },
	      {
	        begin: /%[qQwWx]?\{/,
	        end: /\}/
	      },
	      {
	        begin: /%[qQwWx]?</,
	        end: />/
	      },
	      {
	        begin: /%[qQwWx]?\//,
	        end: /\//
	      },
	      {
	        begin: /%[qQwWx]?%/,
	        end: /%/
	      },
	      {
	        begin: /%[qQwWx]?-/,
	        end: /-/
	      },
	      {
	        begin: /%[qQwWx]?\|/,
	        end: /\|/
	      },
	      {
	        begin: /\B\?(\\\d{1,3})/
	      },
	      {
	        begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/
	      },
	      {
	        begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/
	      },
	      {
	        begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/
	      },
	      {
	        begin: /\B\?\\(c|C-)[\x20-\x7e]/
	      },
	      {
	        begin: /\B\?\\?\S/
	      },
	      {
	        begin: /<<[-~]?'?(\w+)\n(?:[^\n]*\n)*?\s*\1\b/,
	        returnBegin: true,
	        contains: [
	          {
	            begin: /<<[-~]?'?/
	          },
	          hljs.END_SAME_AS_BEGIN({
	            begin: /(\w+)/,
	            end: /(\w+)/,
	            contains: [
	              hljs.BACKSLASH_ESCAPE,
	              SUBST
	            ]
	          })
	        ]
	      }
	    ]
	  };
	  const decimal = '[1-9](_?[0-9])*|0';
	  const digits = '[0-9](_?[0-9])*';
	  const NUMBER = {
	    className: 'number',
	    relevance: 0,
	    variants: [
	      {
	        begin: `\\b(${decimal})(\\.(${digits}))?([eE][+-]?(${digits})|r)?i?\\b`
	      },
	      {
	        begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b"
	      },
	      {
	        begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b"
	      },
	      {
	        begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b"
	      },
	      {
	        begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b"
	      },
	      {
	        begin: "\\b0(_?[0-7])+r?i?\\b"
	      }
	    ]
	  };
	  const PARAMS = {
	    className: 'params',
	    begin: '\\(',
	    end: '\\)',
	    endsParent: true,
	    keywords: RUBY_KEYWORDS
	  };
	  const RUBY_DEFAULT_CONTAINS = [
	    STRING,
	    {
	      className: 'class',
	      beginKeywords: 'class module',
	      end: '$|;',
	      illegal: /=/,
	      contains: [
	        hljs.inherit(hljs.TITLE_MODE, {
	          begin: '[A-Za-z_]\\w*(::\\w+)*(\\?|!)?'
	        }),
	        {
	          begin: '<\\s*',
	          contains: [
	            {
	              begin: '(' + hljs.IDENT_RE + '::)?' + hljs.IDENT_RE,
	              relevance: 0
	            }
	          ]
	        }
	      ].concat(COMMENT_MODES)
	    },
	    {
	      className: 'function',
	      begin: concat$9(/def\s+/, lookahead$6(RUBY_METHOD_RE + "\\s*(\\(|;|$)")),
	      relevance: 0,
	      keywords: "def",
	      end: '$|;',
	      contains: [
	        hljs.inherit(hljs.TITLE_MODE, {
	          begin: RUBY_METHOD_RE
	        }),
	        PARAMS
	      ].concat(COMMENT_MODES)
	    },
	    {
	      begin: hljs.IDENT_RE + '::'
	    },
	    {
	      className: 'symbol',
	      begin: hljs.UNDERSCORE_IDENT_RE + '(!|\\?)?:',
	      relevance: 0
	    },
	    {
	      className: 'symbol',
	      begin: ':(?!\\s)',
	      contains: [
	        STRING,
	        {
	          begin: RUBY_METHOD_RE
	        }
	      ],
	      relevance: 0
	    },
	    NUMBER,
	    {
	      className: "variable",
	      begin: '(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])' + `(?![A-Za-z])(?![@$?'])`
	    },
	    {
	      className: 'params',
	      begin: /\|/,
	      end: /\|/,
	      relevance: 0,
	      keywords: RUBY_KEYWORDS
	    },
	    {
	      begin: '(' + hljs.RE_STARTERS_RE + '|unless)\\s*',
	      keywords: 'unless',
	      contains: [
	        {
	          className: 'regexp',
	          contains: [
	            hljs.BACKSLASH_ESCAPE,
	            SUBST
	          ],
	          illegal: /\n/,
	          variants: [
	            {
	              begin: '/',
	              end: '/[a-z]*'
	            },
	            {
	              begin: /%r\{/,
	              end: /\}[a-z]*/
	            },
	            {
	              begin: '%r\\(',
	              end: '\\)[a-z]*'
	            },
	            {
	              begin: '%r!',
	              end: '![a-z]*'
	            },
	            {
	              begin: '%r\\[',
	              end: '\\][a-z]*'
	            }
	          ]
	        }
	      ].concat(IRB_OBJECT, COMMENT_MODES),
	      relevance: 0
	    }
	  ].concat(IRB_OBJECT, COMMENT_MODES);
	  SUBST.contains = RUBY_DEFAULT_CONTAINS;
	  PARAMS.contains = RUBY_DEFAULT_CONTAINS;
	  const SIMPLE_PROMPT = "[>?]>";
	  const DEFAULT_PROMPT = "[\\w#]+\\(\\w+\\):\\d+:\\d+>";
	  const RVM_PROMPT = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>";
	  const IRB_DEFAULT = [
	    {
	      begin: /^\s*=>/,
	      starts: {
	        end: '$',
	        contains: RUBY_DEFAULT_CONTAINS
	      }
	    },
	    {
	      className: 'meta',
	      begin: '^(' + SIMPLE_PROMPT + "|" + DEFAULT_PROMPT + '|' + RVM_PROMPT + ')(?=[ ])',
	      starts: {
	        end: '$',
	        contains: RUBY_DEFAULT_CONTAINS
	      }
	    }
	  ];
	  COMMENT_MODES.unshift(IRB_OBJECT);
	  return {
	    name: 'Ruby',
	    aliases: [
	      'rb',
	      'gemspec',
	      'podspec',
	      'thor',
	      'irb'
	    ],
	    keywords: RUBY_KEYWORDS,
	    illegal: /\/\*/,
	    contains: [
	      hljs.SHEBANG({
	        binary: "ruby"
	      })
	    ]
	      .concat(IRB_DEFAULT)
	      .concat(COMMENT_MODES)
	      .concat(RUBY_DEFAULT_CONTAINS)
	  };
	}
	var ruby_1 = ruby;

	function vim(hljs) {
	  return {
	    name: 'Vim Script',
	    keywords: {
	      $pattern: /[!#@\w]+/,
	      keyword:
	        'N|0 P|0 X|0 a|0 ab abc abo al am an|0 ar arga argd arge argdo argg argl argu as au aug aun b|0 bN ba bad bd be bel bf bl bm bn bo bp br brea breaka breakd breakl bro bufdo buffers bun bw c|0 cN cNf ca cabc caddb cad caddf cal cat cb cc ccl cd ce cex cf cfir cgetb cgete cg changes chd che checkt cl cla clo cm cmapc cme cn cnew cnf cno cnorea cnoreme co col colo com comc comp con conf cope ' +
	        'cp cpf cq cr cs cst cu cuna cunme cw delm deb debugg delc delf dif diffg diffo diffp diffpu diffs diffthis dig di dl dell dj dli do doautoa dp dr ds dsp e|0 ea ec echoe echoh echom echon el elsei em en endfo endf endt endw ene ex exe exi exu f|0 files filet fin fina fini fir fix fo foldc foldd folddoc foldo for fu go gr grepa gu gv ha helpf helpg helpt hi hid his ia iabc if ij il im imapc ' +
	        'ime ino inorea inoreme int is isp iu iuna iunme j|0 ju k|0 keepa kee keepj lN lNf l|0 lad laddb laddf la lan lat lb lc lch lcl lcs le lefta let lex lf lfir lgetb lgete lg lgr lgrepa lh ll lla lli lmak lm lmapc lne lnew lnf ln loadk lo loc lockv lol lope lp lpf lr ls lt lu lua luad luaf lv lvimgrepa lw m|0 ma mak map mapc marks mat me menut mes mk mks mksp mkv mkvie mod mz mzf nbc nb nbs new nm nmapc nme nn nnoreme noa no noh norea noreme norm nu nun nunme ol o|0 om omapc ome on ono onoreme opt ou ounme ow p|0 ' +
	        'profd prof pro promptr pc ped pe perld po popu pp pre prev ps pt ptN ptf ptj ptl ptn ptp ptr pts pu pw py3 python3 py3d py3f py pyd pyf quita qa rec red redi redr redraws reg res ret retu rew ri rightb rub rubyd rubyf rund ru rv sN san sa sal sav sb sbN sba sbf sbl sbm sbn sbp sbr scrip scripte scs se setf setg setl sf sfir sh sim sig sil sl sla sm smap smapc sme sn sni sno snor snoreme sor ' +
	        'so spelld spe spelli spellr spellu spellw sp spr sre st sta startg startr star stopi stj sts sun sunm sunme sus sv sw sy synti sync tN tabN tabc tabdo tabe tabf tabfir tabl tabm tabnew ' +
	        'tabn tabo tabp tabr tabs tab ta tags tc tcld tclf te tf th tj tl tm tn to tp tr try ts tu u|0 undoj undol una unh unl unlo unm unme uns up ve verb vert vim vimgrepa vi viu vie vm vmapc vme vne vn vnoreme vs vu vunme windo w|0 wN wa wh wi winc winp wn wp wq wqa ws wu wv x|0 xa xmapc xm xme xn xnoreme xu xunme y|0 z|0 ~ ' +
	        'Next Print append abbreviate abclear aboveleft all amenu anoremenu args argadd argdelete argedit argglobal arglocal argument ascii autocmd augroup aunmenu buffer bNext ball badd bdelete behave belowright bfirst blast bmodified bnext botright bprevious brewind break breakadd breakdel breaklist browse bunload ' +
	        'bwipeout change cNext cNfile cabbrev cabclear caddbuffer caddexpr caddfile call catch cbuffer cclose center cexpr cfile cfirst cgetbuffer cgetexpr cgetfile chdir checkpath checktime clist clast close cmap cmapclear cmenu cnext cnewer cnfile cnoremap cnoreabbrev cnoremenu copy colder colorscheme command comclear compiler continue confirm copen cprevious cpfile cquit crewind cscope cstag cunmap ' +
	        'cunabbrev cunmenu cwindow delete delmarks debug debuggreedy delcommand delfunction diffupdate diffget diffoff diffpatch diffput diffsplit digraphs display deletel djump dlist doautocmd doautoall deletep drop dsearch dsplit edit earlier echo echoerr echohl echomsg else elseif emenu endif endfor ' +
	        'endfunction endtry endwhile enew execute exit exusage file filetype find finally finish first fixdel fold foldclose folddoopen folddoclosed foldopen function global goto grep grepadd gui gvim hardcopy help helpfind helpgrep helptags highlight hide history insert iabbrev iabclear ijump ilist imap ' +
	        'imapclear imenu inoremap inoreabbrev inoremenu intro isearch isplit iunmap iunabbrev iunmenu join jumps keepalt keepmarks keepjumps lNext lNfile list laddexpr laddbuffer laddfile last language later lbuffer lcd lchdir lclose lcscope left leftabove lexpr lfile lfirst lgetbuffer lgetexpr lgetfile lgrep lgrepadd lhelpgrep llast llist lmake lmap lmapclear lnext lnewer lnfile lnoremap loadkeymap loadview ' +
	        'lockmarks lockvar lolder lopen lprevious lpfile lrewind ltag lunmap luado luafile lvimgrep lvimgrepadd lwindow move mark make mapclear match menu menutranslate messages mkexrc mksession mkspell mkvimrc mkview mode mzscheme mzfile nbclose nbkey nbsart next nmap nmapclear nmenu nnoremap ' +
	        'nnoremenu noautocmd noremap nohlsearch noreabbrev noremenu normal number nunmap nunmenu oldfiles open omap omapclear omenu only onoremap onoremenu options ounmap ounmenu ownsyntax print profdel profile promptfind promptrepl pclose pedit perl perldo pop popup ppop preserve previous psearch ptag ptNext ' +
	        'ptfirst ptjump ptlast ptnext ptprevious ptrewind ptselect put pwd py3do py3file python pydo pyfile quit quitall qall read recover redo redir redraw redrawstatus registers resize retab return rewind right rightbelow ruby rubydo rubyfile rundo runtime rviminfo substitute sNext sandbox sargument sall saveas sbuffer sbNext sball sbfirst sblast sbmodified sbnext sbprevious sbrewind scriptnames scriptencoding ' +
	        'scscope set setfiletype setglobal setlocal sfind sfirst shell simalt sign silent sleep slast smagic smapclear smenu snext sniff snomagic snoremap snoremenu sort source spelldump spellgood spellinfo spellrepall spellundo spellwrong split sprevious srewind stop stag startgreplace startreplace ' +
	        'startinsert stopinsert stjump stselect sunhide sunmap sunmenu suspend sview swapname syntax syntime syncbind tNext tabNext tabclose tabedit tabfind tabfirst tablast tabmove tabnext tabonly tabprevious tabrewind tag tcl tcldo tclfile tearoff tfirst throw tjump tlast tmenu tnext topleft tprevious ' + 'trewind tselect tunmenu undo undojoin undolist unabbreviate unhide unlet unlockvar unmap unmenu unsilent update vglobal version verbose vertical vimgrep vimgrepadd visual viusage view vmap vmapclear vmenu vnew ' +
	        'vnoremap vnoremenu vsplit vunmap vunmenu write wNext wall while winsize wincmd winpos wnext wprevious wqall wsverb wundo wviminfo xit xall xmapclear xmap xmenu xnoremap xnoremenu xunmap xunmenu yank',
	      built_in:
	        'synIDtrans atan2 range matcharg did_filetype asin feedkeys xor argv ' +
	        'complete_check add getwinposx getqflist getwinposy screencol ' +
	        'clearmatches empty extend getcmdpos mzeval garbagecollect setreg ' +
	        'ceil sqrt diff_hlID inputsecret get getfperm getpid filewritable ' +
	        'shiftwidth max sinh isdirectory synID system inputrestore winline ' +
	        'atan visualmode inputlist tabpagewinnr round getregtype mapcheck ' +
	        'hasmapto histdel argidx findfile sha256 exists toupper getcmdline ' +
	        'taglist string getmatches bufnr strftime winwidth bufexists ' +
	        'strtrans tabpagebuflist setcmdpos remote_read printf setloclist ' +
	        'getpos getline bufwinnr float2nr len getcmdtype diff_filler luaeval ' +
	        'resolve libcallnr foldclosedend reverse filter has_key bufname ' +
	        'str2float strlen setline getcharmod setbufvar index searchpos ' +
	        'shellescape undofile foldclosed setqflist buflisted strchars str2nr ' +
	        'virtcol floor remove undotree remote_expr winheight gettabwinvar ' +
	        'reltime cursor tabpagenr finddir localtime acos getloclist search ' +
	        'tanh matchend rename gettabvar strdisplaywidth type abs py3eval ' +
	        'setwinvar tolower wildmenumode log10 spellsuggest bufloaded ' +
	        'synconcealed nextnonblank server2client complete settabwinvar ' +
	        'executable input wincol setmatches getftype hlID inputsave ' +
	        'searchpair or screenrow line settabvar histadd deepcopy strpart ' +
	        'remote_peek and eval getftime submatch screenchar winsaveview ' +
	        'matchadd mkdir screenattr getfontname libcall reltimestr getfsize ' +
	        'winnr invert pow getbufline byte2line soundfold repeat fnameescape ' +
	        'tagfiles sin strwidth spellbadword trunc maparg log lispindent ' +
	        'hostname setpos globpath remote_foreground getchar synIDattr ' +
	        'fnamemodify cscope_connection stridx winbufnr indent min ' +
	        'complete_add nr2char searchpairpos inputdialog values matchlist ' +
	        'items hlexists strridx browsedir expand fmod pathshorten line2byte ' +
	        'argc count getwinvar glob foldtextresult getreg foreground cosh ' +
	        'matchdelete has char2nr simplify histget searchdecl iconv ' +
	        'winrestcmd pumvisible writefile foldlevel haslocaldir keys cos ' +
	        'matchstr foldtext histnr tan tempname getcwd byteidx getbufvar ' +
	        'islocked escape eventhandler remote_send serverlist winrestview ' +
	        'synstack pyeval prevnonblank readfile cindent filereadable changenr ' +
	        'exp'
	    },
	    illegal: /;/,
	    contains: [
	      hljs.NUMBER_MODE,
	      {
	        className: 'string',
	        begin: '\'',
	        end: '\'',
	        illegal: '\\n'
	      },
	      {
	        className: 'string',
	        begin: /"(\\"|\n\\|[^"\n])*"/
	      },
	      hljs.COMMENT('"', '$'),
	      {
	        className: 'variable',
	        begin: /[bwtglsav]:[\w\d_]*/
	      },
	      {
	        className: 'function',
	        beginKeywords: 'function function!',
	        end: '$',
	        relevance: 0,
	        contains: [
	          hljs.TITLE_MODE,
	          {
	            className: 'params',
	            begin: '\\(',
	            end: '\\)'
	          }
	        ]
	      },
	      {
	        className: 'symbol',
	        begin: /<[\w-]+>/
	      }
	    ]
	  };
	}
	var vim_1 = vim;

	function php(hljs) {
	  const VARIABLE = {
	    className: 'variable',
	    begin: '\\$+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*' +
	      `(?![A-Za-z0-9])(?![$])`
	  };
	  const PREPROCESSOR = {
	    className: 'meta',
	    variants: [
	      { begin: /<\?php/, relevance: 10 },
	      { begin: /<\?[=]?/ },
	      { begin: /\?>/ }
	    ]
	  };
	  const SUBST = {
	    className: 'subst',
	    variants: [
	      { begin: /\$\w+/ },
	      { begin: /\{\$/, end: /\}/ }
	    ]
	  };
	  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
	    illegal: null,
	  });
	  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
	    illegal: null,
	    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
	  });
	  const HEREDOC = hljs.END_SAME_AS_BEGIN({
	    begin: /<<<[ \t]*(\w+)\n/,
	    end: /[ \t]*(\w+)\b/,
	    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
	  });
	  const STRING = {
	    className: 'string',
	    contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
	    variants: [
	      hljs.inherit(SINGLE_QUOTED, {
	        begin: "b'", end: "'",
	      }),
	      hljs.inherit(DOUBLE_QUOTED, {
	        begin: 'b"', end: '"',
	      }),
	      DOUBLE_QUOTED,
	      SINGLE_QUOTED,
	      HEREDOC
	    ]
	  };
	  const NUMBER = {
	    className: 'number',
	    variants: [
	      { begin: `\\b0b[01]+(?:_[01]+)*\\b` },
	      { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` },
	      { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` },
	      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?` }
	    ],
	    relevance: 0
	  };
	  const KEYWORDS = {
	    keyword:
	    '__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ ' +
	    'die echo exit include include_once print require require_once ' +
	    'array abstract and as binary bool boolean break callable case catch class clone const continue declare ' +
	    'default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends ' +
	    'final finally float for foreach from global goto if implements instanceof insteadof int integer interface ' +
	    'isset iterable list match|0 mixed new object or private protected public real return string switch throw trait ' +
	    'try unset use var void while xor yield',
	    literal: 'false null true',
	    built_in:
	    'Error|0 ' +
	    'AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ' +
	    'ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap ' +
	    'Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass'
	  };
	  return {
	    aliases: ['php3', 'php4', 'php5', 'php6', 'php7', 'php8'],
	    case_insensitive: true,
	    keywords: KEYWORDS,
	    contains: [
	      hljs.HASH_COMMENT_MODE,
	      hljs.COMMENT('//', '$', {contains: [PREPROCESSOR]}),
	      hljs.COMMENT(
	        '/\\*',
	        '\\*/',
	        {
	          contains: [
	            {
	              className: 'doctag',
	              begin: '@[A-Za-z]+'
	            }
	          ]
	        }
	      ),
	      hljs.COMMENT(
	        '__halt_compiler.+?;',
	        false,
	        {
	          endsWithParent: true,
	          keywords: '__halt_compiler'
	        }
	      ),
	      PREPROCESSOR,
	      {
	        className: 'keyword', begin: /\$this\b/
	      },
	      VARIABLE,
	      {
	        begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
	      },
	      {
	        className: 'function',
	        relevance: 0,
	        beginKeywords: 'fn function', end: /[;{]/, excludeEnd: true,
	        illegal: '[$%\\[]',
	        contains: [
	          {
	            beginKeywords: 'use',
	          },
	          hljs.UNDERSCORE_TITLE_MODE,
	          {
	            begin: '=>',
	            endsParent: true
	          },
	          {
	            className: 'params',
	            begin: '\\(', end: '\\)',
	            excludeBegin: true,
	            excludeEnd: true,
	            keywords: KEYWORDS,
	            contains: [
	              'self',
	              VARIABLE,
	              hljs.C_BLOCK_COMMENT_MODE,
	              STRING,
	              NUMBER
	            ]
	          }
	        ]
	      },
	      {
	        className: 'class',
	        variants: [
	          { beginKeywords: "enum", illegal: /[($"]/ },
	          { beginKeywords: "class interface trait", illegal: /[:($"]/ }
	        ],
	        relevance: 0,
	        end: /\{/,
	        excludeEnd: true,
	        contains: [
	          {beginKeywords: 'extends implements'},
	          hljs.UNDERSCORE_TITLE_MODE
	        ]
	      },
	      {
	        beginKeywords: 'namespace',
	        relevance: 0,
	        end: ';',
	        illegal: /[.']/,
	        contains: [hljs.UNDERSCORE_TITLE_MODE]
	      },
	      {
	        beginKeywords: 'use',
	        relevance: 0,
	        end: ';',
	        contains: [hljs.UNDERSCORE_TITLE_MODE]
	      },
	      STRING,
	      NUMBER
	    ]
	  };
	}
	var php_1 = php;

	function source$a(re) {
	  if (!re) return null;
	  if (typeof re === "string") return re;
	  return re.source;
	}
	function concat$a(...args) {
	  const joined = args.map((x) => source$a(x)).join("");
	  return joined;
	}
	function either$3(...args) {
	  const joined = '(' + args.map((x) => source$a(x)).join("|") + ")";
	  return joined;
	}
	function perl(hljs) {
	  const KEYWORDS = [
	    'abs',
	    'accept',
	    'alarm',
	    'and',
	    'atan2',
	    'bind',
	    'binmode',
	    'bless',
	    'break',
	    'caller',
	    'chdir',
	    'chmod',
	    'chomp',
	    'chop',
	    'chown',
	    'chr',
	    'chroot',
	    'close',
	    'closedir',
	    'connect',
	    'continue',
	    'cos',
	    'crypt',
	    'dbmclose',
	    'dbmopen',
	    'defined',
	    'delete',
	    'die',
	    'do',
	    'dump',
	    'each',
	    'else',
	    'elsif',
	    'endgrent',
	    'endhostent',
	    'endnetent',
	    'endprotoent',
	    'endpwent',
	    'endservent',
	    'eof',
	    'eval',
	    'exec',
	    'exists',
	    'exit',
	    'exp',
	    'fcntl',
	    'fileno',
	    'flock',
	    'for',
	    'foreach',
	    'fork',
	    'format',
	    'formline',
	    'getc',
	    'getgrent',
	    'getgrgid',
	    'getgrnam',
	    'gethostbyaddr',
	    'gethostbyname',
	    'gethostent',
	    'getlogin',
	    'getnetbyaddr',
	    'getnetbyname',
	    'getnetent',
	    'getpeername',
	    'getpgrp',
	    'getpriority',
	    'getprotobyname',
	    'getprotobynumber',
	    'getprotoent',
	    'getpwent',
	    'getpwnam',
	    'getpwuid',
	    'getservbyname',
	    'getservbyport',
	    'getservent',
	    'getsockname',
	    'getsockopt',
	    'given',
	    'glob',
	    'gmtime',
	    'goto',
	    'grep',
	    'gt',
	    'hex',
	    'if',
	    'index',
	    'int',
	    'ioctl',
	    'join',
	    'keys',
	    'kill',
	    'last',
	    'lc',
	    'lcfirst',
	    'length',
	    'link',
	    'listen',
	    'local',
	    'localtime',
	    'log',
	    'lstat',
	    'lt',
	    'ma',
	    'map',
	    'mkdir',
	    'msgctl',
	    'msgget',
	    'msgrcv',
	    'msgsnd',
	    'my',
	    'ne',
	    'next',
	    'no',
	    'not',
	    'oct',
	    'open',
	    'opendir',
	    'or',
	    'ord',
	    'our',
	    'pack',
	    'package',
	    'pipe',
	    'pop',
	    'pos',
	    'print',
	    'printf',
	    'prototype',
	    'push',
	    'q|0',
	    'qq',
	    'quotemeta',
	    'qw',
	    'qx',
	    'rand',
	    'read',
	    'readdir',
	    'readline',
	    'readlink',
	    'readpipe',
	    'recv',
	    'redo',
	    'ref',
	    'rename',
	    'require',
	    'reset',
	    'return',
	    'reverse',
	    'rewinddir',
	    'rindex',
	    'rmdir',
	    'say',
	    'scalar',
	    'seek',
	    'seekdir',
	    'select',
	    'semctl',
	    'semget',
	    'semop',
	    'send',
	    'setgrent',
	    'sethostent',
	    'setnetent',
	    'setpgrp',
	    'setpriority',
	    'setprotoent',
	    'setpwent',
	    'setservent',
	    'setsockopt',
	    'shift',
	    'shmctl',
	    'shmget',
	    'shmread',
	    'shmwrite',
	    'shutdown',
	    'sin',
	    'sleep',
	    'socket',
	    'socketpair',
	    'sort',
	    'splice',
	    'split',
	    'sprintf',
	    'sqrt',
	    'srand',
	    'stat',
	    'state',
	    'study',
	    'sub',
	    'substr',
	    'symlink',
	    'syscall',
	    'sysopen',
	    'sysread',
	    'sysseek',
	    'system',
	    'syswrite',
	    'tell',
	    'telldir',
	    'tie',
	    'tied',
	    'time',
	    'times',
	    'tr',
	    'truncate',
	    'uc',
	    'ucfirst',
	    'umask',
	    'undef',
	    'unless',
	    'unlink',
	    'unpack',
	    'unshift',
	    'untie',
	    'until',
	    'use',
	    'utime',
	    'values',
	    'vec',
	    'wait',
	    'waitpid',
	    'wantarray',
	    'warn',
	    'when',
	    'while',
	    'write',
	    'x|0',
	    'xor',
	    'y|0'
	  ];
	  const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/;
	  const PERL_KEYWORDS = {
	    $pattern: /[\w.]+/,
	    keyword: KEYWORDS.join(" ")
	  };
	  const SUBST = {
	    className: 'subst',
	    begin: '[$@]\\{',
	    end: '\\}',
	    keywords: PERL_KEYWORDS
	  };
	  const METHOD = {
	    begin: /->\{/,
	    end: /\}/
	  };
	  const VAR = {
	    variants: [
	      {
	        begin: /\$\d/
	      },
	      {
	        begin: concat$a(
	          /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
	          `(?![A-Za-z])(?![@$%])`
	        )
	      },
	      {
	        begin: /[$%@][^\s\w{]/,
	        relevance: 0
	      }
	    ]
	  };
	  const STRING_CONTAINS = [
	    hljs.BACKSLASH_ESCAPE,
	    SUBST,
	    VAR
	  ];
	  const REGEX_DELIMS = [
	    /!/,
	    /\//,
	    /\|/,
	    /\?/,
	    /'/,
	    /"/,
	    /#/
	  ];
	  const PAIRED_DOUBLE_RE = (prefix, open, close = '\\1') => {
	    const middle = (close === '\\1')
	      ? close
	      : concat$a(close, open);
	    return concat$a(
	      concat$a("(?:", prefix, ")"),
	      open,
	      /(?:\\.|[^\\\/])*?/,
	      middle,
	      /(?:\\.|[^\\\/])*?/,
	      close,
	      REGEX_MODIFIERS
	    );
	  };
	  const PAIRED_RE = (prefix, open, close) => {
	    return concat$a(
	      concat$a("(?:", prefix, ")"),
	      open,
	      /(?:\\.|[^\\\/])*?/,
	      close,
	      REGEX_MODIFIERS
	    );
	  };
	  const PERL_DEFAULT_CONTAINS = [
	    VAR,
	    hljs.HASH_COMMENT_MODE,
	    hljs.COMMENT(
	      /^=\w/,
	      /=cut/,
	      {
	        endsWithParent: true
	      }
	    ),
	    METHOD,
	    {
	      className: 'string',
	      contains: STRING_CONTAINS,
	      variants: [
	        {
	          begin: 'q[qwxr]?\\s*\\(',
	          end: '\\)',
	          relevance: 5
	        },
	        {
	          begin: 'q[qwxr]?\\s*\\[',
	          end: '\\]',
	          relevance: 5
	        },
	        {
	          begin: 'q[qwxr]?\\s*\\{',
	          end: '\\}',
	          relevance: 5
	        },
	        {
	          begin: 'q[qwxr]?\\s*\\|',
	          end: '\\|',
	          relevance: 5
	        },
	        {
	          begin: 'q[qwxr]?\\s*<',
	          end: '>',
	          relevance: 5
	        },
	        {
	          begin: 'qw\\s+q',
	          end: 'q',
	          relevance: 5
	        },
	        {
	          begin: '\'',
	          end: '\'',
	          contains: [ hljs.BACKSLASH_ESCAPE ]
	        },
	        {
	          begin: '"',
	          end: '"'
	        },
	        {
	          begin: '`',
	          end: '`',
	          contains: [ hljs.BACKSLASH_ESCAPE ]
	        },
	        {
	          begin: /\{\w+\}/,
	          relevance: 0
	        },
	        {
	          begin: '-?\\w+\\s*=>',
	          relevance: 0
	        }
	      ]
	    },
	    {
	      className: 'number',
	      begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
	      relevance: 0
	    },
	    {
	      begin: '(\\/\\/|' + hljs.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
	      keywords: 'split return print reverse grep',
	      relevance: 0,
	      contains: [
	        hljs.HASH_COMMENT_MODE,
	        {
	          className: 'regexp',
	          variants: [
	            { begin: PAIRED_DOUBLE_RE("s|tr|y", either$3(...REGEX_DELIMS)) },
	            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
	            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
	            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
	          ],
	          relevance: 2
	        },
	        {
	          className: 'regexp',
	          variants: [
	            {
	              begin: /(m|qr)\/\//,
	              relevance: 0
	            },
	            { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//)},
	            { begin: PAIRED_RE("m|qr", either$3(...REGEX_DELIMS), /\1/)},
	            { begin: PAIRED_RE("m|qr", /\(/, /\)/)},
	            { begin: PAIRED_RE("m|qr", /\[/, /\]/)},
	            { begin: PAIRED_RE("m|qr", /\{/, /\}/)}
	          ]
	        }
	      ]
	    },
	    {
	      className: 'function',
	      beginKeywords: 'sub',
	      end: '(\\s*\\(.*?\\))?[;{]',
	      excludeEnd: true,
	      relevance: 5,
	      contains: [ hljs.TITLE_MODE ]
	    },
	    {
	      begin: '-\\w\\b',
	      relevance: 0
	    },
	    {
	      begin: "^__DATA__$",
	      end: "^__END__$",
	      subLanguage: 'mojolicious',
	      contains: [
	        {
	          begin: "^@@.*",
	          end: "$",
	          className: "comment"
	        }
	      ]
	    }
	  ];
	  SUBST.contains = PERL_DEFAULT_CONTAINS;
	  METHOD.contains = PERL_DEFAULT_CONTAINS;
	  return {
	    name: 'Perl',
	    aliases: [
	      'pl',
	      'pm'
	    ],
	    keywords: PERL_KEYWORDS,
	    contains: PERL_DEFAULT_CONTAINS
	  };
	}
	var perl_1 = perl;

	function powershell(hljs) {
	  const TYPES = [
	    "string",
	    "char",
	    "byte",
	    "int",
	    "long",
	    "bool",
	    "decimal",
	    "single",
	    "double",
	    "DateTime",
	    "xml",
	    "array",
	    "hashtable",
	    "void"
	  ];
	  const VALID_VERBS =
	    'Add|Clear|Close|Copy|Enter|Exit|Find|Format|Get|Hide|Join|Lock|' +
	    'Move|New|Open|Optimize|Pop|Push|Redo|Remove|Rename|Reset|Resize|' +
	    'Search|Select|Set|Show|Skip|Split|Step|Switch|Undo|Unlock|' +
	    'Watch|Backup|Checkpoint|Compare|Compress|Convert|ConvertFrom|' +
	    'ConvertTo|Dismount|Edit|Expand|Export|Group|Import|Initialize|' +
	    'Limit|Merge|Mount|Out|Publish|Restore|Save|Sync|Unpublish|Update|' +
	    'Approve|Assert|Build|Complete|Confirm|Deny|Deploy|Disable|Enable|Install|Invoke|' +
	    'Register|Request|Restart|Resume|Start|Stop|Submit|Suspend|Uninstall|' +
	    'Unregister|Wait|Debug|Measure|Ping|Repair|Resolve|Test|Trace|Connect|' +
	    'Disconnect|Read|Receive|Send|Write|Block|Grant|Protect|Revoke|Unblock|' +
	    'Unprotect|Use|ForEach|Sort|Tee|Where';
	  const COMPARISON_OPERATORS =
	    '-and|-as|-band|-bnot|-bor|-bxor|-casesensitive|-ccontains|-ceq|-cge|-cgt|' +
	    '-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|' +
	    '-creplace|-csplit|-eq|-exact|-f|-file|-ge|-gt|-icontains|-ieq|-ige|-igt|' +
	    '-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|' +
	    '-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-not|' +
	    '-notcontains|-notin|-notlike|-notmatch|-or|-regex|-replace|-shl|-shr|' +
	    '-split|-wildcard|-xor';
	  const KEYWORDS = {
	    $pattern: /-?[A-z\.\-]+\b/,
	    keyword:
	      'if else foreach return do while until elseif begin for trap data dynamicparam ' +
	      'end break throw param continue finally in switch exit filter try process catch ' +
	      'hidden static parameter',
	    built_in:
	      'ac asnp cat cd CFS chdir clc clear clhy cli clp cls clv cnsn compare copy cp ' +
	      'cpi cpp curl cvpa dbp del diff dir dnsn ebp echo|0 epal epcsv epsn erase etsn exsn fc fhx ' +
	      'fl ft fw gal gbp gc gcb gci gcm gcs gdr gerr ghy gi gin gjb gl gm gmo gp gps gpv group ' +
	      'gsn gsnp gsv gtz gu gv gwmi h history icm iex ihy ii ipal ipcsv ipmo ipsn irm ise iwmi ' +
	      'iwr kill lp ls man md measure mi mount move mp mv nal ndr ni nmo npssc nsn nv ogv oh ' +
	      'popd ps pushd pwd r rbp rcjb rcsn rd rdr ren ri rjb rm rmdir rmo rni rnp rp rsn rsnp ' +
	      'rujb rv rvpa rwmi sajb sal saps sasv sbp sc scb select set shcm si sl sleep sls sort sp ' +
	      'spjb spps spsv start stz sujb sv swmi tee trcm type wget where wjb write'
	  };
	  const TITLE_NAME_RE = /\w[\w\d]*((-)[\w\d]+)*/;
	  const BACKTICK_ESCAPE = {
	    begin: '`[\\s\\S]',
	    relevance: 0
	  };
	  const VAR = {
	    className: 'variable',
	    variants: [
	      {
	        begin: /\$\B/
	      },
	      {
	        className: 'keyword',
	        begin: /\$this/
	      },
	      {
	        begin: /\$[\w\d][\w\d_:]*/
	      }
	    ]
	  };
	  const LITERAL = {
	    className: 'literal',
	    begin: /\$(null|true|false)\b/
	  };
	  const QUOTE_STRING = {
	    className: "string",
	    variants: [
	      {
	        begin: /"/,
	        end: /"/
	      },
	      {
	        begin: /@"/,
	        end: /^"@/
	      }
	    ],
	    contains: [
	      BACKTICK_ESCAPE,
	      VAR,
	      {
	        className: 'variable',
	        begin: /\$[A-z]/,
	        end: /[^A-z]/
	      }
	    ]
	  };
	  const APOS_STRING = {
	    className: 'string',
	    variants: [
	      {
	        begin: /'/,
	        end: /'/
	      },
	      {
	        begin: /@'/,
	        end: /^'@/
	      }
	    ]
	  };
	  const PS_HELPTAGS = {
	    className: "doctag",
	    variants: [
	      {
	        begin: /\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/
	      },
	      {
	        begin: /\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/
	      }
	    ]
	  };
	  const PS_COMMENT = hljs.inherit(
	    hljs.COMMENT(null, null),
	    {
	      variants: [
	        {
	          begin: /#/,
	          end: /$/
	        },
	        {
	          begin: /<#/,
	          end: /#>/
	        }
	      ],
	      contains: [ PS_HELPTAGS ]
	    }
	  );
	  const CMDLETS = {
	    className: 'built_in',
	    variants: [
	      {
	        begin: '('.concat(VALID_VERBS, ')+(-)[\\w\\d]+')
	      }
	    ]
	  };
	  const PS_CLASS = {
	    className: 'class',
	    beginKeywords: 'class enum',
	    end: /\s*[{]/,
	    excludeEnd: true,
	    relevance: 0,
	    contains: [ hljs.TITLE_MODE ]
	  };
	  const PS_FUNCTION = {
	    className: 'function',
	    begin: /function\s+/,
	    end: /\s*\{|$/,
	    excludeEnd: true,
	    returnBegin: true,
	    relevance: 0,
	    contains: [
	      {
	        begin: "function",
	        relevance: 0,
	        className: "keyword"
	      },
	      {
	        className: "title",
	        begin: TITLE_NAME_RE,
	        relevance: 0
	      },
	      {
	        begin: /\(/,
	        end: /\)/,
	        className: "params",
	        relevance: 0,
	        contains: [ VAR ]
	      }
	    ]
	  };
	  const PS_USING = {
	    begin: /using\s/,
	    end: /$/,
	    returnBegin: true,
	    contains: [
	      QUOTE_STRING,
	      APOS_STRING,
	      {
	        className: 'keyword',
	        begin: /(using|assembly|command|module|namespace|type)/
	      }
	    ]
	  };
	  const PS_ARGUMENTS = {
	    variants: [
	      {
	        className: 'operator',
	        begin: '('.concat(COMPARISON_OPERATORS, ')\\b')
	      },
	      {
	        className: 'literal',
	        begin: /(-)[\w\d]+/,
	        relevance: 0
	      }
	    ]
	  };
	  const HASH_SIGNS = {
	    className: 'selector-tag',
	    begin: /@\B/,
	    relevance: 0
	  };
	  const PS_METHODS = {
	    className: 'function',
	    begin: /\[.*\]\s*[\w]+[ ]??\(/,
	    end: /$/,
	    returnBegin: true,
	    relevance: 0,
	    contains: [
	      {
	        className: 'keyword',
	        begin: '('.concat(
	          KEYWORDS.keyword.toString().replace(/\s/g, '|'
	          ), ')\\b'),
	        endsParent: true,
	        relevance: 0
	      },
	      hljs.inherit(hljs.TITLE_MODE, {
	        endsParent: true
	      })
	    ]
	  };
	  const GENTLEMANS_SET = [
	    PS_METHODS,
	    PS_COMMENT,
	    BACKTICK_ESCAPE,
	    hljs.NUMBER_MODE,
	    QUOTE_STRING,
	    APOS_STRING,
	    CMDLETS,
	    VAR,
	    LITERAL,
	    HASH_SIGNS
	  ];
	  const PS_TYPE = {
	    begin: /\[/,
	    end: /\]/,
	    excludeBegin: true,
	    excludeEnd: true,
	    relevance: 0,
	    contains: [].concat(
	      'self',
	      GENTLEMANS_SET,
	      {
	        begin: "(" + TYPES.join("|") + ")",
	        className: "built_in",
	        relevance: 0
	      },
	      {
	        className: 'type',
	        begin: /[\.\w\d]+/,
	        relevance: 0
	      }
	    )
	  };
	  PS_METHODS.contains.unshift(PS_TYPE);
	  return {
	    name: 'PowerShell',
	    aliases: [
	      "ps",
	      "ps1"
	    ],
	    case_insensitive: true,
	    keywords: KEYWORDS,
	    contains: GENTLEMANS_SET.concat(
	      PS_CLASS,
	      PS_FUNCTION,
	      PS_USING,
	      PS_ARGUMENTS,
	      PS_TYPE
	    )
	  };
	}
	var powershell_1 = powershell;

	function makefile(hljs) {
	  const VARIABLE = {
	    className: 'variable',
	    variants: [
	      {
	        begin: '\\$\\(' + hljs.UNDERSCORE_IDENT_RE + '\\)',
	        contains: [ hljs.BACKSLASH_ESCAPE ]
	      },
	      {
	        begin: /\$[@%<?\^\+\*]/
	      }
	    ]
	  };
	  const QUOTE_STRING = {
	    className: 'string',
	    begin: /"/,
	    end: /"/,
	    contains: [
	      hljs.BACKSLASH_ESCAPE,
	      VARIABLE
	    ]
	  };
	  const FUNC = {
	    className: 'variable',
	    begin: /\$\([\w-]+\s/,
	    end: /\)/,
	    keywords: {
	      built_in:
	        'subst patsubst strip findstring filter filter-out sort ' +
	        'word wordlist firstword lastword dir notdir suffix basename ' +
	        'addsuffix addprefix join wildcard realpath abspath error warning ' +
	        'shell origin flavor foreach if or and call eval file value'
	    },
	    contains: [ VARIABLE ]
	  };
	  const ASSIGNMENT = {
	    begin: '^' + hljs.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)'
	  };
	  const META = {
	    className: 'meta',
	    begin: /^\.PHONY:/,
	    end: /$/,
	    keywords: {
	      $pattern: /[\.\w]+/,
	      'meta-keyword': '.PHONY'
	    }
	  };
	  const TARGET = {
	    className: 'section',
	    begin: /^[^\s]+:/,
	    end: /$/,
	    contains: [ VARIABLE ]
	  };
	  return {
	    name: 'Makefile',
	    aliases: [
	      'mk',
	      'mak',
	      'make',
	    ],
	    keywords: {
	      $pattern: /[\w-]+/,
	      keyword: 'define endef undefine ifdef ifndef ifeq ifneq else endif ' +
	      'include -include sinclude override export unexport private vpath'
	    },
	    contains: [
	      hljs.HASH_COMMENT_MODE,
	      VARIABLE,
	      QUOTE_STRING,
	      FUNC,
	      ASSIGNMENT,
	      META,
	      TARGET
	    ]
	  };
	}
	var makefile_1 = makefile;

	[{
	  lang: 'java',
	  mod: java_1
	}, {
	  lang: 'javascript',
	  mod: javascript_1
	}, {
	  lang: 'json',
	  mod: json_1
	}, {
	  lang: 'css',
	  mod: css_1
	}, {
	  lang: 'scss',
	  mod: scss_1
	}, {
	  lang: 'less',
	  mod: less_1
	}, {
	  lang: 'stylus',
	  mod: stylus_1
	}, {
	  lang: 'shell',
	  mod: shell_1
	}, {
	  lang: 'bash',
	  mod: bash_1
	}, {
	  lang: 'cpp',
	  mod: cpp_1
	}, {
	  lang: 'go',
	  mod: go_1
	}, {
	  lang: 'xml',
	  mod: xml_1
	}, {
	  lang: 'python',
	  mod: python_1
	}, {
	  lang: 'typescript',
	  mod: typescript_1
	}, {
	  lang: 'sql',
	  mod: sql_1
	}, {
	  lang: 'ruby',
	  mod: ruby_1
	}, {
	  lang: 'vim',
	  mod: vim_1
	}, {
	  lang: 'php',
	  mod: php_1
	}, {
	  lang: 'perl',
	  mod: perl_1
	}, {
	  lang: 'powershell',
	  mod: powershell_1
	}, {
	  lang: 'makefile',
	  mod: makefile_1
	}].forEach(function (item) {
	  core.registerLanguage(item.lang, item.mod);
	});
	var script = {
	  name: 'bk-diff',
	  directives: {
	    highlight: function highlight(el) {
	      var blocks = el.querySelectorAll('code');
	      blocks.forEach(function (block) {
	        core.highlightElement(block);
	      });
	    }
	  },
	  props: {
	    oldContent: {
	      type: String,
	      default: ''
	    },
	    newContent: {
	      type: String,
	      default: ''
	    },
	    context: {
	      type: Number,
	      default: Infinity
	    },
	    format: {
	      type: String,
	      default: 'line-by-line'
	    },
	    theme: {
	      type: String,
	      default: 'light',
	      validator: function validator(value) {
	        return ['light', 'dark'].includes(value);
	      }
	    },
	    language: {
	      type: String,
	      required: true
	    },
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  computed: {
	    html: function html() {
	      function htmlReplace(html) {
	        return html.replace(/<span class="d2h-code-line-ctn">(.+?)<\/span>/g, '<span class="d2h-code-line-ctn"><code>$1</code></span>');
	      }
	      var oldContent = this.oldContent + '\n// --end--';
	      var newContent = this.newContent + "\n// -- end--";
	      var args = ['', oldContent, newContent, '', '', {
	        context: this.context
	      }];
	      var dd = diff_1.apply(void 0, args);
	      var outStr = diff2html_1.getJsonFromDiff(dd, {
	        inputFormat: 'diff',
	        outputFormat: this.format,
	        showFiles: false,
	        matching: 'lines'
	      });
	      var html = diff2html_1.getPrettyHtml(outStr, {
	        inputFormat: 'json',
	        outputFormat: this.format,
	        showFiles: false,
	        matching: 'lines'
	      });
	      return htmlReplace(html);
	    },
	    classes: function classes() {
	      return [this.theme, this.extCls, "format-".concat(this.format)];
	    }
	  },
	  watch: {
	    language: {
	      handler: function handler(language) {
	        core.configure({
	          languages: [language]
	        });
	      },
	      immediate: true
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  }
	  var options = typeof script === 'function' ? script.options : script;
	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true;
	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  }
	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    hook = function hook(context) {
	      context = context ||
	      this.$vnode && this.$vnode.ssrContext ||
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      }
	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      }
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    };
	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}
	var normalizeComponent_1 = normalizeComponent;

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "html",
	    staticClass: "bk-diff",
	    class: _vm.classes
	  }, [_c('div', {
	    directives: [{
	      name: "highlight",
	      rawName: "v-highlight"
	    }],
	    domProps: {
	      "innerHTML": _vm._s(_vm.html)
	    }
	  })]);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var toString = {}.toString;
	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.12' };
	if (typeof __e == 'number') __e = core;
	});
	var _core_1 = _core.version;

	var _global = createCommonjsModule(function (module) {
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  : Function('return this')();
	if (typeof __g == 'number') __g = global;
	});

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');
	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');
	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function () {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var PROTOTYPE = 'prototype';
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    out = own ? target[key] : source[key];
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    : IS_BIND && own ? _ctx(out, _global)
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;

	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	function setInstaller (component, afterInstall) {
	  component.install = function (Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var props = component.props || {};
	    keys$1(options).forEach(function (key) {
	      if (props.hasOwnProperty(key)) {
	        if (typeof props[key] === 'function' || props[key] instanceof Array) {
	          props[key] = {
	            type: props[key],
	            default: options[key]
	          };
	        } else {
	          props[key].default = options[key];
	        }
	      }
	    });
	    component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
	    Vue.component(component.name, component);
	    typeof afterInstall === 'function' && afterInstall(Vue, options);
	  };
	}

	setInstaller(__vue_component__);

	exports.default = __vue_component__;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
