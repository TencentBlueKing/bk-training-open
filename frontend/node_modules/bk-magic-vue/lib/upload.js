(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('bk-magic-vue/lib/locale')) :
  typeof define === 'function' && define.amd ? define(['exports', 'bk-magic-vue/lib/locale'], factory) :
  (global = global || self, factory(global.library = {}, global.locale));
}(this, function (exports, locale) { 'use strict';

  var locale__default = 'default' in locale ? locale['default'] : locale;

  var ceil = Math.ceil;
  var floor = Math.floor;
  var _toInteger = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };

  var _defined = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };

  var _stringAt = function (TO_STRING) {
    return function (that, pos) {
      var s = String(_defined(that));
      var i = _toInteger(pos);
      var l = s.length;
      var a, b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
        ? TO_STRING ? s.charAt(i) : a
        : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var _global = createCommonjsModule(function (module) {
  var global = module.exports = typeof window != 'undefined' && window.Math == Math
    ? window : typeof self != 'undefined' && self.Math == Math ? self
    : Function('return this')();
  if (typeof __g == 'number') __g = global;
  });

  var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.6.12' };
  if (typeof __e == 'number') __e = core;
  });
  var _core_1 = _core.version;

  var _aFunction = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };

  var _ctx = function (fn, that, length) {
    _aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };

  var _isObject = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };

  var _anObject = function (it) {
    if (!_isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };

  var _fails = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };

  var _descriptors = !_fails(function () {
    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
  });

  var document$1 = _global.document;
  var is = _isObject(document$1) && _isObject(document$1.createElement);
  var _domCreate = function (it) {
    return is ? document$1.createElement(it) : {};
  };

  var _ie8DomDefine = !_descriptors && !_fails(function () {
    return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
  });

  var _toPrimitive = function (it, S) {
    if (!_isObject(it)) return it;
    var fn, val;
    if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
    if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var dP = Object.defineProperty;
  var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
    _anObject(O);
    P = _toPrimitive(P, true);
    _anObject(Attributes);
    if (_ie8DomDefine) try {
      return dP(O, P, Attributes);
    } catch (e) {  }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var _objectDp = {
  	f: f
  };

  var _propertyDesc = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var _hide = _descriptors ? function (object, key, value) {
    return _objectDp.f(object, key, _propertyDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var hasOwnProperty = {}.hasOwnProperty;
  var _has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F;
    var IS_GLOBAL = type & $export.G;
    var IS_STATIC = type & $export.S;
    var IS_PROTO = type & $export.P;
    var IS_BIND = type & $export.B;
    var IS_WRAP = type & $export.W;
    var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
    var expProto = exports[PROTOTYPE];
    var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
    var key, own, out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && target[key] !== undefined;
      if (own && _has(exports, key)) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
      : IS_BIND && own ? _ctx(out, _global)
      : IS_WRAP && target[key] == out ? (function (C) {
        var F = function (a, b, c) {
          if (this instanceof C) {
            switch (arguments.length) {
              case 0: return new C();
              case 1: return new C(a);
              case 2: return new C(a, b);
            } return new C(a, b, c);
          } return C.apply(this, arguments);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
      if (IS_PROTO) {
        (exports.virtual || (exports.virtual = {}))[key] = out;
        if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
      }
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  $export.U = 64;
  $export.R = 128;
  var _export = $export;

  var _redefine = _hide;

  var _iterators = {};

  var toString = {}.toString;
  var _cof = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return _cof(it) == 'String' ? it.split('') : Object(it);
  };

  var _toIobject = function (it) {
    return _iobject(_defined(it));
  };

  var min = Math.min;
  var _toLength = function (it) {
    return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
  };

  var max = Math.max;
  var min$1 = Math.min;
  var _toAbsoluteIndex = function (index, length) {
    index = _toInteger(index);
    return index < 0 ? max(index + length, 0) : min$1(index, length);
  };

  var _arrayIncludes = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = _toIobject($this);
      var length = _toLength(O.length);
      var index = _toAbsoluteIndex(fromIndex, length);
      var value;
      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++];
        if (value != value) return true;
      } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES && -1;
    };
  };

  var _shared = createCommonjsModule(function (module) {
  var SHARED = '__core-js_shared__';
  var store = _global[SHARED] || (_global[SHARED] = {});
  (module.exports = function (key, value) {
    return store[key] || (store[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: _core.version,
    mode:  'pure' ,
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
  });
  });

  var id = 0;
  var px = Math.random();
  var _uid = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };

  var shared = _shared('keys');
  var _sharedKey = function (key) {
    return shared[key] || (shared[key] = _uid(key));
  };

  var arrayIndexOf = _arrayIncludes(false);
  var IE_PROTO = _sharedKey('IE_PROTO');
  var _objectKeysInternal = function (object, names) {
    var O = _toIobject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
    while (names.length > i) if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
    return result;
  };

  var _enumBugKeys = (
    'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
  ).split(',');

  var _objectKeys = Object.keys || function keys(O) {
    return _objectKeysInternal(O, _enumBugKeys);
  };

  var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    _anObject(O);
    var keys = _objectKeys(Properties);
    var length = keys.length;
    var i = 0;
    var P;
    while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
    return O;
  };

  var document$2 = _global.document;
  var _html = document$2 && document$2.documentElement;

  var IE_PROTO$1 = _sharedKey('IE_PROTO');
  var Empty = function () {  };
  var PROTOTYPE$1 = 'prototype';
  var createDict = function () {
    var iframe = _domCreate('iframe');
    var i = _enumBugKeys.length;
    var lt = '<';
    var gt = '>';
    var iframeDocument;
    iframe.style.display = 'none';
    _html.appendChild(iframe);
    iframe.src = 'javascript:';
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
    iframeDocument.close();
    createDict = iframeDocument.F;
    while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
    return createDict();
  };
  var _objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      Empty[PROTOTYPE$1] = _anObject(O);
      result = new Empty();
      Empty[PROTOTYPE$1] = null;
      result[IE_PROTO$1] = O;
    } else result = createDict();
    return Properties === undefined ? result : _objectDps(result, Properties);
  };

  var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');
  var Symbol = _global.Symbol;
  var USE_SYMBOL = typeof Symbol == 'function';
  var $exports = module.exports = function (name) {
    return store[name] || (store[name] =
      USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
  };
  $exports.store = store;
  });

  var def = _objectDp.f;
  var TAG = _wks('toStringTag');
  var _setToStringTag = function (it, tag, stat) {
    if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
  };

  var IteratorPrototype = {};
  _hide(IteratorPrototype, _wks('iterator'), function () { return this; });
  var _iterCreate = function (Constructor, NAME, next) {
    Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
    _setToStringTag(Constructor, NAME + ' Iterator');
  };

  var _toObject = function (it) {
    return Object(_defined(it));
  };

  var IE_PROTO$2 = _sharedKey('IE_PROTO');
  var ObjectProto = Object.prototype;
  var _objectGpo = Object.getPrototypeOf || function (O) {
    O = _toObject(O);
    if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    } return O instanceof Object ? ObjectProto : null;
  };

  var ITERATOR = _wks('iterator');
  var BUGGY = !([].keys && 'next' in [].keys());
  var FF_ITERATOR = '@@iterator';
  var KEYS = 'keys';
  var VALUES = 'values';
  var returnThis = function () { return this; };
  var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    _iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS: return function keys() { return new Constructor(this, kind); };
        case VALUES: return function values() { return new Constructor(this, kind); };
      } return function entries() { return new Constructor(this, kind); };
    };
    var TAG = NAME + ' Iterator';
    var DEF_VALUES = DEFAULT == VALUES;
    var VALUES_BUG = false;
    var proto = Base.prototype;
    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
    var $default = $native || getMethod(DEFAULT);
    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
    var methods, key, IteratorPrototype;
    if ($anyNative) {
      IteratorPrototype = _objectGpo($anyNative.call(new Base()));
      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
        _setToStringTag(IteratorPrototype, TAG, true);
      }
    }
    if (DEF_VALUES && $native && $native.name !== VALUES) {
      VALUES_BUG = true;
      $default = function values() { return $native.call(this); };
    }
    if (( FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      _hide(proto, ITERATOR, $default);
    }
    _iterators[NAME] = $default;
    _iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: $entries
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) _redefine(proto, key, methods[key]);
      } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };

  var $at = _stringAt(true);
  _iterDefine(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t;
    var index = this._i;
    var point;
    if (index >= O.length) return { value: undefined, done: true };
    point = $at(O, index);
    this._i += point.length;
    return { value: point, done: false };
  });

  var _iterCall = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) _anObject(ret.call(iterator));
      throw e;
    }
  };

  var ITERATOR$1 = _wks('iterator');
  var ArrayProto = Array.prototype;
  var _isArrayIter = function (it) {
    return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
  };

  var _createProperty = function (object, index, value) {
    if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));
    else object[index] = value;
  };

  var TAG$1 = _wks('toStringTag');
  var ARG = _cof(function () { return arguments; }()) == 'Arguments';
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (e) {  }
  };
  var _classof = function (it) {
    var O, T, B;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
      : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
      : ARG ? _cof(O)
      : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };

  var ITERATOR$2 = _wks('iterator');
  var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
    if (it != undefined) return it[ITERATOR$2]
      || it['@@iterator']
      || _iterators[_classof(it)];
  };

  var ITERATOR$3 = _wks('iterator');
  var SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR$3]();
    riter['return'] = function () { SAFE_CLOSING = true; };
    Array.from(riter, function () { throw 2; });
  } catch (e) {  }
  var _iterDetect = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7];
      var iter = arr[ITERATOR$3]();
      iter.next = function () { return { done: safe = true }; };
      arr[ITERATOR$3] = function () { return iter; };
      exec(arr);
    } catch (e) {  }
    return safe;
  };

  _export(_export.S + _export.F * !_iterDetect(function (iter) { Array.from(iter); }), 'Array', {
    from: function from(arrayLike ) {
      var O = _toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var aLen = arguments.length;
      var mapfn = aLen > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var index = 0;
      var iterFn = core_getIteratorMethod(O);
      var length, result, step, iterator;
      if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
        }
      } else {
        length = _toLength(O.length);
        for (result = new C(length); length > index; index++) {
          _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
        }
      }
      result.length = index;
      return result;
    }
  });

  var from_1 = _core.Array.from;

  var from_1$1 = from_1;

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  var _isArray = Array.isArray || function isArray(arg) {
    return _cof(arg) == 'Array';
  };

  _export(_export.S, 'Array', { isArray: _isArray });

  var isArray = _core.Array.isArray;

  var isArray$1 = isArray;

  var parseResponse = function parseResponse(response) {
    if (!response) {
      return response || {};
    }
    try {
      return JSON.parse(response);
    } catch (error) {
      return response || {};
    }
  };
  function upload(options) {
    var xhr = new XMLHttpRequest();
    options.fileObj.xhr = xhr;
    var formData = new FormData();
    options.data.forEach(function (item) {
      formData.append(item.name, item.value);
    });
    formData.append(options.fileName, options.fileObj.origin);
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        var reponseText = parseResponse(xhr.responseText || xhr.response);
        if (xhr.status < 200 || xhr.status >= 300) {
          options.fileObj.progress = 100 + '%';
          options.fileObj.errorMsg = reponseText.message || locale.t('bk.uploadFile.uploadFailed');
          options.onError(options.fileObj, options.fileList, xhr.response);
        } else {
          options.onSuccess(reponseText, options.fileObj);
        }
        options.onDone(options.fileObj);
      }
    };
    xhr.upload.addEventListener('progress', options.onProgress, false);
    xhr.withCredentials = options.withCredentials;
    xhr.open(options.method, options.url, true);
    if (options.header) {
      if (isArray$1(options.header)) {
        options.header.forEach(function (head) {
          var headerKey = head.name;
          var headerVal = head.value;
          xhr.setRequestHeader(headerKey, headerVal);
        });
      } else {
        var headerKey = options.header.name;
        var headerVal = options.header.value;
        xhr.setRequestHeader(headerKey, headerVal);
      }
    }
    xhr.send(formData);
    return {
      abort: function abort() {
        xhr.abort();
      }
    };
  }

  var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

  var space = '[' + _stringWs + ']';
  var non = '\u200b\u0085';
  var ltrim = RegExp('^' + space + space + '*');
  var rtrim = RegExp(space + space + '*$');
  var exporter = function (KEY, exec, ALIAS) {
    var exp = {};
    var FORCE = _fails(function () {
      return !!_stringWs[KEY]() || non[KEY]() != non;
    });
    var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
    if (ALIAS) exp[ALIAS] = fn;
    _export(_export.P + _export.F * FORCE, 'String', exp);
  };
  var trim = exporter.trim = function (string, TYPE) {
    string = String(_defined(string));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
  var _stringTrim = exporter;

  var $parseFloat = _global.parseFloat;
  var $trim = _stringTrim.trim;
  var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
    var string = $trim(String(str), 3);
    var result = $parseFloat(string);
    return result === 0 && string.charAt(0) == '-' ? -0 : result;
  } : $parseFloat;

  _export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

  var _parseFloat$1 = _core.parseFloat;

  var _parseFloat$2 = _parseFloat$1;

  var $parseInt = _global.parseInt;
  var $trim$1 = _stringTrim.trim;
  var hex = /^[-+]?0[xX]/;
  var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
    var string = $trim$1(String(str), 3);
    return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
  } : $parseInt;

  _export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

  var _parseInt$1 = _core.parseInt;

  var _parseInt$2 = _parseInt$1;

  var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    window.setTimeout(callback, 1000 / 60);
  };
  var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
    window.clearTimeout(id);
  };
  function uuid() {
    var id = '';
    var randomNum = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    for (var i = 0; i < 7; i++) {
      id += randomNum;
    }
    return id;
  }
  function checkOverflow(el) {
    if (!el) return false;
    var createDom = function createDom(el, css) {
      var dom = document.createElement('div');
      var width = _parseFloat$2(css['width']) ? Math.ceil(_parseFloat$2(css['width'])) + 'px' : css['width'];
      dom.style.cssText = "\n        width: ".concat(width, ";\n        line-height: ").concat(css['line-height'], ";\n        font-size: ").concat(css['font-size'], ";\n        word-break: ").concat(css['word-break'], ";\n        padding: ").concat(css['padding'], ";\n    ");
      dom.textContent = el.textContent;
      return dom;
    };
    var isOverflow = false;
    try {
      var css = window.getComputedStyle(el, null);
      var lineClamp = css.webkitLineClamp;
      if (lineClamp !== 'none') {
        var targetHeight = _parseFloat$2(css.height);
        var dom = createDom(el, css);
        document.body.appendChild(dom);
        var domHeight = window.getComputedStyle(dom, null)['height'];
        document.body.removeChild(dom);
        isOverflow = targetHeight < _parseFloat$2(domHeight);
      } else {
        isOverflow = el.clientWidth < el.scrollWidth || el.clientHeight < el.scrollHeight;
      }
    } catch (e) {
      console.warn('There is an error when check element overflow state: ', e);
    }
    return isOverflow;
  }

  var _objectSap = function (KEY, exec) {
    var fn = (_core.Object || {})[KEY] || Object[KEY];
    var exp = {};
    exp[KEY] = exec(fn);
    _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
  };

  _objectSap('keys', function () {
    return function keys(it) {
      return _objectKeys(_toObject(it));
    };
  });

  var keys = _core.Object.keys;

  var keys$1 = keys;

  var f$1 = Object.getOwnPropertySymbols;
  var _objectGops = {
  	f: f$1
  };

  var f$2 = {}.propertyIsEnumerable;
  var _objectPie = {
  	f: f$2
  };

  var $assign = Object.assign;
  var _objectAssign = !$assign || _fails(function () {
    var A = {};
    var B = {};
    var S = Symbol();
    var K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) { B[k] = k; });
    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = _toObject(target);
    var aLen = arguments.length;
    var index = 1;
    var getSymbols = _objectGops.f;
    var isEnum = _objectPie.f;
    while (aLen > index) {
      var S = _iobject(arguments[index++]);
      var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
      var length = keys.length;
      var j = 0;
      var key;
      while (length > j) {
        key = keys[j++];
        if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
      }
    } return T;
  } : $assign;

  _export(_export.S + _export.F, 'Object', { assign: _objectAssign });

  var assign = _core.Object.assign;

  var assign$1 = assign;

  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }
  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser && window.Promise;
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent(getParentNode(element));
  }
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent(commonAncestorContainer);
    }
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return _parseFloat$2(styles["border".concat(sideA, "Width")], 10) + _parseFloat$2(styles["border".concat(sideB, "Width")], 10);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body["offset".concat(axis)], body["scroll".concat(axis)], html["client".concat(axis)], html["offset".concat(axis)], html["scroll".concat(axis)], isIE(10) ? _parseInt$2(html["offset".concat(axis)]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Top' : 'Left')]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }
  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }
  var _extends$1 = assign$1 || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect(offsets) {
    return _extends$1({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect(element) {
    var rect = {};
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = _parseFloat$2(styles.borderTopWidth, 10);
    var borderLeftWidth = _parseFloat$2(styles.borderLeftWidth, 10);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE10 && isHTML) {
      var marginTop = _parseFloat$2(styles.marginTop, 10);
      var marginLeft = _parseFloat$2(styles.marginLeft, 10);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }
  function getFixedPositionOffsetParent(element) {
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      var boundariesNode;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    if (placement.indexOf('auto') === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = keys$1(rects).map(function (key) {
      return _extends$1({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? "-".concat(variation) : '');
  }
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = _parseFloat$2(styles.marginTop || 0) + _parseFloat$2(styles.marginBottom || 0);
    var y = _parseFloat$2(styles.marginLeft || 0) + _parseFloat$2(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];
    var popperRect = getOuterSizes(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
    return popperOffsets;
  }
  function find(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex(arr, prop, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }
    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function _update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
    data = runModifiers(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref3) {
      var name = _ref3.name,
          enabled = _ref3.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var _i = 0; _i < prefixes.length; _i++) {
      var prefix = prefixes[_i];
      var toCheck = prefix ? "".concat(prefix).concat(upperProp) : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }
  function _destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    });
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function _enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners(reference, state) {
    getWindow(reference).removeEventListener('resize', state.updateBound);
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function _disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  function isNumeric(n) {
    return n !== '' && !isNaN(_parseFloat$2(n)) && isFinite(n);
  }
  function setStyles(element, styles) {
    keys$1(styles).forEach(function (prop) {
      var unit = '';
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }
  function setAttributes(element, attributes) {
    keys$1(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  function applyStyle(data) {
    setStyles(data.instance.popper, data.styles);
    setAttributes(data.instance.popper, data.attributes);
    if (data.arrowElement && keys$1(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement);
    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;
    var noRound = function noRound(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';
    var prefixedProperty = getSupportedPropertyName('transform');
    var left, top;
    if (sideA === 'bottom') {
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = "translate3d(".concat(left, "px, ").concat(top, "px, 0)");
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = "".concat(sideA, ", ").concat(sideB);
    }
    var attributes = {
      'x-placement': data.placement
    };
    data.attributes = _extends$1({}, attributes, data.attributes);
    data.styles = _extends$1({}, styles, data.styles);
    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref4) {
      var name = _ref4.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = "`".concat(requestingName, "`");
      var requested = "`".concat(requestedName, "`");
      console.warn("".concat(requested, " modifier is required by ").concat(_requesting, " modifier in order to work, be sure to include it before ").concat(_requesting, "!"));
    }
    return isRequired;
  }
  function arrow(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }
    var placement = data.placement.split('-')[0];
    var _data$offsets2 = data.offsets,
        popper = _data$offsets2.popper,
        reference = _data$offsets2.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = _parseFloat$2(css["margin".concat(sideCapitalized)], 10);
    var popperBorderSide = _parseFloat$2(css["border".concat(sideCapitalized, "Width")], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
  var validPlacements = placements.slice(3);
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  function flip(data, options) {
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? '-' + variation : '');
        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  function keepTogether(data) {
    var _data$offsets3 = data.offsets,
        popper = _data$offsets3.popper,
        reference = _data$offsets3.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf('%') === 0) {
      var element;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      var size;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function (op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset(data, _ref5) {
    var offset = _ref5.offset;
    var placement = data.placement,
        _data$offsets4 = data.offsets,
        popper = _data$offsets4.popper,
        reference = _data$offsets4.reference;
    var basePlacement = placement.split('-')[0];
    var offsets;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }
    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style;
    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return _defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return _defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends$1({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];
    if (shiftvariation) {
      var _data$offsets5 = data.offsets,
          reference = _data$offsets5.reference,
          popper = _data$offsets5.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: _defineProperty({}, side, reference[side]),
        end: _defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }
    return data;
  }
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets6 = data.offsets,
        popper = _data$offsets6.popper,
        reference = _data$offsets6.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  var modifiers = {
    shift: {
      order: 100,
      enabled: true,
      fn: shift
    },
    offset: {
      order: 200,
      enabled: true,
      fn: offset,
      offset: 0
    },
    preventOverflow: {
      order: 300,
      enabled: true,
      fn: preventOverflow,
      priority: ['left', 'right', 'top', 'bottom'],
      padding: 5,
      boundariesElement: 'scrollParent'
    },
    keepTogether: {
      order: 400,
      enabled: true,
      fn: keepTogether
    },
    arrow: {
      order: 500,
      enabled: true,
      fn: arrow,
      element: '[x-arrow]'
    },
    flip: {
      order: 600,
      enabled: true,
      fn: flip,
      behavior: 'flip',
      padding: 5,
      boundariesElement: 'viewport',
      flipVariations: false,
      flipVariationsByContent: false
    },
    inner: {
      order: 700,
      enabled: false,
      fn: inner
    },
    hide: {
      order: 800,
      enabled: true,
      fn: hide
    },
    computeStyle: {
      order: 850,
      enabled: true,
      fn: computeStyle,
      gpuAcceleration: true,
      x: 'bottom',
      y: 'right'
    },
    applyStyle: {
      order: 900,
      enabled: true,
      fn: applyStyle,
      onLoad: applyStyleOnLoad,
      gpuAcceleration: undefined
    }
  };
  var Defaults = {
    placement: 'bottom',
    positionFixed: false,
    eventsEnabled: true,
    removeOnDestroy: false,
    onCreate: function onCreate() {},
    onUpdate: function onUpdate() {},
    modifiers: modifiers
  };
  var Popper = function () {
    function Popper(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      _classCallCheck(this, Popper);
      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce(this.update.bind(this));
      this.options = _extends$1({}, Popper.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      keys$1(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = keys$1(this.options.modifiers).map(function (name) {
        return _extends$1({
          name: name
        }, _this.options.modifiers[name]);
      })
      .sort(function (a, b) {
        return a.order - b.order;
      });
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    _createClass(Popper, [{
      key: "update",
      value: function update() {
        return _update.call(this);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        return _destroy.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function enableEventListeners() {
        return _enableEventListeners.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function disableEventListeners() {
        return _disableEventListeners.call(this);
      }
    }]);
    return Popper;
  }();
  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  function _extends$2() {
    _extends$2 = assign$1 || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  var version = "4.3.4";
  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
  var ua = isBrowser$1 ? navigator.userAgent : '';
  var isIE$1 = /MSIE |Trident\//.test(ua);
  var isUCBrowser = /UCBrowser\//.test(ua);
  var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
  var defaultProps = {
    a11y: true,
    allowHTML: true,
    animateFill: true,
    animation: 'shift-away',
    appendTo: function appendTo() {
      return document.body;
    },
    aria: 'describedby',
    arrow: false,
    arrowType: 'sharp',
    boundary: 'scrollParent',
    content: '',
    delay: 0,
    distance: 10,
    duration: [325, 275],
    flip: true,
    flipBehavior: 'flip',
    flipOnUpdate: false,
    followCursor: false,
    hideOnClick: true,
    ignoreAttributes: false,
    inertia: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    lazy: true,
    width: 'auto',
    maxWidth: 'auto',
    multiple: false,
    offset: 0,
    onHidden: function onHidden() {},
    onHide: function onHide() {},
    onMount: function onMount() {},
    onShow: function onShow() {},
    onShown: function onShown() {},
    onTrigger: function onTrigger() {},
    placement: 'top',
    popperOptions: {},
    role: 'tooltip',
    showOnInit: false,
    size: 'regular',
    sticky: false,
    target: '',
    theme: 'dark',
    touch: true,
    touchHold: false,
    trigger: 'mouseenter focus',
    triggerTarget: null,
    updateDuration: 0,
    wait: null,
    zIndex: 9999,
    extCls: ''
  };
  var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
  var elementProto = isBrowser$1 ? Element.prototype : {};
  var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
  function arrayFrom(value) {
    return [].slice.call(value);
  }
  function closest(element, selector) {
    return closestCallback(element, function (el) {
      return matches.call(el, selector);
    });
  }
  function closestCallback(element, callback) {
    while (element) {
      if (callback(element)) {
        return element;
      }
      element = element.parentElement;
    }
    return null;
  }
  var PASSIVE = {
    passive: true
  };
  var PADDING = 4;
  var PLACEMENT_ATTRIBUTE = 'x-placement';
  var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries';
  var IOS_CLASS = "tippy-iOS";
  var ACTIVE_CLASS = "tippy-active";
  var POPPER_CLASS = "tippy-popper";
  var TOOLTIP_CLASS = "tippy-tooltip";
  var CONTENT_CLASS = "tippy-content";
  var BACKDROP_CLASS = "tippy-backdrop";
  var ARROW_CLASS = "tippy-arrow";
  var ROUND_ARROW_CLASS = "tippy-roundarrow";
  var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
  var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
  var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
  var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
  var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
  var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
  var isUsingTouch = false;
  function onDocumentTouch() {
    if (isUsingTouch) {
      return;
    }
    isUsingTouch = true;
    if (isIOS) {
      document.body.classList.add(IOS_CLASS);
    }
    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove);
    }
  }
  var lastMouseMoveTime = 0;
  function onDocumentMouseMove() {
    var now = performance.now();
    if (now - lastMouseMoveTime < 20) {
      isUsingTouch = false;
      document.removeEventListener('mousemove', onDocumentMouseMove);
      if (!isIOS) {
        document.body.classList.remove(IOS_CLASS);
      }
    }
    lastMouseMoveTime = now;
  }
  function onWindowBlur() {
    var _document = document,
        activeElement = _document.activeElement;
    if (activeElement && activeElement.blur && activeElement._tippy) {
      activeElement.blur();
    }
  }
  function bindGlobalEventListeners() {
    document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
    window.addEventListener('blur', onWindowBlur);
  }
  var keys$2 = keys$1(defaultProps);
  function getDataAttributeOptions(reference) {
    return keys$2.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();
      if (!valueAsString) {
        return acc;
      }
      if (key === 'content') {
        acc[key] = valueAsString;
      } else {
        try {
          acc[key] = JSON.parse(valueAsString);
        } catch (e) {
          acc[key] = valueAsString;
        }
      }
      return acc;
    }, {});
  }
  function polyfillElementPrototypeProperties(virtualReference) {
    var polyfills = {
      isVirtual: true,
      attributes: virtualReference.attributes || {},
      contains: function contains() {},
      setAttribute: function setAttribute(key, value) {
        virtualReference.attributes[key] = value;
      },
      getAttribute: function getAttribute(key) {
        return virtualReference.attributes[key];
      },
      removeAttribute: function removeAttribute(key) {
        delete virtualReference.attributes[key];
      },
      hasAttribute: function hasAttribute(key) {
        return key in virtualReference.attributes;
      },
      addEventListener: function addEventListener() {},
      removeEventListener: function removeEventListener() {},
      classList: {
        classNames: {},
        add: function add(key) {
          virtualReference.classList.classNames[key] = true;
        },
        remove: function remove(key) {
          delete virtualReference.classList.classNames[key];
        },
        contains: function contains(key) {
          return key in virtualReference.classList.classNames;
        }
      }
    };
    for (var key in polyfills) {
      virtualReference[key] = polyfills[key];
    }
  }
  function isBareVirtualElement(value) {
    return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
  }
  function isReferenceElement(value) {
    return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
  }
  function hasOwnProperty$1(obj, key) {
    return {}.hasOwnProperty.call(obj, key);
  }
  function getArrayOfElements(value) {
    if (isSingular(value)) {
      return [value];
    }
    if (value instanceof NodeList) {
      return arrayFrom(value);
    }
    if (isArray$1(value)) {
      return value;
    }
    try {
      return arrayFrom(document.querySelectorAll(value));
    } catch (e) {
      return [];
    }
  }
  function getValue(value, index, defaultValue) {
    if (isArray$1(value)) {
      var v = value[index];
      return v == null ? defaultValue : v;
    }
    return value;
  }
  function debounce$1(fn, ms) {
    if (ms === 0) {
      return fn;
    }
    var timeout;
    return function (arg) {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        fn(arg);
      }, ms);
    };
  }
  function getModifier(obj, key) {
    return obj && obj.modifiers && obj.modifiers[key];
  }
  function includes(a, b) {
    return a.indexOf(b) > -1;
  }
  function isRealElement(value) {
    return value instanceof Element;
  }
  function isSingular(value) {
    return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);
  }
  function innerHTML() {
    return 'innerHTML';
  }
  function invokeWithArgsOrReturn(value, args) {
    return typeof value === 'function' ? value.apply(null, args) : value;
  }
  function setFlipModifierEnabled(modifiers, value) {
    modifiers.filter(function (m) {
      return m.name === 'flip';
    })[0].enabled = value;
  }
  function canReceiveFocus(element) {
    return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
  }
  function div() {
    return document.createElement('div');
  }
  function setTransitionDuration(els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = "".concat(value, "ms");
      }
    });
  }
  function setVisibilityState(els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state);
      }
    });
  }
  function evaluateProps(reference, props) {
    var out = _extends$2({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
    if (out.arrow || isUCBrowser) {
      out.animateFill = false;
    }
    return out;
  }
  function validateOptions(options, defaultProps) {
    keys$1(options).forEach(function (option) {
      if (!hasOwnProperty$1(defaultProps, option)) {
        throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
      }
    });
  }
  function setInnerHTML(element, html) {
    element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
  }
  function setContent(contentEl, props) {
    if (isRealElement(props.content)) {
      setInnerHTML(contentEl, '');
      contentEl.appendChild(props.content);
    } else if (typeof props.content !== 'function') {
      var key = props.allowHTML ? 'innerHTML' : 'textContent';
      contentEl[key] = props.content;
    }
  }
  function getChildren(popper) {
    return {
      tooltip: popper.querySelector(TOOLTIP_SELECTOR),
      backdrop: popper.querySelector(BACKDROP_SELECTOR),
      content: popper.querySelector(CONTENT_SELECTOR),
      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
    };
  }
  function addInertia(tooltip) {
    tooltip.setAttribute('data-inertia', '');
  }
  function removeInertia(tooltip) {
    tooltip.removeAttribute('data-inertia');
  }
  function createArrowElement(arrowType) {
    var arrow = div();
    if (arrowType === 'round') {
      arrow.className = ROUND_ARROW_CLASS;
      setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
    } else {
      arrow.className = ARROW_CLASS;
    }
    return arrow;
  }
  function createBackdropElement() {
    var backdrop = div();
    backdrop.className = BACKDROP_CLASS;
    backdrop.setAttribute('data-state', 'hidden');
    return backdrop;
  }
  function addInteractive(popper, tooltip) {
    popper.setAttribute('tabindex', '-1');
    tooltip.setAttribute('data-interactive', '');
  }
  function removeInteractive(popper, tooltip) {
    popper.removeAttribute('tabindex');
    tooltip.removeAttribute('data-interactive');
  }
  function updateTransitionEndListener(tooltip, action, listener) {
    var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
    tooltip[action + 'EventListener'](eventName, listener);
  }
  function getBasicPlacement(popper) {
    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
    return fullPlacement ? fullPlacement.split('-')[0] : '';
  }
  function reflow(popper) {
    void popper.offsetHeight;
  }
  function updateTheme(tooltip, action, theme) {
    theme.split(' ').forEach(function (themeName) {
      tooltip.classList[action](themeName + '-theme');
    });
  }
  function setWidth(tooltip, props, key) {
    var width = props[key];
    var parsedWidth = _parseInt$2(width);
    if (typeof width === 'number') {
      tooltip.style[key] = width + 'px';
    } else if (isNaN(parsedWidth)) {
      tooltip.style[key] = width;
    } else {
      tooltip.style[key] = parsedWidth + 'px';
    }
  }
  function createPopperElement(id, props) {
    var popper = div();
    popper.className = POPPER_CLASS + (props.extCls ? " ".concat(props.extCls) : '');
    popper.id = "tippy-".concat(id);
    popper.style.zIndex = '' + props.zIndex;
    popper.style.position = 'absolute';
    popper.style.top = '0';
    popper.style.left = '0';
    if (props.role) {
      popper.setAttribute('role', props.role);
    }
    var tooltip = div();
    tooltip.className = TOOLTIP_CLASS;
    setWidth(tooltip, props, 'maxWidth');
    setWidth(tooltip, props, 'width');
    tooltip.setAttribute('data-size', props.size);
    tooltip.setAttribute('data-animation', props.animation);
    tooltip.setAttribute('data-state', 'hidden');
    updateTheme(tooltip, 'add', props.theme);
    var content = div();
    content.className = CONTENT_CLASS;
    content.setAttribute('data-state', 'hidden');
    if (props.interactive) {
      addInteractive(popper, tooltip);
    }
    if (props.arrow) {
      tooltip.appendChild(createArrowElement(props.arrowType));
    }
    if (props.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    }
    if (props.inertia) {
      addInertia(tooltip);
    }
    setContent(content, props);
    tooltip.appendChild(content);
    popper.appendChild(tooltip);
    return popper;
  }
  function updatePopperElement(popper, prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        tooltip = _getChildren.tooltip,
        content = _getChildren.content,
        backdrop = _getChildren.backdrop,
        arrow = _getChildren.arrow;
    popper.style.zIndex = '' + nextProps.zIndex;
    tooltip.setAttribute('data-size', nextProps.size);
    tooltip.setAttribute('data-animation', nextProps.animation);
    tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');
    if (nextProps.role) {
      popper.setAttribute('role', nextProps.role);
    } else {
      popper.removeAttribute('role');
    }
    if (prevProps.content !== nextProps.content) {
      setContent(content, nextProps);
    }
    if (!prevProps.animateFill && nextProps.animateFill) {
      tooltip.appendChild(createBackdropElement());
      tooltip.setAttribute('data-animatefill', '');
    } else if (prevProps.animateFill && !nextProps.animateFill) {
      tooltip.removeChild(backdrop);
      tooltip.removeAttribute('data-animatefill');
    }
    if (!prevProps.arrow && nextProps.arrow) {
      tooltip.appendChild(createArrowElement(nextProps.arrowType));
    } else if (prevProps.arrow && !nextProps.arrow) {
      tooltip.removeChild(arrow);
    }
    if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
      tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
    }
    if (!prevProps.interactive && nextProps.interactive) {
      addInteractive(popper, tooltip);
    } else if (prevProps.interactive && !nextProps.interactive) {
      removeInteractive(popper, tooltip);
    }
    if (!prevProps.inertia && nextProps.inertia) {
      addInertia(tooltip);
    } else if (prevProps.inertia && !nextProps.inertia) {
      removeInertia(tooltip);
    }
    if (prevProps.theme !== nextProps.theme) {
      updateTheme(tooltip, 'remove', prevProps.theme);
      updateTheme(tooltip, 'add', nextProps.theme);
    }
  }
  function hideAll() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        excludedReferenceOrInstance = _ref.exclude,
        duration = _ref.duration;
    arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
      var instance = popper._tippy;
      if (instance) {
        var isExcluded = false;
        if (excludedReferenceOrInstance) {
          isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
        }
        if (!isExcluded) {
          instance.hide(duration);
        }
      }
    });
  }
  function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
    if (!popperPlacement) {
      return true;
    }
    var x = event.clientX,
        y = event.clientY;
    var interactiveBorder = props.interactiveBorder,
        distance = props.distance;
    var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
    var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
    var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
    var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  }
  function getOffsetDistanceInPx(distance) {
    return -(distance - 10) + 'px';
  }
  var idCounter = 1;
  var mouseMoveListeners = [];
  function createTippy(reference, collectionProps) {
    var props = evaluateProps(reference, collectionProps);
    if (!props.multiple && reference._tippy) {
      return null;
    }
    var lastTriggerEventType;
    var lastMouseMoveEvent;
    var showTimeoutId;
    var hideTimeoutId;
    var scheduleHideAnimationFrameId;
    var isScheduledToShow = false;
    var isBeingDestroyed = false;
    var previousPlacement;
    var wasVisibleDuringPreviousUpdate = false;
    var hasMountCallbackRun = false;
    var currentMountCallback;
    var currentTransitionEndListener;
    var listeners = [];
    var currentComputedPadding;
    var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
    var id = idCounter++;
    var popper = createPopperElement(id, props);
    var popperChildren = getChildren(popper);
    var popperInstance = null;
    var state = {
      isEnabled: true,
      isVisible: false,
      isDestroyed: false,
      isMounted: false,
      isShown: false
    };
    var instance = {
      id: id,
      reference: reference,
      popper: popper,
      popperChildren: popperChildren,
      popperInstance: popperInstance,
      props: props,
      state: state,
      clearDelayTimeouts: clearDelayTimeouts,
      set: set,
      setContent: setContent,
      show: show,
      hide: hide,
      enable: enable,
      disable: disable,
      destroy: destroy
    };
    reference._tippy = instance;
    popper._tippy = instance;
    addTriggersToReference();
    if (!props.lazy) {
      createPopperInstance();
    }
    if (props.showOnInit) {
      scheduleShow();
    }
    if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
      getEventListenersTarget().setAttribute('tabindex', '0');
    }
    popper.addEventListener('mouseenter', function (event) {
      if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
        scheduleShow(event, true);
      }
    });
    popper.addEventListener('mouseleave', function () {
      if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
        document.addEventListener('mousemove', debouncedOnMouseMove);
      }
    });
    return instance;
    function removeFollowCursorListener() {
      document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
    }
    function cleanupInteractiveMouseListeners() {
      document.body.removeEventListener('mouseleave', scheduleHide);
      document.removeEventListener('mousemove', debouncedOnMouseMove);
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove;
      });
    }
    function getEventListenersTarget() {
      return instance.props.triggerTarget || reference;
    }
    function addDocumentClickListener() {
      document.addEventListener('click', onDocumentClick, true);
    }
    function removeDocumentClickListener() {
      document.removeEventListener('click', onDocumentClick, true);
    }
    function getTransitionableElements() {
      return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
    }
    function getIsInLooseFollowCursorMode() {
      var followCursor = instance.props.followCursor;
      return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
    }
    function makeSticky() {
      setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);
      function updatePosition() {
        instance.popperInstance.scheduleUpdate();
        if (instance.state.isMounted) {
          requestAnimationFrame(updatePosition);
        } else {
          setTransitionDuration([popper], 0);
        }
      }
      updatePosition();
    }
    function onTransitionedOut(duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback();
        }
      });
    }
    function onTransitionedIn(duration, callback) {
      onTransitionEnd(duration, callback);
    }
    function onTransitionEnd(duration, callback) {
      var tooltip = instance.popperChildren.tooltip;
      function listener(event) {
        if (event.target === tooltip) {
          updateTransitionEndListener(tooltip, 'remove', listener);
          callback();
        }
      }
      if (duration === 0) {
        return callback();
      }
      updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
      updateTransitionEndListener(tooltip, 'add', listener);
      currentTransitionEndListener = listener;
    }
    function on(eventType, handler) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      getEventListenersTarget().addEventListener(eventType, handler, options);
      listeners.push({
        eventType: eventType,
        handler: handler,
        options: options
      });
    }
    function addTriggersToReference() {
      if (instance.props.touchHold && !instance.props.target) {
        on('touchstart', onTrigger, PASSIVE);
        on('touchend', onMouseLeave, PASSIVE);
      }
      instance.props.trigger.trim().split(' ').forEach(function (eventType) {
        if (eventType === 'manual') {
          return;
        }
        if (!instance.props.target) {
          on(eventType, onTrigger);
          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;
            case 'focus':
              on(isIE$1 ? 'focusout' : 'blur', onBlur);
              break;
          }
        } else {
          switch (eventType) {
            case 'mouseenter':
              on('mouseover', onDelegateShow);
              on('mouseout', onDelegateHide);
              break;
            case 'focus':
              on('focusin', onDelegateShow);
              on('focusout', onDelegateHide);
              break;
            case 'click':
              on(eventType, onDelegateShow);
              break;
          }
        }
      });
    }
    function removeTriggersFromReference() {
      listeners.forEach(function (_ref) {
        var eventType = _ref.eventType,
            handler = _ref.handler,
            options = _ref.options;
        getEventListenersTarget().removeEventListener(eventType, handler, options);
      });
      listeners = [];
    }
    function positionVirtualReferenceNearCursor(event) {
      var _lastMouseMoveEvent = lastMouseMoveEvent = event,
          x = _lastMouseMoveEvent.clientX,
          y = _lastMouseMoveEvent.clientY;
      if (!currentComputedPadding) {
        return;
      }
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      var rect = reference.getBoundingClientRect();
      var followCursor = instance.props.followCursor;
      var isHorizontal = followCursor === 'horizontal';
      var isVertical = followCursor === 'vertical';
      var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
      var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
      var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
      var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
      var halfSize = size / 2;
      var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
      var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
      if (isCursorOverReference || !instance.props.interactive) {
        instance.popperInstance.reference = _extends$2({}, instance.popperInstance.reference, {
          clientWidth: 0,
          clientHeight: 0,
          getBoundingClientRect: function getBoundingClientRect() {
            return {
              width: isVerticalPlacement ? size : 0,
              height: isVerticalPlacement ? 0 : size,
              top: (isHorizontal ? rect.top : y) - verticalIncrease,
              bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
              left: (isVertical ? rect.left : x) - horizontalIncrease,
              right: (isVertical ? rect.right : x) + horizontalIncrease
            };
          }
        });
        instance.popperInstance.update();
      }
      if (followCursor === 'initial' && instance.state.isVisible) {
        removeFollowCursorListener();
      }
    }
    function createDelegateChildTippy(event) {
      if (event) {
        var targetEl = closest(event.target, instance.props.target);
        if (targetEl && !targetEl._tippy) {
          createTippy(targetEl, _extends$2({}, instance.props, {
            content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
            appendTo: collectionProps.appendTo,
            target: '',
            showOnInit: true
          }));
        }
      }
    }
    function onTrigger(event) {
      if (!instance.state.isEnabled || isEventListenerStopped(event)) {
        return;
      }
      if (!instance.state.isVisible) {
        lastTriggerEventType = event.type;
        if (event instanceof MouseEvent) {
          lastMouseMoveEvent = event;
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        }
      }
      if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
        scheduleHide();
      } else {
        scheduleShow(event);
      }
    }
    function onMouseMove(event) {
      var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
      var isCursorOverReference = closestCallback(event.target, function (el) {
        return el === reference;
      });
      if (isCursorOverPopper || isCursorOverReference) {
        return;
      }
      if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
        cleanupInteractiveMouseListeners();
        scheduleHide();
      }
    }
    function onMouseLeave(event) {
      if (isEventListenerStopped(event)) {
        return;
      }
      if (instance.props.interactive) {
        document.body.addEventListener('mouseleave', scheduleHide);
        document.addEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners.push(debouncedOnMouseMove);
        return;
      }
      scheduleHide();
    }
    function onBlur(event) {
      if (event.target !== getEventListenersTarget()) {
        return;
      }
      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return;
      }
      scheduleHide();
    }
    function onDelegateShow(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleShow(event);
      }
    }
    function onDelegateHide(event) {
      if (closest(event.target, instance.props.target)) {
        scheduleHide();
      }
    }
    function isEventListenerStopped(event) {
      var supportsTouch = ('ontouchstart' in window);
      var isTouchEvent = includes(event.type, 'touch');
      var touchHold = instance.props.touchHold;
      return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
    }
    function runMountCallback() {
      if (!hasMountCallbackRun && currentMountCallback) {
        hasMountCallbackRun = true;
        reflow(popper);
        currentMountCallback();
      }
    }
    function createPopperInstance() {
      var popperOptions = instance.props.popperOptions;
      var _instance$popperChild = instance.popperChildren,
          tooltip = _instance$popperChild.tooltip,
          arrow = _instance$popperChild.arrow;
      var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
      function applyMutations(data) {
        if (instance.props.flip && !instance.props.flipOnUpdate) {
          if (data.flipped) {
            instance.popperInstance.options.placement = data.placement;
          }
          setFlipModifierEnabled(instance.popperInstance.modifiers, false);
        }
        tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);
        if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
          tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
        } else {
          tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
        }
        if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
          tooltip.style.transition = 'none';
          requestAnimationFrame(function () {
            tooltip.style.transition = '';
          });
        }
        previousPlacement = data.placement;
        wasVisibleDuringPreviousUpdate = instance.state.isVisible;
        var basicPlacement = getBasicPlacement(popper);
        var styles = tooltip.style;
        styles.top = styles.bottom = styles.left = styles.right = '';
        styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
        var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
        var isPaddingNumber = typeof padding === 'number';
        var computedPadding = _extends$2({
          top: isPaddingNumber ? padding : padding.top,
          bottom: isPaddingNumber ? padding : padding.bottom,
          left: isPaddingNumber ? padding : padding.left,
          right: isPaddingNumber ? padding : padding.right
        }, !isPaddingNumber && padding);
        computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
        instance.popperInstance.modifiers.filter(function (m) {
          return m.name === 'preventOverflow';
        })[0].padding = computedPadding;
        currentComputedPadding = computedPadding;
      }
      var config = _extends$2({
        eventsEnabled: false,
        placement: instance.props.placement
      }, popperOptions, {
        modifiers: _extends$2({}, popperOptions ? popperOptions.modifiers : {}, {
          preventOverflow: _extends$2({
            boundariesElement: instance.props.boundary,
            padding: PADDING
          }, preventOverflowModifier),
          arrow: _extends$2({
            element: arrow,
            enabled: !!arrow
          }, getModifier(popperOptions, 'arrow')),
          flip: _extends$2({
            enabled: instance.props.flip,
            padding: instance.props.distance + PADDING,
            behavior: instance.props.flipBehavior
          }, getModifier(popperOptions, 'flip')),
          offset: _extends$2({
            offset: instance.props.offset
          }, getModifier(popperOptions, 'offset'))
        }),
        onCreate: function onCreate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onCreate) {
            popperOptions.onCreate(data);
          }
        },
        onUpdate: function onUpdate(data) {
          applyMutations(data);
          runMountCallback();
          if (popperOptions && popperOptions.onUpdate) {
            popperOptions.onUpdate(data);
          }
        }
      });
      instance.popperInstance = new Popper(reference, popper, config);
    }
    function mount() {
      hasMountCallbackRun = false;
      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
      if (instance.popperInstance) {
        setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.reference = reference;
          instance.popperInstance.enableEventListeners();
        }
        instance.popperInstance.scheduleUpdate();
      } else {
        createPopperInstance();
        if (!isInLooseFollowCursorMode) {
          instance.popperInstance.enableEventListeners();
        }
      }
      var appendTo = instance.props.appendTo;
      var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);
      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper);
        instance.props.onMount(instance);
        instance.state.isMounted = true;
      }
    }
    function scheduleShow(event, shouldAvoidCallingOnTrigger) {
      clearDelayTimeouts();
      if (instance.state.isVisible) {
        return;
      }
      if (instance.props.target) {
        return createDelegateChildTippy(event);
      }
      isScheduledToShow = true;
      if (event && !shouldAvoidCallingOnTrigger) {
        instance.props.onTrigger(instance, event);
      }
      if (instance.props.wait) {
        return instance.props.wait(instance, event);
      }
      if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
        if (!instance.popperInstance) {
          createPopperInstance();
        }
        document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
      }
      addDocumentClickListener();
      var delay = getValue(instance.props.delay, 0, defaultProps.delay);
      if (delay) {
        showTimeoutId = setTimeout(function () {
          show();
        }, delay);
      } else {
        show();
      }
    }
    function scheduleHide() {
      clearDelayTimeouts();
      if (!instance.state.isVisible) {
        return removeFollowCursorListener();
      }
      isScheduledToShow = false;
      var delay = getValue(instance.props.delay, 1, defaultProps.delay);
      if (delay) {
        hideTimeoutId = setTimeout(function () {
          if (instance.state.isVisible) {
            hide();
          }
        }, delay);
      } else {
        scheduleHideAnimationFrameId = requestAnimationFrame(function () {
          hide();
        });
      }
    }
    function onDocumentClick(event) {
      if (instance.props.interactive && popper.contains(event.target)) {
        return;
      }
      if (getEventListenersTarget().contains(event.target)) {
        if (isUsingTouch) {
          return;
        }
        if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
          return;
        }
      }
      if (instance.props.hideOnClick === true) {
        clearDelayTimeouts();
        hide();
      }
    }
    function enable() {
      instance.state.isEnabled = true;
    }
    function disable() {
      instance.state.isEnabled = false;
    }
    function clearDelayTimeouts() {
      clearTimeout(showTimeoutId);
      clearTimeout(hideTimeoutId);
      cancelAnimationFrame(scheduleHideAnimationFrameId);
    }
    function set(options) {
      options = options || {};
      validateOptions(options, defaultProps);
      removeTriggersFromReference();
      var prevProps = instance.props;
      var nextProps = evaluateProps(reference, _extends$2({}, instance.props, options, {
        ignoreAttributes: true
      }));
      nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
      instance.props = nextProps;
      addTriggersToReference();
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
      updatePopperElement(popper, prevProps, nextProps);
      instance.popperChildren = getChildren(popper);
      if (instance.popperInstance) {
        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
          return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];
        })) {
          instance.popperInstance.destroy();
          createPopperInstance();
          if (instance.state.isVisible) {
            instance.popperInstance.enableEventListeners();
          }
          if (instance.props.followCursor && lastMouseMoveEvent) {
            positionVirtualReferenceNearCursor(lastMouseMoveEvent);
          }
        } else {
          instance.popperInstance.update();
        }
      }
    }
    function setContent(content) {
      set({
        content: content
      });
    }
    function show() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
        return;
      }
      if (getEventListenersTarget().hasAttribute('disabled')) {
        return;
      }
      if (instance.props.onShow(instance) === false) {
        return;
      }
      addDocumentClickListener();
      popper.style.visibility = 'visible';
      instance.state.isVisible = true;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.add(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements.concat(popper), 0);
      currentMountCallback = function currentMountCallback() {
        if (!instance.state.isVisible) {
          return;
        }
        var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
        if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
        } else if (!isInLooseFollowCursorMode) {
          instance.popperInstance.update();
        }
        if (instance.popperChildren.backdrop) {
          instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
        }
        if (instance.props.sticky) {
          makeSticky();
        }
        setTransitionDuration([popper], instance.props.updateDuration);
        setTransitionDuration(transitionableElements, duration);
        setVisibilityState(transitionableElements, 'visible');
        onTransitionedIn(duration, function () {
          if (instance.props.aria) {
            getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
          }
          instance.props.onShown(instance);
          instance.state.isShown = true;
        });
      };
      mount();
    }
    function hide() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
      if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
        return;
      }
      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
        return;
      }
      removeDocumentClickListener();
      popper.style.visibility = 'hidden';
      instance.state.isVisible = false;
      instance.state.isShown = false;
      wasVisibleDuringPreviousUpdate = false;
      if (instance.props.interactive) {
        getEventListenersTarget().classList.remove(ACTIVE_CLASS);
      }
      var transitionableElements = getTransitionableElements();
      setTransitionDuration(transitionableElements, duration);
      setVisibilityState(transitionableElements, 'hidden');
      onTransitionedOut(duration, function () {
        if (!isScheduledToShow) {
          removeFollowCursorListener();
        }
        if (instance.props.aria) {
          getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
        }
        instance.popperInstance.disableEventListeners();
        instance.popperInstance.options.placement = instance.props.placement;
        popper.parentNode.removeChild(popper);
        instance.props.onHidden(instance);
        instance.state.isMounted = false;
      });
    }
    function destroy(destroyTargetInstances) {
      if (instance.state.isDestroyed) {
        return;
      }
      isBeingDestroyed = true;
      if (instance.state.isMounted) {
        hide(0);
      }
      removeTriggersFromReference();
      delete reference._tippy;
      var target = instance.props.target;
      if (target && destroyTargetInstances && isRealElement(reference)) {
        arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
          if (child._tippy) {
            child._tippy.destroy();
          }
        });
      }
      if (instance.popperInstance) {
        instance.popperInstance.destroy();
      }
      isBeingDestroyed = false;
      instance.state.isDestroyed = true;
    }
  }
  function group(instances) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$delay = _ref.delay,
        delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === void 0 ? 0 : _ref$duration;
    var isAnyTippyOpen = false;
    instances.forEach(function (instance) {
      if (instance._originalProps) {
        instance.set(instance._originalProps);
      } else {
        instance._originalProps = _extends$2({}, instance.props);
      }
    });
    function setIsAnyTippyOpen(value) {
      isAnyTippyOpen = value;
      updateInstances();
    }
    function onShow(instance) {
      instance._originalProps.onShow(instance);
      instances.forEach(function (instance) {
        instance.set({
          duration: duration
        });
        if (instance.state.isVisible) {
          instance.hide();
        }
      });
      setIsAnyTippyOpen(true);
    }
    function onHide(instance) {
      instance._originalProps.onHide(instance);
      setIsAnyTippyOpen(false);
    }
    function onShown(instance) {
      instance._originalProps.onShown(instance);
      instance.set({
        duration: instance._originalProps.duration
      });
    }
    function updateInstances() {
      instances.forEach(function (instance) {
        instance.set({
          onShow: onShow,
          onShown: onShown,
          onHide: onHide,
          delay: isAnyTippyOpen ? [0, isArray$1(delay) ? delay[1] : delay] : delay,
          duration: isAnyTippyOpen ? duration : instance._originalProps.duration
        });
      });
    }
    updateInstances();
  }
  var globalEventListenersBound = false;
  function tippy(targets, options) {
    validateOptions(options || {}, defaultProps);
    if (!globalEventListenersBound) {
      bindGlobalEventListeners();
      globalEventListenersBound = true;
    }
    var props = _extends$2({}, defaultProps, options);
    if (isBareVirtualElement(targets)) {
      polyfillElementPrototypeProperties(targets);
    }
    var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, props);
      if (instance) {
        acc.push(instance);
      }
      return acc;
    }, []);
    return isSingular(targets) ? instances[0] : instances;
  }
  tippy.version = version;
  tippy.defaults = defaultProps;
  tippy.setDefaults = function (partialDefaults) {
    keys$1(partialDefaults).forEach(function (key) {
      defaultProps[key] = partialDefaults[key];
    });
  };
  tippy.hideAll = hideAll;
  tippy.group = group;
  function autoInit() {
    arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
      var content = el.getAttribute('data-tippy');
      if (content) {
        tippy(el, {
          content: content
        });
      }
    });
  }
  if (isBrowser$1) {
    setTimeout(autoInit);
  }

  function beforeShow(instance) {
    var reference = instance.reference;
    var props = reference._bk_overflow_tips_.props;
    var isOverflow = checkOverflow(reference);
    if (isOverflow) {
      instance.setContent(props.content ? props.content : props.allowHTML ? reference.innerHTML : reference.textContent);
      return true;
    }
    return false;
  }
  function setupOnShow(props, customProps) {
    props.onShow = function (instance) {
      if (typeof customProps.onShow === 'function') {
        var result = customProps.onShow(instance);
        if (!result) return false;
      }
      return beforeShow(instance);
    };
  }
  function setupTheme(props, customProps) {
    var theme = ['bk-overflow-tips'];
    if (customProps.theme) {
      theme.push(customProps.theme);
    }
    props.theme = theme.join(' ');
  }
  var defaultProps$1 = {
    arrow: true,
    interactive: true,
    delay: 150,
    allowHTML: false,
    maxWidth: 400,
    boundary: 'window',
    placement: 'top'
  };
  var overflowTips = {
    inserted: function inserted(el) {
      var binding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
      var props = _extends(_objectSpread({}, defaultProps$1), customProps);
      setupOnShow(props, customProps);
      setupTheme(props, customProps);
      el._bk_overflow_tips_ = {
        props: props,
        instance: tippy(el, props)
      };
    },
    update: function update(el, binding) {
      var _el$_bk_overflow_tips = el._bk_overflow_tips_,
          props = _el$_bk_overflow_tips.props,
          instance = _el$_bk_overflow_tips.instance;
      var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
      _extends(props, customProps);
      setupOnShow(props, customProps);
      instance.set(props);
    },
    unbind: function unbind(el) {
      el._tippy && el._tippy.destroy();
      delete el._bk_overflow_tips_;
    },
    setDefaultProps: function setDefaultProps(props) {
      _extends(defaultProps$1, props);
    }
  };
  overflowTips.install = function (Vue) {
    Vue.directive('bk-overflow-tips', overflowTips);
  };

  var script = {
    name: 'bk-upload',
    directives: {
      bkOverflowTips: overflowTips
    },
    mixins: [locale__default.mixin],
    props: {
      theme: {
        type: String,
        default: 'draggable'
      },
      files: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      name: {
        type: String,
        default: 'upload_file'
      },
      multiple: {
        type: Boolean,
        default: true
      },
      accept: {
        type: String
      },
      delayTime: {
        type: Number,
        default: 0
      },
      url: {
        required: true,
        type: String
      },
      size: {
        type: [Number, Object],
        default: function _default() {
          return {
            maxFileSize: 5,
            maxImgSize: 1
          };
        }
      },
      handleResCode: {
        type: Function,
        default: function _default(res) {
          if (res && res.code === 0) {
            return true;
          }
          return false;
        }
      },
      header: [Array, Object],
      tip: {
        type: String,
        default: ''
      },
      validateName: {
        type: RegExp
      },
      withCredentials: {
        type: Boolean,
        default: false
      },
      limit: Number,
      formDataAttributes: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      extCls: {
        type: String,
        default: ''
      },
      customRequest: Function
    },
    data: function data() {
      return {
        dragText: '',
        clickText: '',
        showDialog: true,
        labelText: '',
        fileList: [],
        width: 0,
        barEl: null,
        fileIndex: null,
        speed: 0,
        total: 0,
        unit: 'kb/s',
        isdrag: false,
        progress: 0
      };
    },
    computed: {
      disabled: function disabled() {
        return this.theme === 'picture' && !this.multiple && this.fileList.length === 1 && this.fileList[0].status === 'running';
      },
      acceptTypes: function acceptTypes() {
        if (this.theme === 'picture' && this.accept === undefined) {
          return 'image/png,image/jpeg,image/jpg';
        }
        return this.accept;
      }
    },
    watch: {
      'fileIndex': function fileIndex(val) {
        if (val !== null && val < this.fileList.length) {
          if (!this.fileList[val].done) {
            this.uploadFile(this.fileList[val]);
          } else {
            this.fileIndex++;
          }
        }
      },
      'files': {
        immediate: true,
        deep: true,
        handler: function handler(list) {
          var _this = this;
          this.fileList = list.map(function (item) {
            _this.fileIndex++;
            return _extends({
              status: 'done',
              done: true,
              progress: '100%',
              name: "image.png".concat(uuid())
            }, item);
          });
        }
      }
    },
    created: function created() {
      this.dragText = this.t('bk.uploadFile.drag');
      this.clickText = this.t('bk.uploadFile.click');
      this.labelText = this.t('bk.uploadFile.uploadLabel');
    },
    mounted: function mounted() {
      var _this2 = this;
      if (this.theme === 'draggable') {
        var uploadEl = this.$refs.uploadel;
        uploadEl.addEventListener('dragenter', function (e) {
          _this2.isdrag = true;
        });
        uploadEl.addEventListener('dragleave', function (e) {
          _this2.isdrag = false;
        });
        uploadEl.addEventListener('dragend', function (e) {
          _this2.isdrag = false;
        });
      }
    },
    methods: {
      isImageType: function isImageType(fileType) {
        return fileType ? fileType.split('/').includes('image') : false;
      },
      getValidTypeFiles: function getValidTypeFiles(files) {
        var _this3 = this;
        return files.filter(function (file) {
          var type = file.type,
              name = file.name;
          var extension = name.indexOf('.') > -1 ? ".".concat(name.split('.').pop()) : '';
          var baseType = type.replace(/\/.*$/, '');
          return _this3.acceptTypes.split(',').map(function (type) {
            return type.trim();
          }).filter(function (type) {
            return type;
          }).some(function (acceptedType) {
            if (/\..+$/.test(acceptedType)) {
              return extension === acceptedType;
            }
            if (/\/\*$/.test(acceptedType)) {
              return baseType === acceptedType.replace(/\/\*$/, '');
            }
            if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
              return type === acceptedType;
            }
            return false;
          });
        });
      },
      filesize: function filesize(val) {
        var size = val / 1000;
        if (size < 1) {
          return "".concat(val.toFixed(3), " KB");
        }
        var index = size.toString().indexOf('.');
        return "".concat(size.toString().slice(0, index + 2), " MB");
      },
      handleWrapEnter: function handleWrapEnter(e) {
        if (e.target !== e.currentTarget) {
          return;
        }
        if ((e.keyCode === 13 || e.keyCode === 32) && this.$refs.uploadel) {
          this.$refs.uploadel.value = null;
          this.$refs.uploadel.click();
        }
      },
      selectFile: function selectFile(e) {
        var originalFiles = from_1$1(e.target.files);
        var files = this.acceptTypes ? this.getValidTypeFiles(originalFiles) : originalFiles;
        if (!files.length) {
          e.target.value = '';
          return;
        }
        if (typeof this.limit === 'number' && this.limit !== 1 && files.length + this.fileList.length > this.limit) {
          e.target.value = '';
          this.$emit('on-exceed', e.target.files, this.fileList);
          return;
        }
        var me = this;
        files.forEach(function (file, i) {
          var fileObj = {
            name: file.name,
            originSize: file.size,
            size: file.size / 1000,
            maxFileSize: null,
            maxImgSize: null,
            type: file.type,
            fileHeader: '',
            origin: file,
            url: '',
            base64: '',
            status: '',
            done: false,
            responseData: '',
            speed: null,
            errorMsg: '',
            progress: ''
          };
          var index = fileObj.type.indexOf('/');
          var type = fileObj.type.slice(0, index);
          fileObj.fileHeader = type;
          if (typeof me.size === 'number') {
            fileObj.maxFileSize = me.size;
            fileObj.maxImgSize = me.size;
          } else {
            fileObj.maxFileSize = me.size.maxFileSize;
            fileObj.maxImgSize = me.size.maxImgSize;
          }
          var onlyAcceptImage = !(me.accept || '').split(',').some(function (acc) {
            return acc.indexOf('image') < 0;
          });
          if (type === 'image' || onlyAcceptImage) {
            me.handleImage(fileObj, file);
          }
          if (type !== 'image' && fileObj.size > fileObj.maxFileSize * 1000) {
            fileObj.errorMsg = me.t('bk.uploadFile.fileExceedMsg', {
              fileName: fileObj.name,
              size: fileObj.maxFileSize
            });
          }
          if (me.validateName) {
            if (!me.validateName.test(fileObj.name)) {
              fileObj.errorMsg = me.t('bk.uploadFile.invalidFileName');
            }
          }
          if (me.theme === 'picture' && !me.multiple || me.limit === 1) {
            me.fileList = [fileObj];
          } else {
            me.fileList.push(fileObj);
          }
        });
        var len = this.fileList.length;
        var fileIndex = this.fileIndex;
        if (len - 1 === fileIndex) {
          this.uploadFile(this.fileList[fileIndex]);
        } else {
          this.fileIndex = 0;
        }
        e.target.value = '';
      },
      hideFileList: function hideFileList() {
        var _this4 = this;
        if (this.delayTime) {
          setTimeout(function () {
            _this4.fileList = [];
          }, this.delayTime);
        }
      },
      uploadFile: function uploadFile(fileObj) {
        var _this5 = this;
        if (fileObj.errorMsg) {
          this.fileIndex += 1;
          fileObj.progress = 100 + '%';
          this.$emit('on-error', fileObj, this.fileList);
          return;
        }
        var uploadProgress = function uploadProgress(e) {
          if (e.lengthComputable) {
            var percentComplete = Math.round(e.loaded * 100 / e.total);
            var kb = Math.round(e.loaded / 1000);
            fileObj.progress = percentComplete + '%';
            _this5.speed = kb - _this5.total;
            _this5.total = kb;
            _this5.unit = 'kb/s';
            if (_this5.speed > 1000) {
              _this5.speed = Math.round(_this5.speed / 1000);
              _this5.unit = 'mb/s';
            }
            _this5.$emit('on-progress', e, fileObj, _this5.fileList);
          }
          fileObj.status = 'running';
        };
        var options = {
          fileName: this.name,
          fileObj: fileObj,
          fileList: this.fileList,
          data: this.formDataAttributes || [],
          withCredentials: this.withCredentials,
          method: 'POST',
          header: this.header,
          url: this.url,
          onProgress: function onProgress(event) {
            uploadProgress(event);
          },
          onSuccess: function onSuccess(reponseText, fileObj) {
            _this5.handleSuccess(reponseText, fileObj);
          },
          onError: function onError(fileObj, fileList, response) {
            _this5.$emit('on-error', fileObj, fileList, response);
          },
          onDone: function onDone(fileObj) {
            _this5.handleDone(fileObj);
          }
        };
        this.isdrag = false;
        var request = this.customRequest || upload;
        request(options);
      },
      handleSuccess: function handleSuccess(response, file) {
        if (this.handleResCode(response)) {
          file.done = true;
          file.responseData = response;
          this.$emit('on-success', file, this.fileList);
        } else {
          file.errorMsg = response.message || this.t('bk.uploadFile.uploadFailed');
          this.$emit('on-error', file, this.fileList);
        }
      },
      handleDone: function handleDone(file) {
        this.fileIndex += 1;
        this.unit = 'kb/s';
        this.total = 0;
        file.status = 'done';
        if (this.fileIndex === this.fileList.length) {
          this.$emit('on-done', this.fileList);
          this.hideFileList();
        }
      },
      handleImage: function handleImage(fileObj, file) {
        var _this6 = this;
        if (fileObj.size > fileObj.maxImgSize * 1000) {
          fileObj.errorMsg = this.t('bk.uploadFile.imageExceedMsg', {
            imgSize: fileObj.maxImgSize
          });
          return false;
        }
        var reader = new FileReader();
        reader.onload = function (e) {
          _this6.smallImage(reader.result, fileObj);
        };
        reader.readAsDataURL(file);
        return true;
      },
      smallImage: function smallImage(result, fileObj) {
        var _this7 = this;
        var img = new Image();
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        img.onload = function () {
          var originWidth = img.width;
          var originHeight = img.height;
          var maxWidth = _this7.theme === 'picture' ? 90 : 36;
          var maxHeight = maxWidth;
          var targetWidth = originWidth;
          var targetHeight = originHeight;
          if (originWidth > maxWidth || originHeight > maxHeight) {
            if (originWidth / originHeight > maxWidth / maxHeight) {
              targetWidth = maxWidth;
              targetHeight = Math.round(maxWidth * (originHeight / originWidth));
            } else {
              targetWidth = maxWidth;
              targetHeight = maxHeight;
            }
          }
          canvas.width = targetWidth;
          canvas.height = targetHeight;
          context.clearRect(0, 0, targetWidth, targetHeight);
          context.drawImage(img, 0, 0, targetWidth, targetHeight);
          var base64 = canvas.toDataURL();
          fileObj['url'] = base64;
          fileObj['base64'] = base64;
        };
        img.src = result;
      },
      getIcon: function getIcon(file) {
        var zipType = ['application/zip', 'application/rar', 'application/tar', 'application/gz'];
        if (zipType.includes(file.type)) {
          return 'bk-icon icon-compressed-file';
        }
        return 'bk-icon icon-text-file';
      },
      deleteFile: function deleteFile(index, file) {
        if (file.xhr) {
          file.xhr.abort();
        }
        this.fileList.splice(index, 1);
        var len = this.fileList.length;
        if (!len) {
          this.fileIndex = null;
        }
        this.$emit('on-delete', file, this.fileList);
      }
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
  , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    var options = typeof script === 'function' ? script.options : script;
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    if (scopeId) {
      options._scopeId = scopeId;
    }
    var hook;
    if (moduleIdentifier) {
      hook = function hook(context) {
        context = context ||
        this.$vnode && this.$vnode.ssrContext ||
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        }
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode ? function () {
        style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        style.call(this, createInjector(context));
      };
    }
    if (hook) {
      if (options.functional) {
        var originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script;
  }
  var normalizeComponent_1 = normalizeComponent;

  /* script */
  var __vue_script__ = script;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: ['bk-upload', _vm.theme, _vm.extCls]
    }, [_vm.theme === 'picture' && _vm.multiple && _vm.fileList.length ? _vm._l(_vm.fileList, function (file, index) {
      return _c('div', {
        key: index,
        staticClass: "pic-item",
        class: {
          fail: file.errorMsg
        }
      }, [_c('img', {
        attrs: {
          "src": file.url
        }
      }), file.status === 'running' ? _c('div', {
        staticClass: "uploading-status"
      }, [_c('span', [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploading')))]), _c('div', {
        staticClass: "progress-bar-wrapper"
      }, [_c('div', {
        staticClass: "progress-bar uploading",
        style: {
          width: _vm.fileList[0].progress
        }
      })])]) : _vm._e(), file.done || file.errorMsg ? _c('div', {
        staticClass: "mask"
      }, [file.errorMsg ? _c('div', {
        directives: [{
          name: "bk-tooltips",
          rawName: "v-bk-tooltips.top",
          value: file.errorMsg,
          expression: "file.errorMsg",
          modifiers: {
            "top": true
          }
        }],
        staticClass: "fail-tips"
      }) : _vm._e(), _c('i', {
        staticClass: "bk-icon icon-close delete-file",
        on: {
          "click": function click($event) {
            _vm.deleteFile(index, file);
          }
        }
      })]) : _vm._e()]);
    }) : _vm._e(), _c('div', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips",
        value: {
          disabled: _vm.theme !== 'picture' || _vm.multiple || _vm.fileList.length === 0 || _vm.fileList.length > 1 || !_vm.fileList[0].errorMsg,
          content: _vm.fileList.length && _vm.fileList[0].errorMsg
        },
        expression: "{\n            disabled: theme !== 'picture' || multiple || fileList.length === 0 || fileList.length > 1 || !fileList[0].errorMsg,\n            content: fileList.length && fileList[0].errorMsg\n        }"
      }],
      staticClass: "file-wrapper",
      class: {
        'isdrag': _vm.isdrag
      },
      attrs: {
        "tabindex": "0",
        "bk-lableName": _vm.labelText
      },
      on: {
        "keydown": _vm.handleWrapEnter
      }
    }, [_vm.theme === 'draggable' ? _c('div', [_c('i', {
      staticClass: "bk-icon upload-icon icon-upload-cloud"
    }), _c('p', {
      staticClass: "text-area"
    }, [_c('span', {
      staticClass: "drop-upload"
    }, [_vm._v(_vm._s(_vm.dragText))]), _c('span', {
      staticClass: "click-upload"
    }, [_vm._v(_vm._s(_vm.clickText))])])]) : _vm._e(), _vm.theme === 'picture' ? _c('div', {
      staticClass: "picture-btn"
    }, [[_vm.multiple || _vm.fileList.length === 0 ? _c('div', {
      staticClass: "upload-btn"
    }, [_c('i', {
      staticClass: "bk-icon icon-plus-line"
    }), _c('div', [_vm._v(_vm._s(_vm.t('bk.uploadFile.click')))])]) : _c('div', {
      staticClass: "pic-item",
      class: {
        fail: !_vm.multiple && _vm.fileList.length && _vm.fileList[0].errorMsg
      }
    }, [_vm.fileList[0].status === 'running' ? _c('div', {
      staticClass: "uploading-status"
    }, [_c('span', [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploading')))]), _c('div', {
      staticClass: "progress-bar-wrapper"
    }, [_c('div', {
      staticClass: "progress-bar uploading",
      style: {
        width: _vm.fileList[0].progress
      }
    })])]) : _vm._e(), _vm.fileList[0].errorMsg ? _c('div', {
      directives: [{
        name: "bk-tooltips",
        rawName: "v-bk-tooltips.top",
        value: _vm.fileList[0].errorMsg,
        expression: "fileList[0].errorMsg",
        modifiers: {
          "top": true
        }
      }],
      staticClass: "fail-status"
    }, [_c('i', {
      staticClass: "bk-icon icon-image error-pic"
    }), _c('div', {
      staticClass: "reupload"
    }, [_vm._v(_vm._s(_vm.t('bk.uploadFile.reupload')))]), _c('i', {
      staticClass: "bk-icon icon-close delete-file error",
      on: {
        "click": function click($event) {
          _vm.deleteFile(0, _vm.fileList[0]);
        }
      }
    })]) : _vm._e(), _vm.fileList[0].status === 'done' && !_vm.fileList[0].errorMsg ? _c('div', {
      staticClass: "uploaded-status"
    }, [_c('img', {
      attrs: {
        "src": _vm.fileList[0].url
      }
    }), _c('div', {
      staticClass: "mask"
    }, [_vm._v("\n                            " + _vm._s(_vm.t('bk.uploadFile.replace')) + "\n                            "), _c('i', {
      staticClass: "bk-icon icon-close delete-file",
      on: {
        "click": function click($event) {
          _vm.deleteFile(0, _vm.fileList[0]);
        }
      }
    })])]) : _vm._e()])]], 2) : _vm._e(), _c('input', {
      ref: "uploadel",
      attrs: {
        "tabindex": "-1",
        "accept": _vm.acceptTypes,
        "multiple": _vm.multiple,
        "disabled": _vm.disabled,
        "type": "file"
      },
      on: {
        "change": _vm.selectFile
      }
    })]), _vm.tip ? _c('p', {
      staticClass: "tip"
    }, [_vm._v(_vm._s(_vm.tip))]) : _vm._e(), _vm.fileList.length && _vm.theme !== 'picture' ? _c('div', {
      staticClass: "all-file"
    }, _vm._l(_vm.fileList, function (file, index) {
      return _c('div', {
        key: index
      }, [_c('div', {
        staticClass: "file-item",
        class: {
          'file-item-fail': file.errorMsg
        }
      }, [_c('div', {
        staticClass: "file-icon"
      }, [_vm.isImageType(file.type) ? _c('img', {
        attrs: {
          "src": file.url
        }
      }) : _c('i', {
        class: _vm.getIcon(file)
      })]), _c('i', {
        staticClass: "bk-icon icon-close close-upload",
        on: {
          "click": function click($event) {
            _vm.deleteFile(index, file);
          }
        }
      }), _c('div', {
        staticClass: "file-info"
      }, [_c('div', {
        staticClass: "file-name"
      }, [_c('span', [_vm._v(_vm._s(file.name))])]), _c('div', {
        staticClass: "file-message"
      }, [_c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !file.done && file.status === 'running',
          expression: "!file.done && file.status === 'running'"
        }],
        staticClass: "upload-speed"
      }, [_vm._v(_vm._s(_vm.speed) + _vm._s(_vm.unit))]), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: !file.done,
          expression: "!file.done"
        }],
        staticClass: "file-size"
      }, [_vm._v(_vm._s(_vm.filesize(file.size)))]), _c('span', {
        directives: [{
          name: "show",
          rawName: "v-show",
          value: file.done,
          expression: "file.done"
        }],
        staticClass: "file-size done"
      }, [_vm._v(_vm._s(_vm.t('bk.uploadFile.uploadDone')))])]), file.errorMsg ? _c('p', {
        directives: [{
          name: "bk-overflow-tips",
          rawName: "v-bk-overflow-tips"
        }],
        staticClass: "error-msg"
      }, [_vm._v(_vm._s(file.errorMsg))]) : _c('div', {
        staticClass: "progress-bar-wrapper"
      }, [_c('div', {
        staticClass: "progress-bar",
        class: {
          'success': file.done,
          'uploading': file.status === 'running' && !file.errorMsg
        },
        style: {
          width: file.progress
        }
      })])])])]);
    }), 0) : _vm._e()], 2);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

  function setInstaller (component, afterInstall) {
    component.install = function (Vue) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var props = component.props || {};
      keys$1(options).forEach(function (key) {
        if (props.hasOwnProperty(key)) {
          if (typeof props[key] === 'function' || props[key] instanceof Array) {
            props[key] = {
              type: props[key],
              default: options[key]
            };
          } else {
            props[key].default = options[key];
          }
        }
      });
      component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
      Vue.component(component.name, component);
      typeof afterInstall === 'function' && afterInstall(Vue, options);
    };
  }

  setInstaller(__vue_component__);

  exports.default = __vue_component__;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
