(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('bk-magic-vue/lib/locale')) :
	typeof define === 'function' && define.amd ? define(['exports', 'bk-magic-vue/lib/locale'], factory) :
	(global = global || self, factory(global.library = {}, global.locale));
}(this, function (exports, locale) { 'use strict';

	locale = locale && locale.hasOwnProperty('default') ? locale['default'] : locale;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var runtime_1 = createCommonjsModule(function (module) {
	var runtime = (function (exports) {
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1;
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    define({}, "");
	  } catch (err) {
	    define = function(obj, key, value) {
	      return obj[key] = value;
	    };
	  }
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	    return generator;
	  }
	  exports.wrap = wrap;
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	  var ContinueSentinel = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  define(Gp, "constructor", GeneratorFunctionPrototype);
	  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
	  GeneratorFunction.displayName = define(
	    GeneratorFunctionPrototype,
	    toStringTagSymbol,
	    "GeneratorFunction"
	  );
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      define(prototype, method, function(arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }
	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };
	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }
	    var previousPromise;
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	      return previousPromise =
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	    this._invoke = enqueue;
	  }
	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator;
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );
	    return exports.isGeneratorFunction(outerFn)
	      ? iter
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	        return doneResult();
	      }
	      context.method = method;
	      context.arg = arg;
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	        if (context.method === "next") {
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	        state = GenStateExecuting;
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      context.delegate = null;
	      if (context.method === "throw") {
	        if (delegate.iterator["return"]) {
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);
	          if (context.method === "throw") {
	            return ContinueSentinel;
	          }
	        }
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	      return ContinueSentinel;
	    }
	    var record = tryCatch(method, delegate.iterator, context.arg);
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    var info = record.arg;
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    if (info.done) {
	      context[delegate.resultName] = info.value;
	      context.next = delegate.nextLoc;
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }
	    } else {
	      return info;
	    }
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	  defineIteratorMethods(Gp);
	  define(Gp, toStringTagSymbol, "Generator");
	  define(Gp, iteratorSymbol, function() {
	    return this;
	  });
	  define(Gp, "toString", function() {
	    return "[object Generator]";
	  });
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	    this.tryEntries.push(entry);
	  }
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	  function Context(tryLocsList) {
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	      next.done = true;
	      return next;
	    };
	  };
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	          next.value = undefined$1;
	          next.done = true;
	          return next;
	        };
	        return next.next = next;
	      }
	    }
	    return { next: doneResult };
	  }
	  exports.values = values;
	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }
	  Context.prototype = {
	    constructor: Context,
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;
	      this.method = "next";
	      this.arg = undefined$1;
	      this.tryEntries.forEach(resetTryEntry);
	      if (!skipTempReset) {
	        for (var name in this) {
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },
	    stop: function() {
	      this.done = true;
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	      return this.rval;
	    },
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        if (caught) {
	          context.method = "next";
	          context.arg = undefined$1;
	        }
	        return !! caught;
	      }
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	        if (entry.tryLoc === "root") {
	          return handle("end");
	        }
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        finallyEntry = null;
	      }
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	      return this.complete(record);
	    },
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	      return ContinueSentinel;
	    },
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	      if (this.method === "next") {
	        this.arg = undefined$1;
	      }
	      return ContinueSentinel;
	    }
	  };
	  return exports;
	}(
	   module.exports 
	));
	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  if (typeof globalThis === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}
	});

	var regenerator = runtime_1;

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? Object(arguments[i]) : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	var _global = createCommonjsModule(function (module) {
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  : Function('return this')();
	if (typeof __g == 'number') __g = global;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.12' };
	if (typeof __e == 'number') __e = core;
	});
	var _core_1 = _core.version;

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function () {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var PROTOTYPE = 'prototype';
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    out = own ? target[key] : source[key];
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    : IS_BIND && own ? _ctx(out, _global)
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;

	var toString = {}.toString;
	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	_export(_export.S, 'Array', { isArray: _isArray });

	var isArray = _core.Array.isArray;

	var isArray$1 = isArray;

	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');
	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};
	var trim = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	var _stringTrim = exporter;

	var $parseInt = _global.parseInt;
	var $trim = _stringTrim.trim;
	var hex = /^[-+]?0[xX]/;
	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	_export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

	var _parseInt$1 = _core.parseInt;

	var _parseInt$2 = _parseInt$1;

	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	var $Object = _core.Object;
	var defineProperty = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};

	var defineProperty$1 = defineProperty;

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');
	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');
	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	var getNodeId = function getNodeId(data, tree) {
	  var idKey = tree.nodeOptions.idKey;
	  if (typeof idKey === 'function') {
	    return idKey(data);
	  }
	  return data[idKey];
	};
	var getNodeIcon = function getNodeIcon(data, tree) {
	  var icon = {
	    expand: tree.expandIcon,
	    collapse: tree.collapseIcon,
	    node: tree.nodeIcon
	  };
	  if (typeof icon.node === 'function') {
	    icon.node = icon.node(data);
	  }
	  return icon;
	};
	var isNullOrUndefined = function isNullOrUndefined(value) {
	  return value === null || value === undefined;
	};
	var convertToArray = function convertToArray(value) {
	  return isArray$1(value) ? value : [value];
	};
	var checkIsLazy = function checkIsLazy(node, tree) {
	  if (typeof tree.lazyMethod !== 'function') {
	    return false;
	  }
	  if (typeof tree.lazyDisabled === 'boolean') {
	    return !tree.lazyDisabled;
	  } else if (typeof tree.lazyDisabled === 'function') {
	    return !tree.lazyDisabled(node);
	  }
	  return true;
	};

	var TreeNode = function () {
	  function TreeNode(data, options, tree) {
	    var _this = this;
	    _classCallCheck(this, TreeNode);
	    var folderKey = tree.nodeOptions['folderKey'];
	    var isFolder = folderKey && data[folderKey];
	    var sealData = {
	      data: data,
	      tree: tree,
	      _vNode: null,
	      id: getNodeId(data, tree),
	      icon: getNodeIcon(data, tree),
	      line: 0,
	      level: options.level,
	      index: options.index,
	      childIndex: options.childIndex || 0,
	      parent: options.parent,
	      children: [],
	      timer: null,
	      isFolder: isFolder
	    };
	    keys$1(sealData).forEach(function (key) {
	      defineProperty$1(_this, key, {
	        enumerable: true,
	        configurable: tree.configurable,
	        writable: true,
	        value: sealData[key]
	      });
	    });
	    this.state = {
	      checked: false,
	      expanded: tree.defaultExpandAll,
	      disabled: false,
	      visible: true,
	      matched: true,
	      loading: false,
	      lazy: checkIsLazy(this, tree)
	    };
	  }
	  _createClass(TreeNode, [{
	    key: "uid",
	    get: function get() {
	      return "".concat(this.tree.id, "-node-").concat(this.index);
	    }
	  }, {
	    key: "name",
	    get: function get() {
	      return this.data[this.tree.nodeOptions.nameKey];
	    }
	  }, {
	    key: "vNode",
	    get:
	    function get() {
	      return this._vNode;
	    }
	    ,
	    set: function set(vNode) {
	      this._vNode = vNode;
	      if (this.expanded) {
	        this.recalculateLinkLine();
	      }
	    }
	  }, {
	    key: "parents",
	    get: function get() {
	      if (!this.parent) {
	        return [];
	      }
	      return [].concat(_toConsumableArray(this.parent.parents), [this.parent]);
	    }
	  }, {
	    key: "descendants",
	    get: function get() {
	      var descendants = [];
	      this.children.forEach(function (node) {
	        descendants.push(node);
	        descendants.push.apply(descendants, _toConsumableArray(node.descendants));
	      });
	      return descendants;
	    }
	  }, {
	    key: "isLeaf",
	    get: function get() {
	      return !this.lazy && !this.loading && !this.children.length;
	    }
	  }, {
	    key: "lazy",
	    get: function get() {
	      return this.state.lazy && !this.children.length;
	    }
	  }, {
	    key: "loading",
	    get: function get() {
	      return this.state.loading;
	    }
	  }, {
	    key: "hasCheckbox",
	    get: function get() {
	      var showCheckbox = this.tree.showCheckbox;
	      if (typeof showCheckbox === 'function') {
	        return showCheckbox(this.data);
	      }
	      return showCheckbox;
	    }
	  }, {
	    key: "collapseIcon",
	    get: function get() {
	      return this.icon.collapse;
	    }
	  }, {
	    key: "selected",
	    get: function get() {
	      return this.tree.selectable && this.tree.selected === this.id;
	    }
	  }, {
	    key: "expandIcon",
	    get: function get() {
	      return this.icon.expand;
	    }
	  }, {
	    key: "nodeIcon",
	    get: function get() {
	      return this.icon.node;
	    }
	  }, {
	    key: "checked",
	    get: function get() {
	      return this.state.checked;
	    },
	    set: function set(checked) {
	      if (this.state.checked === checked && !this.indeterminate) {
	        return false;
	      }
	      this.setState('checked', checked);
	      if (this.tree.checkStrictly) {
	        this.children.forEach(function (child) {
	          if (child.checkable) {
	            child.checked = checked;
	          }
	        });
	        if (this.parent) {
	          this.parents.reverse().forEach(function (parent) {
	            if (checked) {
	              var parentChecked = !parent.children.some(function (node) {
	                return !node.checked;
	              });
	              parent.setState('checked', parentChecked);
	            } else {
	              parent.setState('checked', false);
	            }
	          });
	        }
	      }
	    }
	  }, {
	    key: "checkable",
	    get: function get() {
	      if (this.disabled) {
	        return false;
	      }
	      if (this.tree.inSearch && this.tree.checkOnlyAvailableStrictly) {
	        if (this.tree.displayMatchedNodeDescendants) {
	          return this.matched || this.childrenMatched || this.parentsMatched;
	        }
	        return this.matched || this.childrenMatched;
	      }
	      return true;
	    }
	  }, {
	    key: "expanded",
	    get: function get() {
	      return this.state.expanded;
	    },
	    set: function set(expanded) {
	      var _this2 = this;
	      if (this.state.expanded === expanded) {
	        return false;
	      }
	      this.setState('expanded', expanded);
	      if (expanded && this.parent) {
	        this.parent.expanded = true;
	      }
	      this.children.forEach(function (node) {
	        node.visible = expanded;
	      });
	      this.tree.$nextTick( _asyncToGenerator( regenerator.mark(function _callee() {
	        var _yield$_this2$tree$la, _yield$_this2$tree$la2, leaf, _yield$_this2$tree$la3, data, newNodes;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(expanded && _this2.lazy)) {
	                  _context.next = 21;
	                  break;
	                }
	                _this2.setState('loading', true);
	                _this2.setState('lazy', false);
	                _context.prev = 3;
	                _context.next = 6;
	                return _this2.tree.lazyMethod(_this2);
	              case 6:
	                _yield$_this2$tree$la = _context.sent;
	                _yield$_this2$tree$la2 = _yield$_this2$tree$la.leaf;
	                leaf = _yield$_this2$tree$la2 === void 0 ? [] : _yield$_this2$tree$la2;
	                _yield$_this2$tree$la3 = _yield$_this2$tree$la.data;
	                data = _yield$_this2$tree$la3 === void 0 ? [] : _yield$_this2$tree$la3;
	                newNodes = _this2.tree.addNode(data, _this2.id);
	                newNodes.forEach(function (node) {
	                  if (leaf.includes(node.id)) {
	                    node.setState('lazy', false);
	                  }
	                });
	                _context.next = 18;
	                break;
	              case 15:
	                _context.prev = 15;
	                _context.t0 = _context["catch"](3);
	                console.error(_context.t0);
	              case 18:
	                _context.prev = 18;
	                _this2.setState('loading', false);
	                return _context.finish(18);
	              case 21:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, null, [[3, 15, 18, 21]]);
	      })));
	      this.recalculateLinkLine();
	    }
	  }, {
	    key: "disabled",
	    get: function get() {
	      return this.state.disabled;
	    },
	    set: function set(disabled) {
	      if (this.state.disabled === disabled) {
	        return false;
	      }
	      this.setState('disabled', disabled);
	      if (this.tree.disableStrictly) {
	        this.descendants.forEach(function (descendant) {
	          descendant.disabled = disabled;
	        });
	      }
	    }
	  }, {
	    key: "matched",
	    get: function get() {
	      return this.state.matched;
	    },
	    set: function set(matched) {
	      this.setState('matched', matched);
	    }
	  }, {
	    key: "childrenMatched",
	    get: function get() {
	      return this.children.some(function (child) {
	        return child.matched || child.childrenMatched;
	      });
	    }
	  }, {
	    key: "parentsMatched",
	    get: function get() {
	      return this.parents.some(function (parent) {
	        return parent.matched;
	      });
	    }
	  }, {
	    key: "visible",
	    get: function get() {
	      var basicVisible = this.parent ? this.parent.expanded && this.state.visible : this.state.visible;
	      if (!this.tree.inSearch) {
	        return basicVisible;
	      }
	      var searchVisible = basicVisible && (this.matched || this.childrenMatched);
	      if (this.tree.displayMatchedNodeDescendants) {
	        var parentMatchedVisible = basicVisible && this.parentsMatched;
	        return searchVisible || parentMatchedVisible;
	      }
	      return searchVisible;
	    },
	    set: function set(visible) {
	      if (this.state.visible === visible) {
	        return false;
	      }
	      this.setState('visible', visible);
	      this.children.forEach(function (node) {
	        node.visible = visible;
	      });
	    }
	  }, {
	    key: "indeterminate",
	    get: function get() {
	      if (this.tree.checkStrictly) {
	        var childrenIndeterminate = this.children.some(function (child) {
	          return child.indeterminate;
	        });
	        if (childrenIndeterminate) {
	          return true;
	        }
	        var checkedChildren = this.children.filter(function (child) {
	          return child.checked;
	        });
	        return !!checkedChildren.length && checkedChildren.length !== this.children.length;
	      }
	      return false;
	    }
	  }, {
	    key: "setState",
	    value: function setState(key, value) {
	      if (this.state.hasOwnProperty(key)) {
	        this.state[key] = value;
	      }
	    }
	  }, {
	    key: "recalculateLinkLine",
	    value: function recalculateLinkLine() {
	      if (this.tree.hasLine) {
	        var needsCalculateNodes = this.tree.needsCalculateNodes;
	        if (needsCalculateNodes.includes(this)) {
	          return false;
	        }
	        needsCalculateNodes.push(this);
	        this.parent && this.parent.recalculateLinkLine();
	      }
	    }
	  }, {
	    key: "appendChild",
	    value: function appendChild(node, offset, options) {
	      var _this$children;
	      var nodes = isArray$1(node) ? node : [node];
	      (_this$children = this.children).splice.apply(_this$children, [offset, 0].concat(_toConsumableArray(nodes)));
	      this.children.slice(offset).forEach(function (node, index) {
	        node.childIndex = offset + index;
	      });
	      this.expanded = options.expandParent;
	      this.recalculateLinkLine();
	      return nodes;
	    }
	  }, {
	    key: "removeChild",
	    value: function removeChild(node) {
	      var _this3 = this;
	      var nodes = isArray$1(node) ? node : [node];
	      var removedChildIndex = [];
	      var removedIndex = [];
	      nodes.forEach(function (node) {
	        var childIndex = node.childIndex;
	        removedChildIndex.push(childIndex);
	        removedIndex.push(node.index);
	        _this3.children.splice(childIndex, 1);
	      });
	      var minIndex = Math.min.apply(Math, removedChildIndex);
	      this.children.slice(minIndex).forEach(function (node, index) {
	        node.childIndex = minIndex + index;
	      });
	      this.recalculateLinkLine();
	      return nodes;
	    }
	  }]);
	  return TreeNode;
	}();

	var script = {
	  name: 'bk-virtual-scroll',
	  props: {
	    itemHeight: {
	      type: Number,
	      default: 16
	    },
	    showIndex: {
	      type: Boolean,
	      default: false
	    },
	    list: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  data: function data() {
	    return {
	      ulHeight: 0,
	      allListData: [],
	      offscreenCanvas: '',
	      indexList: [],
	      listData: [],
	      worker: {},
	      mainWidth: 0,
	      mainLeft: 0,
	      totalHeight: 0,
	      itemNumber: 0,
	      totalNumber: 0,
	      visHeight: 0,
	      visWidth: 0,
	      totalScrollHeight: 0,
	      startMinMapMove: false,
	      tempVal: 0,
	      minMapTop: 0,
	      minNavTop: 0,
	      navHeight: 0,
	      mapHeight: 0,
	      moveRate: 0,
	      bottomScrollWidth: Infinity,
	      bottomScrollDis: 0,
	      itemWidth: 0,
	      isScrolling: false,
	      isBottomMove: false,
	      downPreDefault: false,
	      upPreDefault: false,
	      indexWidth: 0,
	      observer: {}
	    };
	  },
	  watch: {
	    list: {
	      handler: function handler(list) {
	        this.setListData(list);
	      },
	      deep: true
	    }
	  },
	  mounted: function mounted() {
	    this.initStatus();
	    this.initEvent();
	    if (this.list.length > 0) this.setListData(this.list);
	  },
	  beforeDestroy: function beforeDestroy() {
	    document.removeEventListener('mousemove', this.minNavMove);
	    document.removeEventListener('mouseup', this.moveEnd);
	    window.removeEventListener('resize', this.resize);
	    if (MutationObserver) this.observer.disconnect();
	    this.observer = {};
	  },
	  methods: {
	    initStatus: function initStatus() {
	      var mainEle = this.$refs.scrollHome;
	      var scrollEle = this.$refs.scrollMain;
	      this.visHeight = mainEle.offsetHeight || 300;
	      this.visWidth = mainEle.offsetWidth || 300;
	      var scrollWidth = scrollEle.scrollWidth || 0;
	      this.itemWidth = scrollWidth;
	      this.bottomScrollWidth = this.visWidth * this.visWidth / scrollWidth < 20 ? 20 : this.visWidth * this.visWidth / scrollWidth;
	      var dpr = window.devicePixelRatio || 1;
	      this.$refs.minNav.width = 8 * dpr;
	      this.$refs.minNav.height = this.visHeight * dpr;
	      this.$refs.minNav.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
	    },
	    initEvent: function initEvent() {
	      document.addEventListener('mousemove', this.minNavMove);
	      document.addEventListener('mouseup', this.moveEnd);
	      window.addEventListener('resize', this.resize);
	      if (MutationObserver) {
	        this.observer = new MutationObserver(this.resize);
	        this.observer.observe(this.$el, {
	          attributes: true,
	          attributeFilter: ['style']
	        });
	      }
	    },
	    resize: function resize(event) {
	      var _this = this;
	      this.slowExec(function () {
	        var lastHeight = _this.visHeight;
	        _this.initStatus();
	        _this.setStatus();
	        _this.minMapTop = _this.visHeight / lastHeight * _this.minMapTop;
	        _this.minNavTop = _this.minMapTop * (_this.visHeight - _this.navHeight) / (_this.mapHeight - _this.visHeight / 8);
	        _this.totalScrollHeight = _this.mapHeight === _this.canvasHeight / 8 ? 0 : _this.minMapTop / (_this.mapHeight - _this.visHeight / 8) * (_this.totalHeight - _this.visHeight);
	        _this.getListData(_this.totalScrollHeight, true);
	      });
	    },
	    handleWheel: function handleWheel(event) {
	      var isVerticalScroll = event.wheelDeltaX !== undefined ? Math.abs(event.wheelDeltaY) > Math.abs(event.wheelDeltaX) : event.axis === 2;
	      if (isVerticalScroll) this.handleVerticalScroll(event);else this.handleHorizontalScroll(event);
	    },
	    handleHorizontalScroll: function handleHorizontalScroll(event) {
	      event.preventDefault();
	      if (this.bottomScrollWidth >= this.mainWidth) return;
	      var deltaX = -Math.max(-1, Math.min(1, event.wheelDeltaX || -event.detail));
	      var bottomScrollLeft = this.bottomScrollDis + deltaX * 4;
	      if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
	      if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
	      this.bottomScrollDis = bottomScrollLeft;
	      this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
	    },
	    handleVerticalScroll: function handleVerticalScroll(event) {
	      var deltaY = Math.max(-1, Math.min(1, event.wheelDeltaY || -event.detail));
	      var shouldPreDefault = deltaY < 0 ? this.downPreDefault : this.upPreDefault;
	      if (shouldPreDefault) event.preventDefault();
	      if (this.isScrolling || this.itemHeight * this.totalNumber <= this.visHeight) return;
	      var dis = 0;
	      if (event.wheelDelta) dis = -1 / 5 * event.wheelDelta;
	      if (event.detail) dis = event.detail;
	      var tickGap = deltaY * -2;
	      if (deltaY === 0) {
	        dis = 0;
	        tickGap = 0;
	      }
	      var scrollHeight = this.minMapTop + (dis + tickGap) * (this.mapHeight - this.visHeight / 8) / (this.totalHeight - this.itemHeight * this.itemNumber);
	      var totalScrollHeight = 0;
	      var minMapTop = 0;
	      var minNavTop = 0;
	      if (scrollHeight < 0) {
	        totalScrollHeight = 0;
	        minMapTop = 0;
	        minNavTop = 0;
	      } else if (scrollHeight >= 0 && scrollHeight <= this.mapHeight - this.visHeight / 8) {
	        minMapTop = scrollHeight;
	        minNavTop = this.minNavTop + (dis + tickGap) * (this.visHeight - this.navHeight) / (this.totalHeight - this.itemHeight * this.itemNumber);
	        totalScrollHeight = scrollHeight * (this.totalHeight - this.itemHeight * this.itemNumber) / (this.mapHeight - this.visHeight / 8);
	      } else {
	        totalScrollHeight = this.totalHeight - this.visHeight;
	        minMapTop = this.mapHeight - this.visHeight / 8;
	        minNavTop = this.visHeight - this.navHeight;
	      }
	      this.minMapTop = minMapTop;
	      this.minNavTop = minNavTop;
	      this.isScrolling = true;
	      this.getListData(totalScrollHeight);
	    },
	    scrollPageByIndex: function scrollPageByIndex(index) {
	      var height = this.itemHeight * index;
	      if (height <= 0) height = 0;else if (height >= this.totalHeight - this.visHeight) height = this.totalHeight - this.visHeight;
	      if (this.totalHeight <= this.visHeight) height = 0;
	      var heightDiff = this.totalHeight - this.visHeight || 1;
	      this.minMapTop = height / heightDiff * (this.mapHeight - this.visHeight / 8);
	      this.minNavTop = height / heightDiff * (this.visHeight - this.navHeight);
	      this.getListData(height);
	    },
	    getListData: function getListData() {
	      var totalScrollHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var isResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var postData = {
	        type: 'wheelGetData',
	        totalScrollHeight: totalScrollHeight,
	        isResize: isResize,
	        totalHeight: this.totalHeight,
	        itemHeight: this.itemHeight,
	        itemNumber: this.itemNumber,
	        canvasHeight: this.visHeight,
	        minMapTop: this.minMapTop,
	        mapHeight: this.mapHeight
	      };
	      this.calcList(postData);
	    },
	    calcList: function calcList(_ref) {
	      var totalScrollHeight = _ref.totalScrollHeight,
	          itemHeight = _ref.itemHeight,
	          itemNumber = _ref.itemNumber,
	          canvasHeight = _ref.canvasHeight,
	          minMapTop = _ref.minMapTop,
	          totalHeight = _ref.totalHeight,
	          mapHeight = _ref.mapHeight,
	          isResize = _ref.isResize;
	      var realHeight = mapHeight === canvasHeight / 8 ? 0 : minMapTop / (mapHeight - canvasHeight / 8) * (totalHeight - canvasHeight);
	      var startIndex = Math.floor(realHeight / itemHeight);
	      var endIndex = startIndex + itemNumber;
	      startIndex = startIndex > 0 ? startIndex - 1 : 0;
	      var listData = [];
	      var indexList = [];
	      var nums = Math.floor(startIndex * itemHeight / 500000);
	      for (var i = startIndex; i <= endIndex; i++) {
	        var top = i * itemHeight - nums * 500000;
	        var value = this.allListData[i];
	        if (value) {
	          indexList.push({
	            top: top,
	            value: i + 1
	          });
	          listData.push({
	            top: top,
	            value: value
	          });
	        }
	      }
	      totalScrollHeight = totalScrollHeight - nums * 500000;
	      this.indexList = indexList;
	      this.listData = listData;
	      this.totalScrollHeight = totalScrollHeight;
	      var firstIndexObj = this.indexList[0] || {};
	      var lastIndexObj = this.indexList[this.indexList.length - 1] || {};
	      this.downPreDefault = lastIndexObj.value + 1 < this.totalNumber;
	      this.upPreDefault = firstIndexObj.value > 1;
	      this.isScrolling = false;
	      this.$emit('change', listData.map(function (x) {
	        return x.value;
	      }));
	    },
	    addListData: function addListData(list) {
	      this.allListData = this.allListData.concat(list);
	      var number = this.totalNumber + list.length;
	      var lastIndexData = this.indexList[this.indexList.length - 1] || {
	        value: 0
	      };
	      if (this.totalNumber - lastIndexData.value <= 3) {
	        this.freshDataScrollBottom(number);
	      } else {
	        this.freshDataNoScroll(number);
	      }
	      this.resize();
	    },
	    setListData: function setListData(list) {
	      this.allListData = list;
	      this.freshDataNoScroll(list.length);
	      this.resize();
	    },
	    freshDataScrollBottom: function freshDataScrollBottom(number) {
	      this.totalNumber = number;
	      this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
	      this.setStatus();
	      this.scrollPageByIndex(this.totalNumber - this.itemNumber + 1);
	    },
	    freshDataNoScroll: function freshDataNoScroll(number) {
	      var oldNumber = this.totalNumber;
	      var oldItemNumber = this.itemNumber;
	      var oldMapHeight = this.mapHeight;
	      var oldVisHeight = this.visHeight;
	      this.totalNumber = number;
	      this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
	      this.setStatus();
	      this.getNumberChangeList({
	        oldNumber: oldNumber,
	        oldItemNumber: oldItemNumber,
	        oldMapHeight: oldMapHeight,
	        oldVisHeight: oldVisHeight
	      });
	    },
	    getNumberChangeList: function getNumberChangeList(_ref2) {
	      var oldNumber = _ref2.oldNumber,
	          oldItemNumber = _ref2.oldItemNumber,
	          oldMapHeight = _ref2.oldMapHeight,
	          oldVisHeight = _ref2.oldVisHeight;
	      var minMapTop = this.minMapTop * (oldNumber - oldItemNumber) / (this.totalNumber - this.itemNumber || 1) * ((this.mapHeight - this.visHeight / 8) / (oldMapHeight - oldVisHeight / 8 || 1));
	      var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.totalHeight - this.visHeight);
	      if (minMapTop <= 0 || this.navHeight >= this.visHeight) {
	        minMapTop = 0;
	        totalScrollHeight = 0;
	      } else if (minMapTop > this.mapHeight - this.visHeight / 8) {
	        minMapTop = this.mapHeight - this.visHeight / 8;
	        totalScrollHeight = this.totalHeight - this.visHeight;
	      }
	      this.minMapTop = minMapTop;
	      this.minNavTop = this.minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.visHeight - this.navHeight);
	      this.getListData(totalScrollHeight);
	    },
	    setStatus: function setStatus() {
	      this.totalHeight = this.totalNumber * this.itemHeight;
	      this.itemNumber = this.totalHeight > this.visHeight ? Math.ceil(this.visHeight / this.itemHeight) : this.totalNumber;
	      this.ulHeight = this.totalHeight > 400000 ? 1000000 : this.totalHeight;
	      var heightRate = this.visHeight / this.totalHeight;
	      var minNavHeight = heightRate * this.visHeight;
	      this.navHeight = heightRate > 1 ? this.visHeight : minNavHeight < 20 ? 20 : minNavHeight;
	      var moveMaxHeight = this.totalNumber * this.itemHeight / 8;
	      this.mapHeight = moveMaxHeight < this.visHeight ? moveMaxHeight : this.visHeight;
	      this.mainWidth = this.visWidth;
	      if (this.$refs.scrollNav) this.mainWidth -= this.$refs.scrollNav.offsetWidth;
	      if (this.showIndex) {
	        this.mainWidth -= (Math.log10(this.totalNumber) + 1) * 7;
	        this.mainLeft = (Math.log10(this.totalNumber) + 1) * 7;
	      }
	    },
	    startBottomMove: function startBottomMove(event) {
	      this.tempVal = event.screenX;
	      this.startMinMapMove = true;
	      this.isBottomMove = true;
	    },
	    startNavMove: function startNavMove(rate) {
	      this.moveRate = rate;
	      this.tempVal = event.screenY;
	      this.startMinMapMove = true;
	      this.$emit('virtual-scroll-scroll-bar-mouse', 'down');
	      document.addEventListener('click', this.docClickHandler);
	    },
	    docClickHandler: function docClickHandler() {
	      var _this2 = this;
	      document.removeEventListener('click', this.docClickHandler);
	      setTimeout(function () {
	        _this2.$emit('virtual-scroll-scroll-bar-mouse', 'up');
	      }, 0);
	    },
	    minNavMove: function minNavMove() {
	      var _this3 = this;
	      if (!this.startMinMapMove) return;
	      if (this.isBottomMove) {
	        var moveDis = event.screenX - this.tempVal;
	        var bottomScrollLeft = this.bottomScrollDis + moveDis;
	        if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
	        if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
	        this.bottomScrollDis = bottomScrollLeft;
	        this.tempVal = event.screenX;
	        this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
	      } else {
	        var _moveDis = event.screenY - this.tempVal;
	        var minMapTop = this.minMapTop + _moveDis / this.moveRate * (this.mapHeight - this.visHeight / 8);
	        if (minMapTop <= 0) minMapTop = 0;
	        if (minMapTop >= this.mapHeight - this.visHeight / 8) minMapTop = this.mapHeight - this.visHeight / 8;
	        var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8) * (this.totalHeight - this.visHeight);
	        this.tempVal = event.screenY;
	        this.minMapTop = minMapTop;
	        this.minNavTop = minMapTop * (this.visHeight - this.navHeight) / (this.mapHeight - this.visHeight / 8);
	        this.slowExec(function () {
	          _this3.getListData(totalScrollHeight);
	        });
	      }
	    },
	    slowExec: function slowExec(callBack) {
	      var now = +new Date();
	      if (now - (this.slowExec.lastTime || 0) >= 100) {
	        this.slowExec.lastTime = now;
	        callBack();
	      }
	      window.clearTimeout(this.slowExec.timeId);
	      this.slowExec.timeId = window.setTimeout(function () {
	        callBack();
	      }, 50);
	    },
	    moveEnd: function moveEnd(event) {
	      event.preventDefault();
	      this.startMinMapMove = false;
	      this.isBottomMove = false;
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  }
	  var options = typeof script === 'function' ? script.options : script;
	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true;
	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  }
	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    hook = function hook(context) {
	      context = context ||
	      this.$vnode && this.$vnode.ssrContext ||
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      }
	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      }
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    };
	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}
	var normalizeComponent_1 = normalizeComponent;

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('section', {
	    ref: "scrollHome",
	    staticClass: "bk-scroll-home",
	    class: _vm.extCls,
	    on: {
	      "mousewheel": _vm.handleWheel,
	      "DOMMouseScroll": _vm.handleWheel
	    }
	  }, [_c('main', {
	    staticClass: "bk-scroll-main"
	  }, [_vm.showIndex ? _c('ul', {
	    staticClass: "bk-scroll-index bk-scroll",
	    style: {
	      height: _vm.ulHeight + "px",
	      top: -_vm.totalScrollHeight + "px",
	      width: _vm.indexWidth + "px"
	    }
	  }, _vm._l(_vm.indexList, function (item, index) {
	    return _c('li', {
	      key: index,
	      staticClass: "bk-scroll-item",
	      style: {
	        height: _vm.itemHeight + "px",
	        top: item.top + "px"
	      }
	    }, [_vm._t("index", [_vm._v("\n                    " + _vm._s(item.value) + "\n                ")], {
	      data: item.value
	    })], 2);
	  }), 0) : _vm._e(), _c('ul', {
	    ref: "scrollMain",
	    staticClass: "bk-scroll",
	    style: {
	      height: _vm.ulHeight + "px",
	      top: -_vm.totalScrollHeight + "px",
	      width: _vm.mainWidth + "px",
	      left: _vm.mainLeft + "px"
	    }
	  }, _vm._l(_vm.listData, function (item) {
	    return _c('li', {
	      key: item.top,
	      staticClass: "bk-scroll-item",
	      style: {
	        height: _vm.itemHeight + "px",
	        top: item.top + "px",
	        left: -_vm.bottomScrollDis * (_vm.itemWidth - _vm.mainWidth) / (_vm.mainWidth - _vm.bottomScrollWidth) + "px"
	      }
	    }, [_vm._t("default", null, {
	      data: item.value
	    })], 2);
	  }), 0)]), _c('canvas', {
	    ref: "minNav",
	    staticClass: "bk-min-nav",
	    style: "height: " + _vm.visHeight + "px;"
	  }), _vm.navHeight < _vm.visHeight ? _c('span', {
	    ref: "scrollNav",
	    staticClass: "bk-min-nav-slide bk-nav-show",
	    style: {
	      height: _vm.navHeight + "px",
	      top: _vm.minNavTop + "px"
	    },
	    on: {
	      "mousedown": function mousedown($event) {
	        _vm.startNavMove(_vm.visHeight - _vm.navHeight);
	      }
	    }
	  }) : _vm._e(), _vm.bottomScrollWidth < _vm.mainWidth ? _c('span', {
	    staticClass: "bk-min-nav-slide bk-bottom-scroll",
	    style: {
	      left: _vm.indexWidth + _vm.bottomScrollDis + "px",
	      width: _vm.bottomScrollWidth + "px"
	    },
	    on: {
	      "mousedown": _vm.startBottomMove
	    }
	  }) : _vm._e()]);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	function setInstaller (component, afterInstall) {
	  component.install = function (Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var props = component.props || {};
	    keys$1(options).forEach(function (key) {
	      if (props.hasOwnProperty(key)) {
	        if (typeof props[key] === 'function' || props[key] instanceof Array) {
	          props[key] = {
	            type: props[key],
	            default: options[key]
	          };
	        } else {
	          props[key].default = options[key];
	        }
	      }
	    });
	    component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
	    Vue.component(component.name, component);
	    typeof afterInstall === 'function' && afterInstall(Vue, options);
	  };
	}

	setInstaller(__vue_component__);

	/* script */

	/* template */
	var __vue_render__$1 = function __vue_render__(_h, _vm) {
	  var _c = _vm._c;
	  return _vm.props.node.visible ? _c('div', {
	    staticClass: "bk-big-tree-node clearfix",
	    class: {
	      'is-root': _vm.props.node.parent === null,
	      'is-leaf': !_vm.props.node.isFolder && _vm.props.node.isLeaf,
	      'is-folder': _vm.props.node.isFolder,
	      'is-expand': _vm.props.node.expanded,
	      'is-selected': _vm.props.node.selected,
	      'is-disabled': _vm.props.node.disabled,
	      'is-checked': _vm.props.node.checked,
	      'has-link-line': _vm.props.node.tree.hasLine
	    },
	    style: {
	      '--level': _vm.props.node.level,
	      '--line': _vm.props.node.line,
	      '--padding': _vm.props.node.tree.padding + "px"
	    },
	    attrs: {
	      "id": _vm.props.node.uid
	    },
	    on: {
	      "click": function click($event) {
	        _vm.props.node.tree.handleNodeClick(_vm.props.node);
	      }
	    }
	  }, [_c('div', {
	    staticClass: "node-options fl"
	  }, [_vm.props.node.loading ? _c('i', {
	    class: _vm.props.node.tree.loadingClass
	  }) : _vm.props.node.isFolder || !_vm.props.node.isLeaf ? _c('i', {
	    class: ['node-folder-icon', _vm.props.node.expanded ? _vm.props.node.expandIcon : _vm.props.node.collapseIcon],
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();

	        _vm.props.node.tree.handleNodeExpand(_vm.props.node);
	      }
	    }
	  }) : _vm._e(), _vm.props.node.hasCheckbox ? _c('span', {
	    staticClass: "node-checkbox",
	    class: {
	      'is-disabled': _vm.props.node.disabled,
	      'is-checked': _vm.props.node.checked,
	      'is-indeterminate': _vm.props.node.indeterminate
	    },
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();

	        _vm.props.node.tree.handleNodeCheck(_vm.props.node);
	      }
	    }
	  }) : _vm._e(), _vm.props.node.nodeIcon ? _c('i', {
	    class: ['node-icon', _vm.props.node.nodeIcon]
	  }) : _vm._e()]), _c('div', {
	    staticClass: "node-content"
	  }, [_vm._t("default", [_vm._v("\n            " + _vm._s(_vm.props.node.name) + "\n        ")], {
	    node: _vm.props.node,
	    data: _vm.props.node.data
	  })], 2)]) : _vm._e();
	};

	var __vue_staticRenderFns__$1 = [];
	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* module identifier */

	var __vue_module_identifier__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = true;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1, {}, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	var idSeed = 0;
	var script$1 = {
	  name: 'bk-big-tree',
	  components: {
	    bkVirtualScroll: __vue_component__,
	    treeItem: __vue_component__$1
	  },
	  mixins: [locale.mixin],
	  props: {
	    data: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    options: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    lazyMethod: Function,
	    lazyDisabled: [Boolean, Function],
	    selectable: Boolean,
	    showCheckbox: [Boolean, Function],
	    checkStrictly: {
	      type: Boolean,
	      default: true
	    },
	    checkOnlyAvailableStrictly: Boolean,
	    disableStrictly: {
	      type: Boolean,
	      default: true
	    },
	    displayMatchedNodeDescendants: Boolean,
	    showLinkLine: Boolean,
	    expandIcon: {
	      type: String,
	      default: 'bk-icon icon-down-shape'
	    },
	    collapseIcon: {
	      type: String,
	      default: 'bk-icon icon-right-shape'
	    },
	    loadingClass: {
	      type: String,
	      default: 'node-loading'
	    },
	    nodeIcon: {
	      type: [String, Function]
	    },
	    defaultExpandAll: Boolean,
	    defaultExpandedNodes: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    defaultCheckedNodes: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    defaultSelectedNode: {
	      type: [String, Number],
	      default: null
	    },
	    defaultDisabledNodes: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    beforeSelect: Function,
	    beforeCheck: Function,
	    expandOnClick: {
	      type: Boolean,
	      default: true
	    },
	    checkOnClick: Boolean,
	    filterMethod: Function,
	    nodeWidth: {
	      type: [String, Number]
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    useDefaultEmpty: Boolean,
	    height: Number,
	    nodeHeight: {
	      type: Number,
	      default: 32
	    },
	    configurable: {
	      type: Boolean,
	      default: true
	    },
	    padding: {
	      type: Number,
	      default: 16
	    },
	    size: {
	      type: String,
	      default: 'normal'
	    }
	  },
	  data: function data() {
	    return {
	      nodes: [],
	      map: {},
	      selected: this.defaultSelectedNode,
	      needsCalculateNodes: [],
	      calculateTimer: null,
	      inSearch: false,
	      isSearchEmpty: false,
	      id: "bk-big-tree-".concat(idSeed++)
	    };
	  },
	  computed: {
	    computedNodeWidth: function computedNodeWidth() {
	      var parsedWidth = _parseInt$2(this.nodeWidth);
	      if (isNaN(parsedWidth)) {
	        return null;
	      }
	      return parsedWidth;
	    },
	    nodeOptions: function nodeOptions() {
	      var nodeOptions = {
	        idKey: 'id',
	        nameKey: 'name',
	        childrenKey: 'children'
	      };
	      return _extends(nodeOptions, this.options);
	    },
	    checkedNodes: function checkedNodes() {
	      return this.nodes.filter(function (node) {
	        return node.checked && node.hasCheckbox;
	      });
	    },
	    checked: function checked() {
	      return this.checkedNodes.map(function (node) {
	        return node.id;
	      });
	    },
	    visibleNodes: function visibleNodes() {
	      return this.nodes.filter(function (node) {
	        return !!node.visible;
	      });
	    },
	    treeHeight: function treeHeight() {
	      return this.height ? "".concat(this.height, "px") : 'auto';
	    },
	    hasLine: function hasLine() {
	      return !this.height && this.showLinkLine;
	    }
	  },
	  watch: {
	    needsCalculateNodes: function needsCalculateNodes() {
	      this.handleCalculateLine();
	    },
	    data: function data(value) {
	      this.setData(value);
	    },
	    hasLine: function hasLine(_hasLine) {
	      var _this$needsCalculateN;
	      _hasLine && (_this$needsCalculateN = this.needsCalculateNodes).push.apply(_this$needsCalculateN, _toConsumableArray(this.visibleNodes));
	    }
	  },
	  mounted: function mounted() {
	    this.setData(this.data);
	  },
	  methods: {
	    setData: function setData(data) {
	      var _this$needsCalculateN2;
	      var nodes = [];
	      var map = {};
	      this.recurrenceNodes(data, null, nodes, map);
	      this.nodes = nodes;
	      this.map = map;
	      this.initNodeState();
	      this.setVirtualScrollList();
	      this.registryOptions(this.nodes);
	      this.hasLine && (_this$needsCalculateN2 = this.needsCalculateNodes).push.apply(_this$needsCalculateN2, _toConsumableArray(this.visibleNodes));
	    },
	    registryOptions: function registryOptions(nodes) {
	      var parent = this.$parent.$parent || this.$root;
	      var name = parent.$options.name;
	      if (name && name === 'bk-select' && parent.registerOption) {
	        parent.autoUpdate = true;
	        nodes.forEach(function (node) {
	          parent.registerOption({
	            id: node.id,
	            name: node.name,
	            disabled: node.disabled,
	            unmatched: false,
	            isHighlight: false
	          });
	        });
	      }
	    },
	    recurrenceNodes: function recurrenceNodes(data, parent, nodes, map) {
	      var _this = this;
	      data.forEach(function (datum, index) {
	        var node = new TreeNode(datum, {
	          level: parent ? parent.level + 1 : 0,
	          parent: parent,
	          index: nodes.length
	        }, _this);
	        if (parent) {
	          node.childIndex = parent.children.length;
	          parent.children.push(node);
	        }
	        nodes.push(node);
	        map[node.id] = node;
	        var children = datum[_this.nodeOptions.childrenKey];
	        if (isArray$1(children) && children.length) {
	          _this.recurrenceNodes(children, node, nodes, map);
	        }
	      });
	    },
	    getNodeById: function getNodeById(id) {
	      return this.map[id];
	    },
	    initNodeState: function initNodeState() {
	      !this.defaultExpandAll && this.initDefaultExpanded();
	      this.initDefaultChecked();
	      this.initDefaultDisabled();
	    },
	    initDefaultExpanded: function initDefaultExpanded() {
	      var _this2 = this;
	      var defaultExpandedNodes = this.defaultSelectedNode !== null ? [].concat(_toConsumableArray(this.defaultExpandedNodes), [this.defaultSelectedNode]) : this.defaultExpandedNodes;
	      defaultExpandedNodes.forEach(function (id) {
	        var node = _this2.getNodeById(id);
	        if (node) {
	          node.expanded = true;
	        }
	      });
	    },
	    initDefaultChecked: function initDefaultChecked() {
	      var _this3 = this;
	      this.defaultCheckedNodes.forEach(function (id) {
	        var node = _this3.getNodeById(id);
	        if (node) {
	          node.checked = true;
	        }
	      });
	    },
	    initDefaultDisabled: function initDefaultDisabled() {
	      var _this4 = this;
	      this.defaultDisabledNodes.forEach(function (id) {
	        var node = _this4.getNodeById(id);
	        if (node) {
	          node.disabled = true;
	        }
	      });
	    },
	    addNode: function addNode(nodeData, parentId) {
	      var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	      var options = _typeof(parentId) === 'object' ? parentId : {
	        parentId: parentId,
	        trailing: trailing
	      };
	      var mergeOptions = _extends({
	        parentId: null,
	        trailing: true,
	        expandParent: true
	      }, options);
	      var data = convertToArray(nodeData);
	      if (!data.length) {
	        return [];
	      }
	      if (isNullOrUndefined(mergeOptions.parentId)) {
	        return this.addRootNode(data, mergeOptions);
	      }
	      return this.addChildNode(data, mergeOptions);
	    },
	    addRootNode: function addRootNode(data, _ref) {
	      var _this5 = this,
	          _this$nodes;
	      var trailing = _ref.trailing;
	      var rootNodes = this.nodes.filter(function (node) {
	        return node.level === 0;
	      });
	      var offset = typeof trailing === 'number' ? Math.min(trailing, rootNodes.length) : trailing ? rootNodes.length : 0;
	      var insertIndex = 0;
	      if (offset > 0) {
	        var referenceRoot = rootNodes[offset - 1];
	        var referenceRootWithDescendants = [referenceRoot].concat(_toConsumableArray(referenceRoot.descendants));
	        var referenceNode = referenceRootWithDescendants[referenceRootWithDescendants.length - 1];
	        insertIndex = referenceNode.index + 1;
	      }
	      var nodes = data.map(function (datum) {
	        return new TreeNode(datum, {
	          level: 0,
	          parent: null
	        }, _this5);
	      });
	      nodes.forEach(function (node) {
	        _this5.$set(_this5.map, node.id, node);
	      });
	      (_this$nodes = this.nodes).splice.apply(_this$nodes, [insertIndex, 0].concat(_toConsumableArray(nodes)));
	      this.nodes.slice(insertIndex).forEach(function (node, index) {
	        node.index = insertIndex + index;
	      });
	      this.setVirtualScrollList();
	      return nodes;
	    },
	    addChildNode: function addChildNode(data, options) {
	      var _this6 = this,
	          _this$nodes2;
	      var parentId = options.parentId,
	          trailing = options.trailing;
	      var parent = this.getNodeById(parentId);
	      if (!parent) {
	        console.warn('Unexpected parent id, add node failed');
	        return;
	      }
	      var children = parent.children;
	      var offset = typeof trailing === 'number' ? Math.min(trailing, children.length) : trailing ? children.length : 0;
	      var insertIndex;
	      if (offset > 0) {
	        var referenceChild = children[offset - 1];
	        var referenceChildWithDescendants = [referenceChild].concat(_toConsumableArray(referenceChild.descendants));
	        var referenceNode = referenceChildWithDescendants[referenceChildWithDescendants.length - 1];
	        insertIndex = referenceNode.index + 1;
	      } else {
	        insertIndex = parent.index + 1;
	      }
	      var nodes = data.map(function (datum) {
	        return new TreeNode(datum, {
	          level: parent.level + 1,
	          parent: parent
	        }, _this6);
	      });
	      parent.appendChild(nodes, offset, options);
	      nodes.forEach(function (node) {
	        _this6.$set(_this6.map, node.id, node);
	      });
	      (_this$nodes2 = this.nodes).splice.apply(_this$nodes2, [insertIndex, 0].concat(_toConsumableArray(nodes)));
	      this.nodes.slice(insertIndex).forEach(function (node, index) {
	        node.index = insertIndex + index;
	      });
	      this.setVirtualScrollList();
	      return nodes;
	    },
	    removeNode: function removeNode(nodeId) {
	      var _this7 = this;
	      try {
	        var ids = convertToArray(nodeId);
	        var nodes = [];
	        ids.forEach(function (id) {
	          var node = _this7.getNodeById(id);
	          if (node) {
	            nodes.push(node);
	          }
	        });
	        nodes.sort(function (M, N) {
	          return N.index - M.index;
	        });
	        nodes.forEach(function (node) {
	          var removeNodes = [node].concat(_toConsumableArray(node.descendants));
	          _this7.nodes.splice(node.index, removeNodes.length);
	          if (node.parent) {
	            node.parent.removeChild(node);
	          }
	        });
	        var minChangedIndex = Math.min.apply(Math, _toConsumableArray(nodes.map(function (node) {
	          return node.index;
	        })));
	        this.nodes.slice(minChangedIndex).forEach(function (node, index) {
	          node.index = minChangedIndex + index;
	        });
	        this.setVirtualScrollList();
	      } catch (e) {
	        console.warn(e.message);
	      }
	    },
	    setSelected: function setSelected(nodeId) {
	      var _this8 = this;
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return _asyncToGenerator( regenerator.mark(function _callee() {
	        var mergeOptions, node, response;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.prev = 0;
	                if (!(!_this8.selectable || nodeId === _this8.selected)) {
	                  _context.next = 3;
	                  break;
	                }
	                return _context.abrupt("return", false);
	              case 3:
	                mergeOptions = _objectSpread({
	                  emitEvent: false,
	                  beforeSelect: true
	                }, options);
	                node = _this8.getNodeById(nodeId);
	                if (!(mergeOptions.beforeSelect && typeof _this8.beforeSelect === 'function')) {
	                  _context.next = 11;
	                  break;
	                }
	                _context.next = 8;
	                return _this8.beforeSelect(node);
	              case 8:
	                response = _context.sent;
	                if (response) {
	                  _context.next = 11;
	                  break;
	                }
	                return _context.abrupt("return", false);
	              case 11:
	                _this8.selected = nodeId;
	                if (mergeOptions.emitEvent) {
	                  _this8.$emit('select-change', node);
	                }
	                _context.next = 18;
	                break;
	              case 15:
	                _context.prev = 15;
	                _context.t0 = _context["catch"](0);
	                console.warn(_context.t0.message);
	              case 18:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, null, [[0, 15]]);
	      }))();
	    },
	    removeChecked: function removeChecked() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      try {
	        var mergeOptions = _objectSpread({
	          emitEvent: true
	        }, options);
	        this.checkedNodes.forEach(function (node) {
	          node.checked = false;
	        });
	        if (mergeOptions.emitEvent) {
	          this.$emit('check-change', [], null, null);
	        }
	      } catch (e) {
	        console.warn(e.message);
	      }
	    },
	    setChecked: function setChecked(nodeId) {
	      var _this9 = this;
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      return _asyncToGenerator( regenerator.mark(function _callee2() {
	        var isMultiple, ids, mergeOptions, nodes, response;
	        return regenerator.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.prev = 0;
	                isMultiple = isArray$1(nodeId);
	                ids = isMultiple ? nodeId : [nodeId];
	                if (!ids.length) {
	                  _context2.next = 14;
	                  break;
	                }
	                mergeOptions = _objectSpread({
	                  emitEvent: false,
	                  beforeCheck: true,
	                  checked: true
	                }, options);
	                nodes = ids.map(function (id) {
	                  return _this9.getNodeById(id);
	                });
	                if (!(mergeOptions.beforeCheck && typeof _this9.beforeCheck === 'function')) {
	                  _context2.next = 12;
	                  break;
	                }
	                _context2.next = 9;
	                return _this9.beforeCheck(nodes.length > 1 ? nodes : nodes[0], mergeOptions.checked);
	              case 9:
	                response = _context2.sent;
	                if (response) {
	                  _context2.next = 12;
	                  break;
	                }
	                return _context2.abrupt("return", false);
	              case 12:
	                nodes.forEach(function (node) {
	                  node.checked = mergeOptions.checked;
	                });
	                if (mergeOptions.emitEvent) {
	                  setTimeout(function () {
	                    _this9.$emit('check-change', _this9.checked, isMultiple ? nodes : nodes[0]);
	                  }, 0);
	                }
	              case 14:
	                _context2.next = 19;
	                break;
	              case 16:
	                _context2.prev = 16;
	                _context2.t0 = _context2["catch"](0);
	                console.warn(_context2.t0.message);
	              case 19:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, null, [[0, 16]]);
	      }))();
	    },
	    setExpanded: function setExpanded(nodeId) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      try {
	        var mergeOptions = _objectSpread({
	          expanded: true,
	          emitEvent: false
	        }, options);
	        var node = this.getNodeById(nodeId);
	        if (!node) {
	          console.warn('Unexpected node id, set expanded failed.');
	          return false;
	        }
	        node.expanded = mergeOptions.expanded;
	        if (mergeOptions.emitEvent) {
	          this.$emit('expand-change', node);
	        }
	        this.setVirtualScrollList();
	      } catch (e) {
	        console.warn(e.message);
	      }
	    },
	    setDisabled: function setDisabled(nodeId) {
	      var _this10 = this;
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      try {
	        var mergeOptions = _objectSpread({
	          disabled: true,
	          emitEvent: false
	        }, options);
	        var ids = convertToArray(nodeId);
	        var nodes = ids.map(function (id) {
	          return _this10.getNodeById(id);
	        }).filter(function (node) {
	          return !!node;
	        });
	        nodes.forEach(function (node) {
	          node.disabled = mergeOptions.disabled;
	        });
	        if (mergeOptions.emitEvent) {
	          this.$emit('disable-change', nodes.length > 1 ? nodes : nodes[0]);
	        }
	      } catch (e) {
	        console.warn(e.message);
	      }
	    },
	    handleCalculateLine: function handleCalculateLine() {
	      var _this11 = this;
	      this.calculateTimer && clearTimeout(this.calculateTimer);
	      if (this.needsCalculateNodes.length) {
	        this.calculateTimer = setTimeout(function () {
	          _this11.needsCalculateNodes.forEach(function (node) {
	            _this11.calculateNodeLine(node);
	          });
	          _this11.needsCalculateNodes.splice(0);
	        }, 0);
	      } else {
	        this.calculateTimer = null;
	      }
	    },
	    calculateNodeLine: function calculateNodeLine(node) {
	      var children = node.children,
	          isLeaf = node.isLeaf,
	          expanded = node.expanded;
	      if (isLeaf || !expanded) {
	        node.line = 0;
	        return;
	      }
	      var visibleChildren = children.filter(function (child) {
	        return child.visible;
	      });
	      if (!visibleChildren.length) {
	        node.line = 0;
	        return;
	      }
	      var firstChild = visibleChildren[0];
	      var firstChildElement = this.$el.querySelector("#".concat(firstChild.uid));
	      var lastChild = visibleChildren[visibleChildren.length - 1];
	      var lastChildElement = this.$el.querySelector("#".concat(lastChild.uid));
	      node.line = lastChildElement.getBoundingClientRect().bottom - firstChildElement.getBoundingClientRect().top;
	    },
	    defaultFilterMethod: function defaultFilterMethod(keyword, node) {
	      return String(node.name).toLowerCase().indexOf(keyword) > -1;
	    },
	    filter: function filter() {
	      var _this12 = this;
	      var keyword = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	      var matchedNodes = [];
	      var filterMethod = this.filterMethod || this.defaultFilterMethod;
	      if (keyword === '') {
	        this.inSearch = false;
	        this.nodes.forEach(function (node) {
	          node.setState('matched', true);
	          node.recalculateLinkLine();
	          if (_this12.checkOnlyAvailableStrictly) {
	            node.setState('checked', false);
	          }
	          matchedNodes.push(node);
	        });
	      } else {
	        this.inSearch = true;
	        var convertKeyword = this.filterMethod ? keyword : String(keyword).toLowerCase();
	        this.nodes.forEach(function (node) {
	          var matched = filterMethod(convertKeyword, node);
	          node.setState('matched', matched);
	          if (_this12.checkOnlyAvailableStrictly) {
	            node.setState('checked', false);
	          }
	          if (matched) {
	            node.parent && (node.parent.expanded = true);
	            matchedNodes.push(node);
	          } else {
	            node.recalculateLinkLine();
	          }
	        });
	      }
	      this.isSearchEmpty = matchedNodes.length === 0;
	      this.setVirtualScrollList();
	      return matchedNodes;
	    },
	    handleNodeClick: function handleNodeClick(node) {
	      if (node.disabled) {
	        return false;
	      }
	      this.$emit('node-click', node);
	      this.setSelected(node.id, {
	        emitEvent: true,
	        beforeSelect: true
	      });
	      if (this.expandOnClick && !node.isLeaf) {
	        this.setExpanded(node.id, {
	          emitEvent: true,
	          expanded: !node.expanded
	        });
	      }
	      if (this.checkOnClick) {
	        this.setChecked(node.id, {
	          emitEvent: true,
	          checked: !node.checked
	        });
	      }
	    },
	    handleNodeExpand: function handleNodeExpand(node) {
	      this.setExpanded(node.id, {
	        expanded: !node.expanded,
	        emitEvent: true
	      });
	    },
	    handleNodeCheck: function handleNodeCheck(node) {
	      if (node.disabled) {
	        return false;
	      }
	      this.setChecked(node.id, {
	        checked: node.indeterminate ? true : !node.checked,
	        emitEvent: true,
	        beforeCheck: true
	      });
	    },
	    setVirtualScrollList: function setVirtualScrollList() {
	      var _this13 = this;
	      if (!this.height) return;
	      if (!this.$refs.virtualScroll) {
	        console.warn('virtual dom is not ready');
	        return;
	      }
	      this.$nextTick(function () {
	        _this13.$refs.virtualScroll.setListData(_this13.visibleNodes);
	      });
	    },
	    resize: function resize() {
	      this.$refs.virtualScroll && this.$refs.virtualScroll.resize();
	    }
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    class: ['bk-big-tree', _vm.extCls, {
	      'with-virtual-scroll': !!_vm.height
	    }, {
	      'bk-big-tree--small': _vm.size === 'small'
	    }],
	    style: {
	      height: _vm.treeHeight
	    }
	  }, [_vm.height ? _c('bk-virtual-scroll', {
	    ref: "virtualScroll",
	    attrs: {
	      "item-height": _vm.nodeHeight
	    },
	    scopedSlots: _vm._u([{
	      key: "default",
	      fn: function fn(ref) {
	        var node = ref.data;
	        return _c('tree-item', {
	          attrs: {
	            "node": node,
	            "id": "bk-big-tree-" + _vm.id + "-node-" + node.id
	          }
	        }, [_vm._t("default", null, {
	          node: node,
	          data: node.data
	        })], 2);
	      }
	    }])
	  }) : _vm._l(_vm.nodes, function (node) {
	    return [_c('tree-item', {
	      key: node.id,
	      ref: node.id,
	      refInFor: true,
	      attrs: {
	        "node": node
	      }
	    }, [_vm._t("default", null, {
	      node: node,
	      data: node.data
	    })], 2)];
	  }), (_vm.$slots.empty || _vm.useDefaultEmpty) && _vm.isSearchEmpty ? _c('div', {
	    staticClass: "bk-big-tree-empty"
	  }, [_vm._t("empty", [_vm._v("\n            " + _vm._s(_vm.t('bk.bigTree.emptyText')) + "\n        ")])], 2) : _vm._e()], 2);
	};

	var __vue_staticRenderFns__$2 = [];
	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* module identifier */

	var __vue_module_identifier__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$2, __vue_script__$1, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$2);

	exports.default = __vue_component__$2;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
