(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('bk-magic-vue/lib/locale')) :
	typeof define === 'function' && define.amd ? define(['exports', 'vue', 'bk-magic-vue/lib/locale'], factory) :
	(global = global || self, factory(global.library = {}, global.Vue, global.locale));
}(this, function (exports, Vue, locale) { 'use strict';

	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
	locale = locale && locale.hasOwnProperty('default') ? locale['default'] : locale;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  : Function('return this')();
	if (typeof __g == 'number') __g = global;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.12' };
	if (typeof __e == 'number') __e = core;
	});
	var _core_1 = _core.version;

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function () {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var PROTOTYPE = 'prototype';
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    out = own ? target[key] : source[key];
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    : IS_BIND && own ? _ctx(out, _global)
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;

	var toString = {}.toString;
	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _library = true;

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');
	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');
	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var f$1 = {}.propertyIsEnumerable;
	var _objectPie = {
		f: f$1
	};

	var isEnum = _objectPie.f;
	var _objectToArray = function (isEntries) {
	  return function (it) {
	    var O = _toIobject(it);
	    var keys = _objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!_descriptors || isEnum.call(O, key)) {
	        result.push(isEntries ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var $values = _objectToArray(false);
	_export(_export.S, 'Object', {
	  values: function values(it) {
	    return $values(it);
	  }
	});

	var values = _core.Object.values;

	var values$1 = values;

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function (obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function (obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
	  try {
	    var info = gen[key](arg);
	    var value = info.value;
	  } catch (error) {
	    reject(error);
	    return;
	  }

	  if (info.done) {
	    resolve(value);
	  } else {
	    Promise.resolve(value).then(_next, _throw);
	  }
	}

	function _asyncToGenerator(fn) {
	  return function () {
	    var self = this,
	        args = arguments;
	    return new Promise(function (resolve, reject) {
	      var gen = fn.apply(self, args);

	      function _next(value) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
	      }

	      function _throw(err) {
	        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
	      }

	      _next(undefined);
	    });
	  };
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? Object(arguments[i]) : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(o);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

	  return arr2;
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _createForOfIteratorHelper(o, allowArrayLike) {
	  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

	  if (!it) {
	    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
	      if (it) o = it;
	      var i = 0;

	      var F = function () {};

	      return {
	        s: F,
	        n: function () {
	          if (i >= o.length) return {
	            done: true
	          };
	          return {
	            done: false,
	            value: o[i++]
	          };
	        },
	        e: function (e) {
	          throw e;
	        },
	        f: F
	      };
	    }

	    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	  }

	  var normalCompletion = true,
	      didErr = false,
	      err;
	  return {
	    s: function () {
	      it = it.call(o);
	    },
	    n: function () {
	      var step = it.next();
	      normalCompletion = step.done;
	      return step;
	    },
	    e: function (e) {
	      didErr = true;
	      err = e;
	    },
	    f: function () {
	      try {
	        if (!normalCompletion && it.return != null) it.return();
	      } finally {
	        if (didErr) throw err;
	      }
	    }
	  };
	}

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	_export(_export.S, 'Array', { isArray: _isArray });

	var isArray = _core.Array.isArray;

	var isArray$1 = isArray;

	function throttle (delay, noTrailing, callback, debounceMode) {
	  var timeoutID;
	  var cancelled = false;
	  var lastExec = 0;
	  function clearExistingTimeout() {
	    if (timeoutID) {
	      clearTimeout(timeoutID);
	    }
	  }
	  function cancel() {
	    clearExistingTimeout();
	    cancelled = true;
	  }
	  if (typeof noTrailing !== 'boolean') {
	    debounceMode = callback;
	    callback = noTrailing;
	    noTrailing = undefined;
	  }
	  function wrapper() {
	    var self = this;
	    var elapsed = Date.now() - lastExec;
	    var args = arguments;
	    if (cancelled) {
	      return;
	    }
	    function exec() {
	      lastExec = Date.now();
	      callback.apply(self, args);
	    }
	    function clear() {
	      timeoutID = undefined;
	    }
	    if (debounceMode && !timeoutID) {
	      exec();
	    }
	    clearExistingTimeout();
	    if (debounceMode === undefined && elapsed > delay) {
	      exec();
	    } else if (noTrailing !== true) {
	      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
	    }
	  }
	  wrapper.cancel = cancel;
	  return wrapper;
	}
	function debounce (delay, atBegin, callback) {
	  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
	}

	var requestFrame = function () {
	  var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
	    return window.setTimeout(fn, 20);
	  };
	  return function (fn) {
	    return raf(fn);
	  };
	}();
	var cancelFrame = function () {
	  var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
	  return function (id) {
	    return cancel(id);
	  };
	}();
	var resetTrigger = function resetTrigger(element) {
	  var trigger = element.__resizeTrigger__;
	  var expand = trigger.firstElementChild;
	  var contract = trigger.lastElementChild;
	  var expandChild = expand.firstElementChild;
	  contract.scrollLeft = contract.scrollWidth;
	  contract.scrollTop = contract.scrollHeight;
	  expandChild.style.width = expand.offsetWidth + 1 + 'px';
	  expandChild.style.height = expand.offsetHeight + 1 + 'px';
	  expand.scrollLeft = expand.scrollWidth;
	  expand.scrollTop = expand.scrollHeight;
	};
	var checkTriggers = function checkTriggers(element) {
	  return element.offsetWidth !== element.__resizeLast__.width || element.offsetHeight !== element.__resizeLast__.height;
	};
	var scrollListener = function scrollListener(event) {
	  var _this = this;
	  resetTrigger(this);
	  if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
	  this.__resizeRAF__ = requestFrame(function () {
	    if (checkTriggers(_this)) {
	      _this.__resizeLast__.width = _this.offsetWidth;
	      _this.__resizeLast__.height = _this.offsetHeight;
	      _this.__resizeListeners__.forEach(function (fn) {
	        fn.call(_this, event);
	      });
	    }
	  });
	};
	var attachEvent = document.attachEvent;
	var DOM_PREFIXES = 'Webkit Moz O ms'.split(' ');
	var START_EVENTS = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' ');
	var RESIZE_ANIMATION_NAME = 'resizeanim';
	var animation = false;
	var keyFramePrefix = '';
	var animationStartEvent = 'animationstart';
	if (!attachEvent) {
	  var testElement = document.createElement('fakeelement');
	  if (testElement.style.animationName !== undefined) {
	    animation = true;
	  }
	  if (animation === false) {
	    var prefix = '';
	    for (var i = 0; i < DOM_PREFIXES.length; i++) {
	      if (testElement.style[DOM_PREFIXES[i] + 'AnimationName'] !== undefined) {
	        prefix = DOM_PREFIXES[i];
	        keyFramePrefix = '-' + prefix.toLowerCase() + '-';
	        animationStartEvent = START_EVENTS[i];
	        animation = true;
	        break;
	      }
	    }
	  }
	}
	var stylesCreated = false;
	var createStyles = function createStyles() {
	  if (!stylesCreated) {
	    var animationKeyframes = "@".concat(keyFramePrefix, "keyframes ").concat(RESIZE_ANIMATION_NAME, " { from { opacity: 0; } to { opacity: 0; } } ");
	    var animationStyle = "".concat(keyFramePrefix, "animation: 1ms ").concat(RESIZE_ANIMATION_NAME, ";");
	    var css = "".concat(animationKeyframes, "\n      .resize-triggers { ").concat(animationStyle, " visibility: hidden; opacity: 0; }\n      .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1 }\n      .resize-triggers > div { background: #eee; overflow: auto; }\n      .contract-trigger:before { width: 200%; height: 200%; }");
	    var head = document.head || document.getElementsByTagName('head')[0];
	    var style = document.createElement('style');
	    style.type = 'text/css';
	    if (style.styleSheet) {
	      style.styleSheet.cssText = css;
	    } else {
	      style.appendChild(document.createTextNode(css));
	    }
	    head.appendChild(style);
	    stylesCreated = true;
	  }
	};
	var addResizeListener = function addResizeListener(element, fn) {
	  if (attachEvent) {
	    element.attachEvent('onresize', fn);
	  } else {
	    if (!element.__resizeTrigger__) {
	      if (getComputedStyle(element).position === 'static') {
	        element.style.position = 'relative';
	      }
	      createStyles();
	      element.__resizeLast__ = {};
	      element.__resizeListeners__ = [];
	      var resizeTrigger = element.__resizeTrigger__ = document.createElement('div');
	      resizeTrigger.className = 'resize-triggers';
	      resizeTrigger.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
	      element.appendChild(resizeTrigger);
	      resetTrigger(element);
	      element.addEventListener('scroll', scrollListener, true);
	      if (animationStartEvent) {
	        resizeTrigger.addEventListener(animationStartEvent, function (event) {
	          if (event.animationName === RESIZE_ANIMATION_NAME) {
	            resetTrigger(element);
	          }
	        });
	      }
	    }
	    element.__resizeListeners__.push(fn);
	  }
	};
	var removeResizeListener = function removeResizeListener(element, fn) {
	  if (!element || !element.__resizeListeners__) return;
	  if (attachEvent) {
	    element.detachEvent('onresize', fn);
	  } else {
	    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
	    if (!element.__resizeListeners__.length) {
	      element.removeEventListener('scroll', scrollListener);
	      element.__resizeTrigger__ = !element.removeChild(element.__resizeTrigger__);
	    }
	  }
	};

	var _populated = false;
	var _ie, _firefox, _opera, _webkit, _chrome;
	var _ie_real_version;
	var _osx, _windows, _linux, _android;
	var _win64;
	var _iphone, _ipad, _native;
	var _mobile;
	function _populate() {
	  if (_populated) {
	    return;
	  }
	  _populated = true;
	  var uas = navigator.userAgent;
	  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
	  var os    = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
	  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
	  _ipad = /\b(iP[ao]d)/.exec(uas);
	  _android = /Android/i.exec(uas);
	  _native = /FBAN\/\w+;/i.exec(uas);
	  _mobile = /Mobile/i.exec(uas);
	  _win64 = !!(/Win64/.exec(uas));
	  if (agent) {
	    _ie = agent[1] ? parseFloat(agent[1]) : (
	          agent[5] ? parseFloat(agent[5]) : NaN);
	    if (_ie && document && document.documentMode) {
	      _ie = document.documentMode;
	    }
	    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
	    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
	    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
	    _opera   = agent[3] ? parseFloat(agent[3]) : NaN;
	    _webkit  = agent[4] ? parseFloat(agent[4]) : NaN;
	    if (_webkit) {
	      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
	      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
	    } else {
	      _chrome = NaN;
	    }
	  } else {
	    _ie = _firefox = _opera = _chrome = _webkit = NaN;
	  }
	  if (os) {
	    if (os[1]) {
	      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
	      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
	    } else {
	      _osx = false;
	    }
	    _windows = !!os[2];
	    _linux   = !!os[3];
	  } else {
	    _osx = _windows = _linux = false;
	  }
	}
	var UserAgent_DEPRECATED = {
	  ie: function() {
	    return _populate() || _ie;
	  },
	  ieCompatibilityMode: function() {
	    return _populate() || (_ie_real_version > _ie);
	  },
	  ie64: function() {
	    return UserAgent_DEPRECATED.ie() && _win64;
	  },
	  firefox: function() {
	    return _populate() || _firefox;
	  },
	  opera: function() {
	    return _populate() || _opera;
	  },
	  webkit: function() {
	    return _populate() || _webkit;
	  },
	  safari: function() {
	    return UserAgent_DEPRECATED.webkit();
	  },
	  chrome : function() {
	    return _populate() || _chrome;
	  },
	  windows: function() {
	    return _populate() || _windows;
	  },
	  osx: function() {
	    return _populate() || _osx;
	  },
	  linux: function() {
	    return _populate() || _linux;
	  },
	  iphone: function() {
	    return _populate() || _iphone;
	  },
	  mobile: function() {
	    return _populate() || (_iphone || _ipad || _android || _mobile);
	  },
	  nativeApp: function() {
	    return _populate() || _native;
	  },
	  android: function() {
	    return _populate() || _android;
	  },
	  ipad: function() {
	    return _populate() || _ipad;
	  }
	};
	var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

	var canUseDOM = !!(
	  typeof window !== 'undefined' &&
	  window.document &&
	  window.document.createElement
	);
	var ExecutionEnvironment = {
	  canUseDOM: canUseDOM,
	  canUseWorkers: typeof Worker !== 'undefined',
	  canUseEventListeners:
	    canUseDOM && !!(window.addEventListener || window.attachEvent),
	  canUseViewport: canUseDOM && !!window.screen,
	  isInWorker: !canUseDOM
	};
	var ExecutionEnvironment_1 = ExecutionEnvironment;

	var useHasFeature;
	if (ExecutionEnvironment_1.canUseDOM) {
	  useHasFeature =
	    document.implementation &&
	    document.implementation.hasFeature &&
	    document.implementation.hasFeature('', '') !== true;
	}
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment_1.canUseDOM ||
	      capture && !('addEventListener' in document)) {
	    return false;
	  }
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	  return isSupported;
	}
	var isEventSupported_1 = isEventSupported;

	var PIXEL_STEP  = 10;
	var LINE_HEIGHT = 40;
	var PAGE_HEIGHT = 800;
	function normalizeWheel( event)  {
	  var sX = 0, sY = 0,
	      pX = 0, pY = 0;
	  if ('detail'      in event) { sY = event.detail; }
	  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
	  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
	  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }
	  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
	    sX = sY;
	    sY = 0;
	  }
	  pX = sX * PIXEL_STEP;
	  pY = sY * PIXEL_STEP;
	  if ('deltaY' in event) { pY = event.deltaY; }
	  if ('deltaX' in event) { pX = event.deltaX; }
	  if ((pX || pY) && event.deltaMode) {
	    if (event.deltaMode == 1) {
	      pX *= LINE_HEIGHT;
	      pY *= LINE_HEIGHT;
	    } else {
	      pX *= PAGE_HEIGHT;
	      pY *= PAGE_HEIGHT;
	    }
	  }
	  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
	  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }
	  return { spinX  : sX,
	           spinY  : sY,
	           pixelX : pX,
	           pixelY : pY };
	}
	normalizeWheel.getEventType = function()  {
	  return (UserAgent_DEPRECATED_1.firefox())
	           ? 'DOMMouseScroll'
	           : (isEventSupported_1('wheel'))
	               ? 'wheel'
	               : 'mousewheel';
	};
	var normalizeWheel_1 = normalizeWheel;

	var normalizeWheel$1 = normalizeWheel_1;

	var isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
	var mousewheel = function mousewheel(element, callback) {
	  if (element && element.addEventListener) {
	    element.addEventListener(isFirefox ? 'DOMMouseScroll' : 'mousewheel', function (event) {
	      var normalized = normalizeWheel$1(event);
	      callback && callback.apply(this, [event, normalized]);
	    });
	  }
	};
	var Mousewheel = {
	  bind: function bind(el, binding) {
	    mousewheel(el, binding.value);
	  }
	};

	_export(_export.S, 'Number', {
	  isNaN: function isNaN(number) {
	    return number != number;
	  }
	});

	var isNan = _core.Number.isNaN;

	var isNan$1 = isNan;

	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	var $Object = _core.Object;
	var defineProperty = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};

	var defineProperty$1 = defineProperty;

	var hasInitZIndex = false;
	var zIndex;
	(function () {
	  if (!window['__bk_zIndex_manager']) {
	    var zIndexManager = {
	      nextZIndex: function nextZIndex() {
	        var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
	        return zIndex === 'default' ? zIndexManager.zIndex++ : zIndex;
	      },
	      nextTickIndex: function nextTickIndex() {
	        var tick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	        var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	        if (zIndex === 'default') {
	          zIndexManager.zIndex += tick;
	          return zIndexManager.zIndex;
	        }
	        return zIndex;
	      }
	    };
	    defineProperty$1(zIndexManager, 'zIndex', {
	      configurable: true,
	      get: function get() {
	        if (!hasInitZIndex) {
	          zIndex = zIndex || (Vue.prototype.$BK_EL || {}).zIndex || 2000;
	          hasInitZIndex = true;
	        }
	        return zIndex;
	      },
	      set: function set(value) {
	        zIndex = value;
	      }
	    });
	    window['__bk_zIndex_manager'] = zIndexManager;
	  }
	})();
	var zIndexManager = window['__bk_zIndex_manager'];

	var script = {
	  name: 'bk-loading',
	  props: {
	    isLoading: {
	      type: Boolean,
	      default: false
	    },
	    title: {
	      type: [String, Object],
	      default: ''
	    },
	    mode: {
	      type: String,
	      default: 'normal'
	    },
	    size: {
	      type: String,
	      default: 'large'
	    },
	    theme: {
	      type: String,
	      default: 'colorful'
	    },
	    delay: {
	      type: Number,
	      default: 0
	    },
	    immediate: {
	      type: Boolean,
	      default: false
	    },
	    opacity: {
	      type: Number,
	      default: 0.9
	    },
	    color: {
	      type: String,
	      default: '#ffffff'
	    },
	    zIndex: {
	      type: Number
	    },
	    afterLeave: {
	      type: Function
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    type: {
	      type: String,
	      default: 'default'
	    }
	  },
	  data: function data() {
	    return {
	      timer: 0,
	      hide: false,
	      duration: 500,
	      isShow: false
	    };
	  },
	  computed: {
	    isSpin: function isSpin() {
	      return this.mode === 'spin';
	    },
	    bgColor: function bgColor() {
	      var color = this.color.replace(/\s/gm, '');
	      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(color)) {
	        var colors = color.substring(1).split('');
	        if (colors.length === 3) {
	          colors = [colors[0], colors[0], colors[1], colors[1], colors[2], colors[2]];
	        }
	        colors = '0x' + colors.join('');
	        return 'rgba(' + [colors >> 16 & 255, colors >> 8 & 255, colors & 255].join(',') + ",".concat(this.opacity, ")");
	      } else if (/^rgba?\(([^\)]+)\)/.test(color)) {
	        return color.replace(/^rgb\(([^\)]+)\)/, "rgba($1,".concat(this.opacity, ")"));
	      }
	      return this.color;
	    },
	    computedClass: function computedClass() {
	      return this.isSpin ? "bk-spin-loading bk-spin-loading-".concat(this.size, " bk-spin-loading-").concat(this.theme) : "bk-loading1 bk-".concat(this.theme, " bk-size-").concat(this.size);
	    },
	    hasZIndexOption: function hasZIndexOption() {
	      if (this.type === 'fixed') {
	        return;
	      }
	      return typeof this.zIndex === 'number' && !isNan$1(this.zIndex);
	    }
	  },
	  watch: {
	    hide: function hide(newVal) {
	      var _this = this;
	      if (newVal) {
	        var delay = isNaN(this.delay) ? 0 : Number(this.delay);
	        clearTimeout(this.timer);
	        if (delay > 0) {
	          this.timer = setTimeout(function () {
	            _this.hideLoading();
	          }, delay);
	        } else {
	          this.hideLoading();
	        }
	      }
	    },
	    isShow: function isShow(newVal) {
	      if (newVal && !this.hasZIndexOption) {
	        this.zIndex = zIndexManager.nextZIndex();
	      }
	    },
	    isLoading: {
	      handler: function handler(newVal) {
	        if (this.type === 'default') {
	          if (newVal) {
	            this.isShow = newVal;
	          } else {
	            this.hide = true;
	          }
	        }
	      },
	      immediate: true
	    }
	  },
	  mounted: function mounted() {
	    this.hide = false;
	  },
	  methods: {
	    hideLoading: function hideLoading() {
	      this.isShow = false;
	      this.$el.addEventListener('transitionend', this.destroyEl);
	    },
	    destroyEl: function destroyEl() {
	      this.$el.removeEventListener('transitionend', this.destroyEl);
	      this.$destroy();
	      this.$el.parentNode.removeChild(this.$el);
	    },
	    animationFinish: function animationFinish() {
	      if (this.afterLeave && typeof this.afterLeave === 'function') {
	        this.afterLeave();
	      }
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  }
	  var options = typeof script === 'function' ? script.options : script;
	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true;
	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  }
	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    hook = function hook(context) {
	      context = context ||
	      this.$vnode && this.$vnode.ssrContext ||
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      }
	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      }
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    };
	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}
	var normalizeComponent_1 = normalizeComponent;

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.type === 'default' ? _c('div', {
	    staticClass: "bk-loading bk-default-loading",
	    class: _vm.extCls,
	    style: {
	      position: 'relative'
	    }
	  }, [_c('div', {
	    staticClass: "bk-loading-body"
	  }, [_vm._t("default")], 2), _c('transition', {
	    attrs: {
	      "name": "fade",
	      "duration": {
	        enter: _vm.duration
	      }
	    },
	    on: {
	      "after-leave": _vm.animationFinish
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.isShow,
	      expression: "isShow"
	    }],
	    staticClass: "bk-loading-wrapper",
	    style: {
	      zIndex: _vm.zIndex,
	      backgroundColor: _vm.bgColor
	    }
	  }, [_c('div', {
	    class: _vm.computedClass
	  }, [_vm.isSpin ? [_c('div', {
	    staticClass: "rotate rotate1"
	  }), _c('div', {
	    staticClass: "rotate rotate2"
	  }), _c('div', {
	    staticClass: "rotate rotate3"
	  }), _c('div', {
	    staticClass: "rotate rotate4"
	  }), _c('div', {
	    staticClass: "rotate rotate5"
	  }), _c('div', {
	    staticClass: "rotate rotate6"
	  }), _c('div', {
	    staticClass: "rotate rotate7"
	  }), _c('div', {
	    staticClass: "rotate rotate8"
	  })] : [_c('div', {
	    staticClass: "point point1"
	  }), _c('div', {
	    staticClass: "point point2"
	  }), _c('div', {
	    staticClass: "point point3"
	  }), _c('div', {
	    staticClass: "point point4"
	  })]], 2), _c('div', {
	    staticClass: "bk-loading-title"
	  }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])], 1) : _c('transition', {
	    attrs: {
	      "name": "fade",
	      "duration": {
	        enter: _vm.duration
	      }
	    },
	    on: {
	      "after-leave": _vm.animationFinish
	    }
	  }, [_c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.isShow,
	      expression: "isShow"
	    }],
	    staticClass: "bk-loading",
	    class: _vm.extCls,
	    style: {
	      position: _vm.type,
	      zIndex: _vm.zIndex,
	      backgroundColor: _vm.bgColor
	    }
	  }, [_c('div', {
	    staticClass: "bk-loading-wrapper"
	  }, [_c('div', {
	    class: _vm.computedClass
	  }, [_vm.isSpin ? [_c('div', {
	    staticClass: "rotate rotate1"
	  }), _c('div', {
	    staticClass: "rotate rotate2"
	  }), _c('div', {
	    staticClass: "rotate rotate3"
	  }), _c('div', {
	    staticClass: "rotate rotate4"
	  }), _c('div', {
	    staticClass: "rotate rotate5"
	  }), _c('div', {
	    staticClass: "rotate rotate6"
	  }), _c('div', {
	    staticClass: "rotate rotate7"
	  }), _c('div', {
	    staticClass: "rotate rotate8"
	  })] : [_c('div', {
	    staticClass: "point point1"
	  }), _c('div', {
	    staticClass: "point point2"
	  }), _c('div', {
	    staticClass: "point point3"
	  }), _c('div', {
	    staticClass: "point point4"
	  })]], 2), _c('div', {
	    staticClass: "bk-loading-title"
	  }, [_vm._t("title", [_vm._v(_vm._s(_vm.title))])], 2)])])]);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	var Model = Vue.extend(__vue_component__);
	function show(el, options) {
	  if (!el.$vm) {
	    el.$vm = el.viewmodel.$mount();
	    el.appendChild(el.$vm.$el);
	  }
	  el.$vm.duration = 0;
	  Vue.nextTick(function () {
	    el.$vm.isShow = true;
	  });
	}
	function toggle(el, options) {
	  if (!el.$vm) {
	    el.$vm = el.viewmodel.$mount();
	    el.appendChild(el.$vm.$el);
	  }
	  clearTimeout(el.$vm.timer);
	  if (options.isLoading) {
	    Vue.nextTick(function () {
	      el.$vm.isShow = true;
	    });
	  } else {
	    var delay = isNaN(options.delay) ? 0 : Number(options.delay);
	    if (delay > 0) {
	      el.$vm.timer = setTimeout(function () {
	        el.$vm.isShow = false;
	      }, delay);
	    } else {
	      el.$vm.isShow = false;
	    }
	  }
	  if (options.title) {
	    el.$vm.title = options.title;
	  }
	}
	var bkLoading = {
	  inserted: function inserted(el, binding) {
	    var value = binding.value;
	    var position = getComputedStyle(el).position;
	    var options = {};
	    if (!position || position !== 'relative' || position !== 'absolute') {
	      el.style.position = 'relative';
	    }
	    for (var key in value) {
	      if (key !== 'isLoading') {
	        options[key] = value[key];
	      }
	    }
	    options.delay = 3000;
	    options.type = 'absolute';
	    options.opacity = options.opacity || 0.9;
	    options.color = options.color || '#ffffff';
	    el.viewmodel = new Model({
	      propsData: options
	    });
	    if (options.immediate) {
	      show(el, binding.value);
	    } else {
	      toggle(el, binding.value);
	    }
	  },
	  update: function update(el, binding) {
	    toggle(el, binding.value);
	  }
	};

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	var _redefine = _hide;

	var _meta = createCommonjsModule(function (module) {
	var META = _uid('meta');
	var setDesc = _objectDp.f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !_fails(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id,
	    w: {}
	  } });
	};
	var fastKey = function (it, create) {
	  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!_has(it, META)) {
	    if (!isExtensible(it)) return 'F';
	    if (!create) return 'E';
	    setMeta(it);
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!_has(it, META)) {
	    if (!isExtensible(it)) return true;
	    if (!create) return false;
	    setMeta(it);
	  } return it[META].w;
	};
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};
	});
	var _meta_1 = _meta.KEY;
	var _meta_2 = _meta.NEED;
	var _meta_3 = _meta.fastKey;
	var _meta_4 = _meta.getWeak;
	var _meta_5 = _meta.onFreeze;

	var _wks = createCommonjsModule(function (module) {
	var store = _shared('wks');
	var Symbol = _global.Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';
	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));
	};
	$exports.store = store;
	});

	var def = _objectDp.f;
	var TAG = _wks('toStringTag');
	var _setToStringTag = function (it, tag, stat) {
	  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};

	var f$2 = _wks;
	var _wksExt = {
		f: f$2
	};

	var defineProperty$2 = _objectDp.f;
	var _wksDefine = function (name) {
	  var $Symbol = _core.Symbol || (_core.Symbol =  {} );
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty$2($Symbol, name, { value: _wksExt.f(name) });
	};

	var f$3 = Object.getOwnPropertySymbols;
	var _objectGops = {
		f: f$3
	};

	var _enumKeys = function (it) {
	  var result = _objectKeys(it);
	  var getSymbols = _objectGops.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = _objectPie.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};

	var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  _anObject(O);
	  var keys = _objectKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

	var document$2 = _global.document;
	var _html = document$2 && document$2.documentElement;

	var IE_PROTO$1 = _sharedKey('IE_PROTO');
	var Empty = function () {  };
	var PROTOTYPE$1 = 'prototype';
	var createDict = function () {
	  var iframe = _domCreate('iframe');
	  var i = _enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  _html.appendChild(iframe);
	  iframe.src = 'javascript:';
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];
	  return createDict();
	};
	var _objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE$1] = _anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE$1] = null;
	    result[IE_PROTO$1] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : _objectDps(result, Properties);
	};

	var hiddenKeys = _enumBugKeys.concat('length', 'prototype');
	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return _objectKeysInternal(O, hiddenKeys);
	};
	var _objectGopn = {
		f: f$4
	};

	var gOPN = _objectGopn.f;
	var toString$1 = {}.toString;
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};
	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));
	};
	var _objectGopnExt = {
		f: f$5
	};

	var gOPD = Object.getOwnPropertyDescriptor;
	var f$6 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = _toIobject(O);
	  P = _toPrimitive(P, true);
	  if (_ie8DomDefine) try {
	    return gOPD(O, P);
	  } catch (e) {  }
	  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
	};
	var _objectGopd = {
		f: f$6
	};

	var META = _meta.KEY;
	var gOPD$1 = _objectGopd.f;
	var dP$1 = _objectDp.f;
	var gOPN$1 = _objectGopnExt.f;
	var $Symbol = _global.Symbol;
	var $JSON = _global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE$2 = 'prototype';
	var HIDDEN = _wks('_hidden');
	var TO_PRIMITIVE = _wks('toPrimitive');
	var isEnum$1 = {}.propertyIsEnumerable;
	var SymbolRegistry = _shared('symbol-registry');
	var AllSymbols = _shared('symbols');
	var OPSymbols = _shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE$2];
	var USE_NATIVE = typeof $Symbol == 'function' && !!_objectGops.f;
	var QObject = _global.QObject;
	var setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;
	var setSymbolDesc = _descriptors && _fails(function () {
	  return _objectCreate(dP$1({}, 'a', {
	    get: function () { return dP$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD$1(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP$1(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP$1(ObjectProto, key, protoDesc);
	} : dP$1;
	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);
	  sym._k = tag;
	  return sym;
	};
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};
	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  _anObject(it);
	  key = _toPrimitive(key, true);
	  _anObject(D);
	  if (_has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!_has(it, HIDDEN)) dP$1(it, HIDDEN, _propertyDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP$1(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  _anObject(it);
	  var keys = _enumKeys(P = _toIobject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum$1.call(this, key = _toPrimitive(key, true));
	  if (this === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;
	  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = _toIobject(it);
	  key = _toPrimitive(key, true);
	  if (it === ObjectProto && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;
	  var D = gOPD$1(it, key);
	  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN$1(_toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, _propertyDesc(1, value));
	    };
	    if (_descriptors && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {
	    return this._k;
	  });
	  _objectGopd.f = $getOwnPropertyDescriptor;
	  _objectDp.f = $defineProperty;
	  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;
	  _objectPie.f = $propertyIsEnumerable;
	  _objectGops.f = $getOwnPropertySymbols;
	  if (_descriptors && !_library) {
	    _redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	  _wksExt.f = function (name) {
	    return wrap(_wks(name));
	  };
	}
	_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Symbol: $Symbol });
	for (var es6Symbols = (
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);
	for (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);
	_export(_export.S + _export.F * !USE_NATIVE, 'Symbol', {
	  'for': function (key) {
	    return _has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});
	_export(_export.S + _export.F * !USE_NATIVE, 'Object', {
	  create: $create,
	  defineProperty: $defineProperty,
	  defineProperties: $defineProperties,
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  getOwnPropertyNames: $getOwnPropertyNames,
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	var FAILS_ON_PRIMITIVES = _fails(function () { _objectGops.f(1); });
	_export(_export.S + _export.F * FAILS_ON_PRIMITIVES, 'Object', {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return _objectGops.f(_toObject(it));
	  }
	});
	$JSON && _export(_export.S + _export.F * (!USE_NATIVE || _fails(function () {
	  var S = $Symbol();
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return;
	    if (!_isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);
	_setToStringTag($Symbol, 'Symbol');
	_setToStringTag(Math, 'Math', true);
	_setToStringTag(_global.JSON, 'JSON', true);

	var getOwnPropertySymbols = _core.Object.getOwnPropertySymbols;

	var getOwnPropertySymbols$1 = getOwnPropertySymbols;

	var _for = _core.Symbol['for'];

	var _for$1 = _for;

	_wksDefine('asyncIterator');

	_wksDefine('observable');

	var symbol = _core.Symbol;

	var symbol$1 = symbol;

	var canUseSymbol = typeof symbol$1 === 'function' && _for$1;
	var REACT_ELEMENT_TYPE = canUseSymbol ? _for$1('react.element') : 0xeac7;
	function isReactElement(value) {
	  return value.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isNonNullObject(value) {
	  return !!value && _typeof(value) === 'object';
	}
	function isSpecial(value) {
	  var stringValue = Object.prototype.toString.call(value);
	  return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
	}
	function defaultIsMergeableObject (value) {
	  return isNonNullObject(value) && !isSpecial(value);
	}

	function emptyTarget(val) {
	  return isArray$1(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, options) {
	  return !!options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
	}
	function defaultArrayMerge(target, source, options) {
	  return target.concat(source).map(function (element) {
	    return cloneUnlessOtherwiseSpecified(element, options);
	  });
	}
	function getMergeFunction(key, options) {
	  if (!options.customMerge) {
	    return deepmerge;
	  }
	  var customMerge = options.customMerge(key);
	  return typeof customMerge === 'function' ? customMerge : deepmerge;
	}
	function getEnumerableOwnPropertySymbols(target) {
	  return getOwnPropertySymbols$1 ? getOwnPropertySymbols$1(target).filter(function (symbol) {
	    return target.propertyIsEnumerable(symbol);
	  }) : [];
	}
	function getKeys(target) {
	  return keys$1(target).concat(getEnumerableOwnPropertySymbols(target));
	}
	function propertyIsOnObject(object, property) {
	  try {
	    return property in object;
	  } catch (_) {
	    return false;
	  }
	}
	function propertyIsUnsafe(target, key) {
	  return propertyIsOnObject(target, key)
	  && !(Object.hasOwnProperty.call(target, key)
	  && Object.propertyIsEnumerable.call(target, key));
	}
	function mergeObject(target, source, options) {
	  var destination = {};
	  if (options.isMergeableObject(target)) {
	    getKeys(target).forEach(function (key) {
	      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
	    });
	  }
	  getKeys(source).forEach(function (key) {
	    if (propertyIsUnsafe(target, key)) {
	      return;
	    }
	    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
	      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
	    } else {
	      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
	    }
	  });
	  return destination;
	}
	function deepmerge(target, source, options) {
	  options = options || {};
	  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	  options.isMergeableObject = options.isMergeableObject || defaultIsMergeableObject;
	  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
	  var sourceIsArray = isArray$1(source);
	  var targetIsArray = isArray$1(target);
	  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
	  if (!sourceAndTargetTypesMatch) {
	    return cloneUnlessOtherwiseSpecified(source, options);
	  } else if (sourceIsArray) {
	    return options.arrayMerge(target, source, options);
	  } else {
	    return mergeObject(target, source, options);
	  }
	}
	deepmerge.all = function deepmergeAll(array, options) {
	  if (!isArray$1(array)) {
	    throw new Error('first argument should be an array');
	  }
	  return array.reduce(function (prev, next) {
	    return deepmerge(prev, next, options);
	  }, {});
	};

	var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	  window.setTimeout(callback, 1000 / 60);
	};
	var cancelAnimationFrame$1 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
	  window.clearTimeout(id);
	};
	var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
	var MOZ_HACK_REGEXP = /^moz([A-Z])/;
	var trim = function trim(string) {
	  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
	};
	var camelCase = function camelCase(name) {
	  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
	    return offset ? letter.toUpperCase() : letter;
	  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
	};
	function hasClass(el, cls) {
	  if (!el || !cls) return false;
	  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');
	  if (el.classList) {
	    return el.classList.contains(cls);
	  } else {
	    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
	  }
	}
	function addClass(el, cls) {
	  if (!el) return;
	  var curClass = el.className;
	  var classes = (cls || '').split(' ');
	  for (var i = 0, j = classes.length; i < j; i++) {
	    var clsName = classes[i];
	    if (!clsName) continue;
	    if (el.classList) {
	      el.classList.add(clsName);
	    } else if (!hasClass(el, clsName)) {
	      curClass += ' ' + clsName;
	    }
	  }
	  if (!el.classList) {
	    el.className = curClass;
	  }
	}
	function removeClass(el, cls) {
	  if (!el || !cls) return;
	  var classes = cls.split(' ');
	  var curClass = ' ' + el.className + ' ';
	  for (var i = 0, j = classes.length; i < j; i++) {
	    var clsName = classes[i];
	    if (!clsName) continue;
	    if (el.classList) {
	      el.classList.remove(clsName);
	    } else if (hasClass(el, clsName)) {
	      curClass = curClass.replace(' ' + clsName + ' ', ' ');
	    }
	  }
	  if (!el.classList) {
	    el.className = trim(curClass);
	  }
	}
	var getStyle = Number(document.documentMode) < 9 ? function (element, styleName) {
	  if (!element || !styleName) return null;
	  styleName = camelCase(styleName);
	  if (styleName === 'float') {
	    styleName = 'styleFloat';
	  }
	  try {
	    switch (styleName) {
	      case 'opacity':
	        try {
	          return element.filters.item('alpha').opacity / 100;
	        } catch (e) {
	          return 1.0;
	        }
	      default:
	        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
	    }
	  } catch (e) {
	    return element.style[styleName];
	  }
	} : function (element, styleName) {
	  if (!element || !styleName) return null;
	  styleName = camelCase(styleName);
	  if (styleName === 'float') {
	    styleName = 'cssFloat';
	  }
	  try {
	    var computed = document.defaultView.getComputedStyle(element, '');
	    return element.style[styleName] || computed ? computed[styleName] : null;
	  } catch (e) {
	    return element.style[styleName];
	  }
	};

	var runtime_1 = createCommonjsModule(function (module) {
	var runtime = (function (exports) {
	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1;
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    define({}, "");
	  } catch (err) {
	    define = function(obj, key, value) {
	      return obj[key] = value;
	    };
	  }
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	    return generator;
	  }
	  exports.wrap = wrap;
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	  var ContinueSentinel = {};
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  define(Gp, "constructor", GeneratorFunctionPrototype);
	  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
	  GeneratorFunction.displayName = define(
	    GeneratorFunctionPrototype,
	    toStringTagSymbol,
	    "GeneratorFunction"
	  );
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      define(prototype, method, function(arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }
	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };
	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	        return PromiseImpl.resolve(value).then(function(unwrapped) {
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }
	    var previousPromise;
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	      return previousPromise =
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	    this._invoke = enqueue;
	  }
	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator;
	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList),
	      PromiseImpl
	    );
	    return exports.isGeneratorFunction(outerFn)
	      ? iter
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	        return doneResult();
	      }
	      context.method = method;
	      context.arg = arg;
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	        if (context.method === "next") {
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	        state = GenStateExecuting;
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      context.delegate = null;
	      if (context.method === "throw") {
	        if (delegate.iterator["return"]) {
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);
	          if (context.method === "throw") {
	            return ContinueSentinel;
	          }
	        }
	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }
	      return ContinueSentinel;
	    }
	    var record = tryCatch(method, delegate.iterator, context.arg);
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    var info = record.arg;
	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    if (info.done) {
	      context[delegate.resultName] = info.value;
	      context.next = delegate.nextLoc;
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }
	    } else {
	      return info;
	    }
	    context.delegate = null;
	    return ContinueSentinel;
	  }
	  defineIteratorMethods(Gp);
	  define(Gp, toStringTagSymbol, "Generator");
	  define(Gp, iteratorSymbol, function() {
	    return this;
	  });
	  define(Gp, "toString", function() {
	    return "[object Generator]";
	  });
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	    this.tryEntries.push(entry);
	  }
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	  function Context(tryLocsList) {
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	      next.done = true;
	      return next;
	    };
	  };
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	          next.value = undefined$1;
	          next.done = true;
	          return next;
	        };
	        return next.next = next;
	      }
	    }
	    return { next: doneResult };
	  }
	  exports.values = values;
	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }
	  Context.prototype = {
	    constructor: Context,
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;
	      this.method = "next";
	      this.arg = undefined$1;
	      this.tryEntries.forEach(resetTryEntry);
	      if (!skipTempReset) {
	        for (var name in this) {
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },
	    stop: function() {
	      this.done = true;
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	      return this.rval;
	    },
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        if (caught) {
	          context.method = "next";
	          context.arg = undefined$1;
	        }
	        return !! caught;
	      }
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	        if (entry.tryLoc === "root") {
	          return handle("end");
	        }
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        finallyEntry = null;
	      }
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	      return this.complete(record);
	    },
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	      return ContinueSentinel;
	    },
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	      if (this.method === "next") {
	        this.arg = undefined$1;
	      }
	      return ContinueSentinel;
	    }
	  };
	  return exports;
	}(
	   module.exports 
	));
	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  if (typeof globalThis === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}
	});

	var regenerator = runtime_1;

	var _stringAt = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(_defined(that));
	    var i = _toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

	var _iterators = {};

	var IteratorPrototype = {};
	_hide(IteratorPrototype, _wks('iterator'), function () { return this; });
	var _iterCreate = function (Constructor, NAME, next) {
	  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
	  _setToStringTag(Constructor, NAME + ' Iterator');
	};

	var IE_PROTO$2 = _sharedKey('IE_PROTO');
	var ObjectProto$1 = Object.prototype;
	var _objectGpo = Object.getPrototypeOf || function (O) {
	  O = _toObject(O);
	  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto$1 : null;
	};

	var ITERATOR = _wks('iterator');
	var BUGGY = !([].keys && 'next' in [].keys());
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';
	var returnThis = function () { return this; };
	var _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  _iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  if ($anyNative) {
	    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      _setToStringTag(IteratorPrototype, TAG, true);
	    }
	  }
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  if (( FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    _hide(proto, ITERATOR, $default);
	  }
	  _iterators[NAME] = $default;
	  _iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) _redefine(proto, key, methods[key]);
	    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

	var $at = _stringAt(true);
	_iterDefine(String, 'String', function (iterated) {
	  this._t = String(iterated);
	  this._i = 0;
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});

	var _iterStep = function (done, value) {
	  return { value: value, done: !!done };
	};

	var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
	  this._t = _toIobject(iterated);
	  this._i = 0;
	  this._k = kind;
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return _iterStep(1);
	  }
	  if (kind == 'keys') return _iterStep(0, index);
	  if (kind == 'values') return _iterStep(0, O[index]);
	  return _iterStep(0, [index, O[index]]);
	}, 'values');
	_iterators.Arguments = _iterators.Array;

	var TO_STRING_TAG = _wks('toStringTag');
	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
	  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
	  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
	  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
	  'TextTrackList,TouchList').split(',');
	for (var i$1 = 0; i$1 < DOMIterables.length; i$1++) {
	  var NAME = DOMIterables[i$1];
	  var Collection = _global[NAME];
	  var proto = Collection && Collection.prototype;
	  if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
	  _iterators[NAME] = _iterators.Array;
	}

	var TAG$1 = _wks('toStringTag');
	var ARG = _cof(function () { return arguments; }()) == 'Arguments';
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (e) {  }
	};
	var _classof = function (it) {
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T
	    : ARG ? _cof(O)
	    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

	var _anInstance = function (it, Constructor, name, forbiddenField) {
	  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

	var _iterCall = function (iterator, fn, value, entries) {
	  try {
	    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
	  } catch (e) {
	    var ret = iterator['return'];
	    if (ret !== undefined) _anObject(ret.call(iterator));
	    throw e;
	  }
	};

	var ITERATOR$1 = _wks('iterator');
	var ArrayProto = Array.prototype;
	var _isArrayIter = function (it) {
	  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);
	};

	var ITERATOR$2 = _wks('iterator');
	var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$2]
	    || it['@@iterator']
	    || _iterators[_classof(it)];
	};

	var _forOf = createCommonjsModule(function (module) {
	var BREAK = {};
	var RETURN = {};
	var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
	  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);
	  var f = _ctx(fn, that, entries ? 2 : 1);
	  var index = 0;
	  var length, step, iterator, result;
	  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
	  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
	    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if (result === BREAK || result === RETURN) return result;
	  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
	    result = _iterCall(iterator, f, step.value, entries);
	    if (result === BREAK || result === RETURN) return result;
	  }
	};
	exports.BREAK = BREAK;
	exports.RETURN = RETURN;
	});

	var SPECIES = _wks('species');
	var _speciesConstructor = function (O, D) {
	  var C = _anObject(O).constructor;
	  var S;
	  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);
	};

	var _invoke = function (fn, args, that) {
	  var un = that === undefined;
	  switch (args.length) {
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return fn.apply(that, args);
	};

	var process = _global.process;
	var setTask = _global.setImmediate;
	var clearTask = _global.clearImmediate;
	var MessageChannel = _global.MessageChannel;
	var Dispatch = _global.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function () {
	  var id = +this;
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function (event) {
	  run.call(event.data);
	};
	if (!setTask || !clearTask) {
	  setTask = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      _invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id) {
	    delete queue[id];
	  };
	  if (_cof(process) == 'process') {
	    defer = function (id) {
	      process.nextTick(_ctx(run, id, 1));
	    };
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(_ctx(run, id, 1));
	    };
	  } else if (MessageChannel) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = _ctx(port.postMessage, port, 1);
	  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {
	    defer = function (id) {
	      _global.postMessage(id + '', '*');
	    };
	    _global.addEventListener('message', listener, false);
	  } else if (ONREADYSTATECHANGE in _domCreate('script')) {
	    defer = function (id) {
	      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {
	        _html.removeChild(this);
	        run.call(id);
	      };
	    };
	  } else {
	    defer = function (id) {
	      setTimeout(_ctx(run, id, 1), 0);
	    };
	  }
	}
	var _task = {
	  set: setTask,
	  clear: clearTask
	};

	var macrotask = _task.set;
	var Observer = _global.MutationObserver || _global.WebKitMutationObserver;
	var process$1 = _global.process;
	var Promise$1 = _global.Promise;
	var isNode = _cof(process$1) == 'process';
	var _microtask = function () {
	  var head, last, notify;
	  var flush = function () {
	    var parent, fn;
	    if (isNode && (parent = process$1.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (e) {
	        if (head) notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };
	  if (isNode) {
	    notify = function () {
	      process$1.nextTick(flush);
	    };
	  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {
	    var toggle = true;
	    var node = document.createTextNode('');
	    new Observer(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  } else if (Promise$1 && Promise$1.resolve) {
	    var promise = Promise$1.resolve(undefined);
	    notify = function () {
	      promise.then(flush);
	    };
	  } else {
	    notify = function () {
	      macrotask.call(_global, flush);
	    };
	  }
	  return function (fn) {
	    var task = { fn: fn, next: undefined };
	    if (last) last.next = task;
	    if (!head) {
	      head = task;
	      notify();
	    } last = task;
	  };
	};

	function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = _aFunction(resolve);
	  this.reject = _aFunction(reject);
	}
	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};
	var _newPromiseCapability = {
		f: f$7
	};

	var _perform = function (exec) {
	  try {
	    return { e: false, v: exec() };
	  } catch (e) {
	    return { e: true, v: e };
	  }
	};

	var navigator$1 = _global.navigator;
	var _userAgent = navigator$1 && navigator$1.userAgent || '';

	var _promiseResolve = function (C, x) {
	  _anObject(C);
	  if (_isObject(x) && x.constructor === C) return x;
	  var promiseCapability = _newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var _redefineAll = function (target, src, safe) {
	  for (var key in src) {
	    if (safe && target[key]) target[key] = src[key];
	    else _hide(target, key, src[key]);
	  } return target;
	};

	var SPECIES$1 = _wks('species');
	var _setSpecies = function (KEY) {
	  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];
	  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {
	    configurable: true,
	    get: function () { return this; }
	  });
	};

	var ITERATOR$3 = _wks('iterator');
	var SAFE_CLOSING = false;
	try {
	  var riter = [7][ITERATOR$3]();
	  riter['return'] = function () { SAFE_CLOSING = true; };
	  Array.from(riter, function () { throw 2; });
	} catch (e) {  }
	var _iterDetect = function (exec, skipClosing) {
	  if (!skipClosing && !SAFE_CLOSING) return false;
	  var safe = false;
	  try {
	    var arr = [7];
	    var iter = arr[ITERATOR$3]();
	    iter.next = function () { return { done: safe = true }; };
	    arr[ITERATOR$3] = function () { return iter; };
	    exec(arr);
	  } catch (e) {  }
	  return safe;
	};

	var task = _task.set;
	var microtask = _microtask();
	var PROMISE = 'Promise';
	var TypeError$1 = _global.TypeError;
	var process$2 = _global.process;
	var versions = process$2 && process$2.versions;
	var v8 = versions && versions.v8 || '';
	var $Promise = _global[PROMISE];
	var isNode$1 = _classof(process$2) == 'process';
	var empty = function () {  };
	var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
	var newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;
	var USE_NATIVE$1 = !!function () {
	  try {
	    var promise = $Promise.resolve(1);
	    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {
	      exec(empty, empty);
	    };
	    return (isNode$1 || typeof PromiseRejectionEvent == 'function')
	      && promise.then(empty) instanceof FakePromise
	      && v8.indexOf('6.6') !== 0
	      && _userAgent.indexOf('Chrome/66') === -1;
	  } catch (e) {  }
	}();
	var isThenable = function (it) {
	  var then;
	  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify = function (promise, isReject) {
	  if (promise._n) return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function () {
	    var value = promise._v;
	    var ok = promise._s == 1;
	    var i = 0;
	    var run = function (reaction) {
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (promise._h == 2) onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value);
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (e) {
	        if (domain && !exited) domain.exit();
	        reject(e);
	      }
	    };
	    while (chain.length > i) run(chain[i++]);
	    promise._c = [];
	    promise._n = false;
	    if (isReject && !promise._h) onUnhandled(promise);
	  });
	};
	var onUnhandled = function (promise) {
	  task.call(_global, function () {
	    var value = promise._v;
	    var unhandled = isUnhandled(promise);
	    var result, handler, console;
	    if (unhandled) {
	      result = _perform(function () {
	        if (isNode$1) {
	          process$2.emit('unhandledRejection', value, promise);
	        } else if (handler = _global.onunhandledrejection) {
	          handler({ promise: promise, reason: value });
	        } else if ((console = _global.console) && console.error) {
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if (unhandled && result.e) throw result.v;
	  });
	};
	var isUnhandled = function (promise) {
	  return promise._h !== 1 && (promise._a || promise._c).length === 0;
	};
	var onHandleUnhandled = function (promise) {
	  task.call(_global, function () {
	    var handler;
	    if (isNode$1) {
	      process$2.emit('rejectionHandled', promise);
	    } else if (handler = _global.onrejectionhandled) {
	      handler({ promise: promise, reason: promise._v });
	    }
	  });
	};
	var $reject = function (value) {
	  var promise = this;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise;
	  promise._v = value;
	  promise._s = 2;
	  if (!promise._a) promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function (value) {
	  var promise = this;
	  var then;
	  if (promise._d) return;
	  promise._d = true;
	  promise = promise._w || promise;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    if (then = isThenable(value)) {
	      microtask(function () {
	        var wrapper = { _w: promise, _d: false };
	        try {
	          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));
	        } catch (e) {
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch (e) {
	    $reject.call({ _w: promise, _d: false }, e);
	  }
	};
	if (!USE_NATIVE$1) {
	  $Promise = function Promise(executor) {
	    _anInstance(this, $Promise, PROMISE, '_h');
	    _aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));
	    } catch (err) {
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor) {
	    this._c = [];
	    this._a = undefined;
	    this._s = 0;
	    this._d = false;
	    this._v = undefined;
	    this._h = 0;
	    this._n = false;
	  };
	  Internal.prototype = _redefineAll($Promise.prototype, {
	    then: function then(onFulfilled, onRejected) {
	      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode$1 ? process$2.domain : undefined;
	      this._c.push(reaction);
	      if (this._a) this._a.push(reaction);
	      if (this._s) notify(this, false);
	      return reaction.promise;
	    },
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    this.promise = promise;
	    this.resolve = _ctx($resolve, promise, 1);
	    this.reject = _ctx($reject, promise, 1);
	  };
	  _newPromiseCapability.f = newPromiseCapability = function (C) {
	    return C === $Promise || C === Wrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}
	_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Promise: $Promise });
	_setToStringTag($Promise, PROMISE);
	_setSpecies(PROMISE);
	Wrapper = _core[PROMISE];
	_export(_export.S + _export.F * !USE_NATIVE$1, PROMISE, {
	  reject: function reject(r) {
	    var capability = newPromiseCapability(this);
	    var $$reject = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	_export(_export.S + _export.F * (_library ), PROMISE, {
	  resolve: function resolve(x) {
	    return _promiseResolve( this === Wrapper ? $Promise : this, x);
	  }
	});
	_export(_export.S + _export.F * !(USE_NATIVE$1 && _iterDetect(function (iter) {
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = _perform(function () {
	      var values = [];
	      var index = 0;
	      var remaining = 1;
	      _forOf(iterable, false, function (promise) {
	        var $index = index++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  },
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability(C);
	    var reject = capability.reject;
	    var result = _perform(function () {
	      _forOf(iterable, false, function (promise) {
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.e) reject(result.v);
	    return capability.promise;
	  }
	});

	_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {
	  var C = _speciesConstructor(this, _core.Promise || _global.Promise);
	  var isFunction = typeof onFinally == 'function';
	  return this.then(
	    isFunction ? function (x) {
	      return _promiseResolve(C, onFinally()).then(function () { return x; });
	    } : onFinally,
	    isFunction ? function (e) {
	      return _promiseResolve(C, onFinally()).then(function () { throw e; });
	    } : onFinally
	  );
	} });

	_export(_export.S, 'Promise', { 'try': function (callbackfn) {
	  var promiseCapability = _newPromiseCapability.f(this);
	  var result = _perform(callbackfn);
	  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
	  return promiseCapability.promise;
	} });

	var promise = _core.Promise;

	var getValueByPath = function getValueByPath(object, prop) {
	  prop = prop || '';
	  var paths = prop.split('.');
	  var current = object;
	  var result = null;
	  for (var i = 0, j = paths.length; i < j; i++) {
	    var path = paths[i];
	    if (!current) break;
	    if (i === j - 1) {
	      result = current[path];
	      break;
	    }
	    current = current[path];
	  }
	  return result;
	};
	var getCell = function getCell(event) {
	  var cell = event.target;
	  while (cell && cell.tagName.toUpperCase() !== 'HTML') {
	    if (cell.tagName.toUpperCase() === 'TD') {
	      return cell;
	    }
	    cell = cell.parentNode;
	  }
	  return null;
	};
	var isObject = function isObject(obj) {
	  return obj !== null && _typeof(obj) === 'object';
	};
	var orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {
	  if (!sortKey && !sortMethod && (!sortBy || isArray$1(sortBy) && !sortBy.length)) {
	    return array;
	  }
	  if (typeof reverse === 'string') {
	    reverse = reverse === 'descending' ? -1 : 1;
	  } else {
	    reverse = reverse && reverse < 0 ? -1 : 1;
	  }
	  var getKey = sortMethod ? null : function (value, index) {
	    if (sortBy) {
	      if (!isArray$1(sortBy)) {
	        sortBy = [sortBy];
	      }
	      return sortBy.map(function (by) {
	        if (typeof by === 'string') {
	          return getValueByPath(value, by);
	        } else {
	          return by(value, index, array);
	        }
	      });
	    }
	    if (sortKey !== '$key') {
	      if (isObject(value) && '$value' in value) value = value.$value;
	    }
	    return [isObject(value) ? getValueByPath(value, sortKey) : value];
	  };
	  var compare = function compare(a, b) {
	    if (sortMethod) {
	      return sortMethod(a.value, b.value);
	    }
	    for (var i = 0, len = a.key.length; i < len; i++) {
	      if (a.key[i] < b.key[i]) {
	        return -1;
	      }
	      if (a.key[i] > b.key[i]) {
	        return 1;
	      }
	    }
	    return 0;
	  };
	  return array.map(function (value, index) {
	    return {
	      value: value,
	      index: index,
	      key: getKey ? getKey(value, index) : null
	    };
	  }).sort(function (a, b) {
	    var order = compare(a, b);
	    if (!order) {
	      order = a.index - b.index;
	    }
	    return order * reverse;
	  }).map(function (item) {
	    return item.value;
	  });
	};
	var getColumnById = function getColumnById(table, columnId) {
	  var column = null;
	  table.columns.forEach(function (item) {
	    if (item.id === columnId) {
	      column = item;
	    }
	  });
	  return column;
	};
	var getColumnByCell = function getColumnByCell(table, cell) {
	  var matches = (cell.className || '').match(/bk-table-[^\s]+/gm);
	  if (matches) {
	    return getColumnById(table, matches[0]);
	  }
	  return null;
	};
	var getRowIdentity = function getRowIdentity(row, rowKey) {
	  if (!row) throw new Error('row is required when get row identity');
	  if (typeof rowKey === 'string') {
	    if (rowKey.indexOf('.') < 0) {
	      return row[rowKey];
	    }
	    var key = rowKey.split('.');
	    var current = row;
	    for (var i = 0; i < key.length; i++) {
	      current = current[key[i]];
	    }
	    return current;
	  } else if (typeof rowKey === 'function') {
	    return rowKey(row);
	  }
	};
	var isShallowEqual = function isShallowEqual() {
	  var current = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var currentKeys = keys$1(current);
	  var previousKeys = keys$1(previous);
	  if (currentKeys.length !== previousKeys.length) {
	    return false;
	  }
	  return !currentKeys.some(function (key) {
	    return current[key] !== previous[key];
	  });
	};

	var sortData = function sortData(data, states) {
	  var sortingColumn = states.sortingColumn;
	  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
	    return data;
	  }
	  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
	};
	var getKeysMap = function getKeysMap() {
	  var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  var rowKey = arguments.length > 1 ? arguments[1] : undefined;
	  var arrayMap = {};
	  array.forEach(function (row, index) {
	    arrayMap[getRowIdentity(row, rowKey)] = {
	      row: row,
	      index: index
	    };
	  });
	  return arrayMap;
	};
	var _toggleRowSelection = function toggleRowSelection(states, row, selected) {
	  var changed = false;
	  var selection = states.selection;
	  var index = selection.indexOf(row);
	  if (typeof selected === 'undefined') {
	    if (index === -1) {
	      selection.push(row);
	      changed = true;
	    } else {
	      selection.splice(index, 1);
	      changed = true;
	    }
	  } else {
	    if (selected && index === -1) {
	      selection.push(row);
	      changed = true;
	    } else if (!selected && index > -1) {
	      selection.splice(index, 1);
	      changed = true;
	    }
	  }
	  return changed;
	};
	var _toggleRowExpansion = function toggleRowExpansion(states, row, expanded) {
	  var changed = false;
	  var expandRows = states.expandRows;
	  if (typeof expanded !== 'undefined') {
	    var index = expandRows.indexOf(row);
	    if (expanded) {
	      if (index === -1) {
	        expandRows.push(row);
	        changed = true;
	      }
	    } else {
	      if (index !== -1) {
	        expandRows.splice(index, 1);
	        changed = true;
	      }
	    }
	  } else {
	    var _index = expandRows.indexOf(row);
	    if (_index === -1) {
	      expandRows.push(row);
	      changed = true;
	    } else {
	      expandRows.splice(_index, 1);
	      changed = true;
	    }
	  }
	  return changed;
	};
	var doFlattenColumns = function doFlattenColumns(columns) {
	  var result = [];
	  columns.forEach(function (column) {
	    if (column.children) {
	      result.push.apply(result, doFlattenColumns(column.children));
	    } else {
	      result.push(column);
	    }
	  });
	  return result;
	};
	var TableStore = function () {
	  function TableStore(table) {
	    var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    _classCallCheck(this, TableStore);
	    if (!table) {
	      throw new Error('Table is required.');
	    }
	    this.table = table;
	    this.isDraging = false;
	    this.states = {
	      rowKey: null,
	      _columns: [],
	      originColumns: [],
	      columns: [],
	      fixedColumns: [],
	      rightFixedColumns: [],
	      leafColumns: [],
	      fixedLeafColumns: [],
	      rightFixedLeafColumns: [],
	      leafColumnsLength: 0,
	      fixedLeafColumnsLength: 0,
	      rightFixedLeafColumnsLength: 0,
	      isComplex: false,
	      filteredData: null,
	      data: null,
	      sortingColumn: null,
	      sortProp: null,
	      sortOrder: null,
	      isAllSelected: false,
	      selection: [],
	      reserveSelection: false,
	      selectable: null,
	      currentRow: null,
	      hoverRow: null,
	      filters: {},
	      expandRows: [],
	      defaultExpandAll: false,
	      selectOnIndeterminate: false
	    };
	    for (var prop in initialState) {
	      if (initialState.hasOwnProperty(prop) && this.states.hasOwnProperty(prop)) {
	        this.states[prop] = initialState[prop];
	      }
	    }
	  }
	  _createClass(TableStore, [{
	    key: "mutations",
	    get: function get() {
	      return {
	        setData: function setData(states, data) {
	          var _this = this;
	          var dataInstanceChanged = states._data !== data;
	          states._data = data;
	          keys$1(states.filters).forEach(function (columnId) {
	            var values = states.filters[columnId];
	            if (!values || values.length === 0) return;
	            var column = getColumnById(_this.states, columnId);
	            if (column && column.filterMethod) {
	              data = data.filter(function (row) {
	                return values.some(function (value) {
	                  return column.filterMethod.call(null, value, row, column);
	                });
	              });
	            }
	          });
	          states.filteredData = data;
	          states.data = sortData(data || [], states);
	          this.updateCurrentRow();
	          var rowKey = states.rowKey;
	          if (!states.reserveSelection) {
	            if (dataInstanceChanged) {
	              this.clearSelection();
	            } else {
	              this.cleanSelection();
	            }
	            this.updateAllSelected();
	          } else {
	            if (rowKey) {
	              var selection = states.selection;
	              var selectedMap = getKeysMap(selection, rowKey);
	              states.data.forEach(function (row) {
	                var rowId = getRowIdentity(row, rowKey);
	                var rowInfo = selectedMap[rowId];
	                if (rowInfo) {
	                  selection[rowInfo.index] = row;
	                }
	              });
	              this.updateAllSelected();
	            } else {
	              console.warn('WARN: rowKey is required when reserve-selection is enabled.');
	            }
	          }
	          var defaultExpandAll = states.defaultExpandAll;
	          if (defaultExpandAll) {
	            this.states.expandRows = (states.data || []).slice(0);
	          } else if (rowKey) {
	            var ids = getKeysMap(this.states.expandRows, rowKey);
	            var expandRows = [];
	            var _iterator = _createForOfIteratorHelper(states.data),
	                _step;
	            try {
	              for (_iterator.s(); !(_step = _iterator.n()).done;) {
	                var row = _step.value;
	                var rowId = getRowIdentity(row, rowKey);
	                if (ids[rowId]) {
	                  expandRows.push(row);
	                }
	              }
	            } catch (err) {
	              _iterator.e(err);
	            } finally {
	              _iterator.f();
	            }
	            this.states.expandRows = expandRows;
	          } else {
	            this.states.expandRows = [];
	          }
	          Vue.nextTick(function () {
	            return _this.table.updateScrollY();
	          });
	        },
	        changeSortCondition: function changeSortCondition(states, options) {
	          var _this2 = this;
	          states.data = sortData(states.filteredData || states._data || [], states);
	          var _this$table = this.table,
	              $el = _this$table.$el,
	              highlightCurrentRow = _this$table.highlightCurrentRow;
	          if ($el && highlightCurrentRow) {
	            var data = states.data;
	            var tr = $el.querySelector('tbody').children;
	            var rows = [].filter.call(tr, function (row) {
	              return hasClass(row, 'bk-table-row');
	            });
	            var row = rows[data.indexOf(states.currentRow)];
	            Array.prototype.forEach.call(rows, function (row) {
	              return removeClass(row, 'current-row');
	            });
	            addClass(row, 'current-row');
	          }
	          if (!options || !options.silent) {
	            this.table.$emit('sort-change', {
	              column: this.states.sortingColumn,
	              prop: this.states.sortProp,
	              order: this.states.sortOrder
	            });
	          }
	          Vue.nextTick(function () {
	            return _this2.table.updateScrollY();
	          });
	        },
	        sort: function sort(states, options) {
	          var _this3 = this;
	          var prop = options.prop,
	              order = options.order;
	          if (prop) {
	            states.sortProp = prop;
	            states.sortOrder = order || 'ascending';
	            Vue.nextTick(function () {
	              for (var i = 0, length = states.columns.length; i < length; i++) {
	                var column = states.columns[i];
	                if (column.property === states.sortProp) {
	                  column.order = states.sortOrder;
	                  states.sortingColumn = column;
	                  break;
	                }
	              }
	              if (states.sortingColumn) {
	                _this3.commit('changeSortCondition');
	              }
	            });
	          }
	        },
	        filterChange: function filterChange(states, options) {
	          var _this4 = this;
	          var values = options.values;
	          var column = options.column,
	              silent = options.silent;
	          if (values && !isArray$1(values)) {
	            values = [values];
	          }
	          var prop = column.property;
	          var filters = {};
	          if (prop) {
	            states.filters[column.id] = values;
	            filters[column.columnKey || column.id] = values;
	          }
	          var data = states._data;
	          keys$1(states.filters).forEach(function (columnId) {
	            var values = states.filters[columnId];
	            if (!values || values.length === 0) return;
	            var column = getColumnById(_this4.states, columnId);
	            if (column && column.filterMethod) {
	              data = data.filter(function (row) {
	                return values.some(function (value) {
	                  return column.filterMethod.call(null, value, row, column);
	                });
	              });
	            }
	          });
	          states.filteredData = data;
	          states.data = sortData(data, states);
	          if (!silent) {
	            this.table.$emit('filter-change', filters, states.filters);
	          }
	          Vue.nextTick(function () {
	            return _this4.table.updateScrollY();
	          });
	        },
	        insertColumn: function insertColumn(states, column, index, parent) {
	          var array = states._columns;
	          if (parent) {
	            array = parent.children;
	            if (!array) array = parent.children = [];
	          }
	          if (typeof index !== 'undefined') {
	            array.splice(index, 0, column);
	          } else {
	            array.push(column);
	          }
	          if (column.type === 'selection') {
	            states.selectable = column.selectable;
	            states.reserveSelection = column.reserveSelection;
	          }
	          if (this.table.$ready) {
	            this.updateColumns();
	            this.scheduleLayout();
	          }
	        },
	        removeColumn: function removeColumn(states, column, parent) {
	          var array = states._columns;
	          if (parent) {
	            array = parent.children;
	            if (!array) array = parent.children = [];
	          }
	          if (array) {
	            array.splice(array.indexOf(column), 1);
	          }
	          if (this.table.$ready) {
	            this.updateColumns();
	            this.scheduleLayout();
	          }
	        },
	        setHoverRow: function setHoverRow(states, row) {
	          states.hoverRow = row;
	        },
	        setCurrentRow: function setCurrentRow(states, row) {
	          var oldCurrentRow = states.currentRow;
	          states.currentRow = row;
	          if (oldCurrentRow !== row) {
	            this.table.$emit('current-change', row, oldCurrentRow);
	          }
	        },
	        rowSelectedChanged: function rowSelectedChanged(states, row) {
	          var changed = _toggleRowSelection(states, row);
	          var selection = states.selection;
	          if (changed) {
	            var table = this.table;
	            table.$emit('selection-change', selection ? selection.slice() : []);
	            table.$emit('select', selection, row);
	          }
	          this.updateAllSelected();
	        },
	        toggleAllSelection: debounce(10, function (states) {
	          if (this.isAllSelectionDisabled) return;
	          var data = states.data;
	          var selection = this.states.selection;
	          var value = states.selectOnIndeterminate ? !states.isAllSelected : !(states.isAllSelected || selection.length);
	          var selectionChanged = false;
	          data.forEach(function (item, index) {
	            if (states.selectable) {
	              if (states.selectable.call(null, item, index) && _toggleRowSelection(states, item, value)) {
	                selectionChanged = true;
	              }
	            } else {
	              if (_toggleRowSelection(states, item, value)) {
	                selectionChanged = true;
	              }
	            }
	          });
	          var table = this.table;
	          if (selectionChanged) {
	            table.$emit('selection-change', selection ? selection.slice() : []);
	          }
	          table.$emit('select-all', selection);
	          states.isAllSelected = value;
	        })
	      };
	    }
	  }, {
	    key: "updateColumns",
	    value: function updateColumns() {
	      var states = this.states;
	      var _columns = states._columns || [];
	      states.fixedColumns = _columns.filter(function (column) {
	        return column.fixed === true || column.fixed === 'left';
	      });
	      states.rightFixedColumns = _columns.filter(function (column) {
	        return column.fixed === 'right';
	      });
	      if (states.fixedColumns.length > 0 && _columns[0] && _columns[0].type === 'selection' && !_columns[0].fixed) {
	        _columns[0].fixed = true;
	        states.fixedColumns.unshift(_columns[0]);
	      }
	      var notFixedColumns = _columns.filter(function (column) {
	        return !column.fixed;
	      });
	      states.originColumns = [].concat(states.fixedColumns).concat(notFixedColumns).concat(states.rightFixedColumns);
	      var leafColumns = doFlattenColumns(notFixedColumns);
	      var fixedLeafColumns = doFlattenColumns(states.fixedColumns);
	      var rightFixedLeafColumns = doFlattenColumns(states.rightFixedColumns);
	      states.leafColumnsLength = leafColumns.length;
	      states.fixedLeafColumnsLength = fixedLeafColumns.length;
	      states.rightFixedLeafColumnsLength = rightFixedLeafColumns.length;
	      states.columns = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
	      states.isComplex = states.fixedColumns.length > 0 || states.rightFixedColumns.length > 0;
	    }
	  }, {
	    key: "isSelected",
	    value: function isSelected(row) {
	      return (this.states.selection || []).indexOf(row) > -1;
	    }
	  }, {
	    key: "isAllSelectionDisabled",
	    get: function get() {
	      var _this5 = this;
	      if (!this.states.selectable) {
	        return false;
	      }
	      var isEmpty = this.states.data && this.states.data.length === 0;
	      var isDisabled = this.states.data.every(function (row, index) {
	        return !_this5.states.selectable(row, index);
	      });
	      return isEmpty || isDisabled;
	    }
	  }, {
	    key: "clearSelection",
	    value: function clearSelection() {
	      var states = this.states;
	      states.isAllSelected = false;
	      var oldSelection = states.selection;
	      if (states.selection.length) {
	        states.selection = [];
	      }
	      if (oldSelection.length > 0) {
	        this.table.$emit('selection-change', states.selection ? states.selection.slice() : []);
	      }
	    }
	  }, {
	    key: "setExpandRowKeys",
	    value: function setExpandRowKeys(rowKeys) {
	      var expandRows = [];
	      var data = this.states.data;
	      var rowKey = this.states.rowKey;
	      if (!rowKey) throw new Error('[Table] prop row-key should not be empty.');
	      var keysMap = getKeysMap(data, rowKey);
	      rowKeys.forEach(function (key) {
	        var info = keysMap[key];
	        if (info) {
	          expandRows.push(info.row);
	        }
	      });
	      this.states.expandRows = expandRows;
	    }
	  }, {
	    key: "toggleRowSelection",
	    value: function toggleRowSelection(row, selected) {
	      var changed = _toggleRowSelection(this.states, row, selected);
	      if (changed) {
	        this.table.$emit('selection-change', this.states.selection ? this.states.selection.slice() : []);
	      }
	    }
	  }, {
	    key: "toggleRowExpansion",
	    value: function toggleRowExpansion(row, expanded) {
	      var changed = _toggleRowExpansion(this.states, row, expanded);
	      if (changed) {
	        this.table.$emit('expand-change', row, this.states.expandRows);
	        this.scheduleLayout();
	      }
	    }
	  }, {
	    key: "isRowExpanded",
	    value: function isRowExpanded(row) {
	      var _this$states = this.states,
	          _this$states$expandRo = _this$states.expandRows,
	          expandRows = _this$states$expandRo === void 0 ? [] : _this$states$expandRo,
	          rowKey = _this$states.rowKey;
	      if (rowKey) {
	        var expandMap = getKeysMap(expandRows, rowKey);
	        return !!expandMap[getRowIdentity(row, rowKey)];
	      }
	      return expandRows.indexOf(row) !== -1;
	    }
	  }, {
	    key: "cleanSelection",
	    value: function cleanSelection() {
	      var selection = this.states.selection || [];
	      var data = this.states.data;
	      var rowKey = this.states.rowKey;
	      var deleted;
	      if (rowKey) {
	        deleted = [];
	        var selectedMap = getKeysMap(selection, rowKey);
	        var dataMap = getKeysMap(data, rowKey);
	        for (var key in selectedMap) {
	          if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
	            deleted.push(selectedMap[key].row);
	          }
	        }
	      } else {
	        deleted = selection.filter(function (item) {
	          return data.indexOf(item) === -1;
	        });
	      }
	      deleted.forEach(function (deletedItem) {
	        selection.splice(selection.indexOf(deletedItem), 1);
	      });
	      if (deleted.length) {
	        this.table.$emit('selection-change', selection ? selection.slice() : []);
	      }
	    }
	  }, {
	    key: "clearFilter",
	    value: function clearFilter() {
	      var states = this.states;
	      var _this$table$$refs = this.table.$refs,
	          tableHeader = _this$table$$refs.tableHeader,
	          fixedTableHeader = _this$table$$refs.fixedTableHeader,
	          rightFixedTableHeader = _this$table$$refs.rightFixedTableHeader;
	      var panels = {};
	      if (tableHeader) panels = deepmerge(panels, tableHeader.filterPanels);
	      if (fixedTableHeader) panels = deepmerge(panels, fixedTableHeader.filterPanels);
	      if (rightFixedTableHeader) panels = deepmerge(panels, rightFixedTableHeader.filterPanels);
	      var keys = keys$1(panels);
	      if (!keys.length) return;
	      keys.forEach(function (key) {
	        panels[key].filteredValue = [];
	      });
	      states.filters = {};
	      this.commit('filterChange', {
	        column: {},
	        values: [],
	        silent: true
	      });
	    }
	  }, {
	    key: "clearSort",
	    value: function clearSort() {
	      var states = this.states;
	      if (!states.sortingColumn) return;
	      states.sortingColumn.order = null;
	      states.sortProp = null;
	      states.sortOrder = null;
	      this.commit('changeSortCondition', {
	        silent: true
	      });
	    }
	  }, {
	    key: "updateAllSelected",
	    value: function updateAllSelected() {
	      var states = this.states;
	      var selection = states.selection,
	          rowKey = states.rowKey,
	          selectable = states.selectable,
	          data = states.data;
	      if (!data || data.length === 0) {
	        states.isAllSelected = false;
	        return;
	      }
	      var selectedMap;
	      if (rowKey) {
	        selectedMap = getKeysMap(states.selection, rowKey);
	      }
	      var isSelected = function isSelected(row) {
	        if (selectedMap) {
	          return !!selectedMap[getRowIdentity(row, rowKey)];
	        } else {
	          return selection.indexOf(row) !== -1;
	        }
	      };
	      var isAllSelected = true;
	      var selectedCount = 0;
	      for (var i = 0, j = data.length; i < j; i++) {
	        var item = data[i];
	        var isRowSelectable = selectable && selectable(item, i);
	        if (!isSelected(item)) {
	          if (!selectable || isRowSelectable) {
	            isAllSelected = false;
	            break;
	          }
	        } else {
	          selectedCount++;
	        }
	      }
	      if (selectedCount === 0) isAllSelected = false;
	      states.isAllSelected = isAllSelected;
	    }
	  }, {
	    key: "scheduleLayout",
	    value: function scheduleLayout(updateColumns) {
	      if (updateColumns) {
	        this.updateColumns();
	      }
	      this.table.debouncedUpdateLayout();
	    }
	  }, {
	    key: "setCurrentRowKey",
	    value: function setCurrentRowKey(key) {
	      var states = this.states;
	      var rowKey = states.rowKey;
	      if (!rowKey) throw new Error('[Table] row-key should not be empty.');
	      var data = states.data || [];
	      var keysMap = getKeysMap(data, rowKey);
	      var info = keysMap[key];
	      states.currentRow = info ? info.row : null;
	    }
	  }, {
	    key: "updateCurrentRow",
	    value: function updateCurrentRow() {
	      var states = this.states;
	      var table = this.table;
	      var data = states.data || [];
	      var oldCurrentRow = states.currentRow;
	      if (data.indexOf(oldCurrentRow) === -1) {
	        states.currentRow = null;
	        if (states.currentRow !== oldCurrentRow) {
	          table.$emit('current-change', null, oldCurrentRow);
	        }
	      }
	    }
	  }, {
	    key: "commit",
	    value: function commit(name) {
	      var mutations = this.mutations;
	      if (mutations[name]) {
	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }
	        mutations[name].apply(this, [this.states].concat(args));
	      } else {
	        throw new Error("Action not found: ".concat(name));
	      }
	    }
	  }]);
	  return TableStore;
	}();

	var scrollBarWidth;
	function scrollbarWidth () {
	  if (scrollBarWidth !== undefined) return scrollBarWidth;
	  var outer = document.createElement('div');
	  outer.className = 'bk-scrollbar-wrap';
	  outer.style.visibility = 'hidden';
	  outer.style.width = '100px';
	  outer.style.position = 'absolute';
	  outer.style.top = '-9999px';
	  document.body.appendChild(outer);
	  var widthNoScroll = outer.offsetWidth;
	  outer.style.overflow = 'scroll';
	  var inner = document.createElement('div');
	  inner.style.width = '100%';
	  outer.appendChild(inner);
	  var widthWithScroll = inner.offsetWidth;
	  outer.parentNode.removeChild(outer);
	  scrollBarWidth = widthNoScroll - widthWithScroll;
	  return scrollBarWidth;
	}

	var TableLayout = function () {
	  function TableLayout(options) {
	    _classCallCheck(this, TableLayout);
	    this.observers = [];
	    this.table = null;
	    this.store = null;
	    this.columns = null;
	    this.fit = true;
	    this.showHeader = true;
	    this.height = null;
	    this.scrollX = false;
	    this.scrollY = false;
	    this.bodyWidth = null;
	    this.fixedWidth = null;
	    this.rightFixedWidth = null;
	    this.tableHeight = null;
	    this.headerHeight = 44;
	    this.appendHeight = 0;
	    this.footerHeight = 44;
	    this.paginationHeight = 0;
	    this.viewportHeight = null;
	    this.bodyHeight = null;
	    this.fixedBodyHeight = null;
	    this.gutterWidth = options.table.virtualRender ? 0 : scrollbarWidth();
	    this.rowsHeight = {};
	    this.debouncedSyncRowHeight = debounce(1000 / 60, this.syncRowHeight);
	    for (var name in options) {
	      if (options.hasOwnProperty(name)) {
	        this[name] = options[name];
	      }
	    }
	    if (!this.table) {
	      throw new Error('table is required for Table Layout');
	    }
	    if (!this.store) {
	      throw new Error('store is required for Table Layout');
	    }
	  }
	  _createClass(TableLayout, [{
	    key: "updateScrollY",
	    value: function updateScrollY() {
	      if (!this.bodyHeight) return;
	      var bodyWrapper = this.table.bodyWrapper;
	      if (this.table.$el && bodyWrapper) {
	        if (this.table.isVirtualRender) {
	          var body = bodyWrapper.querySelector('.bk-virtual-section');
	          this.scrollY = body.offsetHeight > this.bodyHeight;
	        } else {
	          var _body = bodyWrapper.querySelector('.bk-table-body');
	          this.scrollY = _body.offsetHeight > this.bodyHeight;
	        }
	      }
	    }
	  }, {
	    key: "setHeight",
	    value: function setHeight(value) {
	      var _this = this;
	      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'height';
	      var el = this.table.$el;
	      if (typeof value === 'string' && /^\d+$/.test(value)) {
	        value = Number(value);
	      }
	      this.height = value;
	      if (!el) return Vue.nextTick(function () {
	        return _this.setHeight(value, prop);
	      });
	      if (typeof value === 'number') {
	        el.style[prop] = value + 'px';
	        this.updateElsHeight();
	      } else if (typeof value === 'string') {
	        el.style[prop] = value;
	        this.updateElsHeight();
	      }
	    }
	  }, {
	    key: "setMaxHeight",
	    value: function setMaxHeight(value) {
	      return this.setHeight(value, 'max-height');
	    }
	  }, {
	    key: "updateElsHeight",
	    value: function updateElsHeight() {
	      var _this2 = this;
	      if (this.table.$destroyed) return;
	      if (!this.table.$ready) return Vue.nextTick(function () {
	        return _this2.updateElsHeight();
	      });
	      var _this$table$$refs = this.table.$refs,
	          headerWrapper = _this$table$$refs.headerWrapper,
	          appendWrapper = _this$table$$refs.appendWrapper,
	          footerWrapper = _this$table$$refs.footerWrapper,
	          paginationWrapper = _this$table$$refs.paginationWrapper;
	      if (this.table.showPagination && !paginationWrapper) return Vue.nextTick(function () {
	        return _this2.updateElsHeight();
	      });
	      this.appendHeight = appendWrapper ? appendWrapper.offsetHeight : 0;
	      this.paginationHeight = paginationWrapper ? paginationWrapper.offsetHeight : 0;
	      if (this.showHeader && !headerWrapper) return;
	      var headerHeight = this.headerHeight = !this.showHeader ? 0 : headerWrapper.offsetHeight;
	      if (this.showHeader && headerWrapper.offsetWidth > 0 && (this.table.columns || []).length > 0 && headerHeight < 2) {
	        return Vue.nextTick(function () {
	          return _this2.updateElsHeight();
	        });
	      }
	      var tableHeight = this.tableHeight = this.table.$el.offsetHeight - this.paginationHeight;
	      var footerHeight = this.footerHeight = footerWrapper ? footerWrapper.offsetHeight : 0;
	      this.bodyHeight = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
	      this.fixedBodyHeight = this.scrollX ? this.bodyHeight - this.gutterWidth : this.bodyHeight;
	      var noData = !this.table.data || this.table.data.length === 0;
	      this.viewportHeight = this.scrollX ? tableHeight - (noData ? 0 : this.gutterWidth) : tableHeight;
	      this.updateScrollY();
	      this.notifyObservers('scrollable');
	    }
	  }, {
	    key: "getFlattenColumns",
	    value: function getFlattenColumns() {
	      var flattenColumns = [];
	      var columns = this.table.columns;
	      columns.forEach(function (column) {
	        if (column.isColumnGroup) {
	          flattenColumns.push.apply(flattenColumns, column.columns);
	        } else {
	          flattenColumns.push(column);
	        }
	      });
	      return flattenColumns;
	    }
	  }, {
	    key: "updateColumnsWidth",
	    value: function updateColumnsWidth() {
	      if (this.table.$destroyed) return;
	      var fit = this.fit;
	      var bodyWidth = this.table.$el.clientWidth;
	      var bodyMinWidth = 0;
	      var flattenColumns = this.getFlattenColumns();
	      if (flattenColumns.length < 1) {
	        return;
	      }
	      var flexColumns = flattenColumns.filter(function (column) {
	        return typeof column.width !== 'number';
	      });
	      if (!this.store.isDraging) {
	        flattenColumns.forEach(function (column) {
	          if (typeof column.width === 'number') {
	            column.realWidth = column.width;
	          }
	        });
	      }
	      if (!this.store.isDraging && flexColumns.length > 0 && fit) {
	        flattenColumns.forEach(function (column) {
	          bodyMinWidth += column.width || column.minWidth;
	        });
	        var scrollYWidth = this.scrollY ? this.gutterWidth : 0;
	        if (bodyMinWidth <= bodyWidth - scrollYWidth) {
	          this.scrollX = false;
	          var virtualScrollWidth = this.table.isVirtualRender && this.scrollY ? 10 : 0;
	          var totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth - virtualScrollWidth;
	          if (flexColumns.length === 1) {
	            flexColumns[0].realWidth = flexColumns[0].minWidth + totalFlexWidth;
	          } else {
	            var flexWidthPerPixel = Math.floor(totalFlexWidth / flexColumns.length);
	            var firstWidth = totalFlexWidth;
	            flexColumns.forEach(function (column, index) {
	              if (index === 0) return;
	              var flexWidth = column.minWidth + flexWidthPerPixel;
	              if (column.maxWidth && column.maxWidth < flexWidth) {
	                flexWidth = column.maxWidth;
	                firstWidth -= column.maxWidth - column.minWidth;
	              } else {
	                firstWidth -= flexWidthPerPixel;
	              }
	              column.realWidth = flexWidth;
	            });
	            flexColumns[0].realWidth = flexColumns[0].minWidth + firstWidth;
	          }
	        } else {
	          this.scrollX = true;
	          flexColumns.forEach(function (column) {
	            column.realWidth = column.minWidth;
	          });
	        }
	        this.bodyWidth = Math.max(bodyMinWidth, bodyWidth);
	        this.table.resizeState.width = this.bodyWidth;
	      } else {
	        flattenColumns.forEach(function (column) {
	          bodyMinWidth += column.realWidth;
	        });
	        this.scrollX = bodyMinWidth > bodyWidth;
	        var findLastColumnWithNotSetting = function findLastColumnWithNotSetting(columnList) {
	          var i = columnList.length;
	          while (--i) {
	            if (columnList[i].type !== 'setting') {
	              return columnList[i];
	            }
	          }
	          return null;
	        };
	        var lastColumn = findLastColumnWithNotSetting(flattenColumns);
	        if (lastColumn) {
	          if (!this.scrollX && flattenColumns.length) {
	            var deltaWidth = bodyWidth - bodyMinWidth;
	            console.log('from print table last column < ', lastColumn);
	            lastColumn.realWidth = lastColumn.realWidth + deltaWidth;
	            this.bodyWidth = bodyWidth;
	          } else {
	            console.log('from print table last column > ', lastColumn);
	            if (lastColumn) {
	              var lastRealWidth = typeof lastColumn.width !== 'number' ? lastColumn.minWidth : lastColumn.width;
	              var preLastColumnBodyMinWidth = bodyMinWidth - lastColumn.realWidth;
	              if (preLastColumnBodyMinWidth + lastRealWidth > bodyWidth) {
	                lastColumn.realWidth = lastRealWidth;
	                bodyMinWidth = preLastColumnBodyMinWidth + lastRealWidth;
	              } else {
	                lastColumn.realWidth = bodyWidth - preLastColumnBodyMinWidth;
	                bodyMinWidth = preLastColumnBodyMinWidth + lastColumn.realWidth;
	              }
	            }
	            this.scrollX = bodyMinWidth > bodyWidth;
	            this.bodyWidth = bodyMinWidth;
	          }
	        }
	      }
	      var fixedColumns = this.store.states.fixedColumns;
	      if (fixedColumns.length > 0) {
	        var fixedWidth = 0;
	        fixedColumns.forEach(function (column) {
	          fixedWidth += column.realWidth || column.width;
	        });
	        this.fixedWidth = fixedWidth;
	      }
	      var rightFixedColumns = this.store.states.rightFixedColumns;
	      if (rightFixedColumns.length > 0) {
	        var rightFixedWidth = 0;
	        rightFixedColumns.forEach(function (column) {
	          rightFixedWidth += column.realWidth || column.width;
	        });
	        this.rightFixedWidth = rightFixedWidth;
	      }
	      this.store.isDraging = false;
	      this.notifyObservers('columns');
	    }
	  }, {
	    key: "syncRowHeight",
	    value: function syncRowHeight() {
	      if (this.table.$destroyed) return;
	      if (!this.table.$ready) return Vue.nextTick(this.syncRowHeight);
	      var rows = this.table.$refs.tableBody.$refs.row || [];
	      var rowsHeight = rows.reduce(function (accumulator, row) {
	        var key = row.getAttribute('data-table-row');
	        accumulator[key] = row.offsetHeight;
	        return accumulator;
	      }, {});
	      if (isShallowEqual(rowsHeight, this.rowsHeight)) return;
	      this.rowsHeight = rowsHeight;
	    }
	  }, {
	    key: "addObserver",
	    value: function addObserver(observer) {
	      this.observers.push(observer);
	    }
	  }, {
	    key: "removeObserver",
	    value: function removeObserver(observer) {
	      var index = this.observers.indexOf(observer);
	      if (index !== -1) {
	        this.observers.splice(index, 1);
	      }
	    }
	  }, {
	    key: "notifyObservers",
	    value: function notifyObservers(event) {
	      var _this3 = this;
	      var observers = this.observers;
	      observers.forEach(function (observer) {
	        switch (event) {
	          case 'columns':
	            observer.onColumnsChange(_this3);
	            break;
	          case 'scrollable':
	            observer.onScrollableChange(_this3);
	            break;
	          default:
	            throw new Error("Table Layout don't have event ".concat(event, "."));
	        }
	      });
	    }
	  }]);
	  return TableLayout;
	}();

	function _extends$1(){return _extends$1=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends$1.apply(this,arguments)}var normalMerge=["attrs","props","domProps"],toArrayMerge=["class","style","directives"],functionalMerge=["on","nativeOn"],mergeJsxProps=function(a){return a.reduce(function(c,a){for(var b in a)if(!c[b])c[b]=a[b];else if(-1!==normalMerge.indexOf(b))c[b]=_extends$1({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e);}else if(-1!==functionalMerge.indexOf(b)){for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h);}else c[b][f]=a[b][f];}else if("hook"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];return c},{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments);}};var helper=mergeJsxProps;

	var _stringWs = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var space = '[' + _stringWs + ']';
	var non = '\u200b\u0085';
	var ltrim = RegExp('^' + space + space + '*');
	var rtrim = RegExp(space + space + '*$');
	var exporter = function (KEY, exec, ALIAS) {
	  var exp = {};
	  var FORCE = _fails(function () {
	    return !!_stringWs[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim$1) : _stringWs[KEY];
	  if (ALIAS) exp[ALIAS] = fn;
	  _export(_export.P + _export.F * FORCE, 'String', exp);
	};
	var trim$1 = exporter.trim = function (string, TYPE) {
	  string = String(_defined(string));
	  if (TYPE & 1) string = string.replace(ltrim, '');
	  if (TYPE & 2) string = string.replace(rtrim, '');
	  return string;
	};
	var _stringTrim = exporter;

	var $parseInt = _global.parseInt;
	var $trim = _stringTrim.trim;
	var hex = /^[-+]?0[xX]/;
	var _parseInt = $parseInt(_stringWs + '08') !== 8 || $parseInt(_stringWs + '0x16') !== 22 ? function parseInt(str, radix) {
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

	_export(_export.G + _export.F * (parseInt != _parseInt), { parseInt: _parseInt });

	var _parseInt$1 = _core.parseInt;

	var _parseInt$2 = _parseInt$1;

	var $assign = Object.assign;
	var _objectAssign = !$assign || _fails(function () {
	  var A = {};
	  var B = {};
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) {
	  var T = _toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = _objectGops.f;
	  var isEnum = _objectPie.f;
	  while (aLen > index) {
	    var S = _iobject(arguments[index++]);
	    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!_descriptors || isEnum.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : $assign;

	_export(_export.S + _export.F, 'Object', { assign: _objectAssign });

	var assign = _core.Object.assign;

	var assign$1 = assign;

	var $parseFloat = _global.parseFloat;
	var $trim$1 = _stringTrim.trim;
	var _parseFloat = 1 / $parseFloat(_stringWs + '-0') !== -Infinity ? function parseFloat(str) {
	  var string = $trim$1(String(str), 3);
	  var result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	_export(_export.G + _export.F * (parseFloat != _parseFloat), { parseFloat: _parseFloat });

	var _parseFloat$1 = _core.parseFloat;

	var _parseFloat$2 = _parseFloat$1;

	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
	var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	var timeoutDuration = 0;
	for (var i$2 = 0; i$2 < longerTimeoutBrowsers.length; i$2 += 1) {
	  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i$2]) >= 0) {
	    timeoutDuration = 1;
	    break;
	  }
	}
	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}
	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}
	var supportsMicroTasks = isBrowser && window.Promise;
	var debounce$1 = supportsMicroTasks ? microtaskDebounce : taskDebounce;
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}
	function getScrollParent(element) {
	  if (!element) {
	    return document.body;
	  }
	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }
	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;
	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }
	  return getScrollParent(getParentNode(element));
	}
	var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
	function isIE(version) {
	  if (version === 11) {
	    return isIE11;
	  }
	  if (version === 10) {
	    return isIE10;
	  }
	  return isIE11 || isIE10;
	}
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }
	  var noOffsetParent = isIE(10) ? document.body : null;
	  var offsetParent = element.offsetParent || null;
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }
	  var nodeName = offsetParent && offsetParent.nodeName;
	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
	    return getOffsetParent(offsetParent);
	  }
	  return offsetParent;
	}
	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }
	  return node;
	}
	function findCommonOffsetParent(element1, element2) {
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;
	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }
	    return getOffsetParent(commonAncestorContainer);
	  }
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }
	  return element[upperSide];
	}
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}
	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
	  return _parseFloat$2(styles["border".concat(sideA, "Width")], 10) + _parseFloat$2(styles["border".concat(sideB, "Width")], 10);
	}
	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body["offset".concat(axis)], body["scroll".concat(axis)], html["client".concat(axis)], html["offset".concat(axis)], html["scroll".concat(axis)], isIE(10) ? _parseInt$2(html["offset".concat(axis)]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Top' : 'Left')]) + _parseInt$2(computedStyle["margin".concat(axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}
	function getWindowSizes(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE(10) && getComputedStyle(html);
	  return {
	    height: getSize('Height', body, html, computedStyle),
	    width: getSize('Width', body, html, computedStyle)
	  };
	}
	var _extends$2 = assign$1 || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	function getClientRect(offsets) {
	  return _extends$2({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}
	function getBoundingClientRect(element) {
	  var rect = {};
	  try {
	    if (isIE(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, 'top');
	      var scrollLeft = getScroll(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}
	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;
	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, 'x');
	    vertScrollbar -= getBordersSize(styles, 'y');
	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }
	  return getClientRect(result);
	}
	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var isIE10 = isIE(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);
	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = _parseFloat$2(styles.borderTopWidth, 10);
	  var borderLeftWidth = _parseFloat$2(styles.borderLeftWidth, 10);
	  if (fixedPosition && isHTML) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;
	  if (!isIE10 && isHTML) {
	    var marginTop = _parseFloat$2(styles.marginTop, 10);
	    var marginLeft = _parseFloat$2(styles.marginLeft, 10);
	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }
	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll(offsets, parent);
	  }
	  return offsets;
	}
	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);
	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };
	  return getClientRect(offset);
	}
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
	    return true;
	  }
	  var parentNode = getParentNode(element);
	  if (!parentNode) {
	    return false;
	  }
	  return isFixed(parentNode);
	}
	function getFixedPositionOffsetParent(element) {
	  if (!element || !element.parentElement || isIE()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	  var boundaries = {
	    top: 0,
	    left: 0
	  };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    var boundariesNode;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }
	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
	    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;
	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      boundaries = offsets;
	    }
	  }
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
	  return boundaries;
	}
	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;
	  return width * height;
	}
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }
	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };
	  var sortedAreas = keys$1(rects).map(function (key) {
	    return _extends$2({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });
	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });
	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
	  var variation = placement.split('-')[1];
	  return computedPlacement + (variation ? "-".concat(variation) : '');
	}
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}
	function getOuterSizes(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = _parseFloat$2(styles.marginTop || 0) + _parseFloat$2(styles.marginBottom || 0);
	  var y = _parseFloat$2(styles.marginLeft || 0) + _parseFloat$2(styles.marginRight || 0);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}
	function getOppositePlacement(placement) {
	  var hash = {
	    left: 'right',
	    right: 'left',
	    bottom: 'top',
	    top: 'bottom'
	  };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];
	  var popperRect = getOuterSizes(popper);
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }
	  return popperOffsets;
	}
	function find(arr, check) {
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }
	  return arr.filter(check)[0];
	}
	function findIndex(arr, prop, value) {
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn;
	    if (modifier.enabled && isFunction(fn)) {
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);
	      data = fn(data, modifier);
	    }
	  });
	  return data;
	}
	function _update() {
	  if (this.state.isDestroyed) {
	    return;
	  }
	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
	  data.originalPlacement = data.placement;
	  data.positionFixed = this.options.positionFixed;
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
	  data = runModifiers(this.modifiers, data);
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref3) {
	    var name = _ref3.name,
	        enabled = _ref3.enabled;
	    return enabled && name === modifierName;
	  });
	}
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
	  for (var _i = 0; _i < prefixes.length; _i++) {
	    var prefix = prefixes[_i];
	    var toCheck = prefix ? "".concat(prefix).concat(upperProp) : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}
	function _destroy() {
	  this.state.isDestroyed = true;
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style.left = '';
	    this.popper.style.right = '';
	    this.popper.style.bottom = '';
	    this.popper.style.willChange = '';
	    this.popper.style[getSupportedPropertyName('transform')] = '';
	  }
	  this.disableEventListeners();
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}
	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, {
	    passive: true
	  });
	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}
	function setupEventListeners(reference, options, state, updateBound) {
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, {
	    passive: true
	  });
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;
	  return state;
	}
	function _enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}
	function removeEventListeners(reference, state) {
	  getWindow(reference).removeEventListener('resize', state.updateBound);
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}
	function _disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}
	function isNumeric(n) {
	  return n !== '' && !isNaN(_parseFloat$2(n)) && isFinite(n);
	}
	function setStyles(element, styles) {
	  keys$1(styles).forEach(function (prop) {
	    var unit = '';
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}
	function setAttributes(element, attributes) {
	  keys$1(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}
	function applyStyle(data) {
	  setStyles(data.instance.popper, data.styles);
	  setAttributes(data.instance.popper, data.attributes);
	  if (data.arrowElement && keys$1(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }
	  return data;
	}
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
	  popper.setAttribute('x-placement', placement);
	  setStyles(popper, {
	    position: options.positionFixed ? 'fixed' : 'absolute'
	  });
	  return options;
	}
	function getRoundedOffsets(data, shouldRound) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var round = Math.round,
	      floor = Math.floor;
	  var noRound = function noRound(v) {
	    return v;
	  };
	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);
	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;
	  return {
	    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
	    top: verticalToInteger(popper.top),
	    bottom: verticalToInteger(popper.bottom),
	    right: horizontalToInteger(popper.right)
	  };
	}
	var isFirefox$1 = isBrowser && /Firefox/i.test(navigator.userAgent);
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;
	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);
	  var styles = {
	    position: popper.position
	  };
	  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox$1);
	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';
	  var prefixedProperty = getSupportedPropertyName('transform');
	  var left, top;
	  if (sideA === 'bottom') {
	    if (offsetParent.nodeName === 'HTML') {
	      top = -offsetParent.clientHeight + offsets.bottom;
	    } else {
	      top = -offsetParentRect.height + offsets.bottom;
	    }
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    if (offsetParent.nodeName === 'HTML') {
	      left = -offsetParent.clientWidth + offsets.right;
	    } else {
	      left = -offsetParentRect.width + offsets.right;
	    }
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = "translate3d(".concat(left, "px, ").concat(top, "px, 0)");
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = "".concat(sideA, ", ").concat(sideB);
	  }
	  var attributes = {
	    'x-placement': data.placement
	  };
	  data.attributes = _extends$2({}, attributes, data.attributes);
	  data.styles = _extends$2({}, styles, data.styles);
	  data.arrowStyles = _extends$2({}, data.offsets.arrow, data.arrowStyles);
	  return data;
	}
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref4) {
	    var name = _ref4.name;
	    return name === requestingName;
	  });
	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });
	  if (!isRequired) {
	    var _requesting = "`".concat(requestingName, "`");
	    var requested = "`".concat(requestedName, "`");
	    console.warn("".concat(requested, " modifier is required by ").concat(_requesting, " modifier in order to work, be sure to include it before ").concat(_requesting, "!"));
	  }
	  return isRequired;
	}
	function arrow(data, options) {
	  var _data$offsets$arrow;
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }
	  var arrowElement = options.element;
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }
	  var placement = data.placement.split('-')[0];
	  var _data$offsets2 = data.offsets,
	      popper = _data$offsets2.popper,
	      reference = _data$offsets2.reference;
	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = _parseFloat$2(css["margin".concat(sideCapitalized)], 10);
	  var popperBorderSide = _parseFloat$2(css["border".concat(sideCapitalized, "Width")], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
	  return data;
	}
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
	var validPlacements = placements.slice(3);
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}
	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};
	function flip(data, options) {
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	    return data;
	  }
	  if (data.flipped && data.placement === data.originalPlacement) {
	    return data;
	  }
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';
	  var flipOrder = [];
	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }
	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }
	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement(placement);
	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
	    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
	    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      data.flipped = true;
	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }
	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }
	      data.placement = placement + (variation ? '-' + variation : '');
	      data.offsets.popper = _extends$2({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
	      data = runModifiers(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}
	function keepTogether(data) {
	  var _data$offsets3 = data.offsets,
	      popper = _data$offsets3.popper,
	      reference = _data$offsets3.reference;
	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';
	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }
	  return data;
	}
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];
	  if (!value) {
	    return str;
	  }
	  if (unit.indexOf('%') === 0) {
	    var element;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }
	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    var size;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    return value;
	  }
	}
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));
	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
	  ops = ops.map(function (op, index) {
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}
	function offset(data, _ref5) {
	  var offset = _ref5.offset;
	  var placement = data.placement,
	      _data$offsets4 = data.offsets,
	      popper = _data$offsets4.popper,
	      reference = _data$offsets4.reference;
	  var basePlacement = placement.split('-')[0];
	  var offsets;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }
	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }
	  data.popper = popper;
	  return data;
	}
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }
	  var transformProp = getSupportedPropertyName('transform');
	  var popperStyles = data.instance.popper.style;
	  var top = popperStyles.top,
	      left = popperStyles.left,
	      transform = popperStyles[transformProp];
	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;
	  options.boundaries = boundaries;
	  var order = options.priority;
	  var popper = data.offsets.popper;
	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return _defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return _defineProperty({}, mainSide, value);
	    }
	  };
	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends$2({}, popper, check[side](placement));
	  });
	  data.offsets.popper = popper;
	  return data;
	}
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];
	  if (shiftvariation) {
	    var _data$offsets5 = data.offsets,
	        reference = _data$offsets5.reference,
	        popper = _data$offsets5.popper;
	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';
	    var shiftOffsets = {
	      start: _defineProperty({}, side, reference[side]),
	      end: _defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };
	    data.offsets.popper = _extends$2({}, popper, shiftOffsets[shiftvariation]);
	  }
	  return data;
	}
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }
	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;
	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    if (data.hide === true) {
	      return data;
	    }
	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    if (data.hide === false) {
	      return data;
	    }
	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }
	  return data;
	}
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets6 = data.offsets,
	      popper = _data$offsets6.popper,
	      reference = _data$offsets6.reference;
	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);
	  return data;
	}
	var modifiers = {
	  shift: {
	    order: 100,
	    enabled: true,
	    fn: shift
	  },
	  offset: {
	    order: 200,
	    enabled: true,
	    fn: offset,
	    offset: 0
	  },
	  preventOverflow: {
	    order: 300,
	    enabled: true,
	    fn: preventOverflow,
	    priority: ['left', 'right', 'top', 'bottom'],
	    padding: 5,
	    boundariesElement: 'scrollParent'
	  },
	  keepTogether: {
	    order: 400,
	    enabled: true,
	    fn: keepTogether
	  },
	  arrow: {
	    order: 500,
	    enabled: true,
	    fn: arrow,
	    element: '[x-arrow]'
	  },
	  flip: {
	    order: 600,
	    enabled: true,
	    fn: flip,
	    behavior: 'flip',
	    padding: 5,
	    boundariesElement: 'viewport',
	    flipVariations: false,
	    flipVariationsByContent: false
	  },
	  inner: {
	    order: 700,
	    enabled: false,
	    fn: inner
	  },
	  hide: {
	    order: 800,
	    enabled: true,
	    fn: hide
	  },
	  computeStyle: {
	    order: 850,
	    enabled: true,
	    fn: computeStyle,
	    gpuAcceleration: true,
	    x: 'bottom',
	    y: 'right'
	  },
	  applyStyle: {
	    order: 900,
	    enabled: true,
	    fn: applyStyle,
	    onLoad: applyStyleOnLoad,
	    gpuAcceleration: undefined
	  }
	};
	var Defaults = {
	  placement: 'bottom',
	  positionFixed: false,
	  eventsEnabled: true,
	  removeOnDestroy: false,
	  onCreate: function onCreate() {},
	  onUpdate: function onUpdate() {},
	  modifiers: modifiers
	};
	var Popper = function () {
	  function Popper(reference, popper) {
	    var _this = this;
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    _classCallCheck(this, Popper);
	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };
	    this.update = debounce$1(this.update.bind(this));
	    this.options = _extends$2({}, Popper.Defaults, options);
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;
	    this.options.modifiers = {};
	    keys$1(_extends$2({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends$2({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });
	    this.modifiers = keys$1(this.options.modifiers).map(function (name) {
	      return _extends$2({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });
	    this.update();
	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      this.enableEventListeners();
	    }
	    this.state.eventsEnabled = eventsEnabled;
	  }
	  _createClass(Popper, [{
	    key: "update",
	    value: function update() {
	      return _update.call(this);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      return _destroy.call(this);
	    }
	  }, {
	    key: "enableEventListeners",
	    value: function enableEventListeners() {
	      return _enableEventListeners.call(this);
	    }
	  }, {
	    key: "disableEventListeners",
	    value: function disableEventListeners() {
	      return _disableEventListeners.call(this);
	    }
	  }]);
	  return Popper;
	}();
	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	function _extends$3() {
	  _extends$3 = assign$1 || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$3.apply(this, arguments);
	}
	var version = "4.3.4";
	var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined';
	var ua = isBrowser$1 ? navigator.userAgent : '';
	var isIE$1 = /MSIE |Trident\//.test(ua);
	var isUCBrowser = /UCBrowser\//.test(ua);
	var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform) && !window.MSStream;
	var defaultProps = {
	  a11y: true,
	  allowHTML: true,
	  animateFill: true,
	  animation: 'shift-away',
	  appendTo: function appendTo() {
	    return document.body;
	  },
	  aria: 'describedby',
	  arrow: false,
	  arrowType: 'sharp',
	  boundary: 'scrollParent',
	  content: '',
	  delay: 0,
	  distance: 10,
	  duration: [325, 275],
	  flip: true,
	  flipBehavior: 'flip',
	  flipOnUpdate: false,
	  followCursor: false,
	  hideOnClick: true,
	  ignoreAttributes: false,
	  inertia: false,
	  interactive: false,
	  interactiveBorder: 2,
	  interactiveDebounce: 0,
	  lazy: true,
	  width: 'auto',
	  maxWidth: 'auto',
	  multiple: false,
	  offset: 0,
	  onHidden: function onHidden() {},
	  onHide: function onHide() {},
	  onMount: function onMount() {},
	  onShow: function onShow() {},
	  onShown: function onShown() {},
	  onTrigger: function onTrigger() {},
	  placement: 'top',
	  popperOptions: {},
	  role: 'tooltip',
	  showOnInit: false,
	  size: 'regular',
	  sticky: false,
	  target: '',
	  theme: 'dark',
	  touch: true,
	  touchHold: false,
	  trigger: 'mouseenter focus',
	  triggerTarget: null,
	  updateDuration: 0,
	  wait: null,
	  zIndex: 9999,
	  extCls: ''
	};
	var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'arrowType', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions'];
	var elementProto = isBrowser$1 ? Element.prototype : {};
	var matches = elementProto.matches || elementProto.matchesSelector || elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector || elementProto.msMatchesSelector;
	function arrayFrom(value) {
	  return [].slice.call(value);
	}
	function closest(element, selector) {
	  return closestCallback(element, function (el) {
	    return matches.call(el, selector);
	  });
	}
	function closestCallback(element, callback) {
	  while (element) {
	    if (callback(element)) {
	      return element;
	    }
	    element = element.parentElement;
	  }
	  return null;
	}
	var PASSIVE = {
	  passive: true
	};
	var PADDING = 4;
	var PLACEMENT_ATTRIBUTE = 'x-placement';
	var OUT_OF_BOUNDARIES_ATTRIBUTE = 'x-out-of-boundaries';
	var IOS_CLASS = "tippy-iOS";
	var ACTIVE_CLASS = "tippy-active";
	var POPPER_CLASS = "tippy-popper";
	var TOOLTIP_CLASS = "tippy-tooltip";
	var CONTENT_CLASS = "tippy-content";
	var BACKDROP_CLASS = "tippy-backdrop";
	var ARROW_CLASS = "tippy-arrow";
	var ROUND_ARROW_CLASS = "tippy-roundarrow";
	var POPPER_SELECTOR = ".".concat(POPPER_CLASS);
	var TOOLTIP_SELECTOR = ".".concat(TOOLTIP_CLASS);
	var CONTENT_SELECTOR = ".".concat(CONTENT_CLASS);
	var BACKDROP_SELECTOR = ".".concat(BACKDROP_CLASS);
	var ARROW_SELECTOR = ".".concat(ARROW_CLASS);
	var ROUND_ARROW_SELECTOR = ".".concat(ROUND_ARROW_CLASS);
	var isUsingTouch = false;
	function onDocumentTouch() {
	  if (isUsingTouch) {
	    return;
	  }
	  isUsingTouch = true;
	  if (isIOS) {
	    document.body.classList.add(IOS_CLASS);
	  }
	  if (window.performance) {
	    document.addEventListener('mousemove', onDocumentMouseMove);
	  }
	}
	var lastMouseMoveTime = 0;
	function onDocumentMouseMove() {
	  var now = performance.now();
	  if (now - lastMouseMoveTime < 20) {
	    isUsingTouch = false;
	    document.removeEventListener('mousemove', onDocumentMouseMove);
	    if (!isIOS) {
	      document.body.classList.remove(IOS_CLASS);
	    }
	  }
	  lastMouseMoveTime = now;
	}
	function onWindowBlur() {
	  var _document = document,
	      activeElement = _document.activeElement;
	  if (activeElement && activeElement.blur && activeElement._tippy) {
	    activeElement.blur();
	  }
	}
	function bindGlobalEventListeners() {
	  document.addEventListener('touchstart', onDocumentTouch, PASSIVE);
	  window.addEventListener('blur', onWindowBlur);
	}
	var keys$2 = keys$1(defaultProps);
	function getDataAttributeOptions(reference) {
	  return keys$2.reduce(function (acc, key) {
	    var valueAsString = (reference.getAttribute("data-tippy-".concat(key)) || '').trim();
	    if (!valueAsString) {
	      return acc;
	    }
	    if (key === 'content') {
	      acc[key] = valueAsString;
	    } else {
	      try {
	        acc[key] = JSON.parse(valueAsString);
	      } catch (e) {
	        acc[key] = valueAsString;
	      }
	    }
	    return acc;
	  }, {});
	}
	function polyfillElementPrototypeProperties(virtualReference) {
	  var polyfills = {
	    isVirtual: true,
	    attributes: virtualReference.attributes || {},
	    contains: function contains() {},
	    setAttribute: function setAttribute(key, value) {
	      virtualReference.attributes[key] = value;
	    },
	    getAttribute: function getAttribute(key) {
	      return virtualReference.attributes[key];
	    },
	    removeAttribute: function removeAttribute(key) {
	      delete virtualReference.attributes[key];
	    },
	    hasAttribute: function hasAttribute(key) {
	      return key in virtualReference.attributes;
	    },
	    addEventListener: function addEventListener() {},
	    removeEventListener: function removeEventListener() {},
	    classList: {
	      classNames: {},
	      add: function add(key) {
	        virtualReference.classList.classNames[key] = true;
	      },
	      remove: function remove(key) {
	        delete virtualReference.classList.classNames[key];
	      },
	      contains: function contains(key) {
	        return key in virtualReference.classList.classNames;
	      }
	    }
	  };
	  for (var key in polyfills) {
	    virtualReference[key] = polyfills[key];
	  }
	}
	function isBareVirtualElement(value) {
	  return {}.toString.call(value) === '[object Object]' && !value.addEventListener;
	}
	function isReferenceElement(value) {
	  return !!value._tippy && !matches.call(value, POPPER_SELECTOR);
	}
	function hasOwnProperty$1(obj, key) {
	  return {}.hasOwnProperty.call(obj, key);
	}
	function getArrayOfElements(value) {
	  if (isSingular(value)) {
	    return [value];
	  }
	  if (value instanceof NodeList) {
	    return arrayFrom(value);
	  }
	  if (isArray$1(value)) {
	    return value;
	  }
	  try {
	    return arrayFrom(document.querySelectorAll(value));
	  } catch (e) {
	    return [];
	  }
	}
	function getValue(value, index, defaultValue) {
	  if (isArray$1(value)) {
	    var v = value[index];
	    return v == null ? defaultValue : v;
	  }
	  return value;
	}
	function debounce$2(fn, ms) {
	  if (ms === 0) {
	    return fn;
	  }
	  var timeout;
	  return function (arg) {
	    clearTimeout(timeout);
	    timeout = setTimeout(function () {
	      fn(arg);
	    }, ms);
	  };
	}
	function getModifier(obj, key) {
	  return obj && obj.modifiers && obj.modifiers[key];
	}
	function includes(a, b) {
	  return a.indexOf(b) > -1;
	}
	function isRealElement(value) {
	  return value instanceof Element;
	}
	function isSingular(value) {
	  return !!(value && hasOwnProperty$1(value, 'isVirtual')) || isRealElement(value);
	}
	function innerHTML() {
	  return 'innerHTML';
	}
	function invokeWithArgsOrReturn(value, args) {
	  return typeof value === 'function' ? value.apply(null, args) : value;
	}
	function setFlipModifierEnabled(modifiers, value) {
	  modifiers.filter(function (m) {
	    return m.name === 'flip';
	  })[0].enabled = value;
	}
	function canReceiveFocus(element) {
	  return isRealElement(element) ? matches.call(element, 'a[href],area[href],button,details,input,textarea,select,iframe,[tabindex]') && !element.hasAttribute('disabled') : true;
	}
	function div() {
	  return document.createElement('div');
	}
	function setTransitionDuration(els, value) {
	  els.forEach(function (el) {
	    if (el) {
	      el.style.transitionDuration = "".concat(value, "ms");
	    }
	  });
	}
	function setVisibilityState(els, state) {
	  els.forEach(function (el) {
	    if (el) {
	      el.setAttribute('data-state', state);
	    }
	  });
	}
	function evaluateProps(reference, props) {
	  var out = _extends$3({}, props, {
	    content: invokeWithArgsOrReturn(props.content, [reference])
	  }, props.ignoreAttributes ? {} : getDataAttributeOptions(reference));
	  if (out.arrow || isUCBrowser) {
	    out.animateFill = false;
	  }
	  return out;
	}
	function validateOptions(options, defaultProps) {
	  keys$1(options).forEach(function (option) {
	    if (!hasOwnProperty$1(defaultProps, option)) {
	      throw new Error("[tippy]: `".concat(option, "` is not a valid option"));
	    }
	  });
	}
	function setInnerHTML(element, html) {
	  element[innerHTML()] = isRealElement(html) ? html[innerHTML()] : html;
	}
	function setContent(contentEl, props) {
	  if (isRealElement(props.content)) {
	    setInnerHTML(contentEl, '');
	    contentEl.appendChild(props.content);
	  } else if (typeof props.content !== 'function') {
	    var key = props.allowHTML ? 'innerHTML' : 'textContent';
	    contentEl[key] = props.content;
	  }
	}
	function getChildren(popper) {
	  return {
	    tooltip: popper.querySelector(TOOLTIP_SELECTOR),
	    backdrop: popper.querySelector(BACKDROP_SELECTOR),
	    content: popper.querySelector(CONTENT_SELECTOR),
	    arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(ROUND_ARROW_SELECTOR)
	  };
	}
	function addInertia(tooltip) {
	  tooltip.setAttribute('data-inertia', '');
	}
	function removeInertia(tooltip) {
	  tooltip.removeAttribute('data-inertia');
	}
	function createArrowElement(arrowType) {
	  var arrow = div();
	  if (arrowType === 'round') {
	    arrow.className = ROUND_ARROW_CLASS;
	    setInnerHTML(arrow, '<svg viewBox="0 0 18 7" xmlns="http://www.w3.org/2000/svg"><path d="M0 7s2.021-.015 5.253-4.218C6.584 1.051 7.797.007 9 0c1.203-.007 2.416 1.035 3.761 2.782C16.012 7.005 18 7 18 7H0z"/></svg>');
	  } else {
	    arrow.className = ARROW_CLASS;
	  }
	  return arrow;
	}
	function createBackdropElement() {
	  var backdrop = div();
	  backdrop.className = BACKDROP_CLASS;
	  backdrop.setAttribute('data-state', 'hidden');
	  return backdrop;
	}
	function addInteractive(popper, tooltip) {
	  popper.setAttribute('tabindex', '-1');
	  tooltip.setAttribute('data-interactive', '');
	}
	function removeInteractive(popper, tooltip) {
	  popper.removeAttribute('tabindex');
	  tooltip.removeAttribute('data-interactive');
	}
	function updateTransitionEndListener(tooltip, action, listener) {
	  var eventName = isUCBrowser && document.body.style.webkitTransition !== undefined ? 'webkitTransitionEnd' : 'transitionend';
	  tooltip[action + 'EventListener'](eventName, listener);
	}
	function getBasicPlacement(popper) {
	  var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	  return fullPlacement ? fullPlacement.split('-')[0] : '';
	}
	function reflow(popper) {
	  void popper.offsetHeight;
	}
	function updateTheme(tooltip, action, theme) {
	  theme.split(' ').forEach(function (themeName) {
	    tooltip.classList[action](themeName + '-theme');
	  });
	}
	function setWidth(tooltip, props, key) {
	  var width = props[key];
	  var parsedWidth = _parseInt$2(width);
	  if (typeof width === 'number') {
	    tooltip.style[key] = width + 'px';
	  } else if (isNaN(parsedWidth)) {
	    tooltip.style[key] = width;
	  } else {
	    tooltip.style[key] = parsedWidth + 'px';
	  }
	}
	function createPopperElement(id, props) {
	  var popper = div();
	  popper.className = POPPER_CLASS + (props.extCls ? " ".concat(props.extCls) : '');
	  popper.id = "tippy-".concat(id);
	  popper.style.zIndex = '' + props.zIndex;
	  popper.style.position = 'absolute';
	  popper.style.top = '0';
	  popper.style.left = '0';
	  if (props.role) {
	    popper.setAttribute('role', props.role);
	  }
	  var tooltip = div();
	  tooltip.className = TOOLTIP_CLASS;
	  setWidth(tooltip, props, 'maxWidth');
	  setWidth(tooltip, props, 'width');
	  tooltip.setAttribute('data-size', props.size);
	  tooltip.setAttribute('data-animation', props.animation);
	  tooltip.setAttribute('data-state', 'hidden');
	  updateTheme(tooltip, 'add', props.theme);
	  var content = div();
	  content.className = CONTENT_CLASS;
	  content.setAttribute('data-state', 'hidden');
	  if (props.interactive) {
	    addInteractive(popper, tooltip);
	  }
	  if (props.arrow) {
	    tooltip.appendChild(createArrowElement(props.arrowType));
	  }
	  if (props.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  }
	  if (props.inertia) {
	    addInertia(tooltip);
	  }
	  setContent(content, props);
	  tooltip.appendChild(content);
	  popper.appendChild(tooltip);
	  return popper;
	}
	function updatePopperElement(popper, prevProps, nextProps) {
	  var _getChildren = getChildren(popper),
	      tooltip = _getChildren.tooltip,
	      content = _getChildren.content,
	      backdrop = _getChildren.backdrop,
	      arrow = _getChildren.arrow;
	  popper.style.zIndex = '' + nextProps.zIndex;
	  tooltip.setAttribute('data-size', nextProps.size);
	  tooltip.setAttribute('data-animation', nextProps.animation);
	  tooltip.style.maxWidth = nextProps.maxWidth + (typeof nextProps.maxWidth === 'number' ? 'px' : '');
	  if (nextProps.role) {
	    popper.setAttribute('role', nextProps.role);
	  } else {
	    popper.removeAttribute('role');
	  }
	  if (prevProps.content !== nextProps.content) {
	    setContent(content, nextProps);
	  }
	  if (!prevProps.animateFill && nextProps.animateFill) {
	    tooltip.appendChild(createBackdropElement());
	    tooltip.setAttribute('data-animatefill', '');
	  } else if (prevProps.animateFill && !nextProps.animateFill) {
	    tooltip.removeChild(backdrop);
	    tooltip.removeAttribute('data-animatefill');
	  }
	  if (!prevProps.arrow && nextProps.arrow) {
	    tooltip.appendChild(createArrowElement(nextProps.arrowType));
	  } else if (prevProps.arrow && !nextProps.arrow) {
	    tooltip.removeChild(arrow);
	  }
	  if (prevProps.arrow && nextProps.arrow && prevProps.arrowType !== nextProps.arrowType) {
	    tooltip.replaceChild(createArrowElement(nextProps.arrowType), arrow);
	  }
	  if (!prevProps.interactive && nextProps.interactive) {
	    addInteractive(popper, tooltip);
	  } else if (prevProps.interactive && !nextProps.interactive) {
	    removeInteractive(popper, tooltip);
	  }
	  if (!prevProps.inertia && nextProps.inertia) {
	    addInertia(tooltip);
	  } else if (prevProps.inertia && !nextProps.inertia) {
	    removeInertia(tooltip);
	  }
	  if (prevProps.theme !== nextProps.theme) {
	    updateTheme(tooltip, 'remove', prevProps.theme);
	    updateTheme(tooltip, 'add', nextProps.theme);
	  }
	}
	function hideAll() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      excludedReferenceOrInstance = _ref.exclude,
	      duration = _ref.duration;
	  arrayFrom(document.querySelectorAll(POPPER_SELECTOR)).forEach(function (popper) {
	    var instance = popper._tippy;
	    if (instance) {
	      var isExcluded = false;
	      if (excludedReferenceOrInstance) {
	        isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : popper === excludedReferenceOrInstance.popper;
	      }
	      if (!isExcluded) {
	        instance.hide(duration);
	      }
	    }
	  });
	}
	function isCursorOutsideInteractiveBorder(popperPlacement, popperRect, event, props) {
	  if (!popperPlacement) {
	    return true;
	  }
	  var x = event.clientX,
	      y = event.clientY;
	  var interactiveBorder = props.interactiveBorder,
	      distance = props.distance;
	  var exceedsTop = popperRect.top - y > (popperPlacement === 'top' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsBottom = y - popperRect.bottom > (popperPlacement === 'bottom' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsLeft = popperRect.left - x > (popperPlacement === 'left' ? interactiveBorder + distance : interactiveBorder);
	  var exceedsRight = x - popperRect.right > (popperPlacement === 'right' ? interactiveBorder + distance : interactiveBorder);
	  return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
	}
	function getOffsetDistanceInPx(distance) {
	  return -(distance - 10) + 'px';
	}
	var idCounter = 1;
	var mouseMoveListeners = [];
	function createTippy(reference, collectionProps) {
	  var props = evaluateProps(reference, collectionProps);
	  if (!props.multiple && reference._tippy) {
	    return null;
	  }
	  var lastTriggerEventType;
	  var lastMouseMoveEvent;
	  var showTimeoutId;
	  var hideTimeoutId;
	  var scheduleHideAnimationFrameId;
	  var isScheduledToShow = false;
	  var isBeingDestroyed = false;
	  var previousPlacement;
	  var wasVisibleDuringPreviousUpdate = false;
	  var hasMountCallbackRun = false;
	  var currentMountCallback;
	  var currentTransitionEndListener;
	  var listeners = [];
	  var currentComputedPadding;
	  var debouncedOnMouseMove = debounce$2(onMouseMove, props.interactiveDebounce);
	  var id = idCounter++;
	  var popper = createPopperElement(id, props);
	  var popperChildren = getChildren(popper);
	  var popperInstance = null;
	  var state = {
	    isEnabled: true,
	    isVisible: false,
	    isDestroyed: false,
	    isMounted: false,
	    isShown: false
	  };
	  var instance = {
	    id: id,
	    reference: reference,
	    popper: popper,
	    popperChildren: popperChildren,
	    popperInstance: popperInstance,
	    props: props,
	    state: state,
	    clearDelayTimeouts: clearDelayTimeouts,
	    set: set,
	    setContent: setContent,
	    show: show,
	    hide: hide,
	    enable: enable,
	    disable: disable,
	    destroy: destroy
	  };
	  reference._tippy = instance;
	  popper._tippy = instance;
	  addTriggersToReference();
	  if (!props.lazy) {
	    createPopperInstance();
	  }
	  if (props.showOnInit) {
	    scheduleShow();
	  }
	  if (props.a11y && !props.target && !canReceiveFocus(getEventListenersTarget())) {
	    getEventListenersTarget().setAttribute('tabindex', '0');
	  }
	  popper.addEventListener('mouseenter', function (event) {
	    if (instance.props.interactive && instance.state.isVisible && lastTriggerEventType === 'mouseenter') {
	      scheduleShow(event, true);
	    }
	  });
	  popper.addEventListener('mouseleave', function () {
	    if (instance.props.interactive && lastTriggerEventType === 'mouseenter') {
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	    }
	  });
	  return instance;
	  function removeFollowCursorListener() {
	    document.removeEventListener('mousemove', positionVirtualReferenceNearCursor);
	  }
	  function cleanupInteractiveMouseListeners() {
	    document.body.removeEventListener('mouseleave', scheduleHide);
	    document.removeEventListener('mousemove', debouncedOnMouseMove);
	    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
	      return listener !== debouncedOnMouseMove;
	    });
	  }
	  function getEventListenersTarget() {
	    return instance.props.triggerTarget || reference;
	  }
	  function addDocumentClickListener() {
	    document.addEventListener('click', onDocumentClick, true);
	  }
	  function removeDocumentClickListener() {
	    document.removeEventListener('click', onDocumentClick, true);
	  }
	  function getTransitionableElements() {
	    return [instance.popperChildren.tooltip, instance.popperChildren.backdrop, instance.popperChildren.content];
	  }
	  function getIsInLooseFollowCursorMode() {
	    var followCursor = instance.props.followCursor;
	    return followCursor && lastTriggerEventType !== 'focus' || isUsingTouch && followCursor === 'initial';
	  }
	  function makeSticky() {
	    setTransitionDuration([popper], isIE$1 ? 0 : instance.props.updateDuration);
	    function updatePosition() {
	      instance.popperInstance.scheduleUpdate();
	      if (instance.state.isMounted) {
	        requestAnimationFrame(updatePosition);
	      } else {
	        setTransitionDuration([popper], 0);
	      }
	    }
	    updatePosition();
	  }
	  function onTransitionedOut(duration, callback) {
	    onTransitionEnd(duration, function () {
	      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
	        callback();
	      }
	    });
	  }
	  function onTransitionedIn(duration, callback) {
	    onTransitionEnd(duration, callback);
	  }
	  function onTransitionEnd(duration, callback) {
	    var tooltip = instance.popperChildren.tooltip;
	    function listener(event) {
	      if (event.target === tooltip) {
	        updateTransitionEndListener(tooltip, 'remove', listener);
	        callback();
	      }
	    }
	    if (duration === 0) {
	      return callback();
	    }
	    updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener);
	    updateTransitionEndListener(tooltip, 'add', listener);
	    currentTransitionEndListener = listener;
	  }
	  function on(eventType, handler) {
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	    getEventListenersTarget().addEventListener(eventType, handler, options);
	    listeners.push({
	      eventType: eventType,
	      handler: handler,
	      options: options
	    });
	  }
	  function addTriggersToReference() {
	    if (instance.props.touchHold && !instance.props.target) {
	      on('touchstart', onTrigger, PASSIVE);
	      on('touchend', onMouseLeave, PASSIVE);
	    }
	    instance.props.trigger.trim().split(' ').forEach(function (eventType) {
	      if (eventType === 'manual') {
	        return;
	      }
	      if (!instance.props.target) {
	        on(eventType, onTrigger);
	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseleave', onMouseLeave);
	            break;
	          case 'focus':
	            on(isIE$1 ? 'focusout' : 'blur', onBlur);
	            break;
	        }
	      } else {
	        switch (eventType) {
	          case 'mouseenter':
	            on('mouseover', onDelegateShow);
	            on('mouseout', onDelegateHide);
	            break;
	          case 'focus':
	            on('focusin', onDelegateShow);
	            on('focusout', onDelegateHide);
	            break;
	          case 'click':
	            on(eventType, onDelegateShow);
	            break;
	        }
	      }
	    });
	  }
	  function removeTriggersFromReference() {
	    listeners.forEach(function (_ref) {
	      var eventType = _ref.eventType,
	          handler = _ref.handler,
	          options = _ref.options;
	      getEventListenersTarget().removeEventListener(eventType, handler, options);
	    });
	    listeners = [];
	  }
	  function positionVirtualReferenceNearCursor(event) {
	    var _lastMouseMoveEvent = lastMouseMoveEvent = event,
	        x = _lastMouseMoveEvent.clientX,
	        y = _lastMouseMoveEvent.clientY;
	    if (!currentComputedPadding) {
	      return;
	    }
	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });
	    var rect = reference.getBoundingClientRect();
	    var followCursor = instance.props.followCursor;
	    var isHorizontal = followCursor === 'horizontal';
	    var isVertical = followCursor === 'vertical';
	    var isVerticalPlacement = includes(['top', 'bottom'], getBasicPlacement(popper));
	    var fullPlacement = popper.getAttribute(PLACEMENT_ATTRIBUTE);
	    var isVariation = fullPlacement ? !!fullPlacement.split('-')[1] : false;
	    var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;
	    var halfSize = size / 2;
	    var verticalIncrease = isVerticalPlacement ? 0 : isVariation ? size : halfSize;
	    var horizontalIncrease = isVerticalPlacement ? isVariation ? size : halfSize : 0;
	    if (isCursorOverReference || !instance.props.interactive) {
	      instance.popperInstance.reference = _extends$3({}, instance.popperInstance.reference, {
	        clientWidth: 0,
	        clientHeight: 0,
	        getBoundingClientRect: function getBoundingClientRect() {
	          return {
	            width: isVerticalPlacement ? size : 0,
	            height: isVerticalPlacement ? 0 : size,
	            top: (isHorizontal ? rect.top : y) - verticalIncrease,
	            bottom: (isHorizontal ? rect.bottom : y) + verticalIncrease,
	            left: (isVertical ? rect.left : x) - horizontalIncrease,
	            right: (isVertical ? rect.right : x) + horizontalIncrease
	          };
	        }
	      });
	      instance.popperInstance.update();
	    }
	    if (followCursor === 'initial' && instance.state.isVisible) {
	      removeFollowCursorListener();
	    }
	  }
	  function createDelegateChildTippy(event) {
	    if (event) {
	      var targetEl = closest(event.target, instance.props.target);
	      if (targetEl && !targetEl._tippy) {
	        createTippy(targetEl, _extends$3({}, instance.props, {
	          content: invokeWithArgsOrReturn(collectionProps.content, [targetEl]),
	          appendTo: collectionProps.appendTo,
	          target: '',
	          showOnInit: true
	        }));
	      }
	    }
	  }
	  function onTrigger(event) {
	    if (!instance.state.isEnabled || isEventListenerStopped(event)) {
	      return;
	    }
	    if (!instance.state.isVisible) {
	      lastTriggerEventType = event.type;
	      if (event instanceof MouseEvent) {
	        lastMouseMoveEvent = event;
	        mouseMoveListeners.forEach(function (listener) {
	          return listener(event);
	        });
	      }
	    }
	    if (event.type === 'click' && instance.props.hideOnClick !== false && instance.state.isVisible) {
	      scheduleHide();
	    } else {
	      scheduleShow(event);
	    }
	  }
	  function onMouseMove(event) {
	    var isCursorOverPopper = closest(event.target, POPPER_SELECTOR) === popper;
	    var isCursorOverReference = closestCallback(event.target, function (el) {
	      return el === reference;
	    });
	    if (isCursorOverPopper || isCursorOverReference) {
	      return;
	    }
	    if (isCursorOutsideInteractiveBorder(getBasicPlacement(popper), popper.getBoundingClientRect(), event, instance.props)) {
	      cleanupInteractiveMouseListeners();
	      scheduleHide();
	    }
	  }
	  function onMouseLeave(event) {
	    if (isEventListenerStopped(event)) {
	      return;
	    }
	    if (instance.props.interactive) {
	      document.body.addEventListener('mouseleave', scheduleHide);
	      document.addEventListener('mousemove', debouncedOnMouseMove);
	      mouseMoveListeners.push(debouncedOnMouseMove);
	      return;
	    }
	    scheduleHide();
	  }
	  function onBlur(event) {
	    if (event.target !== getEventListenersTarget()) {
	      return;
	    }
	    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
	      return;
	    }
	    scheduleHide();
	  }
	  function onDelegateShow(event) {
	    if (closest(event.target, instance.props.target)) {
	      scheduleShow(event);
	    }
	  }
	  function onDelegateHide(event) {
	    if (closest(event.target, instance.props.target)) {
	      scheduleHide();
	    }
	  }
	  function isEventListenerStopped(event) {
	    var supportsTouch = ('ontouchstart' in window);
	    var isTouchEvent = includes(event.type, 'touch');
	    var touchHold = instance.props.touchHold;
	    return supportsTouch && isUsingTouch && touchHold && !isTouchEvent || isUsingTouch && !touchHold && isTouchEvent;
	  }
	  function runMountCallback() {
	    if (!hasMountCallbackRun && currentMountCallback) {
	      hasMountCallbackRun = true;
	      reflow(popper);
	      currentMountCallback();
	    }
	  }
	  function createPopperInstance() {
	    var popperOptions = instance.props.popperOptions;
	    var _instance$popperChild = instance.popperChildren,
	        tooltip = _instance$popperChild.tooltip,
	        arrow = _instance$popperChild.arrow;
	    var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow');
	    function applyMutations(data) {
	      if (instance.props.flip && !instance.props.flipOnUpdate) {
	        if (data.flipped) {
	          instance.popperInstance.options.placement = data.placement;
	        }
	        setFlipModifierEnabled(instance.popperInstance.modifiers, false);
	      }
	      tooltip.setAttribute(PLACEMENT_ATTRIBUTE, data.placement);
	      if (data.attributes[OUT_OF_BOUNDARIES_ATTRIBUTE] !== false) {
	        tooltip.setAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE, '');
	      } else {
	        tooltip.removeAttribute(OUT_OF_BOUNDARIES_ATTRIBUTE);
	      }
	      if (previousPlacement && previousPlacement !== data.placement && wasVisibleDuringPreviousUpdate) {
	        tooltip.style.transition = 'none';
	        requestAnimationFrame(function () {
	          tooltip.style.transition = '';
	        });
	      }
	      previousPlacement = data.placement;
	      wasVisibleDuringPreviousUpdate = instance.state.isVisible;
	      var basicPlacement = getBasicPlacement(popper);
	      var styles = tooltip.style;
	      styles.top = styles.bottom = styles.left = styles.right = '';
	      styles[basicPlacement] = getOffsetDistanceInPx(instance.props.distance);
	      var padding = preventOverflowModifier && preventOverflowModifier.padding !== undefined ? preventOverflowModifier.padding : PADDING;
	      var isPaddingNumber = typeof padding === 'number';
	      var computedPadding = _extends$3({
	        top: isPaddingNumber ? padding : padding.top,
	        bottom: isPaddingNumber ? padding : padding.bottom,
	        left: isPaddingNumber ? padding : padding.left,
	        right: isPaddingNumber ? padding : padding.right
	      }, !isPaddingNumber && padding);
	      computedPadding[basicPlacement] = isPaddingNumber ? padding + instance.props.distance : (padding[basicPlacement] || 0) + instance.props.distance;
	      instance.popperInstance.modifiers.filter(function (m) {
	        return m.name === 'preventOverflow';
	      })[0].padding = computedPadding;
	      currentComputedPadding = computedPadding;
	    }
	    var config = _extends$3({
	      eventsEnabled: false,
	      placement: instance.props.placement
	    }, popperOptions, {
	      modifiers: _extends$3({}, popperOptions ? popperOptions.modifiers : {}, {
	        preventOverflow: _extends$3({
	          boundariesElement: instance.props.boundary,
	          padding: PADDING
	        }, preventOverflowModifier),
	        arrow: _extends$3({
	          element: arrow,
	          enabled: !!arrow
	        }, getModifier(popperOptions, 'arrow')),
	        flip: _extends$3({
	          enabled: instance.props.flip,
	          padding: instance.props.distance + PADDING,
	          behavior: instance.props.flipBehavior
	        }, getModifier(popperOptions, 'flip')),
	        offset: _extends$3({
	          offset: instance.props.offset
	        }, getModifier(popperOptions, 'offset'))
	      }),
	      onCreate: function onCreate(data) {
	        applyMutations(data);
	        runMountCallback();
	        if (popperOptions && popperOptions.onCreate) {
	          popperOptions.onCreate(data);
	        }
	      },
	      onUpdate: function onUpdate(data) {
	        applyMutations(data);
	        runMountCallback();
	        if (popperOptions && popperOptions.onUpdate) {
	          popperOptions.onUpdate(data);
	        }
	      }
	    });
	    instance.popperInstance = new Popper(reference, popper, config);
	  }
	  function mount() {
	    hasMountCallbackRun = false;
	    var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
	    if (instance.popperInstance) {
	      setFlipModifierEnabled(instance.popperInstance.modifiers, instance.props.flip);
	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.reference = reference;
	        instance.popperInstance.enableEventListeners();
	      }
	      instance.popperInstance.scheduleUpdate();
	    } else {
	      createPopperInstance();
	      if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.enableEventListeners();
	      }
	    }
	    var appendTo = instance.props.appendTo;
	    var parentNode = appendTo === 'parent' ? reference.parentNode : invokeWithArgsOrReturn(appendTo, [reference]);
	    if (!parentNode.contains(popper)) {
	      parentNode.appendChild(popper);
	      instance.props.onMount(instance);
	      instance.state.isMounted = true;
	    }
	  }
	  function scheduleShow(event, shouldAvoidCallingOnTrigger) {
	    clearDelayTimeouts();
	    if (instance.state.isVisible) {
	      return;
	    }
	    if (instance.props.target) {
	      return createDelegateChildTippy(event);
	    }
	    isScheduledToShow = true;
	    if (event && !shouldAvoidCallingOnTrigger) {
	      instance.props.onTrigger(instance, event);
	    }
	    if (instance.props.wait) {
	      return instance.props.wait(instance, event);
	    }
	    if (getIsInLooseFollowCursorMode() && !instance.state.isMounted) {
	      if (!instance.popperInstance) {
	        createPopperInstance();
	      }
	      document.addEventListener('mousemove', positionVirtualReferenceNearCursor);
	    }
	    addDocumentClickListener();
	    var delay = getValue(instance.props.delay, 0, defaultProps.delay);
	    if (delay) {
	      showTimeoutId = setTimeout(function () {
	        show();
	      }, delay);
	    } else {
	      show();
	    }
	  }
	  function scheduleHide() {
	    clearDelayTimeouts();
	    if (!instance.state.isVisible) {
	      return removeFollowCursorListener();
	    }
	    isScheduledToShow = false;
	    var delay = getValue(instance.props.delay, 1, defaultProps.delay);
	    if (delay) {
	      hideTimeoutId = setTimeout(function () {
	        if (instance.state.isVisible) {
	          hide();
	        }
	      }, delay);
	    } else {
	      scheduleHideAnimationFrameId = requestAnimationFrame(function () {
	        hide();
	      });
	    }
	  }
	  function onDocumentClick(event) {
	    if (instance.props.interactive && popper.contains(event.target)) {
	      return;
	    }
	    if (getEventListenersTarget().contains(event.target)) {
	      if (isUsingTouch) {
	        return;
	      }
	      if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
	        return;
	      }
	    }
	    if (instance.props.hideOnClick === true) {
	      clearDelayTimeouts();
	      hide();
	    }
	  }
	  function enable() {
	    instance.state.isEnabled = true;
	  }
	  function disable() {
	    instance.state.isEnabled = false;
	  }
	  function clearDelayTimeouts() {
	    clearTimeout(showTimeoutId);
	    clearTimeout(hideTimeoutId);
	    cancelAnimationFrame(scheduleHideAnimationFrameId);
	  }
	  function set(options) {
	    options = options || {};
	    validateOptions(options, defaultProps);
	    removeTriggersFromReference();
	    var prevProps = instance.props;
	    var nextProps = evaluateProps(reference, _extends$3({}, instance.props, options, {
	      ignoreAttributes: true
	    }));
	    nextProps.ignoreAttributes = hasOwnProperty$1(options, 'ignoreAttributes') ? options.ignoreAttributes || false : prevProps.ignoreAttributes;
	    instance.props = nextProps;
	    addTriggersToReference();
	    cleanupInteractiveMouseListeners();
	    debouncedOnMouseMove = debounce$2(onMouseMove, nextProps.interactiveDebounce);
	    updatePopperElement(popper, prevProps, nextProps);
	    instance.popperChildren = getChildren(popper);
	    if (instance.popperInstance) {
	      if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
	        return hasOwnProperty$1(options, prop) && options[prop] !== prevProps[prop];
	      })) {
	        instance.popperInstance.destroy();
	        createPopperInstance();
	        if (instance.state.isVisible) {
	          instance.popperInstance.enableEventListeners();
	        }
	        if (instance.props.followCursor && lastMouseMoveEvent) {
	          positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	        }
	      } else {
	        instance.popperInstance.update();
	      }
	    }
	  }
	  function setContent(content) {
	    set({
	      content: content
	    });
	  }
	  function show() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 0, defaultProps.duration[1]);
	    if (instance.state.isDestroyed || !instance.state.isEnabled || isUsingTouch && !instance.props.touch) {
	      return;
	    }
	    if (getEventListenersTarget().hasAttribute('disabled')) {
	      return;
	    }
	    if (instance.props.onShow(instance) === false) {
	      return;
	    }
	    addDocumentClickListener();
	    popper.style.visibility = 'visible';
	    instance.state.isVisible = true;
	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.add(ACTIVE_CLASS);
	    }
	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements.concat(popper), 0);
	    currentMountCallback = function currentMountCallback() {
	      if (!instance.state.isVisible) {
	        return;
	      }
	      var isInLooseFollowCursorMode = getIsInLooseFollowCursorMode();
	      if (isInLooseFollowCursorMode && lastMouseMoveEvent) {
	        positionVirtualReferenceNearCursor(lastMouseMoveEvent);
	      } else if (!isInLooseFollowCursorMode) {
	        instance.popperInstance.update();
	      }
	      if (instance.popperChildren.backdrop) {
	        instance.popperChildren.content.style.transitionDelay = Math.round(duration / 12) + 'ms';
	      }
	      if (instance.props.sticky) {
	        makeSticky();
	      }
	      setTransitionDuration([popper], instance.props.updateDuration);
	      setTransitionDuration(transitionableElements, duration);
	      setVisibilityState(transitionableElements, 'visible');
	      onTransitionedIn(duration, function () {
	        if (instance.props.aria) {
	          getEventListenersTarget().setAttribute("aria-".concat(instance.props.aria), popper.id);
	        }
	        instance.props.onShown(instance);
	        instance.state.isShown = true;
	      });
	    };
	    mount();
	  }
	  function hide() {
	    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getValue(instance.props.duration, 1, defaultProps.duration[1]);
	    if (instance.state.isDestroyed || !instance.state.isEnabled && !isBeingDestroyed) {
	      return;
	    }
	    if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
	      return;
	    }
	    removeDocumentClickListener();
	    popper.style.visibility = 'hidden';
	    instance.state.isVisible = false;
	    instance.state.isShown = false;
	    wasVisibleDuringPreviousUpdate = false;
	    if (instance.props.interactive) {
	      getEventListenersTarget().classList.remove(ACTIVE_CLASS);
	    }
	    var transitionableElements = getTransitionableElements();
	    setTransitionDuration(transitionableElements, duration);
	    setVisibilityState(transitionableElements, 'hidden');
	    onTransitionedOut(duration, function () {
	      if (!isScheduledToShow) {
	        removeFollowCursorListener();
	      }
	      if (instance.props.aria) {
	        getEventListenersTarget().removeAttribute("aria-".concat(instance.props.aria));
	      }
	      instance.popperInstance.disableEventListeners();
	      instance.popperInstance.options.placement = instance.props.placement;
	      popper.parentNode.removeChild(popper);
	      instance.props.onHidden(instance);
	      instance.state.isMounted = false;
	    });
	  }
	  function destroy(destroyTargetInstances) {
	    if (instance.state.isDestroyed) {
	      return;
	    }
	    isBeingDestroyed = true;
	    if (instance.state.isMounted) {
	      hide(0);
	    }
	    removeTriggersFromReference();
	    delete reference._tippy;
	    var target = instance.props.target;
	    if (target && destroyTargetInstances && isRealElement(reference)) {
	      arrayFrom(reference.querySelectorAll(target)).forEach(function (child) {
	        if (child._tippy) {
	          child._tippy.destroy();
	        }
	      });
	    }
	    if (instance.popperInstance) {
	      instance.popperInstance.destroy();
	    }
	    isBeingDestroyed = false;
	    instance.state.isDestroyed = true;
	  }
	}
	function group(instances) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$delay = _ref.delay,
	      delay = _ref$delay === void 0 ? instances[0].props.delay : _ref$delay,
	      _ref$duration = _ref.duration,
	      duration = _ref$duration === void 0 ? 0 : _ref$duration;
	  var isAnyTippyOpen = false;
	  instances.forEach(function (instance) {
	    if (instance._originalProps) {
	      instance.set(instance._originalProps);
	    } else {
	      instance._originalProps = _extends$3({}, instance.props);
	    }
	  });
	  function setIsAnyTippyOpen(value) {
	    isAnyTippyOpen = value;
	    updateInstances();
	  }
	  function onShow(instance) {
	    instance._originalProps.onShow(instance);
	    instances.forEach(function (instance) {
	      instance.set({
	        duration: duration
	      });
	      if (instance.state.isVisible) {
	        instance.hide();
	      }
	    });
	    setIsAnyTippyOpen(true);
	  }
	  function onHide(instance) {
	    instance._originalProps.onHide(instance);
	    setIsAnyTippyOpen(false);
	  }
	  function onShown(instance) {
	    instance._originalProps.onShown(instance);
	    instance.set({
	      duration: instance._originalProps.duration
	    });
	  }
	  function updateInstances() {
	    instances.forEach(function (instance) {
	      instance.set({
	        onShow: onShow,
	        onShown: onShown,
	        onHide: onHide,
	        delay: isAnyTippyOpen ? [0, isArray$1(delay) ? delay[1] : delay] : delay,
	        duration: isAnyTippyOpen ? duration : instance._originalProps.duration
	      });
	    });
	  }
	  updateInstances();
	}
	var globalEventListenersBound = false;
	function tippy(targets, options) {
	  validateOptions(options || {}, defaultProps);
	  if (!globalEventListenersBound) {
	    bindGlobalEventListeners();
	    globalEventListenersBound = true;
	  }
	  var props = _extends$3({}, defaultProps, options);
	  if (isBareVirtualElement(targets)) {
	    polyfillElementPrototypeProperties(targets);
	  }
	  var instances = getArrayOfElements(targets).reduce(function (acc, reference) {
	    var instance = reference && createTippy(reference, props);
	    if (instance) {
	      acc.push(instance);
	    }
	    return acc;
	  }, []);
	  return isSingular(targets) ? instances[0] : instances;
	}
	tippy.version = version;
	tippy.defaults = defaultProps;
	tippy.setDefaults = function (partialDefaults) {
	  keys$1(partialDefaults).forEach(function (key) {
	    defaultProps[key] = partialDefaults[key];
	  });
	};
	tippy.hideAll = hideAll;
	tippy.group = group;
	function autoInit() {
	  arrayFrom(document.querySelectorAll('[data-tippy]')).forEach(function (el) {
	    var content = el.getAttribute('data-tippy');
	    if (content) {
	      tippy(el, {
	        content: content
	      });
	    }
	  });
	}
	if (isBrowser$1) {
	  setTimeout(autoInit);
	}
	var getValidTippyProps = function getValidTippyProps(props) {
	  var validProps = {};
	  for (var key in props) {
	    if (defaultProps.hasOwnProperty(key)) {
	      validProps[key] = props[key];
	    }
	  }
	  return validProps;
	};

	var requestAnimationFrame$2 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	  window.setTimeout(callback, 1000 / 60);
	};
	var cancelAnimationFrame$2 = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {
	  window.clearTimeout(id);
	};
	function uuid() {
	  var id = '';
	  var randomNum = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  for (var i = 0; i < 7; i++) {
	    id += randomNum;
	  }
	  return id;
	}
	function checkOverflow(el) {
	  if (!el) return false;
	  var createDom = function createDom(el, css) {
	    var dom = document.createElement('div');
	    var width = _parseFloat$2(css['width']) ? Math.ceil(_parseFloat$2(css['width'])) + 'px' : css['width'];
	    dom.style.cssText = "\n        width: ".concat(width, ";\n        line-height: ").concat(css['line-height'], ";\n        font-size: ").concat(css['font-size'], ";\n        word-break: ").concat(css['word-break'], ";\n        padding: ").concat(css['padding'], ";\n    ");
	    dom.textContent = el.textContent;
	    return dom;
	  };
	  var isOverflow = false;
	  try {
	    var css = window.getComputedStyle(el, null);
	    var lineClamp = css.webkitLineClamp;
	    if (lineClamp !== 'none') {
	      var targetHeight = _parseFloat$2(css.height);
	      var dom = createDom(el, css);
	      document.body.appendChild(dom);
	      var domHeight = window.getComputedStyle(dom, null)['height'];
	      document.body.removeChild(dom);
	      isOverflow = targetHeight < _parseFloat$2(domHeight);
	    } else {
	      isOverflow = el.clientWidth < el.scrollWidth || el.clientHeight < el.scrollHeight;
	    }
	  } catch (e) {
	    console.warn('There is an error when check element overflow state: ', e);
	  }
	  return isOverflow;
	}

	function beforeShow(instance) {
	  var reference = instance.reference;
	  var props = reference._bk_overflow_tips_.props;
	  var isOverflow = checkOverflow(reference);
	  if (isOverflow) {
	    instance.setContent(props.content ? props.content : props.allowHTML ? reference.innerHTML : reference.textContent);
	    return true;
	  }
	  return false;
	}
	function setupOnShow(props, customProps) {
	  props.onShow = function (instance) {
	    if (typeof customProps.onShow === 'function') {
	      var result = customProps.onShow(instance);
	      if (!result) return false;
	    }
	    return beforeShow(instance);
	  };
	}
	function setupTheme(props, customProps) {
	  var theme = ['bk-overflow-tips'];
	  if (customProps.theme) {
	    theme.push(customProps.theme);
	  }
	  props.theme = theme.join(' ');
	}
	var defaultProps$1 = {
	  arrow: true,
	  interactive: true,
	  delay: 150,
	  allowHTML: false,
	  maxWidth: 400,
	  boundary: 'window',
	  placement: 'top'
	};
	var overflowTips = {
	  inserted: function inserted(el) {
	    var binding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
	    var props = _extends(_objectSpread({}, defaultProps$1), customProps);
	    setupOnShow(props, customProps);
	    setupTheme(props, customProps);
	    el._bk_overflow_tips_ = {
	      props: props,
	      instance: tippy(el, props)
	    };
	  },
	  update: function update(el, binding) {
	    var _el$_bk_overflow_tips = el._bk_overflow_tips_,
	        props = _el$_bk_overflow_tips.props,
	        instance = _el$_bk_overflow_tips.instance;
	    var customProps = _typeof(binding.value) === 'object' ? binding.value : {};
	    _extends(props, customProps);
	    setupOnShow(props, customProps);
	    instance.set(props);
	  },
	  unbind: function unbind(el) {
	    el._tippy && el._tippy.destroy();
	    delete el._bk_overflow_tips_;
	  },
	  setDefaultProps: function setDefaultProps(props) {
	    _extends(defaultProps$1, props);
	  }
	};
	overflowTips.install = function (Vue) {
	  Vue.directive('bk-overflow-tips', overflowTips);
	};

	var emitter = {
	  methods: {
	    dispatch: function dispatch(componentName, eventName, params) {
	      var parent = this.$parent || this.$root;
	      var name = parent.$options.name;
	      while (parent && (!name || name !== componentName)) {
	        parent = parent.$parent;
	        if (parent) {
	          name = parent.$options.name;
	        }
	      }
	      if (parent) {
	        parent.$emit.apply(parent, [eventName].concat(params));
	      }
	    }
	  }
	};

	var checkboxSeed = 0;
	var groupSeed = 0;
	function getCheckboxName() {
	  return "bk-checkbox_".concat(checkboxSeed++);
	}
	function getGroupName() {
	  return "bk-checkbox-group_".concat(groupSeed++);
	}

	var script$1 = {
	  name: 'bk-checkbox',
	  mixins: [emitter],
	  props: {
	    value: {
	      type: [String, Number, Boolean],
	      default: undefined
	    },
	    checked: {
	      type: Boolean,
	      default: undefined
	    },
	    trueValue: {
	      type: [String, Number, Boolean],
	      default: true
	    },
	    falseValue: {
	      type: [String, Number, Boolean],
	      default: false
	    },
	    label: {
	      type: [String, Number]
	    },
	    name: {
	      type: String,
	      default: function _default() {
	        return getCheckboxName();
	      }
	    },
	    disabled: Boolean,
	    indeterminate: Boolean,
	    extCls: {
	      type: String,
	      default: ''
	    },
	    beforeChange: Function
	  },
	  data: function data() {
	    return {
	      parent: null,
	      localValue: undefined
	    };
	  },
	  computed: {
	    selected: function selected() {
	      return this.localValue === this.localTrueValue;
	    },
	    parentValue: function parentValue() {
	      return this.parent ? this.parent.localValue : null;
	    },
	    localTrueValue: function localTrueValue() {
	      var localValue;
	      if (this.parent) {
	        if (this.label === undefined && this.value === undefined) {
	          localValue = this.trueValue;
	        } else if (this.value !== undefined) {
	          localValue = this.value;
	        } else {
	          localValue = this.label;
	        }
	      } else {
	        if (this.label === undefined) {
	          localValue = this.trueValue;
	        } else {
	          localValue = this.label;
	        }
	      }
	      return localValue;
	    }
	  },
	  watch: {
	    value: function value(val) {
	      this.setLocalValue(val);
	    },
	    checked: function checked() {
	      this.setLocalValue();
	    },
	    parentValue: function parentValue() {
	      this.setLocalValue();
	    }
	  },
	  created: function created() {
	    this.dispatch('bk-checkbox-group', 'checkbox-item-add', this);
	    this.init();
	  },
	  methods: {
	    getValue: function getValue() {
	      if (this.selected) {
	        return {
	          isChecked: true,
	          value: this.localTrueValue
	        };
	      } else {
	        return {
	          isChecked: false,
	          value: this.falseValue
	        };
	      }
	    },
	    init: function init() {
	      var parent = this.$parent;
	      while (parent && !parent.isCheckboxGroup && !parent.$options.name !== 'bk-checkbox-group') {
	        parent = parent.$parent;
	      }
	      this.parent = parent;
	      this.setLocalValue();
	    },
	    setLocalValue: function setLocalValue(val) {
	      if (val !== undefined) {
	        this.localValue = val;
	        return;
	      }
	      if (this.parent) {
	        var trueValue = this.localTrueValue;
	        var isSelected = this.parent.localValue.includes(trueValue);
	        this.localValue = isSelected ? trueValue : this.falseValue;
	      } else {
	        if (this.checked !== undefined) {
	          this.localValue = this.checked ? this.localTrueValue : this.falseValue;
	        } else if (this.value === undefined) {
	          this.localValue = this.falseValue;
	        } else {
	          this.localValue = this.value;
	        }
	      }
	    },
	    handleClick: function handleClick() {
	      var _this = this;
	      return _asyncToGenerator( regenerator.mark(function _callee() {
	        var shouldChange, oldValue, newValue, groupValue;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!_this.disabled) {
	                  _context.next = 2;
	                  break;
	                }
	                return _context.abrupt("return", false);
	              case 2:
	                if (!(typeof _this.beforeChange === 'function')) {
	                  _context.next = 8;
	                  break;
	                }
	                _context.next = 5;
	                return _this.beforeChange();
	              case 5:
	                shouldChange = _context.sent;
	                if (!(shouldChange === false)) {
	                  _context.next = 8;
	                  break;
	                }
	                return _context.abrupt("return");
	              case 8:
	                oldValue = _this.localValue;
	                if (_this.indeterminate) {
	                  newValue = _this.localTrueValue;
	                } else {
	                  newValue = oldValue === _this.localTrueValue ? _this.falseValue : _this.localTrueValue;
	                }
	                _this.localValue = newValue;
	                _this.$emit('input', newValue, _this.localTrueValue);
	                _this.$emit('change', newValue, oldValue, _this.localTrueValue);
	                _this.dispatch('bk-form-item', 'form-change');
	                if (_this.parent) {
	                  groupValue = _this.localTrueValue === undefined ? newValue : _this.localTrueValue;
	                  _this.parent.handleChange(_this.selected, groupValue);
	                }
	              case 15:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }))();
	    }
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('label', {
	    staticClass: "bk-form-checkbox",
	    class: [{
	      'is-disabled': _vm.disabled,
	      'is-indeterminate': _vm.indeterminate,
	      'is-checked': _vm.selected
	    }, _vm.extCls],
	    on: {
	      "click": _vm.handleClick,
	      "keydown": function keydown($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
	          return null;
	        }

	        $event.preventDefault();
	        return _vm.handleClick($event);
	      }
	    }
	  }, [_c('span', {
	    staticClass: "bk-checkbox",
	    attrs: {
	      "tabindex": _vm.disabled ? false : 0
	    }
	  }), _c('input', {
	    attrs: {
	      "type": "hidden",
	      "name": _vm.name
	    },
	    domProps: {
	      "value": _vm.label === undefined ? _vm.localValue : _vm.label
	    }
	  }), _vm.$slots.default ? _c('span', {
	    staticClass: "bk-checkbox-text"
	  }, [_vm._t("default")], 2) : _vm._e()]);
	};

	var __vue_staticRenderFns__$1 = [];
	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* module identifier */

	var __vue_module_identifier__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	function setInstaller (component, afterInstall) {
	  component.install = function (Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var props = component.props || {};
	    keys$1(options).forEach(function (key) {
	      if (props.hasOwnProperty(key)) {
	        if (typeof props[key] === 'function' || props[key] instanceof Array) {
	          props[key] = {
	            type: props[key],
	            default: options[key]
	          };
	        } else {
	          props[key].default = options[key];
	        }
	      }
	    });
	    component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
	    Vue.component(component.name, component);
	    typeof afterInstall === 'function' && afterInstall(Vue, options);
	  };
	}

	setInstaller(__vue_component__$1);

	var LayoutObserver = {
	  created: function created() {
	    this.tableLayout.addObserver(this);
	  },
	  destroyed: function destroyed() {
	    this.tableLayout.removeObserver(this);
	  },
	  computed: {
	    tableLayout: function tableLayout() {
	      var layout = this.layout;
	      if (!layout && this.table) {
	        layout = this.table.layout;
	      }
	      if (!layout) {
	        throw new Error('Can not find table layout.');
	      }
	      return layout;
	    }
	  },
	  mounted: function mounted() {
	    this.onColumnsChange(this.tableLayout);
	    this.onScrollableChange(this.tableLayout);
	  },
	  updated: function updated() {
	    if (this.__updated__) {
	      return;
	    }
	    this.onColumnsChange(this.tableLayout);
	    this.onScrollableChange(this.tableLayout);
	    this.__updated__ = true;
	  },
	  methods: {
	    onColumnsChange: function onColumnsChange() {
	      var cols = this.$el.querySelectorAll('colgroup > col');
	      if (!cols.length) {
	        return;
	      }
	      var flattenColumns = this.tableLayout.getFlattenColumns();
	      var columnsMap = {};
	      flattenColumns.forEach(function (column) {
	        columnsMap[column.id] = column;
	      });
	      for (var i = 0, j = cols.length; i < j; i++) {
	        var col = cols[i];
	        var name = col.getAttribute('name');
	        var column = columnsMap[name];
	        if (column) {
	          col.setAttribute('width', column.realWidth || column.width);
	        }
	      }
	    },
	    onScrollableChange: function onScrollableChange(layout) {
	      var cols = this.$el.querySelectorAll('colgroup > col[name=gutter]');
	      for (var i = 0, j = cols.length; i < j; i++) {
	        var col = cols[i];
	        col.setAttribute('width', layout.scrollY ? layout.gutterWidth : '0');
	      }
	      var ths = this.$el.querySelectorAll('th.gutter');
	      for (var _i = 0, _j = ths.length; _i < _j; _i++) {
	        var th = ths[_i];
	        th.style.width = layout.scrollY ? layout.gutterWidth + 'px' : '0';
	        th.style.display = layout.scrollY ? '' : 'none';
	      }
	    }
	  }
	};

	function visibleRender(e, wrapper, binding) {
	  var _binding$value = binding.value,
	      _binding$value$lineHe = _binding$value.lineHeight,
	      lineHeight = _binding$value$lineHe === void 0 ? 30 : _binding$value$lineHe,
	      callback = _binding$value.callback;
	  var scrollTop = wrapper.scrollTop,
	      offsetHeight = wrapper.offsetHeight,
	      startIndex = wrapper.startIndex,
	      endIndex = wrapper.endIndex;
	  var targetStartIndex = Math.floor(scrollTop / lineHeight);
	  var targetEndIndex = Math.ceil(offsetHeight / lineHeight) + targetStartIndex;
	  if (startIndex !== targetStartIndex || endIndex !== targetEndIndex) {
	    typeof callback === 'function' && callback(e, targetStartIndex, targetEndIndex, scrollTop);
	  }
	}
	var throttledRender = throttle(60, function (e, wrapper, binding) {
	  return visibleRender(e, wrapper, binding);
	});
	var virtualRender = {
	  inserted: function inserted(el, binding) {
	    var wrapper = el.parentNode;
	    wrapper.addEventListener('scroll', function (e) {
	      return throttledRender(e, wrapper, binding);
	    });
	  },
	  componentUpdated: function componentUpdated(el, binding) {
	    var wrapper = el.parentNode;
	    throttledRender(null, wrapper, binding);
	  },
	  unbind: function unbind(el) {
	    if (el) {
	      var wrapper = el.parentNode;
	      wrapper && wrapper.removeEventListener('scroll', throttledRender);
	    }
	  }
	};

	var Component = {
	  name: 'bk-virtual-render',
	  directives: {
	    virtualRender: virtualRender
	  },
	  props: {
	    className: {
	      type: String,
	      default: ''
	    },
	    scrollXName: {
	      type: String,
	      default: 'bk-scroll-x'
	    },
	    scrollYName: {
	      type: String,
	      default: 'bk-scroll-y'
	    },
	    list: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    lineHeight: {
	      type: Number,
	      default: 30
	    },
	    minHeight: {
	      type: Number,
	      default: 30
	    },
	    height: {
	      type: [Number, String],
	      default: '100%'
	    },
	    width: {
	      type: [Number, String],
	      default: '100%'
	    },
	    groupItemCount: {
	      type: Number,
	      default: 1
	    },
	    preloadItemCount: {
	      type: Number,
	      default: 1
	    },
	    renderAs: {
	      type: String,
	      default: 'div'
	    },
	    contentAs: {
	      type: String,
	      default: 'div'
	    },
	    scrollPosition: {
	      type: String,
	      default: 'content'
	    },
	    abosuteHeight: {
	      type: [Number, String],
	      default: 'auto'
	    }
	  },
	  data: function data() {
	    return {
	      startIndex: 0,
	      endIndex: 0,
	      scrollTop: 1,
	      translateY: 0
	    };
	  },
	  computed: {
	    listLength: function listLength() {
	      return Math.ceil((this.localList || []).length / this.groupItemCount);
	    },
	    calcList: function calcList() {
	      return this.localList.slice(this.startIndex * this.groupItemCount, (this.endIndex + this.preloadItemCount) * this.groupItemCount);
	    },
	    wrapperStyle: function wrapperStyle() {
	      return {
	        height: typeof this.height === 'number' ? "".concat(this.height, "px") : this.height,
	        width: typeof this.width === 'number' ? "".concat(this.width, "px") : this.width,
	        display: 'inline-block'
	      };
	    },
	    innerHeight: function innerHeight() {
	      return this.abosuteHeight === 'auto' ? this.lineHeight * this.listLength : "".concat(this.abosuteHeight, "px");
	    },
	    innerContentStyle: function innerContentStyle() {
	      return {
	        top: "".concat(this.scrollTop, "px"),
	        transform: "translateY(-".concat(this.translateY, "px)")
	      };
	    },
	    innerStyle: function innerStyle() {
	      return {
	        height: "".concat(this.innerHeight < this.minHeight ? this.minHeight : this.innerHeight, "px"),
	        display: this.abosuteHeight === 0 ? 'none' : 'block'
	      };
	    },
	    localList: function localList() {
	      return (this.list || []).map(function (item, index) {
	        return _extends(item, {
	          $index: index
	        });
	      });
	    }
	  },
	  watch: {
	    list: function list(val) {
	      var _this = this;
	      this.$nextTick(function () {
	        return _this.scrollToIndex(0);
	      });
	    }
	  },
	  methods: {
	    handleScrollCallback: function handleScrollCallback(event, startIndex, endIndex, scrollTop) {
	      this.startIndex = startIndex;
	      this.endIndex = endIndex;
	      this.scrollTop = scrollTop;
	      this.$emit('content-scroll', event);
	      this.translateY = scrollTop % this.lineHeight;
	    },
	    scrollToIndex: function scrollToIndex(index) {
	      if (index >= 0) {
	        var scrollTop = this.lineHeight * index;
	        this.$el && this.$el.scrollTo({
	          top: scrollTop,
	          behavior: 'smooth'
	        });
	      }
	    }
	  },
	  render: function render(h) {
	    return h(this.renderAs || 'div', {
	      class: ['bk-virtual-render', this.scrollXName, this.scrollYName, this.className, this.scrollPosition === 'container' ? 'bk-virtual-content' : ''],
	      style: _objectSpread({}, this.wrapperStyle, this.scrollPosition === 'container' ? this.innerContentStyle : {})
	    }, [this.$slots.beforeContent, h(this.contentAs || 'div', {
	      class: [this.scrollPosition === 'content' ? 'bk-virtual-content' : ''],
	      style: this.scrollPosition === 'content' ? this.innerContentStyle : {},
	      directives: [{
	        name: 'virtual-render',
	        value: {
	          callback: this.handleScrollCallback,
	          listLength: this.listLength,
	          lineHeight: this.lineHeight,
	          startIndex: this.startIndex,
	          endIndex: this.endIndex
	        }
	      }]
	    }, [this.$scopedSlots.default({
	      data: this.calcList
	    })]), this.$slots.afterContent, h('div', {
	      class: ['bk-virtual-section'],
	      style: this.innerStyle
	    })]);
	  }
	};

	setInstaller(Component);

	var TableBody = {
	  name: 'bk-table-body',
	  mixins: [LayoutObserver],
	  components: {
	    bkCheckbox: __vue_component__$1,
	    bkVirtualRender: Component
	  },
	  directives: {
	    bkOverflowTips: overflowTips
	  },
	  props: {
	    store: {
	      required: true
	    },
	    stripe: Boolean,
	    context: {},
	    rowClassName: [String, Function],
	    rowStyle: [Object, Function],
	    fixed: String,
	    highlight: Boolean
	  },
	  render: function render(h) {
	    var _this = this;
	    var columnsHidden = this.columns.map(function (column, index) {
	      return _this.isColumnHidden(index);
	    });
	    var renderRows = function renderRows(row, $index) {
	      return [h("tr", helper([{
	        "ref": "row",
	        "refInFor": true,
	        "style": _this.getRowStyle(row, $index),
	        "key": _this.table.rowKey ? _this.getKeyOfRow(row, $index) : $index,
	        "on": {
	          "dblclick": function dblclick($event) {
	            return _this.handleDoubleClick($event, row);
	          },
	          "click": function click($event) {
	            return _this.handleClick($event, row);
	          },
	          "contextmenu": function contextmenu($event) {
	            return _this.handleContextMenu($event, row);
	          },
	          "mouseenter": function mouseenter($event) {
	            return _this.handleMouseEnter($index, $event, row);
	          },
	          "mouseleave": function mouseleave($event) {
	            return _this.handleMouseLeave($index, $event, row);
	          }
	        },
	        "class": [_this.getRowClass(row, $index)]
	      }, {
	        "attrs": _this.getRowAttributes(row, $index)
	      }]), [_this._l(_this.columns, function (column, cellIndex) {
	        var _this$getSpan = _this.getSpan(row, column, $index, cellIndex),
	            rowspan = _this$getSpan.rowspan,
	            colspan = _this$getSpan.colspan;
	        if (!rowspan || !colspan || column.type === 'setting') {
	          return '';
	        } else {
	          return h("td", helper([{
	            "style": _this.getCellStyle($index, cellIndex, row, column),
	            "class": _this.getCellClass($index, cellIndex, row, column),
	            "attrs": {
	              "rowspan": rowspan,
	              "colspan": colspan
	            },
	            "on": {
	              "mouseenter": function mouseenter($event) {
	                return _this.handleCellMouseEnter($event, row);
	              },
	              "mouseleave": _this.handleCellMouseLeave
	            }
	          }, {
	            "domProps": _this.getCellAttributes($index, cellIndex, row, column)
	          }]), [_this.isColumnInvisible(cellIndex) ? '' : column.renderCell.call(_this._renderProxy, h, {
	            row: row,
	            column: column,
	            $index: $index,
	            store: _this.store,
	            _self: _this.context || _this.table.$vnode.context
	          }, columnsHidden[cellIndex])]);
	        }
	      })]), _this.store.isRowExpanded(row) ? h("tr", helper([{
	        "ref": "row",
	        "refInFor": true
	      }, {
	        "attrs": _this.getExpandedRowAttributes(row, $index)
	      }, {
	        "style": _this.getExpandedRowStyle(row, $index),
	        "class": _this.getExpandedRowClass(row, $index)
	      }]), [h("td", {
	        "attrs": {
	          "colspan": _this.columns.length
	        },
	        "class": "bk-table-expanded-cell"
	      }, [!_this.fixed && _this.table.renderExpanded ? _this.table.renderExpanded(h, {
	        row: row,
	        $index: $index,
	        store: _this.store
	      }) : ''])]) : ''];
	    };
	    var tableStyle = {
	      width: "".concat(this.tableLayout.bodyWidth - (this.tableLayout.scrollY ? 10 : 0), "px")
	    };
	    return this.virtualRender ? h("bk-virtual-render", helper([{
	      "attrs": {
	        "list": this.data,
	        "width": this.virtualRenderOpt.width,
	        "height": this.virtualRenderOpt.height,
	        "lineHeight": this.virtualRenderOpt.lineHeight
	      }
	    }, {
	      scopedSlots: {
	        default: function _default(slot) {
	          return h("table", {
	            "class": "bk-table-body",
	            "attrs": {
	              "cellspacing": "0",
	              "cellpadding": "0",
	              "border": "0"
	            },
	            "style": tableStyle
	          }, [h("colgroup", [_this._l(_this.columns, function (column) {
	            return h("col", {
	              "attrs": {
	                "name": column.id
	              }
	            });
	          })]), h("tbody", [_this._l(slot.data, renderRows)])]);
	        }
	      }
	    }])) : h("table", {
	      "class": "bk-table-body",
	      "attrs": {
	        "cellspacing": "0",
	        "cellpadding": "0",
	        "border": "0"
	      }
	    }, [h("colgroup", [this._l(this.columns, function (column) {
	      return h("col", {
	        "attrs": {
	          "name": column.id
	        }
	      });
	    })]), h("tbody", [this._l(this.data, renderRows)])]);
	  },
	  watch: {
	    'store.states.hoverRow': function storeStatesHoverRow(newVal, oldVal) {
	      var el = this.$el;
	      if (!el) {
	        return;
	      }
	      var tr = el.querySelector('tbody').children;
	      var rows = [].filter.call(tr, function (row) {
	        return hasClass(row, 'bk-table-row');
	      });
	      var oldRow = rows[oldVal];
	      var newRow = rows[newVal];
	      if (oldRow) {
	        removeClass(oldRow, 'hover-row');
	      }
	      if (newRow) {
	        addClass(newRow, 'hover-row');
	      }
	    },
	    'store.states.currentRow': function storeStatesCurrentRow(newVal, oldVal) {
	      if (!this.highlight) {
	        return;
	      }
	      var el = this.$el;
	      if (!el) {
	        return;
	      }
	      var data = this.store.states.data;
	      var tr = el.querySelector('tbody').children;
	      var rows = [].filter.call(tr, function (row) {
	        return hasClass(row, 'bk-table-row');
	      });
	      var oldRow = rows[data.indexOf(oldVal)];
	      var newRow = rows[data.indexOf(newVal)];
	      if (oldRow) {
	        removeClass(oldRow, 'current-row');
	      } else {
	        [].forEach.call(rows, function (row) {
	          return removeClass(row, 'current-row');
	        });
	      }
	      if (newRow) {
	        addClass(newRow, 'current-row');
	      }
	    }
	  },
	  computed: {
	    table: function table() {
	      return this.$parent;
	    },
	    data: function data() {
	      return this.store.states.data;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedLeafCount: function leftFixedLeafCount() {
	      return this.store.states.fixedLeafColumnsLength;
	    },
	    rightFixedLeafCount: function rightFixedLeafCount() {
	      return this.store.states.rightFixedLeafColumnsLength;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    },
	    virtualRender: function virtualRender() {
	      return this.table.isVirtualRender;
	    },
	    virtualRenderOpt: function virtualRenderOpt() {
	      var _this2 = this;
	      if (this.virtualRender) {
	        var virtualCfg = keys$1(this.table.virtualRender).filter(function (key) {
	          return ['height', 'width', 'lineHeight'].includes(key);
	        }).reduce(function (pre, curr) {
	          return _objectSpread({}, pre, _defineProperty({}, curr, _this2.table.virtualRender[curr]));
	        }, {});
	        return _objectSpread({
	          height: this.tableLayout.bodyHeight - 4,
	          width: '100%',
	          lineHeight: 42
	        }, virtualCfg || {});
	      }
	      return {};
	    }
	  },
	  data: function data() {
	    return {
	      tooltipContent: ''
	    };
	  },
	  created: function created() {
	    this.activateTooltip = debounce(50, function (tooltip) {
	      return tooltip.handleShowPopper();
	    });
	  },
	  updated: function updated() {
	    this.syncFixedRowHeight();
	  },
	  methods: {
	    getKeyOfRow: function getKeyOfRow(row, index) {
	      var rowKey = this.table.rowKey;
	      if (rowKey) {
	        return getRowIdentity(row, rowKey);
	      }
	      return index;
	    },
	    isColumnInvisible: function isColumnInvisible(index) {
	      if (!this.fixed) {
	        return false;
	      }
	      return this.isColumnHidden(index);
	    },
	    isColumnHidden: function isColumnHidden(index) {
	      if (this.fixed === true || this.fixed === 'left') {
	        return index >= this.leftFixedLeafCount;
	      } else if (this.fixed === 'right') {
	        return index < this.columnsCount - this.rightFixedLeafCount;
	      } else {
	        return index < this.leftFixedLeafCount || index >= this.columnsCount - this.rightFixedLeafCount;
	      }
	    },
	    getSpan: function getSpan(row, column, rowIndex, columnIndex) {
	      var rowspan = 1;
	      var colspan = 1;
	      var fn = this.table.spanMethod;
	      if (typeof fn === 'function') {
	        var result = fn({
	          row: row,
	          column: column,
	          rowIndex: rowIndex,
	          columnIndex: columnIndex
	        });
	        if (isArray$1(result)) {
	          rowspan = result[0];
	          colspan = result[1];
	        } else if (_typeof(result) === 'object') {
	          rowspan = result.rowspan;
	          colspan = result.colspan;
	        }
	      }
	      var nextColumn = this.columns[columnIndex + 1];
	      colspan = nextColumn && nextColumn.type === 'setting' ? colspan + 1 : colspan;
	      return {
	        rowspan: rowspan,
	        colspan: colspan
	      };
	    },
	    getRowStyle: function getRowStyle(row, rowIndex) {
	      var rowStyle = this.table.rowStyle || {};
	      if (typeof rowStyle === 'function') {
	        rowStyle = rowStyle({
	          row: row,
	          rowIndex: rowIndex
	        });
	      }
	      var height = this.tableLayout.rowsHeight["row-".concat(rowIndex)];
	      if (this.fixed && height) {
	        rowStyle.height = height + 'px';
	      }
	      return rowStyle;
	    },
	    getRowClass: function getRowClass(row, rowIndex) {
	      var classes = ['bk-table-row'];
	      if (rowIndex === this.data.length - 1) {
	        classes.push('bk-table-row-last');
	      }
	      if (this.table.highlightCurrentRow && row === this.store.states.currentRow) {
	        classes.push('current-row');
	      }
	      if (this.stripe && rowIndex % 2 === 1) {
	        classes.push('bk-table-row-striped');
	      }
	      var rowClassName = this.table.rowClassName;
	      if (typeof rowClassName === 'string') {
	        classes.push(rowClassName);
	      } else if (typeof rowClassName === 'function') {
	        classes.push(rowClassName({
	          row: row,
	          rowIndex: rowIndex
	        }));
	      }
	      if (this.store.states.expandRows.indexOf(row) > -1) {
	        classes.push('expanded');
	      }
	      return classes.join(' ');
	    },
	    getRowAttributes: function getRowAttributes(row, rowIndex) {
	      return {
	        'data-table-row': "row-".concat(rowIndex)
	      };
	    },
	    getCellStyle: function getCellStyle(rowIndex, columnIndex, row, column) {
	      var cellStyle = this.table.cellStyle;
	      if (typeof cellStyle === 'function') {
	        return cellStyle({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex,
	          row: row,
	          column: column
	        });
	      }
	      return cellStyle;
	    },
	    getCellClass: function getCellClass(rowIndex, columnIndex, row, column) {
	      var classes = [column.id, column.align, column.className];
	      if (this.isColumnHidden(columnIndex)) {
	        classes.push('is-hidden');
	      }
	      if (columnIndex === 0) {
	        classes.push('is-first');
	      }
	      if (columnIndex === this.columns.length - 1) {
	        classes.push('is-last');
	      }
	      var cellClassName = this.table.cellClassName;
	      if (typeof cellClassName === 'string') {
	        classes.push(cellClassName);
	      } else if (typeof cellClassName === 'function') {
	        classes.push(cellClassName({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex,
	          row: row,
	          column: column
	        }));
	      }
	      return classes.join(' ');
	    },
	    getCellAttributes: function getCellAttributes(rowIndex, cellIndex, row, column) {
	      if (typeof this.table.cellAttributes === 'function') {
	        var attributes = this.table.cellAttributes({
	          rowIndex: rowIndex,
	          cellIndex: cellIndex,
	          row: row,
	          column: column
	        });
	        return _typeof(attributes) === 'object' ? attributes : {};
	      } else if (_typeof(this.table.cellAttributes) === 'object') {
	        return this.table.cellAttributes;
	      }
	      return {};
	    },
	    getExpandedRowAttributes: function getExpandedRowAttributes(row, rowIndex) {
	      return {
	        'data-table-row': "expanded-row-".concat(rowIndex)
	      };
	    },
	    getExpandedRowStyle: function getExpandedRowStyle(row, rowIndex) {
	      var style = {};
	      var height = this.tableLayout.rowsHeight["expanded-row-".concat(rowIndex)];
	      if (this.fixed && height) {
	        style.height = height + 'px';
	      }
	      return style;
	    },
	    getExpandedRowClass: function getExpandedRowClass(row, rowIndex) {
	      var classes = ['is-expanded-row'];
	      return classes.join(' ');
	    },
	    handleCellMouseEnter: function handleCellMouseEnter(event, row) {
	      var table = this.table;
	      var cell = getCell(event);
	      if (cell) {
	        var column = getColumnByCell(table, cell);
	        var hoverState = table.hoverState = {
	          cell: cell,
	          column: column,
	          row: row
	        };
	        table.$emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
	      }
	    },
	    handleCellMouseLeave: function handleCellMouseLeave(event) {
	      var cell = getCell(event);
	      if (!cell) return;
	      var oldHoverState = this.table.hoverState || {};
	      this.table.$emit('cell-mouse-leave', oldHoverState.row, oldHoverState.column, oldHoverState.cell, event);
	    },
	    handleMouseEnter: function handleMouseEnter(index, event, row) {
	      this.store.commit('setHoverRow', index);
	      this.table.$emit('row-mouse-enter', index, event, row);
	    },
	    handleMouseLeave: function handleMouseLeave(index, event, row) {
	      this.store.commit('setHoverRow', null);
	      this.table.$emit('row-mouse-leave', index, event, row);
	    },
	    handleContextMenu: function handleContextMenu(event, row) {
	      this.handleEvent(event, row, 'contextmenu');
	    },
	    handleDoubleClick: function handleDoubleClick(event, row) {
	      this.handleEvent(event, row, 'dblclick');
	    },
	    handleClick: function handleClick(event, row) {
	      this.store.commit('setCurrentRow', row);
	      this.handleEvent(event, row, 'click');
	    },
	    handleEvent: function handleEvent(event, row, name) {
	      var table = this.table;
	      var cell = getCell(event);
	      var rowIndex = this.data.indexOf(row);
	      var column;
	      var columnIndex;
	      if (cell) {
	        column = getColumnByCell(table, cell);
	        if (column) {
	          columnIndex = this.columns.indexOf(column);
	          table.$emit("cell-".concat(name), row, column, cell, event, rowIndex, columnIndex);
	        }
	      }
	      table.$emit("row-".concat(name), row, event, column, rowIndex, columnIndex);
	    },
	    handleExpandClick: function handleExpandClick(data) {
	      var _this3 = this;
	      return _asyncToGenerator( regenerator.mark(function _callee() {
	        var row, event, column, result;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                row = data.row, event = data.event, column = data.column;
	                event.stopPropagation();
	                if (!(typeof column.beforeExpandChange === 'function')) {
	                  _context.next = 8;
	                  break;
	                }
	                _context.next = 5;
	                return column.beforeExpandChange(data);
	              case 5:
	                result = _context.sent;
	                if (result) {
	                  _context.next = 8;
	                  break;
	                }
	                return _context.abrupt("return", false);
	              case 8:
	                _this3.store.toggleRowExpansion(row);
	              case 9:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee);
	      }))();
	    },
	    syncFixedRowHeight: function syncFixedRowHeight() {
	      if (!this.fixed && (this.leftFixedCount || this.rightFixedCount)) {
	        this.tableLayout.debouncedSyncRowHeight();
	      }
	    },
	    renderBodyRows: function renderBodyRows() {}
	  }
	};

	var zIndex$1 = {
	  props: {
	    zIndex: {
	      type: [Number, String],
	      default: 'default'
	    }
	  },
	  methods: {
	    getLocalZIndex: function getLocalZIndex(zIndex) {
	      return zIndexManager.nextTickIndex(2, zIndex);
	    }
	  }
	};

	(function () {
	  if (!window['__bk_pop_manager']) {
	    var __containerId = "bk_pop_".concat(new Date().getTime());
	    var __maskId = "bk_pop_mask_".concat(new Date().getTime());
	    var __defaultKey = "bk_pop_key_".concat(new Date().getTime());
	    var __popInstances = [];
	    var popManager = {
	      containerId: __containerId,
	      maskId: __maskId,
	      defaultKey: __defaultKey,
	      formatKey: function formatKey(key) {
	        return String(key).replace(/#/g, '_');
	      },
	      show: function show(key, instance) {
	        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
	          tplAction: 'keepAll',
	          zIndex: '',
	          beforeHide: function beforeHide() {},
	          ignoreExistMask: false,
	          appendToBody: false
	        };
	        key = key === undefined || key === null || isNan$1(key) ? this.defaultKey : key;
	        key = this.formatKey(key);
	        var uid = uuid();
	        var isAppendToBody = false;
	        if (options.tplAction === 'onlyone') {
	          this.clearByTpl(key);
	        }
	        if (this.shouldAppendToBody(key)) {
	          isAppendToBody = true;
	          this.showModalMask(options.zIndex);
	          !options.appendToBody && this.container.append(instance);
	        } else {
	          isAppendToBody = false;
	          var lastInsZindex = options.zIndex;
	          this.showModalMask(lastInsZindex);
	        }
	        var beforeHide = options.beforeHide,
	            zIndex = options.zIndex,
	            ignoreExistMask = options.ignoreExistMask;
	        this.instances.push({
	          uid: uid,
	          ins: instance,
	          tplName: key,
	          beforeHide: beforeHide,
	          zIndex: zIndex,
	          ignoreExistMask: ignoreExistMask,
	          isAppendToBody: isAppendToBody
	        });
	        return "".concat(uid, "#").concat(key);
	      },
	      shouldAppendToBody: function shouldAppendToBody(tplName) {
	        return this.instances.some(function (item) {
	          return item.tplName === tplName;
	        });
	      },
	      hide: function hide(popId, options) {
	        options = options || {
	          action: 'hideUid'
	        };
	        switch (options.action) {
	          case 'hideAll':
	            this.clearAll();
	            break;
	          case 'hideUid':
	            this.clearByUid(popId);
	            break;
	          case 'hideSameTpl':
	            this.clearByTpl(popId);
	            break;
	          default:
	            this.autoClear(popId);
	            break;
	        }
	        this.updateModalMaskIndex();
	      },
	      updateModalMaskIndex: function updateModalMaskIndex() {
	        if (this.instances.length) {
	          var lastIns = this.instances.slice(-1)[0];
	          var lastInsZindex = lastIns.isAppendToBody ? lastIns.zIndex : lastIns.zIndex - 1;
	          this.showModalMask(lastInsZindex);
	        } else {
	          this.hideModalMask();
	        }
	      },
	      autoClear: function autoClear() {
	        var uid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
	        if (uid.indexOf('#') > 0) {
	          this.clearByUid(uid);
	        } else {
	          this.clearByTpl();
	        }
	      },
	      clearByTpl: function clearByTpl(uid) {
	        var _this = this;
	        var keyStr = uid.split('#');
	        var tplName = keyStr.slice(-1)[0];
	        this.instances = this.instances.filter(function (item) {
	          if (item.tplName === tplName) {
	            _this.__hideInstance(item);
	            return false;
	          } else {
	            return true;
	          }
	        });
	      },
	      clearByUid: function clearByUid(uid) {
	        var keyStr = uid.split('#');
	        var instanceUid = keyStr[0];
	        var tplName = keyStr[1];
	        var index = this.instances.findIndex(function (ins) {
	          return ins.uid === instanceUid && ins.tplName === tplName;
	        });
	        if (index >= 0) {
	          this.__hideInstance(this.instances[index]);
	          this.instances.splice(index, 1);
	        } else {
	          console.warn('Can not find pop instance with index ' + index);
	        }
	      },
	      clearAll: function clearAll() {
	        var _this2 = this;
	        this.instances.forEach(function (item) {
	          return _this2.__hideInstance(item);
	        });
	        this.instances = [];
	      },
	      showModalMask: function showModalMask(zIndex) {
	        this.dialogMask.setAttribute('style', "z-index:".concat(zIndex, ";"));
	        document.body.style.overflow = 'hidden';
	        this.dialogMask.classList.remove('hide-active');
	        this.dialogMask.classList.add('show-active');
	      },
	      hideModalMask: function hideModalMask() {
	        this.dialogMask.classList.remove('show-active');
	        this.dialogMask.classList.add('hide-active');
	        document.body.style.overflow = '';
	      },
	      __hideInstance: function __hideInstance(instance) {
	        if (typeof instance.beforeHide === 'function') {
	          instance.beforeHide();
	          setTimeout(function () {
	            if (instance.isAppendToBody) {
	              instance.ins.remove();
	            }
	          });
	        } else {
	          if (instance.isAppendToBody) {
	            instance.ins.remove();
	          }
	        }
	      }
	    };
	    defineProperty$1(popManager, 'container', {
	      get: function get() {
	        var container = document.querySelector('[data-bkpop-container]');
	        if (!container) {
	          container = document.createElement('div');
	          container.setAttribute('id', this.containerId);
	          container.setAttribute('data-bkpop-container', 'true');
	          document.body.append(container);
	        }
	        return container;
	      }
	    });
	    defineProperty$1(popManager, 'dialogMask', {
	      get: function get() {
	        var mask = document.querySelector('[data-bkpop-mask]');
	        if (!mask) {
	          mask = document.createElement('div');
	          mask.setAttribute('id', this.maskId);
	          mask.setAttribute('class', 'bk-dialog-mask');
	          mask.setAttribute('data-bkpop-mask', 'true');
	          this.container.append(mask);
	        }
	        return mask;
	      }
	    });
	    defineProperty$1(popManager, 'instances', {
	      get: function get() {
	        return __popInstances;
	      },
	      set: function set(val) {
	        __popInstances = val;
	      }
	    });
	    window['__bk_pop_manager'] = popManager;
	    window['__bk_pop_manager'].__container = popManager.container;
	  }
	})();
	var popManager = window['__bk_pop_manager'];

	var script$2 = {
	  name: 'bk-popover',
	  mixins: [zIndex$1],
	  props: {
	    placement: {
	      type: String,
	      default: 'top'
	    },
	    content: {
	      type: String,
	      default: ''
	    },
	    theme: {
	      type: String,
	      default: 'dark'
	    },
	    interactive: {
	      type: [Boolean, String],
	      default: true
	    },
	    arrow: {
	      type: [Boolean, String],
	      default: true
	    },
	    arrowType: {
	      type: String,
	      default: 'sharp'
	    },
	    boundary: {
	      type: String,
	      default: 'window'
	    },
	    showOnInit: {
	      type: Boolean,
	      default: false
	    },
	    arrowTransform: {
	      type: String,
	      default: ''
	    },
	    trigger: {
	      type: String,
	      default: 'mouseenter focus'
	    },
	    animation: {
	      type: String,
	      default: 'shift-away'
	    },
	    distance: {
	      type: Number,
	      default: 10
	    },
	    width: {
	      type: [String, Number],
	      default: 'auto'
	    },
	    maxWidth: {
	      type: [String, Number],
	      default: 'auto'
	    },
	    offset: {
	      type: [Number, String],
	      default: 0
	    },
	    always: {
	      type: Boolean,
	      default: false
	    },
	    followCursor: {
	      type: [Boolean, String],
	      default: false
	    },
	    sticky: {
	      type: [Boolean, String],
	      default: false
	    },
	    delay: {
	      type: Number,
	      default: 100
	    },
	    size: {
	      type: String,
	      default: 'small'
	    },
	    onShow: {
	      type: Function,
	      default: function _default() {}
	    },
	    onHide: {
	      type: Function,
	      default: function _default() {}
	    },
	    tippyOptions: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    disabled: Boolean
	  },
	  data: function data() {
	    return {
	      instance: null
	    };
	  },
	  watch: {
	    disabled: function disabled(_disabled) {
	      if (this.instance) {
	        _disabled ? this.instance.disable() : this.instance.enable();
	      }
	    },
	    tippyOptions: function tippyOptions(v) {
	      this.instance && this.instance.set(v);
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;
	    var options = getValidTippyProps(_extends({}, {
	      appendTo: popManager.container
	    }, this.$props, this.tippyOptions));
	    var onShow = options.onShow;
	    var onHide = options.onHide;
	    options.onShow = function (tip) {
	      tip.set({
	        zIndex: _this.getLocalZIndex(_this.zIndex)
	      });
	      onShow && onShow(tip);
	      _this.$emit('show');
	    };
	    options.onHide = function (tip) {
	      onHide && onHide(tip);
	      _this.$emit('hide');
	    };
	    options.content = this.$refs.html;
	    if (this.always) {
	      options.showOnInit = true;
	      options.hideOnClick = false;
	      options.trigger = 'manual';
	    }
	    this.instance = tippy(this.$refs.reference, options);
	    if (this.disabled) {
	      this.instance.disable();
	    }
	  },
	  updated: function updated() {
	    this.instance.setContent(this.$refs.html);
	    if (this.instance.popperInstance) {
	      this.instance.popperInstance.update();
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.instance.destroy();
	  },
	  methods: {
	    showHandler: function showHandler() {
	      this.instance.show();
	    },
	    hideHandler: function hideHandler() {
	      this.instance.hide();
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-tooltip"
	  }, [_c('div', {
	    ref: "html",
	    staticClass: "bk-tooltip-content"
	  }, [_vm._t("content", [_vm._v(_vm._s(_vm.content))])], 2), _c('div', {
	    ref: "reference",
	    staticClass: "bk-tooltip-ref",
	    attrs: {
	      "tabindex": "-1"
	    }
	  }, [_vm._t("default")], 2)]);
	};

	var __vue_staticRenderFns__$2 = [];
	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* module identifier */

	var __vue_module_identifier__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$2, function (Vue, options) {
	  Vue.prototype.$bkPopover = function (el, options) {
	    return tippy(el, options);
	  };
	});

	var bkTableSetting = {
	  name: 'bk-table-setting',
	  components: {
	    bkPopover: __vue_component__$2
	  },
	  props: {
	    column: Object
	  },
	  render: function render(h) {
	    var popoverContent = this.column.settingContent ? this.column.settingContent(h) : '';
	    return h("bk-popover", {
	      "attrs": {
	        "trigger": "click",
	        "placement": "bottom-end",
	        "theme": "light bk-table-setting-popover-content",
	        "distance": -2
	      }
	    }, [h("i", {
	      "class": 'bk-table-setting-icon ' + this.column.icon
	    }), h("template", {
	      "slot": "content"
	    }, [popoverContent])]);
	  }
	};

	var script$3 = {
	  name: 'bk-checkbox-group',
	  props: {
	    value: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    name: {
	      type: [String, Number],
	      default: function _default() {
	        return getGroupName();
	      }
	    }
	  },
	  data: function data() {
	    return {
	      checkboxItems: [],
	      isCheckboxGroup: true,
	      localValue: _toConsumableArray(this.value)
	    };
	  },
	  watch: {
	    value: function value(_value) {
	      this.localValue = _toConsumableArray(_value);
	    }
	  },
	  created: function created() {
	    var _this = this;
	    this.$on('checkbox-item-add', function (item) {
	      if (item) {
	        _this.checkboxItems.push(item);
	      }
	      return false;
	    });
	  },
	  methods: {
	    handleChange: function handleChange(checked, value) {
	      var oldValue = _toConsumableArray(this.localValue);
	      var localValue = [];
	      this.checkboxItems.forEach(function (checkbox) {
	        var params = checkbox.getValue();
	        if (params.isChecked) {
	          localValue.push(params.value);
	        }
	      });
	      this.localValue = localValue;
	      this.$emit('input', this.localValue);
	      this.$emit('change', this.localValue, oldValue);
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;
	/* template */

	var __vue_render__$3 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-form-control",
	    attrs: {
	      "name": _vm.name
	    }
	  }, [_vm._t("default")], 2);
	};

	var __vue_staticRenderFns__$3 = [];
	/* style */

	var __vue_inject_styles__$3 = undefined;
	/* scoped */

	var __vue_scope_id__$3 = undefined;
	/* module identifier */

	var __vue_module_identifier__$3 = undefined;
	/* functional template */

	var __vue_is_functional_template__$3 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$3 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$3,
	  staticRenderFns: __vue_staticRenderFns__$3
	}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$3);

	var script$4 = {
	  name: 'bk-link',
	  props: {
	    disabled: Boolean,
	    underline: Boolean,
	    href: {
	      type: String,
	      default: null
	    },
	    icon: String,
	    iconPlacement: {
	      type: String,
	      default: 'left'
	    },
	    theme: {
	      type: String,
	      default: 'default',
	      validator: function validator(val) {
	        return ['default', 'primary', 'success', 'warning', 'danger'].includes(val);
	      }
	    }
	  },
	  methods: {
	    handleClick: function handleClick(event) {
	      if (this.disabled) {
	        event.preventDefault();
	        return false;
	      }
	      this.$emit('click', event);
	    }
	  }
	};

	/* script */
	var __vue_script__$4 = script$4;
	/* template */

	var __vue_render__$4 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('a', _vm._b({
	    class: ['bk-link', "is-" + _vm.theme, _vm.disabled && 'is-disabled', _vm.underline && !_vm.disabled && 'has-underline'],
	    attrs: {
	      "href": _vm.href
	    },
	    on: {
	      "click": _vm.handleClick
	    }
	  }, 'a', _vm.$attrs, false), [_vm.icon && _vm.iconPlacement === 'left' ? _c('i', {
	    class: ['bk-link-icon is-left', _vm.icon]
	  }) : _vm._e(), _vm.$slots.default ? _c('span', {
	    staticClass: "bk-link-text"
	  }, [_vm._t("default")], 2) : _vm._e(), _vm.icon && _vm.iconPlacement === 'right' ? _c('i', {
	    class: ['bk-link-icon is-right', _vm.icon]
	  }) : _vm._e()]);
	};

	var __vue_staticRenderFns__$4 = [];
	/* style */

	var __vue_inject_styles__$4 = undefined;
	/* scoped */

	var __vue_scope_id__$4 = undefined;
	/* module identifier */

	var __vue_module_identifier__$4 = undefined;
	/* functional template */

	var __vue_is_functional_template__$4 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$4 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$4,
	  staticRenderFns: __vue_staticRenderFns__$4
	}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$4);

	var script$5 = {
	  name: 'bk-table-filter-panel',
	  components: {
	    bkCheckboxGroup: __vue_component__$3,
	    bkCheckbox: __vue_component__$1,
	    bkLink: __vue_component__$4
	  },
	  mixins: [locale.mixin],
	  data: function data() {
	    return {
	      instance: null,
	      reference: null,
	      filters: [],
	      multiple: false,
	      placement: 'bottom-start',
	      method: null,
	      selected: [],
	      column: null,
	      table: null,
	      searchable: false,
	      keyword: '',
	      matchedFilters: []
	    };
	  },
	  computed: {
	    searchEmpty: function searchEmpty() {
	      return this.keyword.length && !this.matchedFilters.length;
	    }
	  },
	  watch: {
	    keyword: function keyword() {
	      this.setMatchedFilters();
	    }
	  },
	  mounted: function mounted() {
	    var _this = this;
	    this.instance = tippy(this.reference, {
	      theme: 'light bk-table-filter-panel',
	      trigger: 'click',
	      interactive: true,
	      placement: this.placement,
	      content: this.$el,
	      onShow: function onShow() {
	        _this.column.filterOpened = true;
	      },
	      onHide: function onHide() {
	        _this.column.filterOpened = false;
	      },
	      onHidden: function onHidden() {
	        _this.keyword = '';
	      }
	    });
	  },
	  methods: {
	    setMatchedFilters: function setMatchedFilters() {
	      var keyword = this.keyword.toLowerCase();
	      this.matchedFilters = this.filters.filter(function (filter) {
	        var index = filter.text.toString().toLowerCase().indexOf(keyword);
	        return index > -1;
	      });
	    },
	    isMatched: function isMatched(filter) {
	      if (!this.keyword.length) {
	        return true;
	      }
	      return this.matchedFilters.includes(filter);
	    },
	    handleConfirm: function handleConfirm() {
	      this.confirmFilter(this.selected);
	      this.instance.hide();
	    },
	    handleReset: function handleReset() {
	      this.selected = [];
	      this.handleConfirm();
	    },
	    handleSelect: function handleSelect(filter) {
	      if (filter.disabled) {
	        return;
	      }
	      if (this.selected.includes(filter.value)) {
	        this.instance.hide();
	        return;
	      }
	      this.selected = [filter.value];
	      this.handleConfirm();
	    },
	    confirmFilter: function confirmFilter() {
	      this.column.filteredValue = this.selected;
	      this.table.store.commit('filterChange', {
	        column: this.column,
	        values: this.selected
	      });
	      this.table.store.updateAllSelected();
	    }
	  }
	};

	/* script */
	var __vue_script__$5 = script$5;
	/* template */

	var __vue_render__$5 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-table-filter-panel",
	    class: {
	      multiple: _vm.multiple
	    }
	  }, [_vm.searchable ? _c('div', {
	    staticClass: "panel-search"
	  }, [_c('i', {
	    staticClass: "panel-search-icon bk-icon icon-search"
	  }), _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model.trim",
	      value: _vm.keyword,
	      expression: "keyword",
	      modifiers: {
	        "trim": true
	      }
	    }],
	    staticClass: "panel-search-input",
	    attrs: {
	      "type": "text",
	      "placeholder": _vm.t('bk.table.filter.placeholder')
	    },
	    domProps: {
	      "value": _vm.keyword
	    },
	    on: {
	      "input": function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.keyword = $event.target.value.trim();
	      },
	      "blur": function blur($event) {
	        _vm.$forceUpdate();
	      }
	    }
	  })]) : _vm._e(), _vm.multiple ? [_c('bk-checkbox-group', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: !_vm.searchEmpty,
	      expression: "!searchEmpty"
	    }],
	    staticClass: "panel-checkbox-group",
	    model: {
	      value: _vm.selected,
	      callback: function callback($$v) {
	        _vm.selected = $$v;
	      },
	      expression: "selected"
	    }
	  }, _vm._l(_vm.filters, function (filter) {
	    return _c('bk-checkbox', {
	      directives: [{
	        name: "show",
	        rawName: "v-show",
	        value: _vm.isMatched(filter),
	        expression: "isMatched(filter)"
	      }],
	      key: filter.value,
	      staticClass: "panel-checkbox",
	      attrs: {
	        "value": filter.value,
	        "disabled": !!filter.disabled
	      }
	    }, [_vm._v("\n                " + _vm._s(filter.text) + "\n            ")]);
	  }), 1), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: !_vm.searchEmpty,
	      expression: "!searchEmpty"
	    }],
	    staticClass: "panel-options"
	  }, [_c('bk-link', {
	    staticClass: "panel-options-link",
	    attrs: {
	      "theme": "primary"
	    },
	    on: {
	      "click": _vm.handleConfirm
	    }
	  }, [_vm._v(_vm._s(_vm.t('bk.table.confirm')))]), _c('bk-link', {
	    staticClass: "panel-options-link",
	    attrs: {
	      "theme": "primary"
	    },
	    on: {
	      "click": _vm.handleReset
	    }
	  }, [_vm._v(_vm._s(_vm.t('bk.table.reset')))])], 1)] : [_c('ul', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: !_vm.searchEmpty,
	      expression: "!searchEmpty"
	    }],
	    staticClass: "panel-list"
	  }, [_c('li', {
	    staticClass: "panel-item",
	    class: {
	      'is-selected': _vm.selected.length === 0,
	      'is-hidden': !!_vm.keyword.length
	    },
	    on: {
	      "click": _vm.handleReset
	    }
	  }, [_vm._v("\n                " + _vm._s(_vm.t('bk.table.all')) + "\n            ")]), _vm._l(_vm.filters, function (filter) {
	    return _c('li', {
	      key: filter.value,
	      staticClass: "panel-item",
	      class: {
	        'is-selected': _vm.selected.includes(filter.value),
	        'is-disabled': !!filter.disabled,
	        'is-hidden': !_vm.isMatched(filter)
	      },
	      on: {
	        "click": function click($event) {
	          _vm.handleSelect(filter);
	        }
	      }
	    }, [_vm._v("\n                " + _vm._s(filter.text) + "\n            ")]);
	  })], 2)], _vm.searchEmpty ? _c('p', {
	    staticClass: "panel-empty"
	  }, [_vm._v(_vm._s(_vm.t('bk.table.filter.empty')))]) : _vm._e()], 2);
	};

	var __vue_staticRenderFns__$5 = [];
	/* style */

	var __vue_inject_styles__$5 = undefined;
	/* scoped */

	var __vue_scope_id__$5 = undefined;
	/* module identifier */

	var __vue_module_identifier__$5 = undefined;
	/* functional template */

	var __vue_is_functional_template__$5 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$5 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$5,
	  staticRenderFns: __vue_staticRenderFns__$5
	}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

	var getAllColumns = function getAllColumns(columns) {
	  var result = [];
	  columns.forEach(function (column) {
	    if (column.children) {
	      result.push(column);
	      result.push.apply(result, getAllColumns(column.children));
	    } else {
	      result.push(column);
	    }
	  });
	  return result;
	};
	var convertToRows = function convertToRows(originColumns) {
	  var maxLevel = 1;
	  var traverse = function traverse(column, parent) {
	    if (parent) {
	      column.level = parent.level + 1;
	      if (maxLevel < column.level) {
	        maxLevel = column.level;
	      }
	    }
	    if (column.children) {
	      var colSpan = 0;
	      column.children.forEach(function (subColumn) {
	        traverse(subColumn, column);
	        colSpan += subColumn.colSpan;
	      });
	      column.colSpan = colSpan;
	    } else {
	      column.colSpan = 1;
	    }
	  };
	  originColumns.forEach(function (column) {
	    column.level = 1;
	    traverse(column);
	  });
	  var rows = [];
	  for (var i = 0; i < maxLevel; i++) {
	    rows.push([]);
	  }
	  var allColumns = getAllColumns(originColumns);
	  allColumns.forEach(function (column) {
	    if (!column.children) {
	      column.rowSpan = maxLevel - column.level + 1;
	    } else {
	      column.rowSpan = 1;
	    }
	    rows[column.level - 1].push(column);
	  });
	  return rows;
	};
	var TableHeader = {
	  name: 'bk-table-header',
	  mixins: [LayoutObserver],
	  render: function render(h) {
	    var _this = this;
	    var originColumns = this.store.states.originColumns;
	    var columnRows = convertToRows(originColumns, this.columns);
	    var isGroup = columnRows.length > 1;
	    if (isGroup) this.$parent.isGroup = true;
	    return h("table", {
	      "class": "bk-table-header",
	      "attrs": {
	        "cellspacing": "0",
	        "cellpadding": "0",
	        "border": "0"
	      }
	    }, [h("colgroup", [this._l(this.columns, function (column) {
	      return h("col", {
	        "attrs": {
	          "name": column.id
	        }
	      });
	    }), this.hasGutter ? h("col", {
	      "attrs": {
	        "name": "gutter"
	      }
	    }) : '']), h("thead", {
	      "class": [{
	        'is-group': isGroup,
	        'has-gutter': this.hasGutter
	      }]
	    }, [this._l(columnRows, function (columns, rowIndex) {
	      return h("tr", {
	        "style": _this.getHeaderRowStyle(rowIndex),
	        "class": _this.getHeaderRowClass(rowIndex)
	      }, [_this._l(columns, function (column, cellIndex) {
	        return h("th", helper([{
	          "attrs": {
	            "colspan": column.colSpan,
	            "rowspan": column.rowSpan
	          },
	          "on": {
	            "mousemove": function mousemove($event) {
	              return _this.handleMouseMove($event, column);
	            },
	            "mouseout": _this.handleMouseOut,
	            "mousedown": function mousedown($event) {
	              return _this.handleMouseDown($event, column);
	            },
	            "click": function click($event) {
	              return _this.handleHeaderClick($event, column);
	            },
	            "contextmenu": function contextmenu($event) {
	              return _this.handleHeaderContextMenu($event, column);
	            }
	          },
	          "style": _this.getHeaderCellStyle(rowIndex, cellIndex, columns, column),
	          "class": _this.getHeaderCellClass(rowIndex, cellIndex, columns, column),
	          "key": column.id
	        }, {
	          "domProps": _this.getHeaderCellAttributes(rowIndex, cellIndex, columns, column)
	        }]), [_this.isCellHidden(cellIndex, columns) ? '' : h("div", {
	          "class": "cell"
	        }, [h("div", {
	          "class": ['bk-table-header-label', column.labelClassName]
	        }, [column.renderHeader ? column.renderHeader.call(_this._renderProxy, h, {
	          column: column,
	          $index: cellIndex,
	          store: _this.store,
	          _self: _this.$parent.$vnode.context,
	          fixed: _this.fixed
	        }) : column.label]), column.sortable ? h("span", {
	          "class": "bk-table-caret-wrapper",
	          "on": {
	            "click": function click($event) {
	              return _this.handleSortClick($event, column);
	            }
	          }
	        }, [h("i", {
	          "class": "bk-table-sort-caret ascending",
	          "on": {
	            "click": function click($event) {
	              return _this.handleSortClick($event, column, 'ascending');
	            }
	          }
	        }), h("i", {
	          "class": "bk-table-sort-caret descending",
	          "on": {
	            "click": function click($event) {
	              return _this.handleSortClick($event, column, 'descending');
	            }
	          }
	        })]) : '', column.filterable ? h("span", {
	          "class": ['bk-table-column-filter-trigger', 'bk-icon icon-funnel', column.filterOpened ? 'is-open' : '', column.filteredValue && column.filteredValue.length > 0 ? 'is-filtered' : ''],
	          "on": {
	            "click": function click($event) {
	              return _this.handleFilterClick($event, column);
	            }
	          }
	        }) : ''])]);
	      }), _this.hasGutter ? h("th", {
	        "class": "gutter"
	      }) : '']);
	    }), this.$slots.prepend ? h("tr", {
	      "class": "bk-table-header-append"
	    }, [h("th", {
	      "attrs": {
	        "colSpan": this.colSpanNum
	      },
	      "class": "is-prepend"
	    }, [this.$slots.prepend])]) : ''])]);
	  },
	  props: {
	    fixed: String,
	    store: {
	      required: true
	    },
	    border: Boolean,
	    defaultSort: {
	      type: Object,
	      default: function _default() {
	        return {
	          prop: '',
	          order: ''
	        };
	      }
	    }
	  },
	  components: {
	    bkCheckbox: __vue_component__$1,
	    bkTableSetting: bkTableSetting
	  },
	  computed: {
	    table: function table() {
	      return this.$parent;
	    },
	    isAllSelected: function isAllSelected() {
	      return this.store.states.isAllSelected;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    leftFixedLeafCount: function leftFixedLeafCount() {
	      return this.store.states.fixedLeafColumnsLength;
	    },
	    rightFixedLeafCount: function rightFixedLeafCount() {
	      return this.store.states.rightFixedLeafColumnsLength;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    },
	    hasGutter: function hasGutter() {
	      return !this.fixed && this.tableLayout.gutterWidth;
	    },
	    colSpanNum: function colSpanNum() {
	      var originColSpan = this.store.states.originColumns.length ? this.store.states.originColumns.map(function (col) {
	        return col.colSpan;
	      }).reduce(function (pre, next) {
	        return pre + next;
	      }) : 0;
	      return this.hasGutter ? originColSpan + 1 : originColSpan;
	    }
	  },
	  created: function created() {
	    this.filterPanels = {};
	  },
	  mounted: function mounted() {
	    var _this$defaultSort = this.defaultSort,
	        prop = _this$defaultSort.prop,
	        order = _this$defaultSort.order;
	    this.store.commit('sort', {
	      prop: prop,
	      order: order
	    });
	  },
	  beforeDestroy: function beforeDestroy() {
	    var panels = this.filterPanels;
	    for (var prop in panels) {
	      if (panels.hasOwnProperty(prop) && panels[prop]) {
	        panels[prop].$destroy(true);
	      }
	    }
	  },
	  methods: {
	    isCellHidden: function isCellHidden(index, columns) {
	      var start = 0;
	      for (var i = 0; i < index; i++) {
	        start += columns[i].colSpan;
	      }
	      var after = start + columns[index].colSpan - 1;
	      if (this.fixed === true || this.fixed === 'left') {
	        return after >= this.leftFixedLeafCount;
	      } else if (this.fixed === 'right') {
	        return start < this.columnsCount - this.rightFixedLeafCount;
	      } else {
	        return after < this.leftFixedLeafCount || start >= this.columnsCount - this.rightFixedLeafCount;
	      }
	    },
	    getHeaderRowStyle: function getHeaderRowStyle(rowIndex) {
	      var headerRowStyle = this.table.headerRowStyle;
	      if (typeof headerRowStyle === 'function') {
	        return headerRowStyle({
	          rowIndex: rowIndex
	        });
	      }
	      return headerRowStyle;
	    },
	    getHeaderRowClass: function getHeaderRowClass(rowIndex) {
	      var classes = [];
	      var headerRowClassName = this.table.headerRowClassName;
	      if (typeof headerRowClassName === 'string') {
	        classes.push(headerRowClassName);
	      } else if (typeof headerRowClassName === 'function') {
	        classes.push(headerRowClassName({
	          rowIndex: rowIndex
	        }));
	      }
	      return classes.join(' ');
	    },
	    getHeaderCellStyle: function getHeaderCellStyle(rowIndex, columnIndex, row, column) {
	      var headerCellStyle = this.table.headerCellStyle;
	      if (typeof headerCellStyle === 'function') {
	        return headerCellStyle({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex,
	          row: row,
	          column: column
	        });
	      }
	      return headerCellStyle;
	    },
	    getHeaderCellClass: function getHeaderCellClass(rowIndex, columnIndex, row, column) {
	      var classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];
	      if (this.border) {
	        classes.push('has-border');
	      }
	      if (rowIndex === 0 && this.isCellHidden(columnIndex, row)) {
	        classes.push('is-hidden');
	      }
	      if (!column.children) {
	        classes.push('is-leaf');
	      }
	      if (column.sortable) {
	        classes.push('is-sortable');
	      }
	      if (column.filterable) {
	        classes.push('is-filterable');
	      }
	      if (columnIndex === 0) {
	        classes.push('is-first');
	      }
	      if (columnIndex === row.length - 1) {
	        classes.push('is-last');
	      }
	      var headerCellClassName = this.table.headerCellClassName;
	      if (typeof headerCellClassName === 'string') {
	        classes.push(headerCellClassName);
	      } else if (typeof headerCellClassName === 'function') {
	        classes.push(headerCellClassName({
	          rowIndex: rowIndex,
	          columnIndex: columnIndex,
	          row: row,
	          column: column
	        }));
	      }
	      return classes.join(' ');
	    },
	    getHeaderCellAttributes: function getHeaderCellAttributes(rowIndex, cellIndex, columns, column) {
	      if (typeof this.table.headerCellAttributes === 'function') {
	        var attributes = this.table.headerCellAttributes({
	          rowIndex: rowIndex,
	          cellIndex: cellIndex,
	          columns: columns,
	          column: column
	        });
	        return _typeof(attributes) === 'object' ? attributes : {};
	      } else if (_typeof(this.table.headerCellAttributes) === 'object') {
	        return this.table.headerCellAttributes;
	      }
	      return {};
	    },
	    toggleAllSelection: function toggleAllSelection() {
	      this.store.commit('toggleAllSelection');
	    },
	    handleFilterClick: function handleFilterClick(event, column) {
	      event.stopPropagation();
	      var target = event.target;
	      while (target && target.tagName !== 'TH') {
	        target = target.parentNode;
	      }
	      var filterReference = target.querySelector('.bk-table-column-filter-trigger');
	      var table = this.$parent;
	      var filterPanel = this.filterPanels[column.id];
	      if (filterPanel && column.filterOpened) {
	        filterPanel.instance.hide();
	        return;
	      }
	      if (!filterPanel) {
	        filterPanel = new Vue(__vue_component__$5);
	        this.filterPanels[column.id] = filterPanel;
	        filterPanel.table = table;
	        filterPanel.column = column;
	        filterPanel.multiple = column.filterMultiple;
	        filterPanel.placement = column.filterPlacement || 'bottom-start';
	        filterPanel.reference = filterReference;
	        filterPanel.filters = column.filters;
	        filterPanel.selected = column.filteredValue;
	        filterPanel.searchable = column.filterSearchable;
	        filterPanel.$mount();
	      }
	      setTimeout(function () {
	        filterPanel.instance.show();
	      }, 1000 / 60);
	    },
	    handleHeaderClick: function handleHeaderClick(event, column) {
	      if (!column.filters && column.sortable) {
	        this.handleSortClick(event, column);
	      } else if (column.filterable && !column.sortable) {
	        this.handleFilterClick(event, column);
	      }
	      this.$parent.$emit('header-click', column, event);
	    },
	    handleHeaderContextMenu: function handleHeaderContextMenu(event, column) {
	      this.$parent.$emit('header-contextmenu', column, event);
	    },
	    handleMouseDown: function handleMouseDown(event, column) {
	      var _this2 = this;
	      if (column.children && column.children.length > 0) return;
	      if (this.draggingColumn) {
	        this.dragging = true;
	        this.$parent.resizeProxyVisible = true;
	        var table = this.$parent;
	        var tableEl = table.$el;
	        var tableLeft = tableEl.getBoundingClientRect().left;
	        var columnEl = this.$el.querySelector("th.".concat(column.id));
	        var columnRect = columnEl.getBoundingClientRect();
	        var minLeft = columnRect.left - tableLeft + 80;
	        addClass(columnEl, 'noclick');
	        this.dragState = {
	          startMouseLeft: event.clientX,
	          startLeft: columnRect.right - tableLeft,
	          startColumnLeft: columnRect.left - tableLeft,
	          tableLeft: tableLeft
	        };
	        var resizeProxy = table.$refs.resizeProxy;
	        resizeProxy.style.left = this.dragState.startLeft + 'px';
	        document.onselectstart = function () {
	          return false;
	        };
	        document.ondragstart = function () {
	          return false;
	        };
	        var handleMouseMove = function handleMouseMove(event) {
	          var deltaLeft = event.clientX - _this2.dragState.startMouseLeft;
	          var proxyLeft = _this2.dragState.startLeft + deltaLeft;
	          resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
	        };
	        var handleMouseUp = function handleMouseUp() {
	          if (_this2.dragging) {
	            var _this2$dragState = _this2.dragState,
	                startColumnLeft = _this2$dragState.startColumnLeft,
	                startLeft = _this2$dragState.startLeft;
	            var finalLeft = _parseInt$2(resizeProxy.style.left, 10);
	            var columnWidth = finalLeft - startColumnLeft;
	            column.width = column.realWidth = columnWidth;
	            table.$emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);
	            _this2.store.isDraging = true;
	            _this2.store.scheduleLayout();
	            document.body.style.cursor = '';
	            _this2.dragging = false;
	            _this2.draggingColumn = null;
	            _this2.dragState = {};
	            table.resizeProxyVisible = false;
	          }
	          document.removeEventListener('mousemove', handleMouseMove);
	          document.removeEventListener('mouseup', handleMouseUp);
	          document.onselectstart = null;
	          document.ondragstart = null;
	          setTimeout(function () {
	            removeClass(columnEl, 'noclick');
	          }, 0);
	        };
	        document.addEventListener('mousemove', handleMouseMove);
	        document.addEventListener('mouseup', handleMouseUp);
	      }
	    },
	    handleMouseMove: function handleMouseMove(event, column) {
	      if (column.children && column.children.length > 0) return;
	      var target = event.target;
	      while (target && target.tagName !== 'TH') {
	        target = target.parentNode;
	      }
	      if (!column || !column.resizable) return;
	      if (!this.dragging) {
	        var rect = target.getBoundingClientRect();
	        var bodyStyle = document.body.style;
	        if (rect.width > 12 && rect.right - event.pageX < 8) {
	          bodyStyle.cursor = 'col-resize';
	          if (hasClass(target, 'is-sortable')) {
	            target.style.cursor = 'col-resize';
	          }
	          this.draggingColumn = column;
	        } else if (!this.dragging) {
	          bodyStyle.cursor = '';
	          if (hasClass(target, 'is-sortable')) {
	            target.style.cursor = 'pointer';
	          }
	          this.draggingColumn = null;
	        }
	      }
	    },
	    handleMouseOut: function handleMouseOut() {
	      document.body.style.cursor = '';
	    },
	    toggleOrder: function toggleOrder(_ref) {
	      var order = _ref.order,
	          sortOrders = _ref.sortOrders;
	      if (order === '') return sortOrders[0];
	      var index = sortOrders.indexOf(order || null);
	      return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
	    },
	    handleSortClick: function handleSortClick(event, column, givenOrder) {
	      event.stopPropagation();
	      var order = givenOrder || this.toggleOrder(column);
	      var target = event.target;
	      while (target && target.tagName !== 'TH') {
	        target = target.parentNode;
	      }
	      if (target && target.tagName === 'TH') {
	        if (hasClass(target, 'noclick')) {
	          removeClass(target, 'noclick');
	          return;
	        }
	      }
	      if (!column.sortable) return;
	      var states = this.store.states;
	      var sortProp = states.sortProp;
	      var sortOrder;
	      var sortingColumn = states.sortingColumn;
	      if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
	        if (sortingColumn) {
	          sortingColumn.order = null;
	        }
	        states.sortingColumn = column;
	        sortProp = column.property;
	      }
	      if (!order) {
	        sortOrder = column.order = null;
	        states.sortingColumn = null;
	        sortProp = null;
	      } else {
	        sortOrder = column.order = order;
	      }
	      states.sortProp = sortProp;
	      states.sortOrder = sortOrder;
	      this.store.commit('changeSortCondition');
	    }
	  },
	  data: function data() {
	    return {
	      draggingColumn: null,
	      dragging: false,
	      dragState: {}
	    };
	  }
	};

	var TableFooter = {
	  name: 'bk-table-footer',
	  mixins: [LayoutObserver],
	  render: function render(h) {
	    var _this = this;
	    var sums = [];
	    if (this.summaryMethod) {
	      sums = this.summaryMethod({
	        columns: this.columns,
	        data: this.store.states.data
	      });
	    } else {
	      this.columns.forEach(function (column, index) {
	        if (index === 0) {
	          sums[index] = _this.sumText;
	          return;
	        }
	        var values = _this.store.states.data.map(function (item) {
	          return Number(item[column.property]);
	        });
	        var precisions = [];
	        var notNumber = true;
	        values.forEach(function (value) {
	          if (!isNaN(value)) {
	            notNumber = false;
	            var decimal = ('' + value).split('.')[1];
	            precisions.push(decimal ? decimal.length : 0);
	          }
	        });
	        var precision = Math.max.apply(null, precisions);
	        if (!notNumber) {
	          sums[index] = values.reduce(function (prev, curr) {
	            var value = Number(curr);
	            if (!isNaN(value)) {
	              return _parseFloat$2((prev + curr).toFixed(Math.min(precision, 20)));
	            } else {
	              return prev;
	            }
	          }, 0);
	        } else {
	          sums[index] = '';
	        }
	      });
	    }
	    return h("table", {
	      "class": "bk-table-footer",
	      "attrs": {
	        "cellspacing": "0",
	        "cellpadding": "0",
	        "border": "0"
	      }
	    }, [h("colgroup", [this._l(this.columns, function (column) {
	      return h("col", {
	        "attrs": {
	          "name": column.id
	        }
	      });
	    }), this.hasGutter ? h("col", {
	      "attrs": {
	        "name": "gutter"
	      }
	    }) : '']), h("tbody", {
	      "class": [{
	        'has-gutter': this.hasGutter
	      }]
	    }, [h("tr", [this._l(this.columns, function (column, cellIndex) {
	      return h("td", {
	        "attrs": {
	          "colspan": column.colSpan,
	          "rowspan": column.rowSpan
	        },
	        "class": [column.id, column.headerAlign, column.className || '', _this.isCellHidden(cellIndex, _this.columns) ? 'is-hidden' : '', !column.children ? 'is-leaf' : '', column.labelClassName]
	      }, [h("div", {
	        "class": ['cell', column.labelClassName]
	      }, [sums[cellIndex]])]);
	    }), this.hasGutter ? h("th", {
	      "class": "gutter"
	    }) : ''])])]);
	  },
	  props: {
	    fixed: String,
	    store: {
	      required: true
	    },
	    summaryMethod: Function,
	    sumText: String,
	    border: Boolean,
	    defaultSort: {
	      type: Object,
	      default: function _default() {
	        return {
	          prop: '',
	          order: ''
	        };
	      }
	    }
	  },
	  computed: {
	    table: function table() {
	      return this.$parent;
	    },
	    isAllSelected: function isAllSelected() {
	      return this.store.states.isAllSelected;
	    },
	    columnsCount: function columnsCount() {
	      return this.store.states.columns.length;
	    },
	    leftFixedCount: function leftFixedCount() {
	      return this.store.states.fixedColumns.length;
	    },
	    rightFixedCount: function rightFixedCount() {
	      return this.store.states.rightFixedColumns.length;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    },
	    hasGutter: function hasGutter() {
	      return !this.fixed && this.tableLayout.gutterWidth;
	    }
	  },
	  methods: {
	    isCellHidden: function isCellHidden(index, columns) {
	      if (this.fixed === true || this.fixed === 'left') {
	        return index >= this.leftFixedCount;
	      } else if (this.fixed === 'right') {
	        var before = 0;
	        for (var i = 0; i < index; i++) {
	          before += columns[i].colSpan;
	        }
	        return before < this.columnsCount - this.rightFixedCount;
	      } else {
	        return index < this.leftFixedCount || index >= this.columnsCount - this.rightFixedCount;
	      }
	    }
	  }
	};

	var meta = _meta.onFreeze;
	_objectSap('seal', function ($seal) {
	  return function seal(it) {
	    return $seal && _isObject(it) ? $seal(meta(it)) : it;
	  };
	});

	var seal = _core.Object.seal;

	var seal$1 = seal;

	var script$6 = {
	  name: 'bk-option-all',
	  mixins: [locale.mixin],
	  inject: ['select'],
	  data: function data() {
	    return {
	      enabledOptions: []
	    };
	  },
	  computed: {
	    disabled: function disabled() {
	      return !this.enabledOptions.length;
	    },
	    isAllSelected: function isAllSelected() {
	      return !this.enabledOptions.some(function (option) {
	        return !option.isSelected;
	      });
	    }
	  },
	  watch: {
	    'select.options': {
	      immediate: true,
	      handler: function handler(options) {
	        this.setEnabledOptions();
	      }
	    }
	  },
	  methods: {
	    setEnabledOptions: function setEnabledOptions() {
	      this.enabledOptions = this.select.options.filter(function (option) {
	        return !option.disabled;
	      });
	    },
	    handleOptionClick: function handleOptionClick() {
	      if (this.disabled) {
	        return false;
	      }
	      if (this.isAllSelected) {
	        this.select.reset();
	      } else {
	        this.select.selectAll();
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$6 = script$6;
	/* template */

	var __vue_render__$6 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('li', {
	    staticClass: "bk-option",
	    class: {
	      'is-disabled': _vm.disabled
	    },
	    on: {
	      "click": _vm.handleOptionClick
	    }
	  }, [_c('div', {
	    staticClass: "bk-option-content"
	  }, [_c('span', {
	    staticClass: "bk-option-name"
	  }, [_vm._v("\n            " + _vm._s(_vm.t('bk.select.selectAll')) + "\n            "), _vm.isAllSelected ? [_vm._v("\n                " + _vm._s("(" + _vm.select.selectedOptions.length + ")") + "\n            ")] : _vm._e()], 2)])]);
	};

	var __vue_staticRenderFns__$6 = [];
	/* style */

	var __vue_inject_styles__$6 = undefined;
	/* scoped */

	var __vue_scope_id__$6 = undefined;
	/* module identifier */

	var __vue_module_identifier__$6 = undefined;
	/* functional template */

	var __vue_is_functional_template__$6 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$6 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$6,
	  staticRenderFns: __vue_staticRenderFns__$6
	}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

	var script$7 = {
	  inject: ['select'],
	  data: function data() {
	    return {
	      overflowTagNode: null,
	      overflowTagIndex: null
	    };
	  },
	  mounted: function mounted() {
	    var _this = this;
	    this.calcOverflow();
	    this.$watch(function () {
	      return _this.select.focus;
	    }, this.calcOverflow);
	    this.$watch(function () {
	      return _this.select.selected;
	    }, this.calcOverflow);
	  },
	  methods: {
	    handleRemoveSelected: function handleRemoveSelected(event, option) {
	      if (this.select.disabled || this.select.readonly) {
	        return false;
	      }
	      event.stopPropagation();
	      this.select.handleTabRemove(option);
	      this.select.unselectOption(option);
	    },
	    getTagDOM: function getTagDOM(index) {
	      var tags = [].slice.call(this.$el.querySelectorAll('.bk-select-tag'));
	      return typeof index === 'number' ? tags[index] : tags;
	    },
	    calcOverflow: function calcOverflow() {
	      var _this2 = this;
	      this.reomveOverflowTagNode();
	      if (!this._isMounted || !this.select.collapseTag || this.select.focus || this.select.selected.length < 2) {
	        return false;
	      }
	      setTimeout(function () {
	        var tags = _this2.getTagDOM();
	        var tagIndexInSecondRow = tags.findIndex(function (currentUser, index) {
	          if (!index) {
	            return false;
	          }
	          var previousTag = tags[index - 1];
	          return previousTag.offsetTop !== currentUser.offsetTop;
	        });
	        if (tagIndexInSecondRow > -1) {
	          _this2.overflowTagIndex = tagIndexInSecondRow;
	        } else {
	          _this2.overflowTagIndex = null;
	        }
	        _this2.$el.scrollTop = 0;
	        _this2.insertOverflowTag();
	      });
	    },
	    insertOverflowTag: function insertOverflowTag() {
	      var _this3 = this;
	      if (!this.overflowTagIndex) {
	        return;
	      }
	      var overflowTagNode = this.getOverflowTagNode();
	      var referenceTag = this.getTagDOM(this.overflowTagIndex);
	      if (referenceTag) {
	        this.setOverflowTagContent();
	        this.$el.insertBefore(overflowTagNode, referenceTag);
	      } else {
	        this.overflowTagIndex = null;
	        return;
	      }
	      setTimeout(function () {
	        var previousTag = _this3.getTagDOM(_this3.overflowTagIndex - 1);
	        if (overflowTagNode.offsetTop !== previousTag.offsetTop) {
	          _this3.overflowTagIndex--;
	          _this3.$el.insertBefore(overflowTagNode, overflowTagNode.previousSibling);
	          _this3.setOverflowTagContent();
	        }
	      });
	    },
	    setOverflowTagContent: function setOverflowTagContent() {
	      this.overflowTagNode.textContent = "+".concat(this.select.selected.length - this.overflowTagIndex);
	    },
	    getOverflowTagNode: function getOverflowTagNode() {
	      if (this.overflowTagNode) {
	        return this.overflowTagNode;
	      }
	      var overflowTagNode = document.createElement('span');
	      overflowTagNode.className = 'bk-select-overflow-tag';
	      this.overflowTagNode = overflowTagNode;
	      return overflowTagNode;
	    },
	    reomveOverflowTagNode: function reomveOverflowTagNode() {
	      if (this.overflowTagNode && this.overflowTagNode.parentNode === this.$el) {
	        this.$el.removeChild(this.overflowTagNode);
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$7 = script$7;
	/* template */

	var __vue_render__$7 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-select-tag-container",
	    class: {
	      'is-fixed-height': _vm.select.collapseTag,
	      'is-focus': _vm.select.focus,
	      'is-available': !_vm.select.disabled && !_vm.select.readonly,
	      'is-disabled': _vm.select.disabled,
	      'is-readonly': _vm.select.readonly,
	      'is-large-size': _vm.select.size === 'large',
	      'is-small-size': _vm.select.size === 'small',
	      'has-prefix-icon': !!_vm.select.prefixIcon
	    }
	  }, _vm._l(_vm.select.selectedOptions, function (option) {
	    return _c('div', {
	      key: option.id,
	      staticClass: "bk-select-tag",
	      class: {
	        'width-limit-tag': _vm.select.isTagWidthLimit
	      }
	    }, [_c('span', [_vm._v(_vm._s(option.name))]), _c('i', {
	      staticClass: "bk-icon icon-close",
	      on: {
	        "click": function click($event) {
	          _vm.handleRemoveSelected($event, option);
	        }
	      }
	    })]);
	  }), 0);
	};

	var __vue_staticRenderFns__$7 = [];
	/* style */

	var __vue_inject_styles__$7 = undefined;
	/* scoped */

	var __vue_scope_id__$7 = undefined;
	/* module identifier */

	var __vue_module_identifier__$7 = undefined;
	/* functional template */

	var __vue_is_functional_template__$7 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$7 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$7,
	  staticRenderFns: __vue_staticRenderFns__$7
	}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

	var UNIHANS = ["\u963F", "\u54CE", "\u5B89", "\u80AE", "\u51F9", "\u516B", "\u6300", "\u6273", "\u90A6", "\u52F9", "\u9642", "\u5954", "\u4F3B", "\u5C44", "\u8FB9", "\u706C", "\u618B", "\u6C43", "\u51AB", "\u7676", "\u5CEC", "\u5693", "\u5072", "\u53C2", "\u4ED3", "\u64A1", "\u518A", "\u5D7E", "\u66FD", "\u53C9", "\u8286", "\u8FBF", "\u4F25", "\u6284", "\u8F66", "\u62BB", "\u9637", "\u5403", "\u5145", "\u62BD", "\u51FA", "\u6B3B", "\u63E3", "\u5DDB", "\u5205", "\u5439", "\u65FE", "\u9034", "\u5472", "\u5306", "\u51D1", "\u7C97", "\u6C46", "\u5D14", "\u90A8", "\u6413", "\u5491", "\u5446", "\u4E39", "\u5F53", "\u5200", "\u561A", "\u6265", "\u706F", "\u6C10", "\u7538", "\u5201", "\u7239", "\u4E01", "\u4E1F", "\u4E1C", "\u543A", "\u53BE", "\u8011", "\u5796", "\u5428", "\u591A", "\u59B8", "\u8BF6", "\u5940", "\u97A5", "\u513F", "\u53D1", "\u5E06", "\u531A", "\u98DE", "\u5206", "\u4E30", "\u8985", "\u4ECF", "\u7D11", "\u592B", "\u65EE", "\u4F85", "\u7518", "\u5188", "\u768B", "\u6208", "\u7ED9", "\u6839", "\u522F", "\u5DE5", "\u52FE", "\u4F30", "\u74DC", "\u4E56", "\u5173", "\u5149", "\u5F52", "\u4E28", "\u5459", "\u54C8", "\u548D", "\u4F44", "\u592F", "\u8320", "\u8BC3", "\u9ED2", "\u62EB", "\u4EA8", "\u5677", "\u53FF", "\u9F41", "\u4E4E", "\u82B1", "\u6000", "\u6B22", "\u5DDF", "\u7070", "\u660F", "\u5419", "\u4E0C", "\u52A0", "\u620B", "\u6C5F", "\u827D", "\u9636", "\u5DFE", "\u5755", "\u5182", "\u4E29", "\u51E5", "\u59E2", "\u5658", "\u519B", "\u5494", "\u5F00", "\u520A", "\u5FFC", "\u5C3B", "\u533C", "\u808E", "\u52A5", "\u7A7A", "\u62A0", "\u625D", "\u5938", "\u84AF", "\u5BBD", "\u5321", "\u4E8F", "\u5764", "\u6269", "\u5783", "\u6765", "\u5170", "\u5577", "\u635E", "\u808B", "\u52D2", "\u5D1A", "\u54E9", "\u4FE9", "\u5941", "\u826F", "\u64A9", "\u6BDF", "\u62CE", "\u4F36", "\u6E9C", "\u56D6", "\u9F99", "\u779C", "\u565C", "\u9A74", "\u5A08", "\u63A0", "\u62A1", "\u7F57", "\u5463", "\u5988", "\u57CB", "\u5ADA", "\u7264", "\u732B", "\u4E48", "\u5445", "\u95E8", "\u753F", "\u54AA", "\u5B80", "\u55B5", "\u4E5C", "\u6C11", "\u540D", "\u8C2C", "\u6478", "\u54DE", "\u6BEA", "\u55EF", "\u62CF", "\u8149", "\u56E1", "\u56D4", "\u5B6C", "\u7592", "\u5A1E", "\u6041", "\u80FD", "\u59AE", "\u62C8", "\u5A18", "\u9E1F", "\u634F", "\u56DC", "\u5B81", "\u599E", "\u519C", "\u7FBA", "\u5974", "\u5973", "\u597B", "\u759F", "\u9EC1", "\u632A", "\u5594", "\u8BB4", "\u5991", "\u62CD", "\u7705", "\u4E53", "\u629B", "\u5478", "\u55B7", "\u5309", "\u4E15", "\u56E8", "\u527D", "\u6C15", "\u59D8", "\u4E52", "\u948B", "\u5256", "\u4EC6", "\u4E03", "\u6390", "\u5343", "\u545B", "\u6084", "\u767F", "\u4EB2", "\u9751", "\u536D", "\u4E18", "\u533A", "\u5CD1", "\u7F3A", "\u590B", "\u5465", "\u7A63", "\u5A06", "\u60F9", "\u4EBA", "\u6254", "\u65E5", "\u8338", "\u53B9", "\u909A", "\u633C", "\u5827", "\u5A51", "\u77A4", "\u637C", "\u4EE8", "\u6BE2", "\u4E09", "\u6852", "\u63BB", "\u95AA", "\u68EE", "\u50E7", "\u6740", "\u7B5B", "\u5C71", "\u4F24", "\u5F30", "\u5962", "\u7533", "\u5347", "\u5C38", "\u53CE", "\u4E66", "\u5237", "\u8870", "\u95E9", "\u53CC", "\u813D", "\u542E", "\u8BF4", "\u53B6", "\u5FEA", "\u635C", "\u82CF", "\u72FB", "\u590A", "\u5B59", "\u5506", "\u4ED6", "\u56FC", "\u574D", "\u6C64", "\u5932", "\u5FD1", "\u71A5", "\u5254", "\u5929", "\u65EB", "\u5E16", "\u5385", "\u56F2", "\u5077", "\u51F8", "\u6E4D", "\u63A8", "\u541E", "\u4E47", "\u7A75", "\u6B6A", "\u5F2F", "\u5C23", "\u5371", "\u6637", "\u7FC1", "\u631D", "\u4E4C", "\u5915", "\u8672", "\u4ED9", "\u4E61", "\u7071", "\u4E9B", "\u5FC3", "\u661F", "\u51F6", "\u4F11", "\u5401", "\u5405", "\u524A", "\u5743", "\u4E2B", "\u6079", "\u592E", "\u5E7A", "\u503B", "\u4E00", "\u56D9", "\u5E94", "\u54DF", "\u4F63", "\u4F18", "\u625C", "\u56E6", "\u66F0", "\u6655", "\u5E00", "\u707D", "\u5142", "\u5328", "\u50AE", "\u5219", "\u8D3C", "\u600E", "\u5897", "\u624E", "\u635A", "\u6CBE", "\u5F20", "\u4F4B", "\u8707", "\u8D1E", "\u4E89", "\u4E4B", "\u4E2D", "\u5DDE", "\u6731", "\u6293", "\u62FD", "\u4E13", "\u5986", "\u96B9", "\u5B92", "\u5353", "\u4E72", "\u5B97", "\u90B9", "\u79DF", "\u94BB", "\u539C", "\u5C0A", "\u6628", "\u5159"];
	var PINYINS = ['A', 'AI', 'AN', 'ANG', 'AO', 'BA', 'BAI', 'BAN', 'BANG', 'BAO', 'BEI', 'BEN', 'BENG', 'BI', 'BIAN', 'BIAO', 'BIE', 'BIN', 'BING', 'BO', 'BU', 'CA', 'CAI', 'CAN', 'CANG', 'CAO', 'CE', 'CEN', 'CENG', 'CHA', 'CHAI', 'CHAN', 'CHANG', 'CHAO', 'CHE', 'CHEN', 'CHENG', 'CHI', 'CHONG', 'CHOU', 'CHU', 'CHUA', 'CHUAI', 'CHUAN', 'CHUANG', 'CHUI', 'CHUN', 'CHUO', 'CI', 'CONG', 'COU', 'CU', 'CUAN', 'CUI', 'CUN', 'CUO', 'DA', 'DAI', 'DAN', 'DANG', 'DAO', 'DE', 'DEN', 'DENG', 'DI', 'DIAN', 'DIAO', 'DIE', 'DING', 'DIU', 'DONG', 'DOU', 'DU', 'DUAN', 'DUI', 'DUN', 'DUO', 'E', 'EI', 'EN', 'ENG', 'ER', 'FA', 'FAN', 'FANG', 'FEI', 'FEN', 'FENG', 'FIAO', 'FO', 'FOU', 'FU', 'GA', 'GAI', 'GAN', 'GANG', 'GAO', 'GE', 'GEI', 'GEN', 'GENG', 'GONG', 'GOU', 'GU', 'GUA', 'GUAI', 'GUAN', 'GUANG', 'GUI', 'GUN', 'GUO', 'HA', 'HAI', 'HAN', 'HANG', 'HAO', 'HE', 'HEI', 'HEN', 'HENG', 'HM', 'HONG', 'HOU', 'HU', 'HUA', 'HUAI', 'HUAN', 'HUANG', 'HUI', 'HUN', 'HUO', 'JI', 'JIA', 'JIAN', 'JIANG', 'JIAO', 'JIE', 'JIN', 'JING', 'JIONG', 'JIU', 'JU', 'JUAN', 'JUE', 'JUN', 'KA', 'KAI', 'KAN', 'KANG', 'KAO', 'KE', 'KEN', 'KENG', 'KONG', 'KOU', 'KU', 'KUA', 'KUAI', 'KUAN', 'KUANG', 'KUI', 'KUN', 'KUO', 'LA', 'LAI', 'LAN', 'LANG', 'LAO', 'LE', 'LEI', 'LENG', 'LI', 'LIA', 'LIAN', 'LIANG', 'LIAO', 'LIE', 'LIN', 'LING', 'LIU', 'LO', 'LONG', 'LOU', 'LU', 'LV', 'LUAN', 'LVE', 'LUN', 'LUO', 'M', 'MA', 'MAI', 'MAN', 'MANG', 'MAO', 'ME', 'MEI', 'MEN', 'MENG', 'MI', 'MIAN', 'MIAO', 'MIE', 'MIN', 'MING', 'MIU', 'MO', 'MOU', 'MU', 'N', 'NA', 'NAI', 'NAN', 'NANG', 'NAO', 'NE', 'NEI', 'NEN', 'NENG', 'NI', 'NIAN', 'NIANG', 'NIAO', 'NIE', 'NIN', 'NING', 'NIU', 'NONG', 'NOU', 'NU', 'NV', 'NUAN', 'NVE', 'NUN', 'NUO', 'O', 'OU', 'PA', 'PAI', 'PAN', 'PANG', 'PAO', 'PEI', 'PEN', 'PENG', 'PI', 'PIAN', 'PIAO', 'PIE', 'PIN', 'PING', 'PO', 'POU', 'PU', 'QI', 'QIA', 'QIAN', 'QIANG', 'QIAO', 'QIE', 'QIN', 'QING', 'QIONG', 'QIU', 'QU', 'QUAN', 'QUE', 'QUN', 'RAN', 'RANG', 'RAO', 'RE', 'REN', 'RENG', 'RI', 'RONG', 'ROU', 'RU', 'RUA', 'RUAN', 'RUI', 'RUN', 'RUO', 'SA', 'SAI', 'SAN', 'SANG', 'SAO', 'SE', 'SEN', 'SENG', 'SHA', 'SHAI', 'SHAN', 'SHANG', 'SHAO', 'SHE', 'SHEN', 'SHENG', 'SHI', 'SHOU', 'SHU', 'SHUA', 'SHUAI', 'SHUAN', 'SHUANG', 'SHUI', 'SHUN', 'SHUO', 'SI', 'SONG', 'SOU', 'SU', 'SUAN', 'SUI', 'SUN', 'SUO', 'TA', 'TAI', 'TAN', 'TANG', 'TAO', 'TE', 'TENG', 'TI', 'TIAN', 'TIAO', 'TIE', 'TING', 'TONG', 'TOU', 'TU', 'TUAN', 'TUI', 'TUN', 'TUO', 'WA', 'WAI', 'WAN', 'WANG', 'WEI', 'WEN', 'WENG', 'WO', 'WU', 'XI', 'XIA', 'XIAN', 'XIANG', 'XIAO', 'XIE', 'XIN', 'XING', 'XIONG', 'XIU', 'XU', 'XUAN', 'XUE', 'XUN', 'YA', 'YAN', 'YANG', 'YAO', 'YE', 'YI', 'YIN', 'YING', 'YO', 'YONG', 'YOU', 'YU', 'YUAN', 'YUE', 'YUN', 'ZA', 'ZAI', 'ZAN', 'ZANG', 'ZAO', 'ZE', 'ZEI', 'ZEN', 'ZENG', 'ZHA', 'ZHAI', 'ZHAN', 'ZHANG', 'ZHAO', 'ZHE', 'ZHEN', 'ZHENG', 'ZHI', 'ZHONG', 'ZHOU', 'ZHU', 'ZHUA', 'ZHUAI', 'ZHUAN', 'ZHUANG', 'ZHUI', 'ZHUN', 'ZHUO', 'ZI', 'ZONG', 'ZOU', 'ZU', 'ZUAN', 'ZUI', 'ZUN', 'ZUO', ''];
	var EXCEPTIONS = {
	  "\u66FE": 'ZENG',
	  "\u6C88": 'SHEN',
	  "\u55F2": 'DIA',
	  "\u78A1": 'ZHOU',
	  "\u8052": 'GUO',
	  "\u7094": 'QUE',
	  "\u86B5": 'KE',
	  "\u7809": 'HUA',
	  "\u5B24": 'MO',
	  "\u5B37": 'MO',
	  "\u8E52": 'PAN',
	  "\u8E4A": 'XI',
	  "\u4E2C": 'PAN',
	  "\u9730": 'XIAN',
	  "\u8398": 'XIN',
	  "\u8C49": 'CHI',
	  "\u9967": 'XING',
	  "\u7B60": 'JUN',
	  "\u957F": 'CHANG',
	  "\u5E27": 'ZHEN',
	  "\u5CD9": 'SHI',
	  "\u90CD": 'NA',
	  "\u828E": 'XIONG',
	  "\u8C01": 'SHUI'
	};
	var DICT = {
	  PINYINS: PINYINS,
	  UNIHANS: UNIHANS,
	  EXCEPTIONS: EXCEPTIONS
	};

	var FIRST_PINYIN_UNIHAN = "\u963F";
	var LAST_PINYIN_UNIHAN = "\u9FFF";
	var LATIN = 1;
	var PINYIN = 2;
	var UNKNOWN = 3;
	var supported = null;
	var COLLATOR;
	function patchDict(patchers) {
	  if (!patchers) return;
	  if (typeof patchers === 'function') {
	    patchers = [patchers];
	  }
	  if (patchers.forEach) {
	    patchers.forEach(function (p) {
	      typeof p === 'function' && p(DICT);
	    });
	  }
	}
	function isSupported(force) {
	  if (!force && supported !== null) {
	    return supported;
	  }
	  if ((typeof Intl === "undefined" ? "undefined" : _typeof(Intl)) === 'object' && Intl.Collator) {
	    COLLATOR = new Intl.Collator(['zh-Hans-CN', 'zh-CN']);
	    supported = Intl.Collator.supportedLocalesOf(['zh-CN']).length === 1;
	  } else {
	    supported = false;
	  }
	  return supported;
	}
	function genToken(ch) {
	  var UNIHANS = DICT.UNIHANS;
	  var PINYINS = DICT.PINYINS;
	  var EXCEPTIONS = DICT.EXCEPTIONS;
	  var token = {
	    source: ch
	  };
	  if (ch in EXCEPTIONS) {
	    token.type = PINYIN;
	    token.target = EXCEPTIONS[ch];
	    return token;
	  }
	  var offset = -1;
	  var cmp;
	  if (ch.charCodeAt(0) < 256) {
	    token.type = LATIN;
	    token.target = ch;
	    return token;
	  } else {
	    cmp = COLLATOR.compare(ch, FIRST_PINYIN_UNIHAN);
	    if (cmp < 0) {
	      token.type = UNKNOWN;
	      token.target = ch;
	      return token;
	    } else if (cmp === 0) {
	      token.type = PINYIN;
	      offset = 0;
	    } else {
	      cmp = COLLATOR.compare(ch, LAST_PINYIN_UNIHAN);
	      if (cmp > 0) {
	        token.type = UNKNOWN;
	        token.target = ch;
	        return token;
	      } else if (cmp === 0) {
	        token.type = PINYIN;
	        offset = UNIHANS.length - 1;
	      }
	    }
	  }
	  token.type = PINYIN;
	  if (offset < 0) {
	    var begin = 0;
	    var end = UNIHANS.length - 1;
	    while (begin <= end) {
	      offset = ~~((begin + end) / 2);
	      var unihan = UNIHANS[offset];
	      cmp = COLLATOR.compare(ch, unihan);
	      if (cmp === 0) {
	        break;
	      } else if (cmp > 0) {
	        begin = offset + 1;
	      } else {
	        end = offset - 1;
	      }
	    }
	  }
	  if (cmp < 0) {
	    offset--;
	  }
	  token.target = PINYINS[offset];
	  if (!token.target) {
	    token.type = UNKNOWN;
	    token.target = token.source;
	  }
	  return token;
	}
	function parse(str) {
	  if (typeof str !== 'string' || !isSupported()) {
	    return str;
	  }
	  return str.split('').map(function (v) {
	    return genToken(v);
	  });
	}
	var pinyin = {
	  isSupported: isSupported,
	  parse: parse,
	  patchDict: patchDict,
	  genToken: genToken,
	  convertToPinyin: function convertToPinyin(str, lowerCase, separator) {
	    return parse(str).map(function (v) {
	      if (lowerCase && v.type === PINYIN) {
	        return v.target.toLowerCase();
	      }
	      return v.target;
	    }).join(separator || '');
	  }
	};

	function patcher(DICT) {
	  DICT.EXCEPTIONS = {
	    "\u55F2": 'DIA',
	    "\u78A1": 'ZHOU',
	    "\u8052": 'GUO',
	    "\u7094": 'QUE',
	    "\u86B5": 'KE',
	    "\u7809": 'HUA',
	    "\u5B37": 'MO',
	    "\u8E4A": 'XI',
	    "\u4E2C": 'PAN',
	    "\u9730": 'XIAN',
	    "\u8C49": 'CHI',
	    "\u9967": 'XING',
	    "\u5E27": 'ZHEN',
	    "\u828E": 'XIONG',
	    "\u8C01": 'SHUI',
	    "\u94B6": 'KE'
	  };
	  DICT.UNIHANS[91] = "\u4F15";
	  DICT.UNIHANS[347] = "\u4EDA";
	  DICT.UNIHANS[393] = "\u8BCC";
	  DICT.UNIHANS[39] = "\u5A64";
	  DICT.UNIHANS[50] = "\u8160";
	  DICT.UNIHANS[369] = "\u6538";
	  DICT.UNIHANS[123] = "\u4E6F";
	  DICT.UNIHANS[171] = "\u5215";
	  DICT.UNIHANS[102] = "\u4F5D";
	  DICT.UNIHANS[126] = "\u72BF";
	  DICT.UNIHANS[176] = "\u5217";
	  DICT.UNIHANS[178] = "\u5222";
	  DICT.UNIHANS[252] = "\u5A1D";
	  DICT.UNIHANS[330] = "\u5078";
	}
	function shouldPatch(toToken) {
	  if (typeof toToken !== 'function') return false;
	  if (toToken("\u4F15").target === 'FOU' && toToken("\u4EDA").target === 'XIA' && toToken("\u8BCC").target === 'ZHONG' && toToken("\u5A64").target === 'CHONG' && toToken("\u8160").target === 'CONG' && toToken("\u6538").target === 'YONG' && toToken("\u4E6F").target === 'HOU' && toToken("\u5215").target === 'LENG' && toToken("\u4F5D").target === 'GONG' && toToken("\u72BF").target === 'HUAI' && toToken("\u5217").target === 'LIAO' && toToken("\u5222").target === 'LIN' && toToken("\u94B6").target === 'E') {
	    return true;
	  }
	  return false;
	}
	var patcher56L = {
	  patcher: patcher,
	  shouldPatch: shouldPatch
	};

	if (pinyin.isSupported() && patcher56L.shouldPatch(pinyin.genToken)) {
	  pinyin.patchDict(patcher56L);
	}

	var script$8 = {
	  name: 'bk-virtual-scroll',
	  props: {
	    itemHeight: {
	      type: Number,
	      default: 16
	    },
	    showIndex: {
	      type: Boolean,
	      default: false
	    },
	    list: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  data: function data() {
	    return {
	      ulHeight: 0,
	      allListData: [],
	      offscreenCanvas: '',
	      indexList: [],
	      listData: [],
	      worker: {},
	      mainWidth: 0,
	      mainLeft: 0,
	      totalHeight: 0,
	      itemNumber: 0,
	      totalNumber: 0,
	      visHeight: 0,
	      visWidth: 0,
	      totalScrollHeight: 0,
	      startMinMapMove: false,
	      tempVal: 0,
	      minMapTop: 0,
	      minNavTop: 0,
	      navHeight: 0,
	      mapHeight: 0,
	      moveRate: 0,
	      bottomScrollWidth: Infinity,
	      bottomScrollDis: 0,
	      itemWidth: 0,
	      isScrolling: false,
	      isBottomMove: false,
	      downPreDefault: false,
	      upPreDefault: false,
	      indexWidth: 0,
	      observer: {}
	    };
	  },
	  watch: {
	    list: {
	      handler: function handler(list) {
	        this.setListData(list);
	      },
	      deep: true
	    }
	  },
	  mounted: function mounted() {
	    this.initStatus();
	    this.initEvent();
	    if (this.list.length > 0) this.setListData(this.list);
	  },
	  beforeDestroy: function beforeDestroy() {
	    document.removeEventListener('mousemove', this.minNavMove);
	    document.removeEventListener('mouseup', this.moveEnd);
	    window.removeEventListener('resize', this.resize);
	    if (MutationObserver) this.observer.disconnect();
	    this.observer = {};
	  },
	  methods: {
	    initStatus: function initStatus() {
	      var mainEle = this.$refs.scrollHome;
	      var scrollEle = this.$refs.scrollMain;
	      this.visHeight = mainEle.offsetHeight || 300;
	      this.visWidth = mainEle.offsetWidth || 300;
	      var scrollWidth = scrollEle.scrollWidth || 0;
	      this.itemWidth = scrollWidth;
	      this.bottomScrollWidth = this.visWidth * this.visWidth / scrollWidth < 20 ? 20 : this.visWidth * this.visWidth / scrollWidth;
	      var dpr = window.devicePixelRatio || 1;
	      this.$refs.minNav.width = 8 * dpr;
	      this.$refs.minNav.height = this.visHeight * dpr;
	      this.$refs.minNav.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
	    },
	    initEvent: function initEvent() {
	      document.addEventListener('mousemove', this.minNavMove);
	      document.addEventListener('mouseup', this.moveEnd);
	      window.addEventListener('resize', this.resize);
	      if (MutationObserver) {
	        this.observer = new MutationObserver(this.resize);
	        this.observer.observe(this.$el, {
	          attributes: true,
	          attributeFilter: ['style']
	        });
	      }
	    },
	    resize: function resize(event) {
	      var _this = this;
	      this.slowExec(function () {
	        var lastHeight = _this.visHeight;
	        _this.initStatus();
	        _this.setStatus();
	        _this.minMapTop = _this.visHeight / lastHeight * _this.minMapTop;
	        _this.minNavTop = _this.minMapTop * (_this.visHeight - _this.navHeight) / (_this.mapHeight - _this.visHeight / 8);
	        _this.totalScrollHeight = _this.mapHeight === _this.canvasHeight / 8 ? 0 : _this.minMapTop / (_this.mapHeight - _this.visHeight / 8) * (_this.totalHeight - _this.visHeight);
	        _this.getListData(_this.totalScrollHeight, true);
	      });
	    },
	    handleWheel: function handleWheel(event) {
	      var isVerticalScroll = event.wheelDeltaX !== undefined ? Math.abs(event.wheelDeltaY) > Math.abs(event.wheelDeltaX) : event.axis === 2;
	      if (isVerticalScroll) this.handleVerticalScroll(event);else this.handleHorizontalScroll(event);
	    },
	    handleHorizontalScroll: function handleHorizontalScroll(event) {
	      event.preventDefault();
	      if (this.bottomScrollWidth >= this.mainWidth) return;
	      var deltaX = -Math.max(-1, Math.min(1, event.wheelDeltaX || -event.detail));
	      var bottomScrollLeft = this.bottomScrollDis + deltaX * 4;
	      if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
	      if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
	      this.bottomScrollDis = bottomScrollLeft;
	      this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
	    },
	    handleVerticalScroll: function handleVerticalScroll(event) {
	      var deltaY = Math.max(-1, Math.min(1, event.wheelDeltaY || -event.detail));
	      var shouldPreDefault = deltaY < 0 ? this.downPreDefault : this.upPreDefault;
	      if (shouldPreDefault) event.preventDefault();
	      if (this.isScrolling || this.itemHeight * this.totalNumber <= this.visHeight) return;
	      var dis = 0;
	      if (event.wheelDelta) dis = -1 / 5 * event.wheelDelta;
	      if (event.detail) dis = event.detail;
	      var tickGap = deltaY * -2;
	      if (deltaY === 0) {
	        dis = 0;
	        tickGap = 0;
	      }
	      var scrollHeight = this.minMapTop + (dis + tickGap) * (this.mapHeight - this.visHeight / 8) / (this.totalHeight - this.itemHeight * this.itemNumber);
	      var totalScrollHeight = 0;
	      var minMapTop = 0;
	      var minNavTop = 0;
	      if (scrollHeight < 0) {
	        totalScrollHeight = 0;
	        minMapTop = 0;
	        minNavTop = 0;
	      } else if (scrollHeight >= 0 && scrollHeight <= this.mapHeight - this.visHeight / 8) {
	        minMapTop = scrollHeight;
	        minNavTop = this.minNavTop + (dis + tickGap) * (this.visHeight - this.navHeight) / (this.totalHeight - this.itemHeight * this.itemNumber);
	        totalScrollHeight = scrollHeight * (this.totalHeight - this.itemHeight * this.itemNumber) / (this.mapHeight - this.visHeight / 8);
	      } else {
	        totalScrollHeight = this.totalHeight - this.visHeight;
	        minMapTop = this.mapHeight - this.visHeight / 8;
	        minNavTop = this.visHeight - this.navHeight;
	      }
	      this.minMapTop = minMapTop;
	      this.minNavTop = minNavTop;
	      this.isScrolling = true;
	      this.getListData(totalScrollHeight);
	    },
	    scrollPageByIndex: function scrollPageByIndex(index) {
	      var height = this.itemHeight * index;
	      if (height <= 0) height = 0;else if (height >= this.totalHeight - this.visHeight) height = this.totalHeight - this.visHeight;
	      if (this.totalHeight <= this.visHeight) height = 0;
	      var heightDiff = this.totalHeight - this.visHeight || 1;
	      this.minMapTop = height / heightDiff * (this.mapHeight - this.visHeight / 8);
	      this.minNavTop = height / heightDiff * (this.visHeight - this.navHeight);
	      this.getListData(height);
	    },
	    getListData: function getListData() {
	      var totalScrollHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var isResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	      var postData = {
	        type: 'wheelGetData',
	        totalScrollHeight: totalScrollHeight,
	        isResize: isResize,
	        totalHeight: this.totalHeight,
	        itemHeight: this.itemHeight,
	        itemNumber: this.itemNumber,
	        canvasHeight: this.visHeight,
	        minMapTop: this.minMapTop,
	        mapHeight: this.mapHeight
	      };
	      this.calcList(postData);
	    },
	    calcList: function calcList(_ref) {
	      var totalScrollHeight = _ref.totalScrollHeight,
	          itemHeight = _ref.itemHeight,
	          itemNumber = _ref.itemNumber,
	          canvasHeight = _ref.canvasHeight,
	          minMapTop = _ref.minMapTop,
	          totalHeight = _ref.totalHeight,
	          mapHeight = _ref.mapHeight,
	          isResize = _ref.isResize;
	      var realHeight = mapHeight === canvasHeight / 8 ? 0 : minMapTop / (mapHeight - canvasHeight / 8) * (totalHeight - canvasHeight);
	      var startIndex = Math.floor(realHeight / itemHeight);
	      var endIndex = startIndex + itemNumber;
	      startIndex = startIndex > 0 ? startIndex - 1 : 0;
	      var listData = [];
	      var indexList = [];
	      var nums = Math.floor(startIndex * itemHeight / 500000);
	      for (var i = startIndex; i <= endIndex; i++) {
	        var top = i * itemHeight - nums * 500000;
	        var value = this.allListData[i];
	        if (value) {
	          indexList.push({
	            top: top,
	            value: i + 1
	          });
	          listData.push({
	            top: top,
	            value: value
	          });
	        }
	      }
	      totalScrollHeight = totalScrollHeight - nums * 500000;
	      this.indexList = indexList;
	      this.listData = listData;
	      this.totalScrollHeight = totalScrollHeight;
	      var firstIndexObj = this.indexList[0] || {};
	      var lastIndexObj = this.indexList[this.indexList.length - 1] || {};
	      this.downPreDefault = lastIndexObj.value + 1 < this.totalNumber;
	      this.upPreDefault = firstIndexObj.value > 1;
	      this.isScrolling = false;
	      this.$emit('change', listData.map(function (x) {
	        return x.value;
	      }));
	    },
	    addListData: function addListData(list) {
	      this.allListData = this.allListData.concat(list);
	      var number = this.totalNumber + list.length;
	      var lastIndexData = this.indexList[this.indexList.length - 1] || {
	        value: 0
	      };
	      if (this.totalNumber - lastIndexData.value <= 3) {
	        this.freshDataScrollBottom(number);
	      } else {
	        this.freshDataNoScroll(number);
	      }
	      this.resize();
	    },
	    setListData: function setListData(list) {
	      this.allListData = list;
	      this.freshDataNoScroll(list.length);
	      this.resize();
	    },
	    freshDataScrollBottom: function freshDataScrollBottom(number) {
	      this.totalNumber = number;
	      this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
	      this.setStatus();
	      this.scrollPageByIndex(this.totalNumber - this.itemNumber + 1);
	    },
	    freshDataNoScroll: function freshDataNoScroll(number) {
	      var oldNumber = this.totalNumber;
	      var oldItemNumber = this.itemNumber;
	      var oldMapHeight = this.mapHeight;
	      var oldVisHeight = this.visHeight;
	      this.totalNumber = number;
	      this.indexWidth = this.showIndex ? (Math.log10(this.totalNumber) + 1) * 7 : 0;
	      this.setStatus();
	      this.getNumberChangeList({
	        oldNumber: oldNumber,
	        oldItemNumber: oldItemNumber,
	        oldMapHeight: oldMapHeight,
	        oldVisHeight: oldVisHeight
	      });
	    },
	    getNumberChangeList: function getNumberChangeList(_ref2) {
	      var oldNumber = _ref2.oldNumber,
	          oldItemNumber = _ref2.oldItemNumber,
	          oldMapHeight = _ref2.oldMapHeight,
	          oldVisHeight = _ref2.oldVisHeight;
	      var minMapTop = this.minMapTop * (oldNumber - oldItemNumber) / (this.totalNumber - this.itemNumber || 1) * ((this.mapHeight - this.visHeight / 8) / (oldMapHeight - oldVisHeight / 8 || 1));
	      var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.totalHeight - this.visHeight);
	      if (minMapTop <= 0 || this.navHeight >= this.visHeight) {
	        minMapTop = 0;
	        totalScrollHeight = 0;
	      } else if (minMapTop > this.mapHeight - this.visHeight / 8) {
	        minMapTop = this.mapHeight - this.visHeight / 8;
	        totalScrollHeight = this.totalHeight - this.visHeight;
	      }
	      this.minMapTop = minMapTop;
	      this.minNavTop = this.minMapTop / (this.mapHeight - this.visHeight / 8 || 1) * (this.visHeight - this.navHeight);
	      this.getListData(totalScrollHeight);
	    },
	    setStatus: function setStatus() {
	      this.totalHeight = this.totalNumber * this.itemHeight;
	      this.itemNumber = this.totalHeight > this.visHeight ? Math.ceil(this.visHeight / this.itemHeight) : this.totalNumber;
	      this.ulHeight = this.totalHeight > 400000 ? 1000000 : this.totalHeight;
	      var heightRate = this.visHeight / this.totalHeight;
	      var minNavHeight = heightRate * this.visHeight;
	      this.navHeight = heightRate > 1 ? this.visHeight : minNavHeight < 20 ? 20 : minNavHeight;
	      var moveMaxHeight = this.totalNumber * this.itemHeight / 8;
	      this.mapHeight = moveMaxHeight < this.visHeight ? moveMaxHeight : this.visHeight;
	      this.mainWidth = this.visWidth;
	      if (this.$refs.scrollNav) this.mainWidth -= this.$refs.scrollNav.offsetWidth;
	      if (this.showIndex) {
	        this.mainWidth -= (Math.log10(this.totalNumber) + 1) * 7;
	        this.mainLeft = (Math.log10(this.totalNumber) + 1) * 7;
	      }
	    },
	    startBottomMove: function startBottomMove(event) {
	      this.tempVal = event.screenX;
	      this.startMinMapMove = true;
	      this.isBottomMove = true;
	    },
	    startNavMove: function startNavMove(rate) {
	      this.moveRate = rate;
	      this.tempVal = event.screenY;
	      this.startMinMapMove = true;
	      this.$emit('virtual-scroll-scroll-bar-mouse', 'down');
	      document.addEventListener('click', this.docClickHandler);
	    },
	    docClickHandler: function docClickHandler() {
	      var _this2 = this;
	      document.removeEventListener('click', this.docClickHandler);
	      setTimeout(function () {
	        _this2.$emit('virtual-scroll-scroll-bar-mouse', 'up');
	      }, 0);
	    },
	    minNavMove: function minNavMove() {
	      var _this3 = this;
	      if (!this.startMinMapMove) return;
	      if (this.isBottomMove) {
	        var moveDis = event.screenX - this.tempVal;
	        var bottomScrollLeft = this.bottomScrollDis + moveDis;
	        if (bottomScrollLeft <= 0) bottomScrollLeft = 0;
	        if (bottomScrollLeft + this.bottomScrollWidth >= this.mainWidth) bottomScrollLeft = this.mainWidth - this.bottomScrollWidth;
	        this.bottomScrollDis = bottomScrollLeft;
	        this.tempVal = event.screenX;
	        this.$emit('horizontal-scroll', this.indexWidth + bottomScrollLeft);
	      } else {
	        var _moveDis = event.screenY - this.tempVal;
	        var minMapTop = this.minMapTop + _moveDis / this.moveRate * (this.mapHeight - this.visHeight / 8);
	        if (minMapTop <= 0) minMapTop = 0;
	        if (minMapTop >= this.mapHeight - this.visHeight / 8) minMapTop = this.mapHeight - this.visHeight / 8;
	        var totalScrollHeight = minMapTop / (this.mapHeight - this.visHeight / 8) * (this.totalHeight - this.visHeight);
	        this.tempVal = event.screenY;
	        this.minMapTop = minMapTop;
	        this.minNavTop = minMapTop * (this.visHeight - this.navHeight) / (this.mapHeight - this.visHeight / 8);
	        this.slowExec(function () {
	          _this3.getListData(totalScrollHeight);
	        });
	      }
	    },
	    slowExec: function slowExec(callBack) {
	      var now = +new Date();
	      if (now - (this.slowExec.lastTime || 0) >= 100) {
	        this.slowExec.lastTime = now;
	        callBack();
	      }
	      window.clearTimeout(this.slowExec.timeId);
	      this.slowExec.timeId = window.setTimeout(function () {
	        callBack();
	      }, 50);
	    },
	    moveEnd: function moveEnd(event) {
	      event.preventDefault();
	      this.startMinMapMove = false;
	      this.isBottomMove = false;
	    }
	  }
	};

	/* script */
	var __vue_script__$8 = script$8;
	/* template */

	var __vue_render__$8 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('section', {
	    ref: "scrollHome",
	    staticClass: "bk-scroll-home",
	    class: _vm.extCls,
	    on: {
	      "mousewheel": _vm.handleWheel,
	      "DOMMouseScroll": _vm.handleWheel
	    }
	  }, [_c('main', {
	    staticClass: "bk-scroll-main"
	  }, [_vm.showIndex ? _c('ul', {
	    staticClass: "bk-scroll-index bk-scroll",
	    style: {
	      height: _vm.ulHeight + "px",
	      top: -_vm.totalScrollHeight + "px",
	      width: _vm.indexWidth + "px"
	    }
	  }, _vm._l(_vm.indexList, function (item, index) {
	    return _c('li', {
	      key: index,
	      staticClass: "bk-scroll-item",
	      style: {
	        height: _vm.itemHeight + "px",
	        top: item.top + "px"
	      }
	    }, [_vm._t("index", [_vm._v("\n                    " + _vm._s(item.value) + "\n                ")], {
	      data: item.value
	    })], 2);
	  }), 0) : _vm._e(), _c('ul', {
	    ref: "scrollMain",
	    staticClass: "bk-scroll",
	    style: {
	      height: _vm.ulHeight + "px",
	      top: -_vm.totalScrollHeight + "px",
	      width: _vm.mainWidth + "px",
	      left: _vm.mainLeft + "px"
	    }
	  }, _vm._l(_vm.listData, function (item) {
	    return _c('li', {
	      key: item.top,
	      staticClass: "bk-scroll-item",
	      style: {
	        height: _vm.itemHeight + "px",
	        top: item.top + "px",
	        left: -_vm.bottomScrollDis * (_vm.itemWidth - _vm.mainWidth) / (_vm.mainWidth - _vm.bottomScrollWidth) + "px"
	      }
	    }, [_vm._t("default", null, {
	      data: item.value
	    })], 2);
	  }), 0)]), _c('canvas', {
	    ref: "minNav",
	    staticClass: "bk-min-nav",
	    style: "height: " + _vm.visHeight + "px;"
	  }), _vm.navHeight < _vm.visHeight ? _c('span', {
	    ref: "scrollNav",
	    staticClass: "bk-min-nav-slide bk-nav-show",
	    style: {
	      height: _vm.navHeight + "px",
	      top: _vm.minNavTop + "px"
	    },
	    on: {
	      "mousedown": function mousedown($event) {
	        _vm.startNavMove(_vm.visHeight - _vm.navHeight);
	      }
	    }
	  }) : _vm._e(), _vm.bottomScrollWidth < _vm.mainWidth ? _c('span', {
	    staticClass: "bk-min-nav-slide bk-bottom-scroll",
	    style: {
	      left: _vm.indexWidth + _vm.bottomScrollDis + "px",
	      width: _vm.bottomScrollWidth + "px"
	    },
	    on: {
	      "mousedown": _vm.startBottomMove
	    }
	  }) : _vm._e()]);
	};

	var __vue_staticRenderFns__$8 = [];
	/* style */

	var __vue_inject_styles__$8 = undefined;
	/* scoped */

	var __vue_scope_id__$8 = undefined;
	/* module identifier */

	var __vue_module_identifier__$8 = undefined;
	/* functional template */

	var __vue_is_functional_template__$8 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$8 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$8,
	  staticRenderFns: __vue_staticRenderFns__$8
	}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$8);

	var script$9 = {
	  name: 'bk-option',
	  props: {
	    id: {
	      type: [String, Number],
	      required: true
	    },
	    name: {
	      type: [String, Number],
	      required: true
	    },
	    disabled: Boolean
	  },
	  inject: ['select', 'optionGroup'],
	  data: function data() {
	    return {
	      unmatched: false,
	      isHighlight: false
	    };
	  },
	  computed: {
	    isSelected: function isSelected() {
	      if (this.select.multiple && isArray$1(this.select.selected)) {
	        return this.select.selected.includes(this.id);
	      }
	      return this.select.selected === this.id;
	    },
	    lowerName: function lowerName() {
	      return String(this.name).toLowerCase();
	    }
	  },
	  created: function created() {
	    this.select.registerOption(this);
	    if (this.optionGroup) {
	      this.optionGroup.registerOption(this);
	    }
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.select.removeOption(this);
	    if (this.optionGroup) {
	      this.optionGroup.removeOption(this);
	    }
	  },
	  methods: {
	    handleOptionClick: function handleOptionClick() {
	      if (this.disabled) {
	        return false;
	      }
	      var select = this.select;
	      if (this.isSelected && select.multiple) {
	        select.unselectOption(this);
	      } else if (!this.isSelected) {
	        select.selectOption(this);
	      }
	      if (!select.multiple) {
	        select.close();
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$9 = script$9;
	/* template */

	var __vue_render__$9 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: !_vm.unmatched,
	      expression: "!unmatched"
	    }],
	    staticClass: "bk-option",
	    class: {
	      'is-selected': _vm.isSelected,
	      'is-disabled': _vm.disabled,
	      'is-highlight': _vm.isHighlight
	    },
	    on: {
	      "click": _vm.handleOptionClick
	    }
	  }, [_c('div', {
	    staticClass: "bk-option-content"
	  }, [_vm._t("default", [_c('div', {
	    staticClass: "bk-option-content-default",
	    attrs: {
	      "title": _vm.name
	    }
	  }, [_vm.select.multiple && _vm.isSelected ? _c('i', {
	    staticClass: "bk-option-icon bk-icon icon-check-1"
	  }) : _vm._e(), _c('span', {
	    staticClass: "bk-option-name",
	    class: _vm.select.fontSizeCls
	  }, [_vm._v("\n                    " + _vm._s(_vm.name) + "\n                ")])])])], 2)]);
	};

	var __vue_staticRenderFns__$9 = [];
	/* style */

	var __vue_inject_styles__$9 = undefined;
	/* scoped */

	var __vue_scope_id__$9 = undefined;
	/* module identifier */

	var __vue_module_identifier__$9 = undefined;
	/* functional template */

	var __vue_is_functional_template__$9 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$9 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$9,
	  staticRenderFns: __vue_staticRenderFns__$9
	}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

	var virtualOption = {
	  name: 'bk-virtual-option',
	  props: {
	    renderFunc: Function,
	    item: Object
	  },
	  components: {
	    bkOption: __vue_component__$9
	  },
	  render: function render(h) {
	    if (this.renderFunc) return this.renderFunc(this.item, h);else return h("bk-option", {
	      "props": _objectSpread({}, this.item),
	      "class": "bk-virtual-option"
	    });
	  }
	};

	var variable = {
	  dropdownMarginBottom: '4px'
	};
	var variable_1 = variable.dropdownMarginBottom;

	var script$a = {
	  name: 'bk-select',
	  components: {
	    bkPopover: __vue_component__$2,
	    bkOptionAll: __vue_component__$6,
	    bkSelectTag: __vue_component__$7,
	    bkVirtualScroll: __vue_component__$8,
	    virtualOption: virtualOption
	  },
	  directives: {
	    bkloading: bkLoading
	  },
	  mixins: [emitter, locale.mixin, zIndex$1],
	  props: {
	    value: {
	      type: [String, Number, Array],
	      default: ''
	    },
	    isTagWidthLimit: {
	      type: Boolean,
	      default: true
	    },
	    multiple: Boolean,
	    showSelectAll: Boolean,
	    scrollHeight: {
	      type: Number,
	      default: 216
	    },
	    popoverMinWidth: Number,
	    popoverWidth: Number,
	    popoverOptions: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    placeholder: {
	      type: String,
	      default: ''
	    },
	    clearable: {
	      type: Boolean,
	      default: true
	    },
	    disabled: Boolean,
	    readonly: Boolean,
	    loading: Boolean,
	    searchable: Boolean,
	    searchIgnoreCase: {
	      type: Boolean,
	      default: true
	    },
	    searchPlaceholder: {
	      type: String,
	      default: ''
	    },
	    size: {
	      type: String,
	      default: '',
	      validator: function validator(val) {
	        return ['', 'large', 'small'].includes(val);
	      }
	    },
	    remoteMethod: {
	      type: Function
	    },
	    emptyText: {
	      type: String,
	      default: ''
	    },
	    fontSize: {
	      type: String,
	      default: 'normal'
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    extPopoverCls: {
	      type: String,
	      default: ''
	    },
	    prefixIcon: {
	      type: String,
	      default: ''
	    },
	    displayTag: Boolean,
	    collapseTag: {
	      type: Boolean,
	      default: true
	    },
	    searchWithPinyin: Boolean,
	    enableVirtualScroll: {
	      type: Boolean,
	      default: false
	    },
	    virtualScrollRender: Function,
	    list: Array,
	    idKey: {
	      type: String,
	      default: 'id'
	    },
	    displayKey: {
	      type: String,
	      default: 'name'
	    },
	    itemHeight: {
	      type: Number,
	      default: 32
	    },
	    showEmpty: {
	      type: Boolean,
	      default: true
	    },
	    showOnInit: {
	      type: Boolean,
	      default: false
	    },
	    behavior: {
	      type: String,
	      default: 'normal',
	      validate: function validate(v) {
	        return ['simplicity', 'normal'].indexOf(v) > -1;
	      }
	    }
	  },
	  provide: function provide() {
	    return {
	      select: this,
	      optionGroup: null
	    };
	  },
	  data: function data() {
	    var selected = this.value;
	    if (this.multiple && !isArray$1(selected)) {
	      selected = [];
	    }
	    return {
	      ready: false,
	      focus: false,
	      selected: selected,
	      options: [],
	      optionsMap: {},
	      selectedOptions: this.multiple ? [] : null,
	      defaultWidth: 0,
	      selectSize: this.size,
	      searchValue: '',
	      searchTimer: null,
	      searchLoading: false,
	      autoUpdate: false,
	      renderPopoverOptions: {},
	      popoverDistance: 10 + _parseInt$2(variable_1)
	    };
	  },
	  computed: {
	    selectedName: function selectedName() {
	      if (this.selectedOptions) {
	        if (this.multiple) {
	          return this.selectedOptions.map(function (option) {
	            return option.name;
	          }).join(',');
	        }
	        return this.selectedOptions.name;
	      }
	      return null;
	    },
	    isRemoteSearch: function isRemoteSearch() {
	      return typeof this.remoteMethod === 'function';
	    },
	    shouldUpdate: function shouldUpdate() {
	      return !this.isRemoteSearch || !this.searchValue;
	    },
	    isUnselected: function isUnselected() {
	      if (this.multiple) {
	        return !this.selected.length;
	      }
	      return this.selected === '';
	    },
	    unmatchedCount: function unmatchedCount() {
	      return this.options.filter(function (option) {
	        return option.unmatched;
	      }).length;
	    },
	    localPlaceholder: function localPlaceholder() {
	      return this.placeholder ? this.placeholder : this.t('bk.select.pleaseselect');
	    },
	    dropdownActive: function dropdownActive() {
	      return !(this.disabled || this.loading || this.readonly);
	    },
	    popoverStyle: function popoverStyle() {
	      return {
	        width: (this.popoverWidth ? this.popoverWidth : this.defaultWidth) + 'px',
	        minWidth: (this.popoverMinWidth ? this.popoverMinWidth : this.defaultWidth) + 'px'
	      };
	    },
	    fontSizeCls: function fontSizeCls() {
	      var cls = '';
	      if (this.fontSize === 'medium') {
	        cls = 'medium-font';
	      } else if (this.fontSize === 'large') {
	        cls = 'large-font';
	      }
	      return cls;
	    },
	    wrapperCls: function wrapperCls() {
	      var wrapperCls = [];
	      if (this.selectSize) {
	        wrapperCls.push("bk-select-".concat(this.selectSize));
	      }
	      return wrapperCls;
	    },
	    popoverCls: function popoverCls() {
	      var wrapperCls = [];
	      if (this.selectSize) {
	        wrapperCls.push("bk-select-popover-".concat(this.selectSize));
	      }
	      return wrapperCls;
	    },
	    localSearchPlaceholder: function localSearchPlaceholder() {
	      return this.searchPlaceholder ? this.searchPlaceholder : this.t('bk.select.searchPlaceholder');
	    }
	  },
	  watch: {
	    value: function value(_value) {
	      if (!this.isSame(_value, this.selected)) {
	        this.selected = _value;
	      }
	    },
	    focus: function focus(_focus) {
	      var _this = this;
	      if (!_focus) {
	        this.resetSearchValue();
	        this.dispatch('bk-form-item', 'form-blur');
	      }
	      this.$nextTick(function () {
	        _this.$emit('toggle', _focus);
	        _this.dispatch('bk-form-item', 'form-focus');
	        if (_focus) _this.showVirtualScroll();
	      });
	    },
	    dropdownActive: function dropdownActive() {
	      this.setDropdownState();
	    },
	    searchValue: function searchValue(val) {
	      var _this2 = this;
	      this.searchTimer && clearTimeout(this.searchTimer);
	      this.searchTimer = setTimeout(function () {
	        if (_this2.isRemoteSearch) {
	          _this2.remoteSearch();
	        } else {
	          _this2.search();
	        }
	      }, 100);
	    },
	    selected: function selected(value, oldValue) {
	      if (this.shouldUpdate || this.autoUpdate) {
	        this.setSelectedOptions();
	      }
	      this.$emit('input', value);
	      this.$emit('change', value, oldValue);
	      this.dispatch('bk-form-item', 'form-change');
	    },
	    list: {
	      handler: function handler(val) {
	        var _this3 = this;
	        if (this.enableVirtualScroll) {
	          this.optionsMap = {};
	          this.options = val.map(function (option) {
	            return seal$1(_objectSpread({}, option, {
	              id: option[_this3.idKey],
	              name: option[_this3.displayKey],
	              lowerName: String(option[_this3.displayKey]).toLowerCase(),
	              unmatched: false
	            }));
	          });
	          this.options.forEach(function (option) {
	            _this3.optionsMap[option.id] = option;
	          });
	        }
	      },
	      immediate: true
	    },
	    options: function options() {
	      this.updatePopoverPosition();
	      this.setSelectedOptions();
	      this.showVirtualScroll();
	    },
	    size: function size(val) {
	      this.selectSize = val;
	    },
	    multiple: function multiple(v) {
	      if (v) {
	        this.selectedOptions = [];
	        this.selected = [];
	      }
	    },
	    popoverOptions: {
	      handler: function handler(v) {
	        this.renderPopoverOptions = _extends({}, v);
	      },
	      immediate: true
	    }
	  },
	  created: function created() {
	    var _this4 = this;
	    this.$nextTick(function () {
	      _this4.setSelectedOptions();
	    });
	  },
	  mounted: function mounted() {
	    this.setDropdownState();
	    this.setDropdownCallback();
	    this.showOnInit && this.show();
	  },
	  methods: {
	    virtualScrollScrollBarMouse: function virtualScrollScrollBarMouse(idx) {
	      var renderPopoverOptions = _extends({}, this.renderPopoverOptions);
	      renderPopoverOptions.hideOnClick = idx !== 'down';
	      this.renderPopoverOptions = _extends({}, renderPopoverOptions);
	    },
	    showVirtualScroll: function showVirtualScroll() {
	      var list = this.options.filter(function (option) {
	        return !option.unmatched;
	      });
	      if (this.$refs.virtualScroll && this.enableVirtualScroll) this.$refs.virtualScroll.setListData(list);
	    },
	    setSelectedOptions: function setSelectedOptions() {
	      var _this5 = this;
	      if (this.multiple) {
	        var existOptions = this.selectedOptions.filter(function (option) {
	          return _this5.selected.includes(option.id);
	        });
	        var newSelected = this.selected.filter(function (value) {
	          return !existOptions.some(function (option) {
	            return option.id === value;
	          });
	        });
	        newSelected.forEach(function (value) {
	          var option = _this5.optionsMap[value];
	          if (option) {
	            existOptions.push(option);
	          }
	        });
	        var selectedOptions = [];
	        this.selected.forEach(function (value) {
	          var option = existOptions.find(function (option) {
	            return option.id === value;
	          });
	          if (option) {
	            selectedOptions.push(option);
	          }
	        });
	        this.selectedOptions = selectedOptions;
	      } else {
	        this.selectedOptions = this.optionsMap[this.selected];
	      }
	    },
	    getPopoverInstance: function getPopoverInstance() {
	      return this.$refs.selectDropdown.instance;
	    },
	    close: function close() {
	      var popover = this.getPopoverInstance();
	      popover.hide();
	    },
	    show: function show() {
	      var popover = this.getPopoverInstance();
	      popover.show();
	    },
	    updatePopoverPosition: function updatePopoverPosition() {
	      if (this.focus) {
	        var popover = this.getPopoverInstance();
	        popover.popperInstance.scheduleUpdate();
	      }
	    },
	    setDropdownState: function setDropdownState() {
	      var popover = this.getPopoverInstance();
	      if (this.dropdownActive) {
	        popover.enable();
	      } else {
	        popover.disable();
	      }
	    },
	    setDropdownCallback: function setDropdownCallback() {
	      var _this6 = this;
	      var popover = this.getPopoverInstance();
	      popover.set({
	        onShown: function onShown() {
	          if (_this6.searchable) {
	            _this6.$refs.searchInput.focus();
	          }
	        }
	      });
	    },
	    handleDropdownShow: function handleDropdownShow() {
	      this.defaultWidth = this.$el.offsetWidth;
	      this.focus = true;
	    },
	    handleDropdownHide: function handleDropdownHide() {
	      this.focus = false;
	    },
	    registerOption: function registerOption(option) {
	      if (this.enableVirtualScroll) return;
	      this.options.push(option);
	      this.$set(this.optionsMap, option.id, option);
	    },
	    removeOption: function removeOption(option) {
	      if (this.enableVirtualScroll) return;
	      var index = this.options.indexOf(option);
	      if (index > -1) {
	        this.options.splice(index, 1);
	      }
	    },
	    selectOption: function selectOption(option) {
	      var _this7 = this;
	      if (this.multiple) {
	        if (!this.shouldUpdate) {
	          this.selectedOptions.push(option);
	        }
	        this.selected = [].concat(_toConsumableArray(this.selected), [option.id]);
	      } else {
	        if (!this.shouldUpdate) {
	          this.selectedOptions = option;
	        }
	        this.selected = option.id;
	        this.close();
	      }
	      this.$nextTick(function () {
	        _this7.$emit('selected', _this7.selected, _this7.selectedOptions);
	      });
	    },
	    unselectOption: function unselectOption(option) {
	      var _this8 = this;
	      if (this.multiple) {
	        if (!this.shouldUpdate) {
	          this.selectedOptions = this.selectedOptions.filter(function (selectedOption) {
	            return selectedOption.id !== option.id;
	          });
	        }
	        this.selected = this.selected.filter(function (value) {
	          return value !== option.id;
	        });
	      } else {
	        this.setSelectedOptions = null;
	        this.reset();
	      }
	      this.$nextTick(function () {
	        _this8.$emit('selected', _this8.selected, _this8.selectedOptions);
	      });
	    },
	    reset: function reset() {
	      var _this9 = this;
	      this.selectedOptions = this.multiple ? [] : null;
	      var prevSelected = this.multiple ? _toConsumableArray(this.selected) : this.selected;
	      this.selected = this.multiple ? [] : '';
	      this.$nextTick(function () {
	        _this9.$emit('clear', prevSelected);
	      });
	    },
	    selectAll: function selectAll() {
	      this.selected = this.options.filter(function (option) {
	        return !option.disabled;
	      }).map(function (option) {
	        return option.id;
	      });
	    },
	    search: function search() {
	      var _this10 = this;
	      this.searchLoading = true;
	      var searchValue = String(this.searchValue).trim();
	      if (searchValue) {
	        if (this.searchIgnoreCase) {
	          searchValue = searchValue.toLowerCase();
	        }
	        this.options.forEach(function (option) {
	          if (_this10.searchIgnoreCase) {
	            option.unmatched = option.lowerName.indexOf(searchValue) < 0;
	          } else {
	            option.unmatched = option.name.indexOf(searchValue) < 0;
	          }
	          if (option.unmatched && _this10.searchWithPinyin) {
	            var pinyinList = pinyin.parse(_this10.searchIgnoreCase ? option.lowerName : option.name).map(function (v) {
	              if (v.type === 2) {
	                return v.target.toLowerCase();
	              }
	              return v.target;
	            });
	            var pinyinStr = pinyinList.reduce(function (res, cur) {
	              return res + cur[0];
	            }, '');
	            option.unmatched = pinyinList.join('').indexOf(searchValue) < 0 && pinyinStr.indexOf(searchValue) < 0;
	          }
	        });
	      } else {
	        this.options.forEach(function (option) {
	          option.unmatched = false;
	        });
	      }
	      this.showVirtualScroll();
	      this.searchLoading = false;
	    },
	    remoteSearch: function remoteSearch() {
	      var _this11 = this;
	      return _asyncToGenerator( regenerator.mark(function _callee() {
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.prev = 0;
	                _this11.searchLoading = true;
	                _context.next = 4;
	                return _this11.remoteMethod(_this11.searchValue);
	              case 4:
	                _context.next = 9;
	                break;
	              case 6:
	                _context.prev = 6;
	                _context.t0 = _context["catch"](0);
	                console.error(_context.t0);
	              case 9:
	                _context.prev = 9;
	                _this11.searchLoading = false;
	                return _context.finish(9);
	              case 12:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, null, [[0, 6, 9, 12]]);
	      }))();
	    },
	    resetSearchValue: function resetSearchValue() {
	      this.searchValue = '';
	    },
	    isSame: function isSame(source, target) {
	      var isArray = isArray$1(source) && isArray$1(target);
	      if (isArray) {
	        if (source.length !== target.length) {
	          return false;
	        }
	        return !source.some(function (value, index) {
	          return value !== target[index];
	        });
	      }
	      return source === target;
	    },
	    handleClose: function handleClose() {
	      this.close();
	      this.$refs.bkSelect && this.$refs.bkSelect.focus();
	    },
	    handleTabRemove: function handleTabRemove(options) {
	      this.$emit('tab-remove', options);
	    }
	  }
	};

	var img = new Image(); img.src = 'data:image/svg+xml;base64,PHN2ZyBjbGFzcz0ibGRzLXNwaW4iIHdpZHRoPSI4MHB4IiBoZWlnaHQ9IjgwcHgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCI+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODAsNTApIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDApIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMSIgdHJhbnNmb3JtPSJzY2FsZSgxLjA3NjY3IDEuMDc2NjcpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuOTE2NjY2NjY2NjY2NjY2NnMiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC45MTY2NjY2NjY2NjY2NjY2cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNzUuOTgwNzYyMTEzNTMzMTYsNjUpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDI5Ljk5OTk5OTk5OTk5OTk5NikiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjkxNjY2NjY2NjY2NjY2NjYiIHRyYW5zZm9ybT0ic2NhbGUoMS4wOTMzMyAxLjA5MzMzKSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjgzMzMzMzMzMzMzMzMzMzRzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuODMzMzMzMzMzMzMzMzMzNHMiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDY1LDc1Ljk4MDc2MjExMzUzMzE2KSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSg1OS45OTk5OTk5OTk5OTk5OSkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjgzMzMzMzMzMzMzMzMzMzQiIHRyYW5zZm9ybT0ic2NhbGUoMS4xMSAxLjExKSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjc1cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjc1cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNTAsODApIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDkwKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNzUiIHRyYW5zZm9ybT0ic2NhbGUoMS4xMjY2NyAxLjEyNjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjY2NjY2NjY2NjY2NjY2NjZzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuNjY2NjY2NjY2NjY2NjY2NnMiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM1LjAwMDAwMDAwMDAwMDAxLDc1Ljk4MDc2MjExMzUzMzE2KSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgxMTkuOTk5OTk5OTk5OTk5OTkpIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMC42NjY2NjY2NjY2NjY2NjY2IiB0cmFuc2Zvcm09InNjYWxlKDEuMTQzMzMgMS4xNDMzMykiPgogICAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0ic2NhbGUiIGJlZ2luPSItMC41ODMzMzMzMzMzMzMzMzM0cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjU4MzMzMzMzMzMzMzMzMzRzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNC4wMTkyMzc4ODY0NjY4NCw2NSkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMTUwLjAwMDAwMDAwMDAwMDAzKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNTgzMzMzMzMzMzMzMzMzNCIgdHJhbnNmb3JtPSJzY2FsZSgxLjE2IDEuMTYpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuNXMiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC41cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjAsNTAuMDAwMDAwMDAwMDAwMDEpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDE4MCkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjUiIHRyYW5zZm9ybT0ic2NhbGUoMS4xNzY2NyAxLjE3NjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjQxNjY2NjY2NjY2NjY2NjdzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuNDE2NjY2NjY2NjY2NjY2N3MiPjwvYW5pbWF0ZT4KICAgICAgPC9jaXJjbGU+CiAgICA8L2c+CiAgPC9nPgogIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI0LjAxOTIzNzg4NjQ2NjgzNiwzNS4wMDAwMDAwMDAwMDAwMSkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjA5Ljk5OTk5OTk5OTk5OTk3KSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuNDE2NjY2NjY2NjY2NjY2NyIgdHJhbnNmb3JtPSJzY2FsZSgxLjE5MzMzIDEuMTkzMzMpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMzMzMzMzMzMzMzMzMzMzM3MiIHZhbHVlcz0iMS4yIDEuMjsxIDEiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIj48L2FuaW1hdGVUcmFuc2Zvcm0+CiAgICAgICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iZmlsbC1vcGFjaXR5IiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgdmFsdWVzPSIxOzAiIGJlZ2luPSItMC4zMzMzMzMzMzMzMzMzMzMzcyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzQuOTk5OTk5OTk5OTk5OTg2LDI0LjAxOTIzNzg4NjQ2Njg0NykiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjM5Ljk5OTk5OTk5OTk5OTk3KSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuMzMzMzMzMzMzMzMzMzMzMyIgdHJhbnNmb3JtPSJzY2FsZSgxLjAxIDEuMDEpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMjVzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuMjVzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg0OS45OTk5OTk5OTk5OTk5OSwyMCkiPgogICAgPGcgdHJhbnNmb3JtPSJyb3RhdGUoMjcwKSI+CiAgICAgIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSI1IiBmaWxsPSIjM2E4NGZmIiBmaWxsLW9wYWNpdHk9IjAuMjUiIHRyYW5zZm9ybT0ic2NhbGUoMS4wMjY2NyAxLjAyNjY3KSI+CiAgICAgICAgPGFuaW1hdGVUcmFuc2Zvcm0gYXR0cmlidXRlTmFtZT0idHJhbnNmb3JtIiB0eXBlPSJzY2FsZSIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49Ii0wLjE2NjY2NjY2NjY2NjY2NjY2cyI+PC9hbmltYXRlPgogICAgICA8L2NpcmNsZT4KICAgIDwvZz4KICA8L2c+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjUsMjQuMDE5MjM3ODg2NDY2ODQzKSI+CiAgICA8ZyB0cmFuc2Zvcm09InJvdGF0ZSgzMDAuMDAwMDAwMDAwMDAwMDYpIj4KICAgICAgPGNpcmNsZSBjeD0iMCIgY3k9IjAiIHI9IjUiIGZpbGw9IiMzYTg0ZmYiIGZpbGwtb3BhY2l0eT0iMC4xNjY2NjY2NjY2NjY2NjY2NiIgdHJhbnNmb3JtPSJzY2FsZSgxLjA0MzMzIDEuMDQzMzMpIj4KICAgICAgICA8YW5pbWF0ZVRyYW5zZm9ybSBhdHRyaWJ1dGVOYW1lPSJ0cmFuc2Zvcm0iIHR5cGU9InNjYWxlIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIiB2YWx1ZXM9IjEuMiAxLjI7MSAxIiBrZXlUaW1lcz0iMDsxIiBkdXI9IjFzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSI+PC9hbmltYXRlVHJhbnNmb3JtPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9ImZpbGwtb3BhY2l0eSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIHZhbHVlcz0iMTswIiBiZWdpbj0iLTAuMDgzMzMzMzMzMzMzMzMzMzNzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3NS45ODA3NjIxMTM1MzMxNiwzNC45OTk5OTk5OTk5OTk5ODYpIj4KICAgIDxnIHRyYW5zZm9ybT0icm90YXRlKDMyOS45OTk5OTk5OTk5OTk5NCkiPgogICAgICA8Y2lyY2xlIGN4PSIwIiBjeT0iMCIgcj0iNSIgZmlsbD0iIzNhODRmZiIgZmlsbC1vcGFjaXR5PSIwLjA4MzMzMzMzMzMzMzMzMzMzIiB0cmFuc2Zvcm09InNjYWxlKDEuMDYgMS4wNikiPgogICAgICAgIDxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9InRyYW5zZm9ybSIgdHlwZT0ic2NhbGUiIGJlZ2luPSIwcyIgdmFsdWVzPSIxLjIgMS4yOzEgMSIga2V5VGltZXM9IjA7MSIgZHVyPSIxcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiPjwvYW5pbWF0ZVRyYW5zZm9ybT4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJmaWxsLW9wYWNpdHkiIGtleVRpbWVzPSIwOzEiIGR1cj0iMXMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiB2YWx1ZXM9IjE7MCIgYmVnaW49IjBzIj48L2FuaW1hdGU+CiAgICAgIDwvY2lyY2xlPgogICAgPC9nPgogIDwvZz4KPC9zdmc+'; var __$_require_ui_images_spinner_svg__ = img.src;

	/* script */
	var __vue_script__$a = script$a;

	var __vue_render__$a = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "bkSelect",
	    staticClass: "bk-select",
	    class: [{
	      'is-focus': _vm.focus,
	      'is-disabled': _vm.disabled,
	      'is-readonly': _vm.readonly,
	      'is-loading': _vm.loading,
	      'is-unselected': _vm.isUnselected,
	      'is-default-trigger': !_vm.$scopedSlots.trigger,
	      'has-prefix-icon': !!_vm.prefixIcon,
	      'only-bottom-border': _vm.behavior === 'simplicity'
	    }, _vm.wrapperCls, _vm.fontSizeCls, _vm.extCls],
	    attrs: {
	      "data-placeholder": _vm.localPlaceholder,
	      "tabindex": "0"
	    },
	    on: {
	      "keydown": [function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) {
	          return null;
	        }

	        $event.preventDefault();
	        return _vm.show($event);
	      }, function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
	          return null;
	        }

	        return _vm.close($event);
	      }, function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
	          return null;
	        }

	        $event.stopPropagation();
	        $event.preventDefault();
	        return _vm.close($event);
	      }]
	    }
	  }, [!_vm.$scopedSlots.trigger ? [_vm.loading ? [_c('img', {
	    staticClass: "bk-select-loading",
	    attrs: {
	      "src": __$_require_ui_images_spinner_svg__
	    }
	  })] : [_vm.clearable && !_vm.isUnselected && !_vm.disabled && !_vm.readonly ? _c('i', {
	    staticClass: "bk-select-clear bk-icon icon-close-circle-shape",
	    on: {
	      "click": function click($event) {
	        $event.preventDefault();
	        $event.stopPropagation();
	        return _vm.reset($event);
	      }
	    }
	  }) : _vm._e(), _c('i', {
	    staticClass: "bk-select-angle bk-icon icon-angle-down"
	  })]] : _vm._e(), _c('bk-popover', {
	    ref: "selectDropdown",
	    staticClass: "bk-select-dropdown",
	    attrs: {
	      "trigger": "click",
	      "placement": "bottom-start",
	      "theme": "light bk-select-dropdown",
	      "animation": "slide-toggle",
	      "offset": -1,
	      "distance": _vm.popoverDistance,
	      "z-index": _vm.zIndex,
	      "on-show": _vm.handleDropdownShow,
	      "on-hide": _vm.handleDropdownHide,
	      "tippy-options": _vm.renderPopoverOptions
	    }
	  }, [_vm.prefixIcon ? _c('i', {
	    class: ['bk-select-prefix-icon', _vm.prefixIcon]
	  }) : _vm._e(), _vm._t("trigger", [_vm.multiple && _vm.displayTag ? _c('bk-select-tag', {
	    attrs: {
	      "width-limit": _vm.isTagWidthLimit
	    }
	  }) : _c('div', {
	    staticClass: "bk-select-name",
	    class: _vm.fontSizeCls,
	    attrs: {
	      "title": _vm.selectedName
	    }
	  }, [_vm._v("\n                " + _vm._s(_vm.selectedName) + "\n            ")])], null, _vm.$props), _c('div', {
	    staticClass: "bk-select-dropdown-content",
	    class: [_vm.popoverCls, _vm.extPopoverCls],
	    style: _vm.popoverStyle,
	    attrs: {
	      "slot": "content"
	    },
	    slot: "content"
	  }, [_vm.searchable ? _c('div', {
	    staticClass: "bk-select-search-wrapper"
	  }, [_c('i', {
	    staticClass: "left-icon bk-icon icon-search"
	  }), _c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: _vm.searchValue,
	      expression: "searchValue"
	    }],
	    ref: "searchInput",
	    staticClass: "bk-select-search-input",
	    class: _vm.fontSizeCls,
	    attrs: {
	      "type": "text",
	      "placeholder": _vm.localSearchPlaceholder
	    },
	    domProps: {
	      "value": _vm.searchValue
	    },
	    on: {
	      "keydown": [function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
	          return null;
	        }

	        return _vm.handleClose($event);
	      }, function ($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) {
	          return null;
	        }

	        $event.stopPropagation();
	        $event.preventDefault();
	        return _vm.handleClose($event);
	      }],
	      "input": function input($event) {
	        if ($event.target.composing) {
	          return;
	        }

	        _vm.searchValue = $event.target.value;
	      }
	    }
	  })]) : _vm._e(), _c('div', {
	    directives: [{
	      name: "bkloading",
	      rawName: "v-bkloading",
	      value: {
	        isLoading: _vm.searchLoading
	      },
	      expression: "{ isLoading: searchLoading }"
	    }],
	    staticClass: "bk-options-wrapper",
	    style: {
	      maxHeight: _vm.scrollHeight + 'px'
	    }
	  }, [_c('ul', {
	    ref: "optionList",
	    staticClass: "bk-options",
	    class: {
	      'bk-options-single': !_vm.multiple
	    },
	    style: {
	      maxHeight: _vm.scrollHeight + 'px'
	    }
	  }, [_vm.multiple && _vm.showSelectAll && !_vm.searchValue ? _c('bk-option-all', {
	    ref: "selectAllOption"
	  }) : _vm._e(), _vm.enableVirtualScroll ? _c('bk-virtual-scroll', {
	    ref: "virtualScroll",
	    staticClass: "bk-virtual-select",
	    style: {
	      height: _vm.scrollHeight + 'px',
	      width: '100%'
	    },
	    attrs: {
	      "item-height": _vm.itemHeight
	    },
	    on: {
	      "virtual-scroll-scroll-bar-mouse": _vm.virtualScrollScrollBarMouse
	    },
	    scopedSlots: _vm._u([{
	      key: "default",
	      fn: function fn(item) {
	        return [_c('virtual-option', {
	          attrs: {
	            "item": item.data,
	            "render-func": _vm.virtualScrollRender
	          }
	        })];
	      }
	    }])
	  }) : _vm._t("default")], 2)]), _vm.showEmpty ? [!_vm.options.length ? _c('div', {
	    staticClass: "bk-select-empty",
	    class: _vm.fontSizeCls
	  }, [_vm._v("\n                    " + _vm._s(_vm.emptyText || _vm.t('bk.select.dataEmpty')) + "\n                ")]) : _vm.searchable && _vm.unmatchedCount === _vm.options.length ? _c('div', {
	    staticClass: "bk-select-empty",
	    class: _vm.fontSizeCls
	  }, [_vm._v("\n                    " + _vm._s(_vm.emptyText || _vm.t('bk.select.searchEmpty')) + "\n                ")]) : _vm._e()] : _vm._e(), _vm.$slots.extension ? _c('div', {
	    staticClass: "bk-select-extension",
	    class: _vm.fontSizeCls
	  }, [_vm._t("extension")], 2) : _vm._e()], 2)], 2)], 2);
	};

	var __vue_staticRenderFns__$a = [];
	/* style */

	var __vue_inject_styles__$a = undefined;
	/* scoped */

	var __vue_scope_id__$a = undefined;
	/* module identifier */

	var __vue_module_identifier__$a = undefined;
	/* functional template */

	var __vue_is_functional_template__$a = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$a = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$a,
	  staticRenderFns: __vue_staticRenderFns__$a
	}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

	/* script */

	/* template */
	var __vue_render__$b = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    class: ['bk-page-selection-count', "bk-page-selection-count-" + _vm.$parent.realityLocation]
	  }, [_vm.$parent.curLang === 'cn' ? [_vm._v("\n        å·²éæ©"), _c('span', {
	    staticClass: "count"
	  }, [_vm._v(_vm._s(_vm.$parent.selectionCount))]), _vm._v("æ¡\n    ")] : [_c('span', {
	    staticClass: "count"
	  }, [_vm._v(_vm._s(_vm.$parent.selectionCount))]), _vm._v(" item(s) selected\n    ")]], 2);
	};

	var __vue_staticRenderFns__$b = [];
	/* style */

	var __vue_inject_styles__$b = undefined;
	/* scoped */

	var __vue_scope_id__$b = undefined;
	/* module identifier */

	var __vue_module_identifier__$b = undefined;
	/* functional template */

	var __vue_is_functional_template__$b = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$b = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$b,
	  staticRenderFns: __vue_staticRenderFns__$b
	}, __vue_inject_styles__$b, {}, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

	/* script */

	/* template */
	var __vue_render__$c = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.$parent.showTotalCount ? _c('div', {
	    class: ['bk-page-total-count', "bk-page-total-count-" + _vm.$parent.realityLocation, {
	      'bk-page-total-small': _vm.$parent.small
	    }]
	  }, [_vm.$parent.curLang === 'cn' ? [_vm._v("\n        å±è®¡"), _c('span', {
	    staticClass: "stress"
	  }, [_vm._v(_vm._s(_vm.$parent.count))]), _vm._v("æ¡\n    ")] : [_vm._v("\n        Total: "), _c('span', {
	    staticClass: "stress"
	  }, [_vm._v(_vm._s(_vm.$parent.count))]), _vm._v(" items\n    ")]], 2) : _vm._e();
	};

	var __vue_staticRenderFns__$c = [];
	/* style */

	var __vue_inject_styles__$c = undefined;
	/* scoped */

	var __vue_scope_id__$c = undefined;
	/* module identifier */

	var __vue_module_identifier__$c = undefined;
	/* functional template */

	var __vue_is_functional_template__$c = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$c = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$c,
	  staticRenderFns: __vue_staticRenderFns__$c
	}, __vue_inject_styles__$c, {}, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

	var script$b = {
	  name: 'small-jump',
	  components: {
	    bkPopover: __vue_component__$2
	  },
	  props: {
	    current: {
	      type: Number,
	      default: ''
	    },
	    total: {
	      type: Number,
	      default: 0
	    }
	  },
	  data: function data() {
	    return {
	      focus: false,
	      currentPage: this.current
	    };
	  },
	  watch: {
	    current: function current(value) {
	      this.currentPage = value;
	    }
	  },
	  methods: {
	    handleInputChange: function handleInputChange(event) {
	      var $target = event.target;
	      var value = Number($target.textContent);
	      if (!value || value < 1 || value > this.total || value === this.current) return;
	      this.currentPage = value;
	      this.setSelection();
	    },
	    handleBlur: function handleBlur() {
	      if (this.currentPage !== this.current) {
	        this.$emit('on-change', this.currentPage);
	      }
	      this.focus = false;
	      this.$refs.jumpInput && (this.$refs.jumpInput.textContent = this.currentPage);
	    },
	    handleStep: function handleStep(step) {
	      var nextStep = this.current + step;
	      if (nextStep > this.total) {
	        return;
	      }
	      if (nextStep < 1) {
	        return;
	      }
	      this.currentPage = nextStep;
	      this.$emit('on-change', this.currentPage);
	    },
	    handleChangePage: function handleChangePage(value) {
	      if (value === this.current) return this.hidePopover();
	      this.currentPage = value;
	      if (!this.focus) {
	        this.handleBlur();
	      }
	      this.hidePopover();
	    },
	    getPopoverInstance: function getPopoverInstance() {
	      return this.$refs.smallJumpPopover && this.$refs.smallJumpPopover.instance;
	    },
	    hidePopover: function hidePopover() {
	      var instance = this.getPopoverInstance();
	      instance && instance.hide();
	    },
	    showPopover: function showPopover() {
	      var instance = this.getPopoverInstance();
	      instance && instance.show();
	    },
	    setSelection: function setSelection() {
	      var _this = this;
	      this.$nextTick(function () {
	        var $input = _this.$refs.jumpInput;
	        $input.focus();
	        var range = window.getSelection();
	        range.selectAllChildren($input);
	        range.collapseToEnd();
	      });
	    },
	    handleKeyDown: function handleKeyDown(e) {
	      if (['Enter', 'NumpadEnter'].includes(e.code)) {
	        this.handleBlur();
	        this.setSelection();
	        this.focus = true;
	        this.hidePopover();
	        e.preventDefault();
	        return false;
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$b = script$b;
	/* template */

	var __vue_render__$d = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-page-small-jump"
	  }, [_c('div', {
	    staticClass: "btn-pre",
	    class: {
	      disable: _vm.current === 1
	    },
	    on: {
	      "click": function click($event) {
	        _vm.handleStep(-1);
	      }
	    }
	  }, [_c('i', {
	    staticClass: "bk-icon icon-left-shape"
	  })]), _c('bk-popover', {
	    ref: "smallJumpPopover",
	    attrs: {
	      "trigger": "manual",
	      "placement": "bottom-start",
	      "theme": "light bk-select-dropdown",
	      "animation": "slide-toggle",
	      "offset": -1,
	      "distance": 12
	    }
	  }, [_c('div', {
	    class: ['jump-input-wrapper', {
	      'focus': _vm.focus
	    }],
	    on: {
	      "click": function click($event) {
	        $event.preventDefault();
	        return _vm.showPopover($event);
	      }
	    }
	  }, [_c('span', {
	    ref: "jumpInput",
	    staticClass: "jump-input",
	    attrs: {
	      "contenteditable": ""
	    },
	    domProps: {
	      "textContent": _vm._s(_vm.current)
	    },
	    on: {
	      "input": _vm.handleInputChange,
	      "blur": _vm.handleBlur,
	      "focus": function focus() {
	        return _vm.focus = true;
	      },
	      "keydown": _vm.handleKeyDown
	    }
	  }), _c('span', {
	    class: ['page-total', {
	      'focus': _vm.focus
	    }]
	  }, [_vm._v("/ " + _vm._s(_vm.total))])]), _c('div', {
	    attrs: {
	      "slot": "content"
	    },
	    slot: "content"
	  }, [_c('ul', {
	    staticClass: "small-jump-options"
	  }, _vm._l(_vm.total, function (index) {
	    return _c('li', {
	      key: index,
	      class: ['small-jump-option', {
	        'is-selected': _vm.current === index
	      }],
	      on: {
	        "mousedown": function mousedown($event) {
	          _vm.handleChangePage(index);
	        }
	      }
	    }, [_vm._v("\n                    " + _vm._s(index) + "\n                ")]);
	  }), 0)])]), _c('div', {
	    staticClass: "btn-next",
	    class: {
	      disable: _vm.current === _vm.total
	    },
	    on: {
	      "click": function click($event) {
	        _vm.handleStep(1);
	      }
	    }
	  }, [_c('i', {
	    staticClass: "bk-icon icon-right-shape"
	  })])], 1);
	};

	var __vue_staticRenderFns__$d = [];
	/* style */

	var __vue_inject_styles__$d = undefined;
	/* scoped */

	var __vue_scope_id__$d = undefined;
	/* module identifier */

	var __vue_module_identifier__$d = undefined;
	/* functional template */

	var __vue_is_functional_template__$d = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$d = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$d,
	  staticRenderFns: __vue_staticRenderFns__$d
	}, __vue_inject_styles__$d, __vue_script__$b, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

	var script$c = {
	  name: 'bk-pagination',
	  components: {
	    bkSelect: __vue_component__$a,
	    bkOption: __vue_component__$9,
	    paginationSelectionCount: __vue_component__$b,
	    paginationTotalCount: __vue_component__$c,
	    SmallJump: __vue_component__$d
	  },
	  mixins: [locale.mixin],
	  props: {
	    type: {
	      type: String,
	      default: 'default',
	      validator: function validator(value) {
	        return ['default', 'compact'].indexOf(value) > -1;
	      }
	    },
	    small: {
	      type: Boolean,
	      default: false
	    },
	    size: {
	      type: String,
	      default: 'default',
	      validator: function validator(value) {
	        return ['default', 'small'].indexOf(value) > -1;
	      }
	    },
	    current: {
	      type: Number,
	      default: 1,
	      required: true,
	      validator: function validator(val) {
	        var positiveInteger = /^[1-9]+[0-9]*]*$/;
	        return positiveInteger.test(val);
	      }
	    },
	    limit: {
	      type: Number,
	      required: true
	    },
	    count: {
	      type: Number,
	      default: 0,
	      required: true
	    },
	    align: {
	      type: String,
	      default: 'left',
	      validator: function validator(val) {
	        return ['left', 'center', 'right'].includes(val);
	      }
	    },
	    limitList: {
	      type: Array,
	      default: function _default() {
	        return [10, 20, 50, 100];
	      }
	    },
	    showLimit: {
	      type: Boolean,
	      default: true
	    },
	    location: {
	      type: String,
	      default: 'right',
	      validator: function validator(val) {
	        return ['left', 'right'].includes(val);
	      }
	    },
	    showSelectionCount: Boolean,
	    selectionCount: {
	      type: Number,
	      default: 0
	    },
	    showTotalCount: Boolean,
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  data: function data() {
	    return {
	      pageSize: 5,
	      renderList: [],
	      curGroup: 1,
	      limitListTmp: [],
	      realityLimit: this.limit || 10,
	      toggle: false
	    };
	  },
	  computed: {
	    curLang: function curLang() {
	      var l = locale.getCurLang().bk.lang;
	      if (['zh', 'cn', 'zh-CN', 'zh-cn', 'zhCN', 'zhcn', 'zh-TW', 'zh-tw', 'zhTW', 'zhtw'].indexOf(l) > -1) {
	        return 'cn';
	      }
	      return 'en';
	    },
	    total: function total() {
	      return Math.ceil(this.count / this.realityLimit);
	    },
	    realityLocation: function realityLocation() {
	      if (this.align === 'left') {
	        return 'right';
	      }
	      if (this.align === 'right') {
	        return 'left';
	      }
	      return this.location;
	    }
	  },
	  watch: {
	    realityLimit: function realityLimit(val, oldVal) {
	      this.$emit('update:limit', val);
	      this.$emit('limit-change', val, oldVal);
	    },
	    current: function current(newVal) {
	      this.calcPageList(newVal);
	    },
	    total: function total(newVal) {
	      this.calcPageList(this.current);
	    },
	    limit: function limit(newVal) {
	      if (this.limitList.includes(newVal)) {
	        this.realityLimit = newVal;
	      } else {
	        this.realityLimit = this.limitList[0];
	      }
	    },
	    paginationIndex: function paginationIndex(newVal) {
	      this.realityLimit = newVal;
	    }
	  },
	  created: function created() {
	    this.limitListTmp = this.limitList.map(function (page) {
	      return {
	        id: page,
	        count: page
	      };
	    });
	    if (this.limitList.includes(this.limit)) {
	      this.realityLimit = this.limit;
	    } else {
	      this.realityLimit = this.limitList[0];
	    }
	    this.calcPageList(this.current);
	  },
	  methods: {
	    _array: function _array(size) {
	      return Array.apply(null, {
	        length: size
	      });
	    },
	    calcPageList: function calcPageList(current) {
	      var total = this.total;
	      var pageSize = this.pageSize;
	      var size = pageSize > total ? total : pageSize;
	      if (current >= size - 1) {
	        if (total - current > Math.floor(size / 2)) {
	          this.renderList = this._array(size).map(function (v, i) {
	            return i + current - Math.ceil(size / 2) + 1;
	          });
	        } else {
	          this.renderList = this._array(size).map(function (v, i) {
	            return total - i;
	          }).reverse();
	        }
	      } else {
	        this.renderList = this._array(size).map(function (v, i) {
	          return i + 1;
	        });
	      }
	    },
	    prevGroup: function prevGroup() {
	      var pageSize = this.pageSize;
	      var middlePage = this.renderList[Math.ceil(this.renderList.length / 2)];
	      if (middlePage - pageSize < 1) {
	        this.calcPageList(1);
	      } else {
	        this.calcPageList(middlePage - pageSize);
	      }
	      this.jumpToPage(this.renderList[Math.floor(this.renderList.length / 2)]);
	    },
	    nextGroup: function nextGroup() {
	      var pageSize = this.pageSize;
	      var total = this.total;
	      var middlePage = this.renderList[Math.ceil(this.renderList.length / 2)];
	      if (middlePage + pageSize > total) {
	        this.calcPageList(total);
	      } else {
	        this.calcPageList(middlePage + pageSize);
	      }
	      this.jumpToPage(this.renderList[Math.floor(this.renderList.length / 2)]);
	    },
	    prevPage: function prevPage() {
	      if (this.current !== 1) {
	        this.jumpToPage(this.current - 1);
	      }
	    },
	    nextPage: function nextPage() {
	      if (this.current !== this.total) {
	        this.jumpToPage(this.current + 1);
	      }
	    },
	    jumpToPage: function jumpToPage(page) {
	      this.$emit('update:current', page);
	      this.$emit('change', page);
	    }
	  }
	};

	/* script */
	var __vue_script__$c = script$c;
	/* template */

	var __vue_render__$e = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _vm.total > 0 ? _c('div', {
	    class: ['bk-page', "bk-page-align-" + _vm.align, {
	      'bk-page-compact': _vm.type === 'compact',
	      'bk-page-small': _vm.size === 'small'
	    }, _vm.extCls]
	  }, [_vm.showTotalCount ? _c('pagination-total-count') : _vm._e(), _vm.showLimit ? _c('div', {
	    class: ['bk-page-count', "bk-page-count-" + _vm.realityLocation, _vm.small && 'bk-page-count-small']
	  }, [_vm.curLang === 'cn' ? [_c('span', [_vm._v("æ¯é¡µ")]), _c('bk-select', {
	    class: {
	      'page-select-small': _vm.small && !_vm.toggle
	    },
	    attrs: {
	      "placeholder": "é¡µæ°",
	      "clearable": false,
	      "size": _vm.small ? 'small' : ''
	    },
	    on: {
	      "toggle": function toggle(value) {
	        return _vm.toggle = value;
	      }
	    },
	    model: {
	      value: _vm.realityLimit,
	      callback: function callback($$v) {
	        _vm.realityLimit = $$v;
	      },
	      expression: "realityLimit"
	    }
	  }, _vm._l(_vm.limitListTmp, function (p, index) {
	    return _c('bk-option', {
	      key: index,
	      attrs: {
	        "id": p.id,
	        "name": p.count
	      }
	    });
	  }), 1), _c('span', [_vm._v("æ¡")])] : [_c('bk-select', {
	    attrs: {
	      "placeholder": "page",
	      "clearable": false
	    },
	    model: {
	      value: _vm.realityLimit,
	      callback: function callback($$v) {
	        _vm.realityLimit = $$v;
	      },
	      expression: "realityLimit"
	    }
	  }, _vm._l(_vm.limitListTmp, function (p, index) {
	    return _c('bk-option', {
	      key: index,
	      attrs: {
	        "id": p.id,
	        "name": p.count + "/page"
	      }
	    });
	  }), 1)]], 2) : _vm._e(), _vm.showSelectionCount ? _c('pagination-selection-count') : _vm._e(), !_vm.small ? _c('ul', {
	    staticClass: "bk-page-list"
	  }, [_c('li', {
	    staticClass: "page-item",
	    class: {
	      disabled: _vm.current === 1
	    },
	    on: {
	      "click": _vm.prevPage
	    }
	  }, [_vm._m(0)]), _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.renderList[0] > 1,
	      expression: "renderList[0] > 1"
	    }],
	    staticClass: "page-item",
	    on: {
	      "click": function click($event) {
	        _vm.jumpToPage(1);
	      }
	    }
	  }, [_c('a', {
	    staticClass: "page-button",
	    attrs: {
	      "href": "javascript:void(0);"
	    }
	  }, [_vm._v("1")])]), _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.renderList[0] > 2 && _vm.current > 3,
	      expression: "renderList[0] > 2 && current > 3"
	    }],
	    class: ['page-item', {
	      'page-omit': _vm.type !== 'compact'
	    }],
	    on: {
	      "click": _vm.prevGroup
	    }
	  }, [_c('span', {
	    staticClass: "page-button"
	  }, [_vm._v("...")])]), _vm._l(_vm.renderList, function (item, index) {
	    return _c('li', {
	      key: index,
	      staticClass: "page-item",
	      class: {
	        'cur-page': item === _vm.current
	      },
	      on: {
	        "click": function click($event) {
	          _vm.jumpToPage(item);
	        }
	      }
	    }, [_c('a', {
	      staticClass: "page-button",
	      attrs: {
	        "href": "javascript:void(0);"
	      }
	    }, [_vm._v(_vm._s(item))])]);
	  }), _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.renderList[_vm.renderList.length - 1] < _vm.total - 1,
	      expression: "renderList[renderList.length - 1] < total - 1"
	    }],
	    class: ['page-item', {
	      'page-omit': _vm.type !== 'compact'
	    }],
	    on: {
	      "click": _vm.nextGroup
	    }
	  }, [_c('span', {
	    staticClass: "page-button"
	  }, [_vm._v("...")])]), _c('li', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.renderList[_vm.renderList.length - 1] !== _vm.total,
	      expression: "renderList[renderList.length - 1] !== total"
	    }],
	    staticClass: "page-item",
	    class: {
	      'cur-page': _vm.current === _vm.total
	    },
	    on: {
	      "click": function click($event) {
	        _vm.jumpToPage(_vm.total);
	      }
	    }
	  }, [_c('a', {
	    staticClass: "page-button",
	    attrs: {
	      "href": "javascript:void(0);"
	    }
	  }, [_vm._v(_vm._s(_vm.total))])]), _c('li', {
	    staticClass: "page-item",
	    class: {
	      disabled: _vm.current === _vm.total
	    },
	    on: {
	      "click": _vm.nextPage
	    }
	  }, [_vm._m(1)])], 2) : _c('small-jump', {
	    attrs: {
	      "current": _vm.current,
	      "total": _vm.total
	    },
	    on: {
	      "on-change": _vm.jumpToPage
	    }
	  })], 1) : _vm._e();
	};

	var __vue_staticRenderFns__$e = [function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('a', {
	    staticClass: "page-button",
	    attrs: {
	      "href": "javascript:void(0);"
	    }
	  }, [_c('i', {
	    staticClass: "bk-icon icon-angle-left"
	  })]);
	}, function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('a', {
	    staticClass: "page-button",
	    attrs: {
	      "href": "javascript:void(0);"
	    }
	  }, [_c('i', {
	    staticClass: "bk-icon icon-angle-right"
	  })]);
	}];
	/* style */

	var __vue_inject_styles__$e = undefined;
	/* scoped */

	var __vue_scope_id__$e = undefined;
	/* module identifier */

	var __vue_module_identifier__$e = undefined;
	/* functional template */

	var __vue_is_functional_template__$e = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$e = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$e,
	  staticRenderFns: __vue_staticRenderFns__$e
	}, __vue_inject_styles__$e, __vue_script__$c, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$e);

	var tableIdSeed = 1;
	var script$d = {
	  name: 'bk-table',
	  components: {
	    TableHeader: TableHeader,
	    TableFooter: TableFooter,
	    TableBody: TableBody,
	    BkPagination: __vue_component__$e
	  },
	  directives: {
	    Mousewheel: Mousewheel,
	    Bkloading: bkLoading
	  },
	  mixins: [locale.mixin],
	  props: {
	    data: {
	      type: Array,
	      default: function _default() {
	        return [];
	      }
	    },
	    size: {
	      type: String,
	      default: 'small',
	      validator: function validator(val) {
	        return ['small', 'medium', 'large'].includes(val);
	      }
	    },
	    height: [String, Number],
	    maxHeight: [String, Number],
	    fit: {
	      type: Boolean,
	      default: true
	    },
	    stripe: Boolean,
	    border: Boolean,
	    outerBorder: {
	      type: Boolean,
	      default: true
	    },
	    rowBorder: {
	      type: Boolean,
	      default: true
	    },
	    colBorder: Boolean,
	    rowKey: [String, Function],
	    context: {
	      type: Object,
	      default: function _default() {
	        return {};
	      }
	    },
	    showHeader: {
	      type: Boolean,
	      default: true
	    },
	    showSummary: Boolean,
	    sumText: String,
	    summaryMethod: Function,
	    rowClassName: [String, Function],
	    rowStyle: [Object, Function],
	    cellClassName: [String, Function],
	    cellStyle: [Object, Function],
	    headerBorder: {
	      type: Boolean,
	      default: false
	    },
	    headerRowClassName: [String, Function],
	    headerRowStyle: [Object, Function],
	    headerCellClassName: [String, Function],
	    headerCellStyle: [Object, Function],
	    highlightCurrentRow: Boolean,
	    currentRowKey: [String, Number],
	    emptyText: String,
	    emptyBlockClassName: String,
	    expandRowKeys: Array,
	    defaultExpandAll: Boolean,
	    defaultSort: Object,
	    spanMethod: Function,
	    selectOnIndeterminate: {
	      type: Boolean,
	      default: true
	    },
	    pagination: Object,
	    showPaginationInfo: {
	      type: Boolean,
	      default: true
	    },
	    autoScrollToTop: {
	      type: Boolean,
	      default: false
	    },
	    extCls: {
	      type: String,
	      default: ''
	    },
	    setting: {
	      type: Object,
	      default: function _default() {
	        return {
	          columns: []
	        };
	      },
	      validator: function validator(setting) {
	        return isArray$1(setting.columns);
	      }
	    },
	    cellAttributes: [Function, Object],
	    headerCellAttributes: [Function, Object],
	    virtualRender: {
	      type: [Object, Boolean],
	      default: false
	    },
	    scrollLoading: {
	      type: Object,
	      default: function _default() {
	        return {
	          size: 'mini',
	          isLoading: false
	        };
	      }
	    }
	  },
	  data: function data() {
	    var store = new TableStore(this, {
	      rowKey: this.rowKey,
	      defaultExpandAll: this.defaultExpandAll,
	      selectOnIndeterminate: this.selectOnIndeterminate
	    });
	    var layout = new TableLayout({
	      store: store,
	      table: this,
	      fit: this.fit,
	      showHeader: this.showHeader
	    });
	    return {
	      layout: layout,
	      store: store,
	      isHidden: false,
	      renderExpanded: null,
	      resizeProxyVisible: false,
	      resizeState: {
	        width: null,
	        height: null
	      },
	      isGroup: false,
	      scrollPosition: 'left',
	      scrollThrottle: false
	    };
	  },
	  computed: {
	    curLang: function curLang() {
	      var l = locale.getCurLang().bk.lang;
	      if (['zh', 'cn', 'zh-CN', 'zh-cn', 'zhCN', 'zhcn', 'zh-TW', 'zh-tw', 'zhTW', 'zhtw'].indexOf(l) > -1) {
	        return 'cn';
	      }
	      return 'en';
	    },
	    tableSize: function tableSize() {
	      return this.size;
	    },
	    tableBorder: function tableBorder() {
	      return this.border || this.rowBorder && this.colBorder;
	    },
	    tableRowBorder: function tableRowBorder() {
	      return this.border || this.rowBorder;
	    },
	    tableColBorder: function tableColBorder() {
	      return this.border || this.colBorder;
	    },
	    bodyWrapper: function bodyWrapper() {
	      return this.$refs.bodyWrapper;
	    },
	    shouldUpdateHeight: function shouldUpdateHeight() {
	      return this.height || this.maxHeight || this.fixedColumns.length > 0 || this.rightFixedColumns.length > 0;
	    },
	    selection: function selection() {
	      return this.store.states.selection;
	    },
	    columns: function columns() {
	      return this.store.states.columns;
	    },
	    tableData: function tableData() {
	      return this.store.states.data;
	    },
	    fixedColumns: function fixedColumns() {
	      return this.store.states.fixedColumns;
	    },
	    rightFixedColumns: function rightFixedColumns() {
	      return this.store.states.rightFixedColumns;
	    },
	    notOnlySetting: function notOnlySetting() {
	      return this.rightFixedColumns.some(function (column) {
	        return column.type !== 'setting';
	      });
	    },
	    bodyWidth: function bodyWidth() {
	      var _this$layout = this.layout,
	          bodyWidth = _this$layout.bodyWidth,
	          scrollY = _this$layout.scrollY,
	          gutterWidth = _this$layout.gutterWidth;
	      return bodyWidth ? bodyWidth - (scrollY ? gutterWidth : 0) + 'px' : '';
	    },
	    bodyHeight: function bodyHeight() {
	      if (this.height) {
	        return {
	          height: this.layout.bodyHeight ? this.layout.bodyHeight + 'px' : ''
	        };
	      } else if (this.maxHeight) {
	        return {
	          'max-height': (this.showHeader ? this.maxHeight - this.layout.headerHeight - this.layout.footerHeight - this.layout.paginationHeight : this.maxHeight - this.layout.footerHeight - this.layout.paginationHeight) + 'px'
	        };
	      }
	      return {};
	    },
	    fixedBodyHeight: function fixedBodyHeight() {
	      if (this.height) {
	        return {
	          height: this.layout.fixedBodyHeight ? this.layout.fixedBodyHeight + 'px' : ''
	        };
	      } else if (this.maxHeight) {
	        var maxHeight = this.layout.scrollX ? this.maxHeight - this.layout.gutterWidth : this.maxHeight;
	        if (this.showHeader) {
	          maxHeight -= this.layout.headerHeight;
	        }
	        maxHeight -= this.layout.footerHeight;
	        maxHeight -= this.layout.paginationHeight;
	        return {
	          'max-height': maxHeight + 'px'
	        };
	      }
	      return {};
	    },
	    fixedHeight: function fixedHeight() {
	      if (this.maxHeight) {
	        if (this.showSummary) {
	          return {
	            bottom: this.layout.paginationHeight + 'px'
	          };
	        }
	        return {
	          bottom: (this.layout.scrollX && this.data.length ? this.layout.gutterWidth + this.layout.paginationHeight : this.layout.paginationHeight) + 'px'
	        };
	      } else {
	        if (this.showSummary) {
	          return {
	            height: this.layout.tableHeight ? this.layout.tableHeight + 'px' : ''
	          };
	        }
	        return {
	          height: this.layout.viewportHeight ? this.layout.viewportHeight + 'px' : ''
	        };
	      }
	    },
	    rightFixedHeight: function rightFixedHeight() {
	      if (this.notOnlySetting) {
	        return this.fixedHeight;
	      }
	      return {
	        height: this.layout.headerHeight + 'px'
	      };
	    },
	    showPagination: function showPagination() {
	      return this.data.length && this.pagination && this.pagination.count > 0;
	    },
	    showSelectionCount: function showSelectionCount() {
	      return this.store.states._columns.some(function (column) {
	        return column.type === 'selection';
	      });
	    },
	    isVirtualRender: function isVirtualRender() {
	      var prop = this.virtualRender;
	      return typeof prop === 'boolean' ? prop : _typeof(prop) === 'object' ? !prop.disabled : false;
	    }
	  },
	  watch: {
	    height: {
	      immediate: true,
	      handler: function handler(value) {
	        this.layout.setHeight(value);
	      }
	    },
	    maxHeight: {
	      immediate: true,
	      handler: function handler(value) {
	        this.layout.setMaxHeight(value);
	      }
	    },
	    currentRowKey: function currentRowKey(newVal) {
	      this.store.setCurrentRowKey(newVal);
	    },
	    data: {
	      immediate: true,
	      handler: function handler(value) {
	        var _this = this;
	        this.store.commit('setData', value);
	        if (this.$ready) {
	          this.$nextTick(function () {
	            _this.doLayout();
	          });
	        }
	      }
	    },
	    expandRowKeys: {
	      immediate: true,
	      handler: function handler(newVal) {
	        if (newVal) {
	          this.store.setExpandRowKeys(newVal);
	        }
	      }
	    }
	  },
	  created: function created() {
	    var _this2 = this;
	    this.tableId = 'bk-table-' + tableIdSeed++;
	    this.debouncedUpdateLayout = debounce(50, function () {
	      return _this2.doLayout();
	    });
	  },
	  mounted: function mounted() {
	    var _this3 = this;
	    this.bindEvents();
	    this.store.updateColumns();
	    this.doLayout();
	    this.resizeState = {
	      width: this.$el.offsetWidth,
	      height: this.$el.offsetHeight
	    };
	    this.store.states.columns.forEach(function (column) {
	      if (column.filteredValue && column.filteredValue.length) {
	        _this3.store.commit('filterChange', {
	          column: column,
	          values: column.filteredValue,
	          silent: true
	        });
	      }
	    });
	    this.$ready = true;
	  },
	  beforeDestroy: function beforeDestroy() {
	    this.$destroyed = true;
	    if (this.resizeListener) removeResizeListener(this.$el, this.resizeListener);
	  },
	  methods: {
	    setCurrentRow: function setCurrentRow(row) {
	      this.store.commit('setCurrentRow', row);
	    },
	    toggleRowSelection: function toggleRowSelection(row, selected) {
	      this.store.toggleRowSelection(row, selected);
	      this.store.updateAllSelected();
	    },
	    toggleRowExpansion: function toggleRowExpansion(row, expanded) {
	      this.store.toggleRowExpansion(row, expanded);
	    },
	    clearSelection: function clearSelection() {
	      this.store.clearSelection();
	    },
	    clearFilter: function clearFilter() {
	      this.store.clearFilter();
	    },
	    clearSort: function clearSort() {
	      this.store.clearSort();
	    },
	    handleMouseLeave: function handleMouseLeave() {
	      this.store.commit('setHoverRow', null);
	      if (this.hoverState) this.hoverState = null;
	    },
	    updateScrollY: function updateScrollY() {
	      this.layout.updateScrollY();
	      this.layout.updateColumnsWidth();
	    },
	    handleFixedMousewheel: function handleFixedMousewheel(event, data) {
	      var bodyWrapper = this.bodyWrapper;
	      if (Math.abs(data.spinY) > 0) {
	        var currentScrollTop = bodyWrapper.scrollTop;
	        if (data.pixelY < 0 && currentScrollTop !== 0) {
	          event.preventDefault();
	        }
	        if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
	          event.preventDefault();
	        }
	        bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
	      } else {
	        bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
	      }
	    },
	    handleHeaderFooterMousewheel: function handleHeaderFooterMousewheel(event, data) {
	      var pixelX = data.pixelX,
	          pixelY = data.pixelY;
	      if (Math.abs(pixelX) >= Math.abs(pixelY)) {
	        event.preventDefault();
	        this.bodyWrapper.scrollLeft += data.pixelX / 5;
	      }
	    },
	    handlePageChange: function handlePageChange(page) {
	      this.autoScrollToTop && this.scrollToTop();
	      this.$emit('page-change', page);
	    },
	    handlePageLimitChange: function handlePageLimitChange(currentLimit, prevLimit) {
	      this.autoScrollToTop && this.scrollToTop();
	      this.$emit('page-limit-change', currentLimit, prevLimit);
	    },
	    scrollToTop: function scrollToTop() {
	      this.$refs.bodyWrapper.scrollTo({
	        top: 0
	      });
	    },
	    bindEvents: function bindEvents() {
	      var _this$$refs = this.$refs,
	          headerWrapper = _this$$refs.headerWrapper,
	          footerWrapper = _this$$refs.footerWrapper,
	          tableHeader = _this$$refs.tableHeader,
	          bodyWrapper = _this$$refs.bodyWrapper;
	      var refs = this.$refs;
	      var self = this;
	      this.bodyWrapper.addEventListener('scroll', function () {
	        var _this4 = this;
	        if (headerWrapper) {
	          headerWrapper.scrollLeft = this.scrollLeft;
	          values$1(tableHeader.filterPanels).forEach(function (filterPanel) {
	            filterPanel.instance && filterPanel.instance.hide(0);
	          });
	        }
	        if (footerWrapper) footerWrapper.scrollLeft = this.scrollLeft;
	        if (refs.fixedBodyWrapper) refs.fixedBodyWrapper.scrollTop = this.scrollTop;
	        if (refs.rightFixedBodyWrapper) refs.rightFixedBodyWrapper.scrollTop = this.scrollTop;
	        var maxScrollLeftPosition = this.scrollWidth - this.offsetWidth - 1;
	        var scrollLeft = this.scrollLeft;
	        if (scrollLeft >= maxScrollLeftPosition) {
	          self.scrollPosition = 'right';
	        } else if (scrollLeft === 0) {
	          self.scrollPosition = 'left';
	        } else {
	          self.scrollPosition = 'middle';
	        }
	        if (self.scrollLoading.isLoading) return;
	        if (this.scrollThrottle) return;
	        this.scrollThrottle = true;
	        setTimeout(function () {
	          _this4.scrollThrottle = false;
	          if (bodyWrapper.scrollHeight - bodyWrapper.offsetHeight - bodyWrapper.scrollTop < 40) {
	            self.$emit('scroll-end');
	          }
	        }, 500);
	      });
	      if (this.fit) {
	        addResizeListener(this.$el, this.resizeListener);
	      }
	    },
	    resizeListener: function resizeListener() {
	      if (!this.$ready) return;
	      var shouldUpdateLayout = false;
	      var el = this.$el;
	      var _this$resizeState = this.resizeState,
	          oldWidth = _this$resizeState.width,
	          oldHeight = _this$resizeState.height;
	      var width = el.offsetWidth;
	      if (oldWidth !== width) {
	        shouldUpdateLayout = true;
	      }
	      var height = el.offsetHeight;
	      if ((this.height || this.shouldUpdateHeight) && oldHeight !== height) {
	        shouldUpdateLayout = true;
	      }
	      if (shouldUpdateLayout) {
	        this.resizeState.width = width;
	        this.resizeState.height = height;
	        this.doLayout();
	      }
	    },
	    doLayout: function doLayout() {
	      if (this.$destroyed) return;
	      if (this.shouldUpdateHeight) {
	        this.layout.updateElsHeight();
	      }
	      this.layout.updateColumnsWidth();
	    },
	    sort: function sort(prop, order) {
	      this.store.commit('sort', {
	        prop: prop,
	        order: order
	      });
	    },
	    toggleAllSelection: function toggleAllSelection() {
	      this.store.commit('toggleAllSelection');
	    }
	  }
	};

	/* script */
	var __vue_script__$d = script$d;
	/* template */

	var __vue_render__$f = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-table",
	    class: [{
	      'bk-table-fit': _vm.fit,
	      'bk-table-striped': _vm.stripe,
	      'bk-table-border': _vm.tableBorder || _vm.isGroup,
	      'bk-table-outer-border': _vm.outerBorder,
	      'bk-table-linear': !(_vm.tableBorder || _vm.outerBorder || _vm.isGroup),
	      'bk-table-row-border': _vm.tableRowBorder,
	      'bk-table-col-border': _vm.tableColBorder,
	      'bk-table-hidden': _vm.isHidden,
	      'bk-table-group': _vm.isGroup,
	      'bk-table-fluid-height': _vm.maxHeight,
	      'bk-table-scrollable-x': _vm.layout.scrollX,
	      'bk-table-scrollable-y': _vm.layout.scrollY,
	      'bk-table-enable-row-transition': (_vm.store.states.data || []).length !== 0 && (_vm.store.states.data || []).length < 100
	    }, _vm.tableSize ? "bk-table-" + _vm.tableSize : '', _vm.extCls],
	    on: {
	      "mouseleave": function mouseleave($event) {
	        _vm.handleMouseLeave($event);
	      }
	    }
	  }, [_c('div', {
	    ref: "hiddenColumns",
	    staticClass: "hidden-columns"
	  }, [_vm._t("default")], 2), _vm.showHeader ? _c('div', {
	    directives: [{
	      name: "mousewheel",
	      rawName: "v-mousewheel",
	      value: _vm.handleHeaderFooterMousewheel,
	      expression: "handleHeaderFooterMousewheel"
	    }],
	    ref: "headerWrapper",
	    staticClass: "bk-table-header-wrapper"
	  }, [_c('table-header', {
	    ref: "tableHeader",
	    style: {
	      width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
	    },
	    attrs: {
	      "store": _vm.store,
	      "border": _vm.headerBorder,
	      "default-sort": _vm.defaultSort
	    }
	  }, [_c('template', {
	    slot: "prepend"
	  }, [_vm._t("prepend")], 2)], 2)], 1) : _vm._e(), _c('div', {
	    ref: "bodyWrapper",
	    staticClass: "bk-table-body-wrapper",
	    class: [_vm.layout.scrollX ? "is-scrolling-" + _vm.scrollPosition : 'is-scrolling-none'],
	    style: [_vm.bodyHeight]
	  }, [_c('table-body', {
	    ref: "tableBody",
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "context": _vm.context,
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle,
	      "highlight": _vm.highlightCurrentRow
	    }
	  }), !_vm.data || _vm.data.length === 0 || _vm.store.states.data.length === 0 ? _c('div', {
	    ref: "emptyBlock",
	    class: ['bk-table-empty-block', _vm.emptyBlockClassName],
	    style: {
	      width: _vm.bodyWidth
	    }
	  }, [_c('span', {
	    staticClass: "bk-table-empty-text"
	  }, [_vm._t("empty", [_c('i', {
	    staticClass: "bk-table-empty-icon bk-icon icon-empty"
	  }), _c('div', [_vm._v(_vm._s(_vm.emptyText || _vm.t('bk.table.emptyText')))])])], 2)]) : _vm._e(), _vm.$slots.append ? _c('div', {
	    ref: "appendWrapper",
	    staticClass: "bk-table-append-wrapper"
	  }, [_vm._t("append")], 2) : _vm._e()], 1), _vm.showSummary ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.data && _vm.data.length > 0,
	      expression: "data && data.length > 0"
	    }, {
	      name: "mousewheel",
	      rawName: "v-mousewheel",
	      value: _vm.handleHeaderFooterMousewheel,
	      expression: "handleHeaderFooterMousewheel"
	    }],
	    ref: "footerWrapper",
	    staticClass: "bk-table-footer-wrapper"
	  }, [_c('table-footer', {
	    style: {
	      width: _vm.layout.bodyWidth ? _vm.layout.bodyWidth + 'px' : ''
	    },
	    attrs: {
	      "store": _vm.store,
	      "border": _vm.tableBorder,
	      "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "default-sort": _vm.defaultSort
	    }
	  })], 1) : _vm._e(), _vm.fixedColumns.length > 0 ? _c('div', {
	    directives: [{
	      name: "mousewheel",
	      rawName: "v-mousewheel",
	      value: _vm.handleFixedMousewheel,
	      expression: "handleFixedMousewheel"
	    }],
	    ref: "fixedWrapper",
	    staticClass: "bk-table-fixed",
	    style: [{
	      width: _vm.layout.fixedWidth ? _vm.layout.fixedWidth + 'px' : ''
	    }, _vm.fixedHeight]
	  }, [_vm.showHeader ? _c('div', {
	    ref: "fixedHeaderWrapper",
	    staticClass: "bk-table-fixed-header-wrapper"
	  }, [_c('table-header', {
	    ref: "fixedTableHeader",
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "left",
	      "border": _vm.headerBorder,
	      "store": _vm.store
	    }
	  }, [_c('template', {
	    slot: "prepend"
	  }, [_vm._t("prepend")], 2)], 2)], 1) : _vm._e(), _c('div', {
	    ref: "fixedBodyWrapper",
	    staticClass: "bk-table-fixed-body-wrapper",
	    style: [{
	      top: _vm.layout.headerHeight + 'px'
	    }, _vm.fixedBodyHeight]
	  }, [_c('table-body', {
	    ref: "leftTableBody",
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "left",
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "highlight": _vm.highlightCurrentRow,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle
	    }
	  }), _vm.$slots.append ? _c('div', {
	    staticClass: "bk-table-append-gutter",
	    style: {
	      height: _vm.layout.appendHeight + 'px'
	    }
	  }) : _vm._e()], 1), _vm.showSummary ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.data && _vm.data.length > 0,
	      expression: "data && data.length > 0"
	    }],
	    ref: "fixedFooterWrapper",
	    staticClass: "bk-table-fixed-footer-wrapper"
	  }, [_c('table-footer', {
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "left",
	      "border": _vm.tableBorder,
	      "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "store": _vm.store
	    }
	  })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c('div', {
	    directives: [{
	      name: "mousewheel",
	      rawName: "v-mousewheel",
	      value: _vm.handleFixedMousewheel,
	      expression: "handleFixedMousewheel"
	    }],
	    ref: "rightFixedWrapper",
	    staticClass: "bk-table-fixed-right",
	    style: [{
	      width: _vm.layout.rightFixedWidth ? _vm.layout.rightFixedWidth + 'px' : '',
	      right: _vm.layout.scrollY ? (_vm.tableBorder ? _vm.layout.gutterWidth : _vm.layout.gutterWidth || 0) + 'px' : ''
	    }, _vm.rightFixedHeight]
	  }, [_vm.showHeader ? _c('div', {
	    ref: "rightFixedHeaderWrapper",
	    staticClass: "bk-table-fixed-header-wrapper"
	  }, [_c('table-header', {
	    ref: "rightFixedTableHeader",
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "right",
	      "border": _vm.headerBorder,
	      "store": _vm.store
	    }
	  })], 1) : _vm._e(), _vm.notOnlySetting ? _c('div', {
	    ref: "rightFixedBodyWrapper",
	    staticClass: "bk-table-fixed-body-wrapper",
	    style: [{
	      top: _vm.layout.headerHeight + 'px'
	    }, _vm.fixedBodyHeight]
	  }, [_c('table-body', {
	    ref: "rightTableBody",
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "right",
	      "store": _vm.store,
	      "stripe": _vm.stripe,
	      "row-class-name": _vm.rowClassName,
	      "row-style": _vm.rowStyle,
	      "highlight": _vm.highlightCurrentRow
	    }
	  })], 1) : _vm._e(), _vm.showSummary ? _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.data && _vm.data.length > 0,
	      expression: "data && data.length > 0"
	    }],
	    ref: "rightFixedFooterWrapper",
	    staticClass: "bk-table-fixed-footer-wrapper"
	  }, [_c('table-footer', {
	    style: {
	      width: _vm.bodyWidth
	    },
	    attrs: {
	      "fixed": "right",
	      "border": _vm.tableBorder,
	      "sum-text": _vm.sumText || _vm.t('bk.table.sumText'),
	      "summary-method": _vm.summaryMethod,
	      "store": _vm.store
	    }
	  })], 1) : _vm._e()]) : _vm._e(), _vm.rightFixedColumns.length > 0 ? _c('div', {
	    ref: "rightFixedPatch",
	    staticClass: "bk-table-fixed-right-patch",
	    style: {
	      width: _vm.layout.scrollY ? _vm.layout.gutterWidth + 'px' : '0',
	      height: _vm.layout.headerHeight + 'px'
	    }
	  }) : _vm._e(), _c('div', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.resizeProxyVisible,
	      expression: "resizeProxyVisible"
	    }],
	    ref: "resizeProxy",
	    staticClass: "bk-table-column-resize-proxy"
	  }), _vm.showPagination ? _c('div', {
	    ref: "paginationWrapper",
	    staticClass: "bk-table-pagination-wrapper"
	  }, [_vm.pagination ? _c('bk-pagination', _vm._b({
	    staticClass: "bk-table-pagination",
	    attrs: {
	      "size": "small",
	      "align": "right",
	      "show-total-count": _vm.showPaginationInfo,
	      "show-selection-count": _vm.showSelectionCount,
	      "selection-count": _vm.store.states.selection.length
	    },
	    on: {
	      "change": _vm.handlePageChange,
	      "limit-change": _vm.handlePageLimitChange
	    }
	  }, 'bk-pagination', _vm.pagination, false)) : _vm._e()], 1) : _vm._e(), _vm.scrollLoading.isLoading ? _c('div', {
	    directives: [{
	      name: "bkloading",
	      rawName: "v-bkloading",
	      value: _vm.scrollLoading,
	      expression: "scrollLoading"
	    }],
	    staticClass: "bk-table-bottom-loading"
	  }) : _vm._e()]);
	};

	var __vue_staticRenderFns__$f = [];
	/* style */

	var __vue_inject_styles__$f = undefined;
	/* scoped */

	var __vue_scope_id__$f = undefined;
	/* module identifier */

	var __vue_module_identifier__$f = undefined;
	/* functional template */

	var __vue_is_functional_template__$f = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$f = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$f,
	  staticRenderFns: __vue_staticRenderFns__$f
	}, __vue_inject_styles__$f, __vue_script__$d, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

	setInstaller(__vue_component__$f);

	exports.default = __vue_component__$f;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
