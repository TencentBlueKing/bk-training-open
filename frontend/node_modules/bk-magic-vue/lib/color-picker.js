(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('tinycolor2')) :
	typeof define === 'function' && define.amd ? define(['exports', 'vue', 'tinycolor2'], factory) :
	(global = global || self, factory(global.library = {}, global.Vue, global.tinycolor));
}(this, function (exports, Vue, tinycolor) { 'use strict';

	Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;
	tinycolor = tinycolor && tinycolor.hasOwnProperty('default') ? tinycolor['default'] : tinycolor;

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var _global = createCommonjsModule(function (module) {
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  : Function('return this')();
	if (typeof __g == 'number') __g = global;
	});

	var _core = createCommonjsModule(function (module) {
	var core = module.exports = { version: '2.6.12' };
	if (typeof __e == 'number') __e = core;
	});
	var _core_1 = _core.version;

	var _aFunction = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};

	var _ctx = function (fn, that, length) {
	  _aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function () {
	    return fn.apply(that, arguments);
	  };
	};

	var _isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	var _anObject = function (it) {
	  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};

	var _fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};

	var _descriptors = !_fails(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});

	var document$1 = _global.document;
	var is = _isObject(document$1) && _isObject(document$1.createElement);
	var _domCreate = function (it) {
	  return is ? document$1.createElement(it) : {};
	};

	var _ie8DomDefine = !_descriptors && !_fails(function () {
	  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;
	});

	var _toPrimitive = function (it, S) {
	  if (!_isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var dP = Object.defineProperty;
	var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  _anObject(O);
	  P = _toPrimitive(P, true);
	  _anObject(Attributes);
	  if (_ie8DomDefine) try {
	    return dP(O, P, Attributes);
	  } catch (e) {  }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};
	var _objectDp = {
		f: f
	};

	var _propertyDesc = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var _hide = _descriptors ? function (object, key, value) {
	  return _objectDp.f(object, key, _propertyDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var _has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var PROTOTYPE = 'prototype';
	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && _has(exports, key)) continue;
	    out = own ? target[key] : source[key];
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    : IS_BIND && own ? _ctx(out, _global)
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);
	    }
	  }
	};
	$export.F = 1;
	$export.G = 2;
	$export.S = 4;
	$export.P = 8;
	$export.B = 16;
	$export.W = 32;
	$export.U = 64;
	$export.R = 128;
	var _export = $export;

	var toString = {}.toString;
	var _cof = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var _isArray = Array.isArray || function isArray(arg) {
	  return _cof(arg) == 'Array';
	};

	_export(_export.S, 'Array', { isArray: _isArray });

	var isArray = _core.Array.isArray;

	var isArray$1 = isArray;

	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
	var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
	var timeoutDuration = 0;
	for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
	  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
	    timeoutDuration = 1;
	    break;
	  }
	}
	function microtaskDebounce(fn) {
	  var called = false;
	  return function () {
	    if (called) {
	      return;
	    }
	    called = true;
	    window.Promise.resolve().then(function () {
	      called = false;
	      fn();
	    });
	  };
	}
	function taskDebounce(fn) {
	  var scheduled = false;
	  return function () {
	    if (!scheduled) {
	      scheduled = true;
	      setTimeout(function () {
	        scheduled = false;
	        fn();
	      }, timeoutDuration);
	    }
	  };
	}
	var supportsMicroTasks = isBrowser && window.Promise;
	var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
	function isFunction(functionToCheck) {
	  var getType = {};
	  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
	}
	function getStyleComputedProperty(element, property) {
	  if (element.nodeType !== 1) {
	    return [];
	  }
	  var window = element.ownerDocument.defaultView;
	  var css = window.getComputedStyle(element, null);
	  return property ? css[property] : css;
	}
	function getParentNode(element) {
	  if (element.nodeName === 'HTML') {
	    return element;
	  }
	  return element.parentNode || element.host;
	}
	function getScrollParent(element) {
	  if (!element) {
	    return document.body;
	  }
	  switch (element.nodeName) {
	    case 'HTML':
	    case 'BODY':
	      return element.ownerDocument.body;
	    case '#document':
	      return element.body;
	  }
	  var _getStyleComputedProp = getStyleComputedProperty(element),
	      overflow = _getStyleComputedProp.overflow,
	      overflowX = _getStyleComputedProp.overflowX,
	      overflowY = _getStyleComputedProp.overflowY;
	  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
	    return element;
	  }
	  return getScrollParent(getParentNode(element));
	}
	var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
	var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
	function isIE(version) {
	  if (version === 11) {
	    return isIE11;
	  }
	  if (version === 10) {
	    return isIE10;
	  }
	  return isIE11 || isIE10;
	}
	function getOffsetParent(element) {
	  if (!element) {
	    return document.documentElement;
	  }
	  var noOffsetParent = isIE(10) ? document.body : null;
	  var offsetParent = element.offsetParent || null;
	  while (offsetParent === noOffsetParent && element.nextElementSibling) {
	    offsetParent = (element = element.nextElementSibling).offsetParent;
	  }
	  var nodeName = offsetParent && offsetParent.nodeName;
	  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
	    return element ? element.ownerDocument.documentElement : document.documentElement;
	  }
	  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
	    return getOffsetParent(offsetParent);
	  }
	  return offsetParent;
	}
	function isOffsetContainer(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY') {
	    return false;
	  }
	  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
	}
	function getRoot(node) {
	  if (node.parentNode !== null) {
	    return getRoot(node.parentNode);
	  }
	  return node;
	}
	function findCommonOffsetParent(element1, element2) {
	  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
	    return document.documentElement;
	  }
	  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
	  var start = order ? element1 : element2;
	  var end = order ? element2 : element1;
	  var range = document.createRange();
	  range.setStart(start, 0);
	  range.setEnd(end, 0);
	  var commonAncestorContainer = range.commonAncestorContainer;
	  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
	    if (isOffsetContainer(commonAncestorContainer)) {
	      return commonAncestorContainer;
	    }
	    return getOffsetParent(commonAncestorContainer);
	  }
	  var element1root = getRoot(element1);
	  if (element1root.host) {
	    return findCommonOffsetParent(element1root.host, element2);
	  } else {
	    return findCommonOffsetParent(element1, getRoot(element2).host);
	  }
	}
	function getScroll(element) {
	  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
	  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    var html = element.ownerDocument.documentElement;
	    var scrollingElement = element.ownerDocument.scrollingElement || html;
	    return scrollingElement[upperSide];
	  }
	  return element[upperSide];
	}
	function includeScroll(rect, element) {
	  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var scrollTop = getScroll(element, 'top');
	  var scrollLeft = getScroll(element, 'left');
	  var modifier = subtract ? -1 : 1;
	  rect.top += scrollTop * modifier;
	  rect.bottom += scrollTop * modifier;
	  rect.left += scrollLeft * modifier;
	  rect.right += scrollLeft * modifier;
	  return rect;
	}
	function getBordersSize(styles, axis) {
	  var sideA = axis === 'x' ? 'Left' : 'Top';
	  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
	  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
	}
	function getSize(axis, body, html, computedStyle) {
	  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
	}
	function getWindowSizes(document) {
	  var body = document.body;
	  var html = document.documentElement;
	  var computedStyle = isIE(10) && getComputedStyle(html);
	  return {
	    height: getSize('Height', body, html, computedStyle),
	    width: getSize('Width', body, html, computedStyle)
	  };
	}
	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};
	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();
	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	};
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	function getClientRect(offsets) {
	  return _extends({}, offsets, {
	    right: offsets.left + offsets.width,
	    bottom: offsets.top + offsets.height
	  });
	}
	function getBoundingClientRect(element) {
	  var rect = {};
	  try {
	    if (isIE(10)) {
	      rect = element.getBoundingClientRect();
	      var scrollTop = getScroll(element, 'top');
	      var scrollLeft = getScroll(element, 'left');
	      rect.top += scrollTop;
	      rect.left += scrollLeft;
	      rect.bottom += scrollTop;
	      rect.right += scrollLeft;
	    } else {
	      rect = element.getBoundingClientRect();
	    }
	  } catch (e) {}
	  var result = {
	    left: rect.left,
	    top: rect.top,
	    width: rect.right - rect.left,
	    height: rect.bottom - rect.top
	  };
	  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
	  var width = sizes.width || element.clientWidth || result.right - result.left;
	  var height = sizes.height || element.clientHeight || result.bottom - result.top;
	  var horizScrollbar = element.offsetWidth - width;
	  var vertScrollbar = element.offsetHeight - height;
	  if (horizScrollbar || vertScrollbar) {
	    var styles = getStyleComputedProperty(element);
	    horizScrollbar -= getBordersSize(styles, 'x');
	    vertScrollbar -= getBordersSize(styles, 'y');
	    result.width -= horizScrollbar;
	    result.height -= vertScrollbar;
	  }
	  return getClientRect(result);
	}
	function getOffsetRectRelativeToArbitraryNode(children, parent) {
	  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	  var isIE10 = isIE(10);
	  var isHTML = parent.nodeName === 'HTML';
	  var childrenRect = getBoundingClientRect(children);
	  var parentRect = getBoundingClientRect(parent);
	  var scrollParent = getScrollParent(children);
	  var styles = getStyleComputedProperty(parent);
	  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
	  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
	  if (fixedPosition && isHTML) {
	    parentRect.top = Math.max(parentRect.top, 0);
	    parentRect.left = Math.max(parentRect.left, 0);
	  }
	  var offsets = getClientRect({
	    top: childrenRect.top - parentRect.top - borderTopWidth,
	    left: childrenRect.left - parentRect.left - borderLeftWidth,
	    width: childrenRect.width,
	    height: childrenRect.height
	  });
	  offsets.marginTop = 0;
	  offsets.marginLeft = 0;
	  if (!isIE10 && isHTML) {
	    var marginTop = parseFloat(styles.marginTop, 10);
	    var marginLeft = parseFloat(styles.marginLeft, 10);
	    offsets.top -= borderTopWidth - marginTop;
	    offsets.bottom -= borderTopWidth - marginTop;
	    offsets.left -= borderLeftWidth - marginLeft;
	    offsets.right -= borderLeftWidth - marginLeft;
	    offsets.marginTop = marginTop;
	    offsets.marginLeft = marginLeft;
	  }
	  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
	    offsets = includeScroll(offsets, parent);
	  }
	  return offsets;
	}
	function getViewportOffsetRectRelativeToArtbitraryNode(element) {
	  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var html = element.ownerDocument.documentElement;
	  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
	  var width = Math.max(html.clientWidth, window.innerWidth || 0);
	  var height = Math.max(html.clientHeight, window.innerHeight || 0);
	  var scrollTop = !excludeScroll ? getScroll(html) : 0;
	  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
	  var offset = {
	    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
	    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
	    width: width,
	    height: height
	  };
	  return getClientRect(offset);
	}
	function isFixed(element) {
	  var nodeName = element.nodeName;
	  if (nodeName === 'BODY' || nodeName === 'HTML') {
	    return false;
	  }
	  if (getStyleComputedProperty(element, 'position') === 'fixed') {
	    return true;
	  }
	  var parentNode = getParentNode(element);
	  if (!parentNode) {
	    return false;
	  }
	  return isFixed(parentNode);
	}
	function getFixedPositionOffsetParent(element) {
	  if (!element || !element.parentElement || isIE()) {
	    return document.documentElement;
	  }
	  var el = element.parentElement;
	  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
	    el = el.parentElement;
	  }
	  return el || document.documentElement;
	}
	function getBoundaries(popper, reference, padding, boundariesElement) {
	  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
	  var boundaries = { top: 0, left: 0 };
	  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  if (boundariesElement === 'viewport') {
	    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
	  } else {
	    var boundariesNode = void 0;
	    if (boundariesElement === 'scrollParent') {
	      boundariesNode = getScrollParent(getParentNode(reference));
	      if (boundariesNode.nodeName === 'BODY') {
	        boundariesNode = popper.ownerDocument.documentElement;
	      }
	    } else if (boundariesElement === 'window') {
	      boundariesNode = popper.ownerDocument.documentElement;
	    } else {
	      boundariesNode = boundariesElement;
	    }
	    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
	    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
	      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
	          height = _getWindowSizes.height,
	          width = _getWindowSizes.width;
	      boundaries.top += offsets.top - offsets.marginTop;
	      boundaries.bottom = height + offsets.top;
	      boundaries.left += offsets.left - offsets.marginLeft;
	      boundaries.right = width + offsets.left;
	    } else {
	      boundaries = offsets;
	    }
	  }
	  padding = padding || 0;
	  var isPaddingNumber = typeof padding === 'number';
	  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
	  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
	  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
	  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
	  return boundaries;
	}
	function getArea(_ref) {
	  var width = _ref.width,
	      height = _ref.height;
	  return width * height;
	}
	function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
	  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	  if (placement.indexOf('auto') === -1) {
	    return placement;
	  }
	  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
	  var rects = {
	    top: {
	      width: boundaries.width,
	      height: refRect.top - boundaries.top
	    },
	    right: {
	      width: boundaries.right - refRect.right,
	      height: boundaries.height
	    },
	    bottom: {
	      width: boundaries.width,
	      height: boundaries.bottom - refRect.bottom
	    },
	    left: {
	      width: refRect.left - boundaries.left,
	      height: boundaries.height
	    }
	  };
	  var sortedAreas = Object.keys(rects).map(function (key) {
	    return _extends({
	      key: key
	    }, rects[key], {
	      area: getArea(rects[key])
	    });
	  }).sort(function (a, b) {
	    return b.area - a.area;
	  });
	  var filteredAreas = sortedAreas.filter(function (_ref2) {
	    var width = _ref2.width,
	        height = _ref2.height;
	    return width >= popper.clientWidth && height >= popper.clientHeight;
	  });
	  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
	  var variation = placement.split('-')[1];
	  return computedPlacement + (variation ? '-' + variation : '');
	}
	function getReferenceOffsets(state, popper, reference) {
	  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
	  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
	}
	function getOuterSizes(element) {
	  var window = element.ownerDocument.defaultView;
	  var styles = window.getComputedStyle(element);
	  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
	  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
	  var result = {
	    width: element.offsetWidth + y,
	    height: element.offsetHeight + x
	  };
	  return result;
	}
	function getOppositePlacement(placement) {
	  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
	  return placement.replace(/left|right|bottom|top/g, function (matched) {
	    return hash[matched];
	  });
	}
	function getPopperOffsets(popper, referenceOffsets, placement) {
	  placement = placement.split('-')[0];
	  var popperRect = getOuterSizes(popper);
	  var popperOffsets = {
	    width: popperRect.width,
	    height: popperRect.height
	  };
	  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
	  var mainSide = isHoriz ? 'top' : 'left';
	  var secondarySide = isHoriz ? 'left' : 'top';
	  var measurement = isHoriz ? 'height' : 'width';
	  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
	  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
	  if (placement === secondarySide) {
	    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
	  } else {
	    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
	  }
	  return popperOffsets;
	}
	function find(arr, check) {
	  if (Array.prototype.find) {
	    return arr.find(check);
	  }
	  return arr.filter(check)[0];
	}
	function findIndex(arr, prop, value) {
	  if (Array.prototype.findIndex) {
	    return arr.findIndex(function (cur) {
	      return cur[prop] === value;
	    });
	  }
	  var match = find(arr, function (obj) {
	    return obj[prop] === value;
	  });
	  return arr.indexOf(match);
	}
	function runModifiers(modifiers, data, ends) {
	  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
	  modifiersToRun.forEach(function (modifier) {
	    if (modifier['function']) {
	      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
	    }
	    var fn = modifier['function'] || modifier.fn;
	    if (modifier.enabled && isFunction(fn)) {
	      data.offsets.popper = getClientRect(data.offsets.popper);
	      data.offsets.reference = getClientRect(data.offsets.reference);
	      data = fn(data, modifier);
	    }
	  });
	  return data;
	}
	function update() {
	  if (this.state.isDestroyed) {
	    return;
	  }
	  var data = {
	    instance: this,
	    styles: {},
	    arrowStyles: {},
	    attributes: {},
	    flipped: false,
	    offsets: {}
	  };
	  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
	  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
	  data.originalPlacement = data.placement;
	  data.positionFixed = this.options.positionFixed;
	  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
	  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';
	  data = runModifiers(this.modifiers, data);
	  if (!this.state.isCreated) {
	    this.state.isCreated = true;
	    this.options.onCreate(data);
	  } else {
	    this.options.onUpdate(data);
	  }
	}
	function isModifierEnabled(modifiers, modifierName) {
	  return modifiers.some(function (_ref) {
	    var name = _ref.name,
	        enabled = _ref.enabled;
	    return enabled && name === modifierName;
	  });
	}
	function getSupportedPropertyName(property) {
	  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
	  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefix = prefixes[i];
	    var toCheck = prefix ? '' + prefix + upperProp : property;
	    if (typeof document.body.style[toCheck] !== 'undefined') {
	      return toCheck;
	    }
	  }
	  return null;
	}
	function destroy() {
	  this.state.isDestroyed = true;
	  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
	    this.popper.removeAttribute('x-placement');
	    this.popper.style.position = '';
	    this.popper.style.top = '';
	    this.popper.style.left = '';
	    this.popper.style.right = '';
	    this.popper.style.bottom = '';
	    this.popper.style.willChange = '';
	    this.popper.style[getSupportedPropertyName('transform')] = '';
	  }
	  this.disableEventListeners();
	  if (this.options.removeOnDestroy) {
	    this.popper.parentNode.removeChild(this.popper);
	  }
	  return this;
	}
	function getWindow(element) {
	  var ownerDocument = element.ownerDocument;
	  return ownerDocument ? ownerDocument.defaultView : window;
	}
	function attachToScrollParents(scrollParent, event, callback, scrollParents) {
	  var isBody = scrollParent.nodeName === 'BODY';
	  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
	  target.addEventListener(event, callback, { passive: true });
	  if (!isBody) {
	    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
	  }
	  scrollParents.push(target);
	}
	function setupEventListeners(reference, options, state, updateBound) {
	  state.updateBound = updateBound;
	  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
	  var scrollElement = getScrollParent(reference);
	  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
	  state.scrollElement = scrollElement;
	  state.eventsEnabled = true;
	  return state;
	}
	function enableEventListeners() {
	  if (!this.state.eventsEnabled) {
	    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
	  }
	}
	function removeEventListeners(reference, state) {
	  getWindow(reference).removeEventListener('resize', state.updateBound);
	  state.scrollParents.forEach(function (target) {
	    target.removeEventListener('scroll', state.updateBound);
	  });
	  state.updateBound = null;
	  state.scrollParents = [];
	  state.scrollElement = null;
	  state.eventsEnabled = false;
	  return state;
	}
	function disableEventListeners() {
	  if (this.state.eventsEnabled) {
	    cancelAnimationFrame(this.scheduleUpdate);
	    this.state = removeEventListeners(this.reference, this.state);
	  }
	}
	function isNumeric(n) {
	  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
	}
	function setStyles(element, styles) {
	  Object.keys(styles).forEach(function (prop) {
	    var unit = '';
	    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
	      unit = 'px';
	    }
	    element.style[prop] = styles[prop] + unit;
	  });
	}
	function setAttributes(element, attributes) {
	  Object.keys(attributes).forEach(function (prop) {
	    var value = attributes[prop];
	    if (value !== false) {
	      element.setAttribute(prop, attributes[prop]);
	    } else {
	      element.removeAttribute(prop);
	    }
	  });
	}
	function applyStyle(data) {
	  setStyles(data.instance.popper, data.styles);
	  setAttributes(data.instance.popper, data.attributes);
	  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
	    setStyles(data.arrowElement, data.arrowStyles);
	  }
	  return data;
	}
	function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
	  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
	  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
	  popper.setAttribute('x-placement', placement);
	  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });
	  return options;
	}
	function getRoundedOffsets(data, shouldRound) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var round = Math.round,
	      floor = Math.floor;
	  var noRound = function noRound(v) {
	    return v;
	  };
	  var referenceWidth = round(reference.width);
	  var popperWidth = round(popper.width);
	  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
	  var isVariation = data.placement.indexOf('-') !== -1;
	  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
	  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
	  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
	  var verticalToInteger = !shouldRound ? noRound : round;
	  return {
	    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
	    top: verticalToInteger(popper.top),
	    bottom: verticalToInteger(popper.bottom),
	    right: horizontalToInteger(popper.right)
	  };
	}
	var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
	function computeStyle(data, options) {
	  var x = options.x,
	      y = options.y;
	  var popper = data.offsets.popper;
	  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'applyStyle';
	  }).gpuAcceleration;
	  if (legacyGpuAccelerationOption !== undefined) {
	    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
	  }
	  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
	  var offsetParent = getOffsetParent(data.instance.popper);
	  var offsetParentRect = getBoundingClientRect(offsetParent);
	  var styles = {
	    position: popper.position
	  };
	  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
	  var sideA = x === 'bottom' ? 'top' : 'bottom';
	  var sideB = y === 'right' ? 'left' : 'right';
	  var prefixedProperty = getSupportedPropertyName('transform');
	  var left = void 0,
	      top = void 0;
	  if (sideA === 'bottom') {
	    if (offsetParent.nodeName === 'HTML') {
	      top = -offsetParent.clientHeight + offsets.bottom;
	    } else {
	      top = -offsetParentRect.height + offsets.bottom;
	    }
	  } else {
	    top = offsets.top;
	  }
	  if (sideB === 'right') {
	    if (offsetParent.nodeName === 'HTML') {
	      left = -offsetParent.clientWidth + offsets.right;
	    } else {
	      left = -offsetParentRect.width + offsets.right;
	    }
	  } else {
	    left = offsets.left;
	  }
	  if (gpuAcceleration && prefixedProperty) {
	    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
	    styles[sideA] = 0;
	    styles[sideB] = 0;
	    styles.willChange = 'transform';
	  } else {
	    var invertTop = sideA === 'bottom' ? -1 : 1;
	    var invertLeft = sideB === 'right' ? -1 : 1;
	    styles[sideA] = top * invertTop;
	    styles[sideB] = left * invertLeft;
	    styles.willChange = sideA + ', ' + sideB;
	  }
	  var attributes = {
	    'x-placement': data.placement
	  };
	  data.attributes = _extends({}, attributes, data.attributes);
	  data.styles = _extends({}, styles, data.styles);
	  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
	  return data;
	}
	function isModifierRequired(modifiers, requestingName, requestedName) {
	  var requesting = find(modifiers, function (_ref) {
	    var name = _ref.name;
	    return name === requestingName;
	  });
	  var isRequired = !!requesting && modifiers.some(function (modifier) {
	    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
	  });
	  if (!isRequired) {
	    var _requesting = '`' + requestingName + '`';
	    var requested = '`' + requestedName + '`';
	    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
	  }
	  return isRequired;
	}
	function arrow(data, options) {
	  var _data$offsets$arrow;
	  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
	    return data;
	  }
	  var arrowElement = options.element;
	  if (typeof arrowElement === 'string') {
	    arrowElement = data.instance.popper.querySelector(arrowElement);
	    if (!arrowElement) {
	      return data;
	    }
	  } else {
	    if (!data.instance.popper.contains(arrowElement)) {
	      console.warn('WARNING: `arrow.element` must be child of its popper element!');
	      return data;
	    }
	  }
	  var placement = data.placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
	  var len = isVertical ? 'height' : 'width';
	  var sideCapitalized = isVertical ? 'Top' : 'Left';
	  var side = sideCapitalized.toLowerCase();
	  var altSide = isVertical ? 'left' : 'top';
	  var opSide = isVertical ? 'bottom' : 'right';
	  var arrowElementSize = getOuterSizes(arrowElement)[len];
	  if (reference[opSide] - arrowElementSize < popper[side]) {
	    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
	  }
	  if (reference[side] + arrowElementSize > popper[opSide]) {
	    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
	  }
	  data.offsets.popper = getClientRect(data.offsets.popper);
	  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
	  var css = getStyleComputedProperty(data.instance.popper);
	  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
	  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
	  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
	  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
	  data.arrowElement = arrowElement;
	  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
	  return data;
	}
	function getOppositeVariation(variation) {
	  if (variation === 'end') {
	    return 'start';
	  } else if (variation === 'start') {
	    return 'end';
	  }
	  return variation;
	}
	var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
	var validPlacements = placements.slice(3);
	function clockwise(placement) {
	  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	  var index = validPlacements.indexOf(placement);
	  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
	  return counter ? arr.reverse() : arr;
	}
	var BEHAVIORS = {
	  FLIP: 'flip',
	  CLOCKWISE: 'clockwise',
	  COUNTERCLOCKWISE: 'counterclockwise'
	};
	function flip(data, options) {
	  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
	    return data;
	  }
	  if (data.flipped && data.placement === data.originalPlacement) {
	    return data;
	  }
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
	  var placement = data.placement.split('-')[0];
	  var placementOpposite = getOppositePlacement(placement);
	  var variation = data.placement.split('-')[1] || '';
	  var flipOrder = [];
	  switch (options.behavior) {
	    case BEHAVIORS.FLIP:
	      flipOrder = [placement, placementOpposite];
	      break;
	    case BEHAVIORS.CLOCKWISE:
	      flipOrder = clockwise(placement);
	      break;
	    case BEHAVIORS.COUNTERCLOCKWISE:
	      flipOrder = clockwise(placement, true);
	      break;
	    default:
	      flipOrder = options.behavior;
	  }
	  flipOrder.forEach(function (step, index) {
	    if (placement !== step || flipOrder.length === index + 1) {
	      return data;
	    }
	    placement = data.placement.split('-')[0];
	    placementOpposite = getOppositePlacement(placement);
	    var popperOffsets = data.offsets.popper;
	    var refOffsets = data.offsets.reference;
	    var floor = Math.floor;
	    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
	    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
	    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
	    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
	    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
	    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
	    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
	    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
	    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
	    if (overlapsRef || overflowsBoundaries || flippedVariation) {
	      data.flipped = true;
	      if (overlapsRef || overflowsBoundaries) {
	        placement = flipOrder[index + 1];
	      }
	      if (flippedVariation) {
	        variation = getOppositeVariation(variation);
	      }
	      data.placement = placement + (variation ? '-' + variation : '');
	      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
	      data = runModifiers(data.instance.modifiers, data, 'flip');
	    }
	  });
	  return data;
	}
	function keepTogether(data) {
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var placement = data.placement.split('-')[0];
	  var floor = Math.floor;
	  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
	  var side = isVertical ? 'right' : 'bottom';
	  var opSide = isVertical ? 'left' : 'top';
	  var measurement = isVertical ? 'width' : 'height';
	  if (popper[side] < floor(reference[opSide])) {
	    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
	  }
	  if (popper[opSide] > floor(reference[side])) {
	    data.offsets.popper[opSide] = floor(reference[side]);
	  }
	  return data;
	}
	function toValue(str, measurement, popperOffsets, referenceOffsets) {
	  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
	  var value = +split[1];
	  var unit = split[2];
	  if (!value) {
	    return str;
	  }
	  if (unit.indexOf('%') === 0) {
	    var element = void 0;
	    switch (unit) {
	      case '%p':
	        element = popperOffsets;
	        break;
	      case '%':
	      case '%r':
	      default:
	        element = referenceOffsets;
	    }
	    var rect = getClientRect(element);
	    return rect[measurement] / 100 * value;
	  } else if (unit === 'vh' || unit === 'vw') {
	    var size = void 0;
	    if (unit === 'vh') {
	      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    } else {
	      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    }
	    return size / 100 * value;
	  } else {
	    return value;
	  }
	}
	function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
	  var offsets = [0, 0];
	  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
	  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
	    return frag.trim();
	  });
	  var divider = fragments.indexOf(find(fragments, function (frag) {
	    return frag.search(/,|\s/) !== -1;
	  }));
	  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
	    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
	  }
	  var splitRegex = /\s*,\s*|\s+/;
	  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
	  ops = ops.map(function (op, index) {
	    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
	    var mergeWithPrevious = false;
	    return op
	    .reduce(function (a, b) {
	      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
	        a[a.length - 1] = b;
	        mergeWithPrevious = true;
	        return a;
	      } else if (mergeWithPrevious) {
	        a[a.length - 1] += b;
	        mergeWithPrevious = false;
	        return a;
	      } else {
	        return a.concat(b);
	      }
	    }, [])
	    .map(function (str) {
	      return toValue(str, measurement, popperOffsets, referenceOffsets);
	    });
	  });
	  ops.forEach(function (op, index) {
	    op.forEach(function (frag, index2) {
	      if (isNumeric(frag)) {
	        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
	      }
	    });
	  });
	  return offsets;
	}
	function offset(data, _ref) {
	  var offset = _ref.offset;
	  var placement = data.placement,
	      _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var basePlacement = placement.split('-')[0];
	  var offsets = void 0;
	  if (isNumeric(+offset)) {
	    offsets = [+offset, 0];
	  } else {
	    offsets = parseOffset(offset, popper, reference, basePlacement);
	  }
	  if (basePlacement === 'left') {
	    popper.top += offsets[0];
	    popper.left -= offsets[1];
	  } else if (basePlacement === 'right') {
	    popper.top += offsets[0];
	    popper.left += offsets[1];
	  } else if (basePlacement === 'top') {
	    popper.left += offsets[0];
	    popper.top -= offsets[1];
	  } else if (basePlacement === 'bottom') {
	    popper.left += offsets[0];
	    popper.top += offsets[1];
	  }
	  data.popper = popper;
	  return data;
	}
	function preventOverflow(data, options) {
	  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
	  if (data.instance.reference === boundariesElement) {
	    boundariesElement = getOffsetParent(boundariesElement);
	  }
	  var transformProp = getSupportedPropertyName('transform');
	  var popperStyles = data.instance.popper.style;
	  var top = popperStyles.top,
	      left = popperStyles.left,
	      transform = popperStyles[transformProp];
	  popperStyles.top = '';
	  popperStyles.left = '';
	  popperStyles[transformProp] = '';
	  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
	  popperStyles.top = top;
	  popperStyles.left = left;
	  popperStyles[transformProp] = transform;
	  options.boundaries = boundaries;
	  var order = options.priority;
	  var popper = data.offsets.popper;
	  var check = {
	    primary: function primary(placement) {
	      var value = popper[placement];
	      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
	        value = Math.max(popper[placement], boundaries[placement]);
	      }
	      return defineProperty({}, placement, value);
	    },
	    secondary: function secondary(placement) {
	      var mainSide = placement === 'right' ? 'left' : 'top';
	      var value = popper[mainSide];
	      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
	        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
	      }
	      return defineProperty({}, mainSide, value);
	    }
	  };
	  order.forEach(function (placement) {
	    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
	    popper = _extends({}, popper, check[side](placement));
	  });
	  data.offsets.popper = popper;
	  return data;
	}
	function shift(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var shiftvariation = placement.split('-')[1];
	  if (shiftvariation) {
	    var _data$offsets = data.offsets,
	        reference = _data$offsets.reference,
	        popper = _data$offsets.popper;
	    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
	    var side = isVertical ? 'left' : 'top';
	    var measurement = isVertical ? 'width' : 'height';
	    var shiftOffsets = {
	      start: defineProperty({}, side, reference[side]),
	      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
	    };
	    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
	  }
	  return data;
	}
	function hide(data) {
	  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
	    return data;
	  }
	  var refRect = data.offsets.reference;
	  var bound = find(data.instance.modifiers, function (modifier) {
	    return modifier.name === 'preventOverflow';
	  }).boundaries;
	  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
	    if (data.hide === true) {
	      return data;
	    }
	    data.hide = true;
	    data.attributes['x-out-of-boundaries'] = '';
	  } else {
	    if (data.hide === false) {
	      return data;
	    }
	    data.hide = false;
	    data.attributes['x-out-of-boundaries'] = false;
	  }
	  return data;
	}
	function inner(data) {
	  var placement = data.placement;
	  var basePlacement = placement.split('-')[0];
	  var _data$offsets = data.offsets,
	      popper = _data$offsets.popper,
	      reference = _data$offsets.reference;
	  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
	  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
	  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
	  data.placement = getOppositePlacement(placement);
	  data.offsets.popper = getClientRect(popper);
	  return data;
	}
	var modifiers = {
	  shift: {
	    order: 100,
	    enabled: true,
	    fn: shift
	  },
	  offset: {
	    order: 200,
	    enabled: true,
	    fn: offset,
	    offset: 0
	  },
	  preventOverflow: {
	    order: 300,
	    enabled: true,
	    fn: preventOverflow,
	    priority: ['left', 'right', 'top', 'bottom'],
	    padding: 5,
	    boundariesElement: 'scrollParent'
	  },
	  keepTogether: {
	    order: 400,
	    enabled: true,
	    fn: keepTogether
	  },
	  arrow: {
	    order: 500,
	    enabled: true,
	    fn: arrow,
	    element: '[x-arrow]'
	  },
	  flip: {
	    order: 600,
	    enabled: true,
	    fn: flip,
	    behavior: 'flip',
	    padding: 5,
	    boundariesElement: 'viewport',
	    flipVariations: false,
	    flipVariationsByContent: false
	  },
	  inner: {
	    order: 700,
	    enabled: false,
	    fn: inner
	  },
	  hide: {
	    order: 800,
	    enabled: true,
	    fn: hide
	  },
	  computeStyle: {
	    order: 850,
	    enabled: true,
	    fn: computeStyle,
	    gpuAcceleration: true,
	    x: 'bottom',
	    y: 'right'
	  },
	  applyStyle: {
	    order: 900,
	    enabled: true,
	    fn: applyStyle,
	    onLoad: applyStyleOnLoad,
	    gpuAcceleration: undefined
	  }
	};
	var Defaults = {
	  placement: 'bottom',
	  positionFixed: false,
	  eventsEnabled: true,
	  removeOnDestroy: false,
	  onCreate: function onCreate() {},
	  onUpdate: function onUpdate() {},
	  modifiers: modifiers
	};
	var Popper = function () {
	  function Popper(reference, popper) {
	    var _this = this;
	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    classCallCheck(this, Popper);
	    this.scheduleUpdate = function () {
	      return requestAnimationFrame(_this.update);
	    };
	    this.update = debounce(this.update.bind(this));
	    this.options = _extends({}, Popper.Defaults, options);
	    this.state = {
	      isDestroyed: false,
	      isCreated: false,
	      scrollParents: []
	    };
	    this.reference = reference && reference.jquery ? reference[0] : reference;
	    this.popper = popper && popper.jquery ? popper[0] : popper;
	    this.options.modifiers = {};
	    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
	      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
	    });
	    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
	      return _extends({
	        name: name
	      }, _this.options.modifiers[name]);
	    })
	    .sort(function (a, b) {
	      return a.order - b.order;
	    });
	    this.modifiers.forEach(function (modifierOptions) {
	      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
	        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
	      }
	    });
	    this.update();
	    var eventsEnabled = this.options.eventsEnabled;
	    if (eventsEnabled) {
	      this.enableEventListeners();
	    }
	    this.state.eventsEnabled = eventsEnabled;
	  }
	  createClass(Popper, [{
	    key: 'update',
	    value: function update$$1() {
	      return update.call(this);
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy$$1() {
	      return destroy.call(this);
	    }
	  }, {
	    key: 'enableEventListeners',
	    value: function enableEventListeners$$1() {
	      return enableEventListeners.call(this);
	    }
	  }, {
	    key: 'disableEventListeners',
	    value: function disableEventListeners$$1() {
	      return disableEventListeners.call(this);
	    }
	  }]);
	  return Popper;
	}();
	Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
	Popper.placements = placements;
	Popper.Defaults = Defaults;

	_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });

	var $Object = _core.Object;
	var defineProperty$1 = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};

	var defineProperty$2 = defineProperty$1;

	var hasInitZIndex = false;
	var zIndex;
	(function () {
	  if (!window['__bk_zIndex_manager']) {
	    var zIndexManager = {
	      nextZIndex: function nextZIndex() {
	        var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
	        return zIndex === 'default' ? zIndexManager.zIndex++ : zIndex;
	      },
	      nextTickIndex: function nextTickIndex() {
	        var tick = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	        var zIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
	        if (zIndex === 'default') {
	          zIndexManager.zIndex += tick;
	          return zIndexManager.zIndex;
	        }
	        return zIndex;
	      }
	    };
	    defineProperty$2(zIndexManager, 'zIndex', {
	      configurable: true,
	      get: function get() {
	        if (!hasInitZIndex) {
	          zIndex = zIndex || (Vue.prototype.$BK_EL || {}).zIndex || 2000;
	          hasInitZIndex = true;
	        }
	        return zIndex;
	      },
	      set: function set(value) {
	        zIndex = value;
	      }
	    });
	    window['__bk_zIndex_manager'] = zIndexManager;
	  }
	})();
	var zIndexManager = window['__bk_zIndex_manager'];

	var transferIndex = 0;
	function transferIncrease() {
	  transferIndex = zIndexManager.nextZIndex();
	}

	var script = {
	  name: 'DatePickerDropdown',
	  props: {
	    placement: {
	      type: String,
	      default: 'bottom-start'
	    },
	    className: {
	      type: String
	    },
	    extPopoverCls: {
	      type: String
	    },
	    transfer: {
	      type: Boolean
	    }
	  },
	  data: function data() {
	    return {
	      popper: null,
	      popperStatus: false,
	      tIndex: this.handleGetIndex()
	    };
	  },
	  computed: {
	    styles: function styles() {
	      var style = {};
	      if (this.transfer) {
	        style['z-index'] = 1060 + this.tIndex;
	      }
	      return style;
	    }
	  },
	  created: function created() {
	    this.$on('on-update-popper', this.update);
	    this.$on('on-destroy-popper', this.destroy);
	  },
	  beforeDestroy: function beforeDestroy() {
	    if (this.popper) {
	      this.popper.destroy();
	    }
	  },
	  methods: {
	    update: function update() {
	      var _this = this;
	      if (this.popper) {
	        this.$nextTick(function () {
	          _this.popper.update();
	          _this.popperStatus = true;
	        });
	      } else {
	        this.$nextTick(function () {
	          _this.popper = new Popper(_this.$parent.$refs.reference, _this.$el, {
	            placement: _this.placement,
	            modifiers: {
	              computeStyle: {
	                gpuAcceleration: false
	              },
	              preventOverflow: {
	                boundariesElement: 'window'
	              }
	            },
	            onCreate: function onCreate() {
	              _this.resetTransformOrigin();
	              _this.$nextTick(_this.popper.update());
	            },
	            onUpdate: function onUpdate() {
	              _this.resetTransformOrigin();
	            }
	          });
	        });
	      }
	      this.tIndex = this.handleGetIndex();
	    },
	    destroy: function destroy() {
	      var _this2 = this;
	      if (this.popper) {
	        setTimeout(function () {
	          if (_this2.popper && !_this2.popperStatus) {
	            _this2.popper.destroy();
	            _this2.popper = null;
	          }
	          _this2.popperStatus = false;
	        }, 300);
	      }
	    },
	    resetTransformOrigin: function resetTransformOrigin() {
	      if (!this.popper) {
	        return;
	      }
	      var xPlacement = this.popper.popper.getAttribute('x-placement');
	      var placementStart = xPlacement.split('-')[0];
	      var placementEnd = xPlacement.split('-')[1];
	      var leftOrRight = xPlacement === 'left' || xPlacement === 'right';
	      if (!leftOrRight) {
	        this.popper.popper.style.transformOrigin = placementStart === 'bottom' || placementStart !== 'top' && placementEnd === 'start' ? 'center top' : 'center bottom';
	      }
	    },
	    handleGetIndex: function handleGetIndex() {
	      transferIncrease();
	      return transferIndex;
	    }
	  }
	};

	function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
	, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
	  if (typeof shadowMode !== 'boolean') {
	    createInjectorSSR = createInjector;
	    createInjector = shadowMode;
	    shadowMode = false;
	  }
	  var options = typeof script === 'function' ? script.options : script;
	  if (template && template.render) {
	    options.render = template.render;
	    options.staticRenderFns = template.staticRenderFns;
	    options._compiled = true;
	    if (isFunctionalTemplate) {
	      options.functional = true;
	    }
	  }
	  if (scopeId) {
	    options._scopeId = scopeId;
	  }
	  var hook;
	  if (moduleIdentifier) {
	    hook = function hook(context) {
	      context = context ||
	      this.$vnode && this.$vnode.ssrContext ||
	      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
	      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
	        context = __VUE_SSR_CONTEXT__;
	      }
	      if (style) {
	        style.call(this, createInjectorSSR(context));
	      }
	      if (context && context._registeredComponents) {
	        context._registeredComponents.add(moduleIdentifier);
	      }
	    };
	    options._ssrRegister = hook;
	  } else if (style) {
	    hook = shadowMode ? function () {
	      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
	    } : function (context) {
	      style.call(this, createInjector(context));
	    };
	  }
	  if (hook) {
	    if (options.functional) {
	      var originalRender = options.render;
	      options.render = function renderWithStyleInjection(h, context) {
	        hook.call(context);
	        return originalRender(h, context);
	      };
	    } else {
	      var existing = options.beforeCreate;
	      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
	    }
	  }
	  return script;
	}
	var normalizeComponent_1 = normalizeComponent;

	/* script */
	var __vue_script__ = script;
	/* template */

	var __vue_render__ = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-date-picker-dropdown",
	    class: [_vm.className, _vm.extPopoverCls],
	    style: _vm.styles
	  }, [_vm._t("default")], 2);
	};

	var __vue_staticRenderFns__ = [];
	/* style */

	var __vue_inject_styles__ = undefined;
	/* scoped */

	var __vue_scope_id__ = undefined;
	/* module identifier */

	var __vue_module_identifier__ = undefined;
	/* functional template */

	var __vue_is_functional_template__ = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__ = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__,
	  staticRenderFns: __vue_staticRenderFns__
	}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

	function formatColor(colorParam) {
	  if (colorParam === '') {
	    colorParam = '#FFFFFF';
	  }
	  var tinyColor = tinycolor(colorParam);
	  var hsl = tinyColor.toHsl();
	  var hsv = tinyColor.toHsv();
	  if (hsl.s === 0) {
	    hsl.h = hsv.h = colorParam.h || 0;
	  }
	  if (hsv.v < 0.0164) {
	    hsv.h = colorParam.h || 0;
	    hsv.s = colorParam.s || 0;
	  }
	  if (hsl.l < 0.01) {
	    hsl.h = colorParam.h || 0;
	    hsl.s = colorParam.s || 0;
	  }
	  return {
	    hsl: hsl,
	    hsv: hsv,
	    hex: tinyColor.toHexString().toUpperCase(),
	    rgba: tinyColor.toRgb()
	  };
	}
	function clamp(value, min, max) {
	  if (value < min) {
	    return min;
	  }
	  if (value > max) {
	    return max;
	  }
	  return value;
	}
	function getTouches(e, prop) {
	  return e.touches ? e.touches[0][prop] : 0;
	}
	function toRGBAString(rgba) {
	  var r = rgba.r,
	      g = rgba.g,
	      b = rgba.b,
	      a = rgba.a;
	  return "rgba(".concat([r, g, b, a].join(','), ")");
	}

	var script$1 = {
	  props: {
	    colorObj: {
	      type: Object,
	      required: true
	    }
	  },
	  computed: {
	    backgroundStyle: function backgroundStyle() {
	      return {
	        background: "hsl(".concat(this.colorObj.hsv.h, ", 100%, 50%)")
	      };
	    },
	    pointerStyle: function pointerStyle() {
	      return {
	        top: "".concat((1 - this.colorObj.hsv.v) * 100, "%"),
	        left: "".concat(this.colorObj.hsv.s * 100, "%")
	      };
	    }
	  },
	  methods: {
	    handleMouseDown: function handleMouseDown(e) {
	      this.$el.focus();
	      this.handlePointChange(e);
	      window.addEventListener('mousemove', this.handlePointChange, {
	        passive: true
	      });
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },
	    handleMouseUp: function handleMouseUp() {
	      window.removeEventListener('mousemove', this.handlePointChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    },
	    handleArrowKeydown: function handleArrowKeydown(e) {
	      var _this$$refs$container = this.$refs.container,
	          clientWidth = _this$$refs$container.clientWidth,
	          clientHeight = _this$$refs$container.clientHeight;
	      var left = this.colorObj.hsv.s * clientWidth;
	      var top = (1 - this.colorObj.hsv.v) * clientHeight;
	      var step = 10;
	      switch (e.code) {
	        case 'ArrowLeft':
	          e.preventDefault();
	          left = clamp(left - step, 0, clientWidth);
	          break;
	        case 'ArrowRight':
	          e.preventDefault();
	          left = clamp(left + step, 0, clientWidth);
	          break;
	        case 'ArrowUp':
	          e.preventDefault();
	          top = clamp(top - step, 0, clientHeight);
	          break;
	        case 'ArrowDown':
	          e.preventDefault();
	          top = clamp(top + step, 0, clientHeight);
	          break;
	        default:
	          return;
	      }
	      this.handlePointChange(null, left, top);
	    },
	    handlePointChange: function handlePointChange(e, appointedLeft, appointedTop) {
	      var _this$$refs$container2 = this.$refs.container,
	          clientWidth = _this$$refs$container2.clientWidth,
	          clientHeight = _this$$refs$container2.clientHeight;
	      var left = appointedLeft !== undefined ? appointedLeft : this.getLeft(e);
	      var top = appointedTop !== undefined ? appointedTop : this.getTop(e);
	      var saturation = left / clientWidth;
	      var bright = 1 - top / clientHeight;
	      this.changeColor(this.colorObj.hsv.h, saturation, bright, this.colorObj.hsv.a);
	    },
	    getLeft: function getLeft(e) {
	      var container = this.$refs.container;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var pageX = e.pageX || getTouches(e, 'PageX');
	      return clamp(pageX - xOffset, 0, container.clientWidth);
	    },
	    getTop: function getTop(e) {
	      var container = this.$refs.container;
	      var yOffset = container.getBoundingClientRect().top + window.pageYOffset;
	      var pageY = e.pageY || getTouches(e, 'PageY');
	      return clamp(pageY - yOffset, 0, container.clientHeight);
	    },
	    changeColor: function changeColor(h, s, v, a) {
	      this.$emit('change', {
	        h: h,
	        s: s,
	        v: v,
	        a: a
	      });
	    }
	  }
	};

	/* script */
	var __vue_script__$1 = script$1;
	/* template */

	var __vue_render__$1 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "container",
	    staticClass: "bk-color-picker-saturation",
	    style: _vm.backgroundStyle,
	    attrs: {
	      "tabindex": "0"
	    },
	    on: {
	      "keydown": _vm.handleArrowKeydown,
	      "mousedown": function mousedown($event) {
	        $event.stopPropagation();
	        return _vm.handleMouseDown($event);
	      }
	    }
	  }, [_c('div', {
	    staticClass: "bk-color-picker-saturation-white"
	  }), _c('div', {
	    staticClass: "bk-color-picker-saturation-black"
	  }), _c('div', {
	    staticClass: "bk-color-picker-pointer",
	    style: _vm.pointerStyle
	  }, [_c('div', {
	    staticClass: "bk-color-picker-circle"
	  })])]);
	};

	var __vue_staticRenderFns__$1 = [];
	/* style */

	var __vue_inject_styles__$1 = undefined;
	/* scoped */

	var __vue_scope_id__$1 = undefined;
	/* module identifier */

	var __vue_module_identifier__$1 = undefined;
	/* functional template */

	var __vue_is_functional_template__$1 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$1 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$1,
	  staticRenderFns: __vue_staticRenderFns__$1
	}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

	var script$2 = {
	  props: {
	    colorObj: {
	      type: Object,
	      required: true
	    }
	  },
	  computed: {
	    pointerStyle: function pointerStyle() {
	      return {
	        left: "".concat(this.colorObj.hsv.h / 360 * 100, "%")
	      };
	    }
	  },
	  methods: {
	    handleArrowKeydown: function handleArrowKeydown(e) {
	      var clientWidth = this.$refs.container.clientWidth;
	      var left = this.colorObj.hsv.h / 360 * clientWidth;
	      var step = 2;
	      var hugeStep = 10;
	      switch (e.code) {
	        case 'ArrowLeft':
	          e.preventDefault();
	          left = clamp(left - step, 0, clientWidth);
	          break;
	        case 'ArrowRight':
	          e.preventDefault();
	          left = clamp(left + step, 0, clientWidth);
	          break;
	        case 'ArrowUp':
	          e.preventDefault();
	          left = clamp(left - hugeStep, 0, clientWidth);
	          break;
	        case 'ArrowDown':
	          e.preventDefault();
	          left = clamp(left + hugeStep, 0, clientWidth);
	          break;
	        default:
	          return;
	      }
	      this.handlePointChange(null, left);
	    },
	    handleMouseDown: function handleMouseDown(e) {
	      this.$el.focus();
	      this.handlePointChange(e);
	      window.addEventListener('mousemove', this.handlePointChange, {
	        passive: true
	      });
	      window.addEventListener('mouseup', this.handleMouseUp);
	    },
	    handleMouseUp: function handleMouseUp() {
	      window.removeEventListener('mousemove', this.handlePointChange);
	      window.removeEventListener('mouseup', this.handleMouseUp);
	    },
	    handlePointChange: function handlePointChange(e, appointedLeft) {
	      var clientWidth = this.$refs.container.clientWidth;
	      var left = appointedLeft !== undefined ? appointedLeft : this.getLeft(e);
	      this.changeColor(left / clientWidth);
	    },
	    getLeft: function getLeft(e) {
	      var container = this.$refs.container;
	      var xOffset = container.getBoundingClientRect().left + window.pageXOffset;
	      var pageX = e.pageX || getTouches(e, 'PageX');
	      return clamp(pageX - xOffset, 0, container.clientWidth);
	    },
	    changeColor: function changeColor(ratio) {
	      var _this$colorObj$hsl = this.colorObj.hsl,
	          h = _this$colorObj$hsl.h,
	          s = _this$colorObj$hsl.s,
	          l = _this$colorObj$hsl.l,
	          a = _this$colorObj$hsl.a;
	      var newHue = ratio * 360;
	      if (h !== newHue) {
	        this.$emit('change', {
	          h: newHue,
	          s: s,
	          l: l,
	          a: a
	        });
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$2 = script$2;
	/* template */

	var __vue_render__$2 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    ref: "container",
	    staticClass: "bk-color-picker-hue",
	    attrs: {
	      "tabindex": "0"
	    },
	    on: {
	      "keydown": _vm.handleArrowKeydown,
	      "mousedown": function mousedown($event) {
	        $event.stopPropagation();
	        return _vm.handleMouseDown($event);
	      }
	    }
	  }, [_c('div', {
	    staticClass: "bk-color-picker-hue-pointer",
	    style: _vm.pointerStyle
	  }, [_c('div', {
	    staticClass: "bk-color-picker-hue-rectangle"
	  })])]);
	};

	var __vue_staticRenderFns__$2 = [];
	/* style */

	var __vue_inject_styles__$2 = undefined;
	/* scoped */

	var __vue_scope_id__$2 = undefined;
	/* module identifier */

	var __vue_module_identifier__$2 = undefined;
	/* functional template */

	var __vue_is_functional_template__$2 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$2 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$2,
	  staticRenderFns: __vue_staticRenderFns__$2
	}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

	var script$3 = {
	  props: {
	    info: {
	      type: Object,
	      required: true
	    }
	  },
	  methods: {
	    handleTab: function handleTab(e) {
	      if (this.info.key === 'a') {
	        this.$emit('tab', e);
	      }
	    },
	    handleInput: function handleInput(e) {
	      var key = this.info.key;
	      var value = e.target.value;
	      this.$emit('input', key, value);
	    }
	  }
	};

	/* script */
	var __vue_script__$3 = script$3;
	/* template */

	var __vue_render__$3 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-color-picker-input-part"
	  }, [_c('input', {
	    class: ['bk-color-picker-input-value', _vm.info.error && 'error'],
	    attrs: {
	      "type": _vm.info.name === 'HEX' ? 'text' : 'number'
	    },
	    domProps: {
	      "value": _vm.info.value
	    },
	    on: {
	      "keydown": function keydown($event) {
	        if (!('button' in $event) && _vm._k($event.keyCode, "tab", 9, $event.key, "Tab")) {
	          return null;
	        }

	        return _vm.handleTab($event);
	      },
	      "input": _vm.handleInput
	    }
	  }), _c('span', {
	    staticClass: "bk-color-picker-input-text"
	  }, [_vm._v(_vm._s(_vm.info.name))])]);
	};

	var __vue_staticRenderFns__$3 = [];
	/* style */

	var __vue_inject_styles__$3 = undefined;
	/* scoped */

	var __vue_scope_id__$3 = undefined;
	/* module identifier */

	var __vue_module_identifier__$3 = undefined;
	/* functional template */

	var __vue_is_functional_template__$3 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$3 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$3,
	  staticRenderFns: __vue_staticRenderFns__$3
	}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

	var script$4 = {
	  components: {
	    InputContainer: __vue_component__$3
	  },
	  props: {
	    colorObj: {
	      type: Object,
	      required: true
	    }
	  },
	  data: function data() {
	    return {
	      hex: {
	        key: 'hex',
	        name: 'HEX',
	        value: this.colorObj.hex,
	        error: false
	      },
	      r: {
	        key: 'r',
	        name: 'R',
	        value: this.colorObj.rgba.r.toString(),
	        error: false
	      },
	      g: {
	        key: 'g',
	        name: 'G',
	        value: this.colorObj.rgba.g.toString(),
	        error: false
	      },
	      b: {
	        key: 'b',
	        name: 'B',
	        value: this.colorObj.rgba.b.toString(),
	        error: false
	      },
	      a: {
	        key: 'a',
	        name: 'Alpha',
	        value: this.colorObj.rgba.a.toString(),
	        error: false
	      }
	    };
	  },
	  watch: {
	    colorObj: function colorObj(val) {
	      if (tinycolor(val.hex).toString() !== tinycolor(this.hex.value).toString()) {
	        this.hex.value = val.hex;
	      }
	      this.r.value = val.rgba.r.toString();
	      this.g.value = val.rgba.g.toString();
	      this.b.value = val.rgba.b.toString();
	      this.a.value = val.rgba.a.toString();
	      this.validate();
	    }
	  },
	  methods: {
	    handleAlphaTab: function handleAlphaTab(e) {
	      this.$emit('tab', e);
	    },
	    handleInput: function handleInput(key, value) {
	      this[key].value = value;
	      if (this.validate()) {
	        var colorStr = key === 'hex' ? this.hex.value : "rgba(".concat(this.r.value, ", ").concat(this.g.value, ", ").concat(this.b.value, ", ").concat(this.a.value, ")");
	        this.$emit('change', colorStr);
	      }
	    },
	    validate: function validate() {
	      var result = true;
	      var hex = this.hex,
	          r = this.r,
	          g = this.g,
	          b = this.b,
	          a = this.a;
	      if (hex.value.startsWith('#') && (hex.value.length === 4 || hex.value.length === 7) && !hex.value.slice(1).match(/[^0-9a-fA-F]/)) {
	        hex.error = false;
	      } else {
	        hex.error = true;
	        result = false;
	      }
	      if (a.value !== '' && a.value >= 0 && a.value <= 1) {
	        a.error = false;
	      } else {
	        a.error = true;
	        result = false;
	      }
	      for (var _i = 0, _arr = [r, g, b]; _i < _arr.length; _i++) {
	        var colorInfo = _arr[_i];
	        var value = colorInfo.value;
	        if (value !== '' && value >= 0 && value <= 255) {
	          colorInfo.error = false;
	        } else {
	          colorInfo.error = true;
	          result = false;
	        }
	      }
	      return result;
	    }
	  }
	};

	/* script */
	var __vue_script__$4 = script$4;
	/* template */

	var __vue_render__$4 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-color-picker-input"
	  }, [_c('div', {
	    staticClass: "bk-color-picker-input-hex"
	  }, [_c('InputContainer', {
	    attrs: {
	      "info": _vm.hex
	    },
	    on: {
	      "input": _vm.handleInput
	    }
	  })], 1), _c('div', {
	    staticClass: "bk-color-picker-input-rgba"
	  }, [_c('InputContainer', {
	    attrs: {
	      "info": _vm.r
	    },
	    on: {
	      "input": _vm.handleInput
	    }
	  }), _c('InputContainer', {
	    attrs: {
	      "info": _vm.g
	    },
	    on: {
	      "input": _vm.handleInput
	    }
	  }), _c('InputContainer', {
	    attrs: {
	      "info": _vm.b
	    },
	    on: {
	      "input": _vm.handleInput
	    }
	  }), _c('InputContainer', {
	    attrs: {
	      "info": _vm.a
	    },
	    on: {
	      "input": _vm.handleInput,
	      "tab": _vm.handleAlphaTab
	    }
	  })], 1)]);
	};

	var __vue_staticRenderFns__$4 = [];
	/* style */

	var __vue_inject_styles__$4 = undefined;
	/* scoped */

	var __vue_scope_id__$4 = undefined;
	/* module identifier */

	var __vue_module_identifier__$4 = undefined;
	/* functional template */

	var __vue_is_functional_template__$4 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$4 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$4,
	  staticRenderFns: __vue_staticRenderFns__$4
	}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

	var script$5 = {
	  props: {
	    colorObj: {
	      type: Object,
	      required: true
	    },
	    recommend: {
	      type: [Boolean, Array],
	      default: true
	    }
	  },
	  data: function data() {
	    return {
	      isFocused: false,
	      selectedIndex: -1,
	      selectedColor: null
	    };
	  },
	  computed: {
	    colors: function colors() {
	      return this.getColorsFromRecommend(this.recommend);
	    }
	  },
	  watch: {
	    colorObj: function colorObj() {
	      this.selectedIndex = -1;
	      this.selectedColor = null;
	    }
	  },
	  methods: {
	    handleKeydown: function handleKeydown(e) {
	      if (e.code === 'Tab') {
	        this.$emit('tab', e);
	      } else {
	        var index = 0;
	        var rowNum = 10;
	        var max = this.colors.length - 1;
	        switch (e.code) {
	          case 'ArrowLeft':
	            e.preventDefault();
	            index = clamp(this.selectedIndex - 1, 0, max);
	            break;
	          case 'ArrowRight':
	            e.preventDefault();
	            index = clamp(this.selectedIndex + 1, 0, max);
	            break;
	          case 'ArrowUp':
	            e.preventDefault();
	            index = clamp(this.selectedIndex - rowNum, 0, max);
	            break;
	          case 'ArrowDown':
	            e.preventDefault();
	            index = clamp(this.selectedIndex + rowNum, 0, max);
	            break;
	          default:
	            return;
	        }
	        this.selectColor(index);
	      }
	    },
	    selectColor: function selectColor(index) {
	      var _this = this;
	      var color = this.colors[index];
	      this.$emit('change', color);
	      this.$nextTick(function () {
	        _this.selectedIndex = index;
	        _this.selectedColor = color;
	      });
	    },
	    getColorsFromRecommend: function getColorsFromRecommend(recommend) {
	      if (recommend === true) {
	        return ['', '#ff4500', '#ff8c00', '#ffd700', '#90ee90', '#ddffff', '#00ced1', '#3a84ff', '#a933f5', '#db7093', '#000000', '#494949', '#9B9B9B', '#ffffff'];
	      } else if (isArray$1(recommend)) {
	        return recommend.map(function (color) {
	          return tinycolor(color).isValid() ? color : '';
	        });
	      }
	    }
	  }
	};

	/* script */
	var __vue_script__$5 = script$5;
	/* template */

	var __vue_render__$5 = function __vue_render__() {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-color-picker-recommend",
	    attrs: {
	      "tabindex": "0"
	    },
	    on: {
	      "focus": function focus($event) {
	        _vm.isFocused = true;
	      },
	      "blur": function blur($event) {
	        _vm.isFocused = false;
	      },
	      "keydown": _vm.handleKeydown
	    }
	  }, _vm._l(_vm.colors, function (color, index) {
	    return _c('div', {
	      key: color + index,
	      class: {
	        'bk-color-picker-recommend-color': true,
	        'bk-color-picker-recommend-selected-color': _vm.isFocused && _vm.selectedIndex === index,
	        'bk-color-picker-empty': color === ''
	      },
	      style: {
	        background: color || '#fff'
	      },
	      on: {
	        "click": function click($event) {
	          _vm.selectColor(index);
	        }
	      }
	    }, [_c('div', {
	      directives: [{
	        name: "show",
	        rawName: "v-show",
	        value: _vm.selectedIndex === index,
	        expression: "selectedIndex === index"
	      }],
	      staticClass: "bk-color-picker-pointer"
	    }, [_c('div', {
	      staticClass: "bk-color-picker-circle"
	    })])]);
	  }), 0);
	};

	var __vue_staticRenderFns__$5 = [];
	/* style */

	var __vue_inject_styles__$5 = undefined;
	/* scoped */

	var __vue_scope_id__$5 = undefined;
	/* module identifier */

	var __vue_module_identifier__$5 = undefined;
	/* functional template */

	var __vue_is_functional_template__$5 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$5 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$5,
	  staticRenderFns: __vue_staticRenderFns__$5
	}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

	var nodeList = [];
	var clickctx = '$clickoutsideCtx';
	var beginClick;
	document.addEventListener('mousedown', function (event) {
	  return beginClick = event;
	});
	document.addEventListener('mouseup', function (event) {
	  nodeList.forEach(function (node) {
	    node[clickctx].clickoutsideHandler(event, beginClick);
	  });
	});
	var bkClickoutside = {
	  bind: function bind(el, binding, vnode) {
	    var id = nodeList.push(el) - 1;
	    var clickoutsideHandler = function clickoutsideHandler() {
	      var mouseup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var mousedown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      if (!vnode.context
	      || !mouseup.target || !mousedown.target || el.contains(mouseup.target)
	      || el.contains(mousedown.target)
	      || el === mouseup.target
	      || vnode.context.popup
	      && (vnode.context.popup.contains(mouseup.target)
	      || vnode.context.popup.contains(mousedown.target)
	      )) {
	        return;
	      }
	      if (binding.expression
	      && el[clickctx].callbackName
	      && vnode.context[el[clickctx].callbackName]
	      ) {
	        vnode.context[el[clickctx].callbackName](mouseup, mousedown, el);
	      } else {
	        el[clickctx].bindingFn && el[clickctx].bindingFn(mouseup, mousedown, el);
	      }
	    };
	    el[clickctx] = {
	      id: id,
	      clickoutsideHandler: clickoutsideHandler,
	      callbackName: binding.expression,
	      callbackFn: binding.value
	    };
	  },
	  update: function update(el, binding) {
	    el[clickctx].callbackName = binding.expression;
	    el[clickctx].callbackFn = binding.value;
	  },
	  unbind: function unbind(el) {
	    for (var i = 0, len = nodeList.length; i < len; i++) {
	      if (nodeList[i][clickctx].id === el[clickctx].id) {
	        nodeList.splice(i, 1);
	        break;
	      }
	    }
	  }
	};
	bkClickoutside.install = function (Vue) {
	  Vue.directive('bkClickoutside', bkClickoutside);
	};

	function _extends$1() {
	  _extends$1 = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends$1.apply(this, arguments);
	}

	function getTarget(node) {
	  if (node === void 0) {
	    node = document.body;
	  }
	  if (node === true) {
	    return document.body;
	  }
	  return node instanceof window.Node ? node : document.querySelector(node);
	}
	var transferDom = {
	  inserted: function inserted(el, _ref, vnode) {
	    var value = _ref.value;
	    if (el.dataset.transfer !== 'true') {
	      return false;
	    }
	    el.className = el.className ? el.className + ' v-transfer-dom' : 'v-transfer-dom';
	    var parentNode = el.parentNode;
	    if (!parentNode) {
	      return;
	    }
	    var home = document.createComment('');
	    var hasMovedOut = false;
	    if (value !== false) {
	      parentNode.replaceChild(home, el);
	      getTarget(value).appendChild(el);
	      hasMovedOut = true;
	    }
	    if (!el.__transferDomData) {
	      el.__transferDomData = {
	        parentNode: parentNode,
	        home: home,
	        target: getTarget(value),
	        hasMovedOut: hasMovedOut
	      };
	    }
	  },
	  componentUpdated: function componentUpdated(el, _ref2) {
	    var value = _ref2.value;
	    if (el.dataset.transfer !== 'true') {
	      return false;
	    }
	    var ref$1 = el.__transferDomData;
	    if (!ref$1) {
	      return;
	    }
	    var parentNode = ref$1.parentNode;
	    var home = ref$1.home;
	    var hasMovedOut = ref$1.hasMovedOut;
	    if (!hasMovedOut && value) {
	      parentNode.replaceChild(home, el);
	      getTarget(value).appendChild(el);
	      el.__transferDomData = _extends$1({}, el.__transferDomData, {
	        hasMovedOut: true,
	        target: getTarget(value)
	      });
	    } else if (hasMovedOut && value === false) {
	      parentNode.replaceChild(el, home);
	      el.__transferDomData = _extends$1({}, el.__transferDomData, {
	        hasMovedOut: false,
	        target: getTarget(value)
	      });
	    } else if (value) {
	      getTarget(value).appendChild(el);
	    }
	  },
	  unbind: function unbind(el) {
	    if (el.dataset.transfer !== 'true') {
	      return false;
	    }
	    el.className = el.className.replace('v-transfer-dom', '');
	    var ref$1 = el.__transferDomData;
	    if (!ref$1) {
	      return;
	    }
	    if (el.__transferDomData.hasMovedOut === true) {
	      el.__transferDomData.parentNode && el.__transferDomData.parentNode.appendChild(el);
	    }
	    el.__transferDomData = null;
	  }
	};
	transferDom.install = function (Vue) {
	  Vue.directive('bk-transfer-dom', transferDom);
	};

	var whiteColorObj = formatColor('#FFFFFF');
	var script$6 = {
	  name: 'bk-color-picker',
	  components: {
	    DatePickerDropdown: __vue_component__,
	    SaturationPanel: __vue_component__$1,
	    HueSlider: __vue_component__$2,
	    ColorInput: __vue_component__$4,
	    RecommendColors: __vue_component__$5
	  },
	  directives: {
	    clickoutside: bkClickoutside,
	    transferDom: transferDom
	  },
	  model: {
	    event: 'change'
	  },
	  props: {
	    value: {
	      type: String,
	      default: ''
	    },
	    disabled: {
	      type: Boolean,
	      default: false
	    },
	    readonly: {
	      type: Boolean,
	      default: false
	    },
	    transfer: {
	      type: Boolean,
	      default: false
	    },
	    size: {
	      type: String,
	      default: '',
	      validator: function validator(val) {
	        return ['', 'large', 'small'].includes(val);
	      }
	    },
	    showValue: {
	      type: Boolean,
	      default: true
	    },
	    recommend: {
	      type: [Boolean, Array],
	      default: true
	    },
	    extCls: {
	      type: String,
	      default: ''
	    }
	  },
	  data: function data() {
	    return {
	      showDropdown: false,
	      colorStr: '',
	      colorObj: whiteColorObj
	    };
	  },
	  computed: {
	    isRenderRecommend: function isRenderRecommend() {
	      return Boolean(this.recommend === true || isArray$1(this.recommend) && this.recommend.length);
	    }
	  },
	  watch: {
	    value: function value() {
	      this.changeColorFromProps();
	    }
	  },
	  created: function created() {
	    this.changeColorFromProps({
	      isCreated: true
	    });
	  },
	  methods: {
	    handleTriggerKeydown: function handleTriggerKeydown(e) {
	      if (e.code === 'Enter' || e.code === 'NumpadEnter') {
	        this.toggleDropdown();
	      } else if (e.code === 'Escape') {
	        this.closeDropdown();
	      }
	    },
	    handleDropdownKeydown: function handleDropdownKeydown(e) {
	      if (this.transfer) {
	        this.handleTriggerKeydown(e);
	      }
	    },
	    toggleDropdown: function toggleDropdown() {
	      if (this.disabled || this.readonly) {
	        return;
	      }
	      this.showDropdown ? this.closeDropdown() : this.openDropdown();
	    },
	    handleTabInput: function handleTabInput(e) {
	      if (!this.isRenderRecommend) {
	        e.preventDefault();
	        this.$refs.saturationPanel.$el.focus();
	      }
	    },
	    handleTabRecommend: function handleTabRecommend(e) {
	      e.preventDefault();
	      this.$refs.saturationPanel.$el.focus();
	    },
	    openDropdown: function openDropdown() {
	      var _this = this;
	      this.showDropdown = true;
	      this.$refs.drop.update();
	      setTimeout(function () {
	        var hexInput = _this.$refs.drop.$el.querySelector('.bk-color-picker-input-hex .bk-color-picker-input-value');
	        hexInput.select();
	      }, 100);
	    },
	    closeDropdown: function closeDropdown() {
	      var _this2 = this;
	      if (this.showDropdown) {
	        this.$nextTick(function () {
	          return _this2.$el.focus();
	        });
	        this.showDropdown = false;
	        this.$refs.drop.destroy();
	        this.changeColorFromProps();
	      }
	    },
	    changeColorFromProps: function changeColorFromProps() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$isCreated = _ref.isCreated,
	          isCreated = _ref$isCreated === void 0 ? false : _ref$isCreated;
	      if (this.value === '') {
	        if (this.colorStr !== '') {
	          this.colorStr = '';
	          this.colorObj = whiteColorObj;
	        }
	        return;
	      }
	      var colorObj = formatColor(this.value);
	      var colorStr = colorObj.rgba.a === 1 ? colorObj.hex : toRGBAString(colorObj.rgba);
	      if (colorStr !== this.colorStr) {
	        var isValid = tinycolor(this.value).isValid();
	        if (isCreated) {
	          if (!isValid) {
	            this.colorObj = whiteColorObj;
	            this.$emit('change', '');
	          } else {
	            this.colorStr = colorStr.toLowerCase() === this.value.toLowerCase() ? this.value
	            : colorStr;
	            this.colorObj = colorObj;
	          }
	        } else {
	          if (!isValid) {
	            this.colorStr = '';
	            this.colorObj = whiteColorObj;
	          } else if (colorStr.toLowerCase() !== this.colorStr.toLowerCase()) {
	            this.colorObj = colorObj;
	            this.colorStr = colorStr;
	          }
	        }
	      }
	    },
	    handleColorChange: function handleColorChange(val) {
	      if (val === '') {
	        this.colorStr = '';
	        this.colorObj = whiteColorObj;
	        this.$emit('change', '');
	        return;
	      }
	      var colorObj = formatColor(val);
	      var colorStr = colorObj.rgba.a === 1 ? colorObj.hex : toRGBAString(colorObj.rgba);
	      this.colorObj = colorObj;
	      this.colorStr = colorStr;
	      this.$emit('change', colorStr);
	    }
	  }
	};

	/* script */
	var __vue_script__$6 = script$6;
	/* template */

	var __vue_render__$6 = function __vue_render__() {
	  var _obj;

	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    directives: [{
	      name: "clickoutside",
	      rawName: "v-clickoutside",
	      value: _vm.closeDropdown,
	      expression: "closeDropdown"
	    }],
	    ref: "reference",
	    class: ['bk-color-picker', _vm.extCls, (_obj = {}, _obj["bk-color-picker-" + _vm.size] = _vm.size, _obj['bk-color-picker-show-dropdown'] = _vm.showDropdown, _obj['bk-color-picker-show-value'] = _vm.showValue, _obj['bk-color-picker-disabled'] = _vm.disabled || _vm.readonly, _obj)],
	    attrs: {
	      "tabindex": "0"
	    },
	    on: {
	      "keydown": _vm.handleTriggerKeydown,
	      "click": _vm.toggleDropdown
	    }
	  }, [_c('div', {
	    staticClass: "bk-color-picker-color"
	  }, [_c('span', {
	    class: ['bk-color-picker-color-square', !_vm.colorStr && 'bk-color-picker-empty'],
	    style: {
	      background: _vm.colorStr || '#FFF'
	    }
	  })]), _vm.showValue ? _c('div', {
	    staticClass: "bk-color-picker-text"
	  }, [_c('span', [_vm._v(_vm._s(_vm.colorStr))])]) : _vm._e(), _vm._m(0), _c('transition', {
	    attrs: {
	      "name": "transition-drop"
	    }
	  }, [_c('DatePickerDropdown', {
	    directives: [{
	      name: "show",
	      rawName: "v-show",
	      value: _vm.showDropdown,
	      expression: "showDropdown"
	    }, {
	      name: "transfer-dom",
	      rawName: "v-transfer-dom"
	    }],
	    ref: "drop",
	    staticStyle: {
	      "padding": "0",
	      "cursor": "default"
	    },
	    attrs: {
	      "transfer": _vm.transfer,
	      "data-transfer": _vm.transfer
	    }
	  }, [_c('div', {
	    staticClass: "bk-color-picker-dropdown",
	    on: {
	      "click": function click($event) {
	        $event.stopPropagation();
	      },
	      "mousedown": function mousedown($event) {
	        $event.stopPropagation();
	      },
	      "keydown": _vm.handleDropdownKeydown
	    }
	  }, [_c('SaturationPanel', {
	    ref: "saturationPanel",
	    attrs: {
	      "color-obj": _vm.colorObj
	    },
	    on: {
	      "change": _vm.handleColorChange
	    }
	  }), _c('HueSlider', {
	    attrs: {
	      "color-obj": _vm.colorObj
	    },
	    on: {
	      "change": _vm.handleColorChange
	    }
	  }), _c('ColorInput', {
	    attrs: {
	      "color-obj": _vm.colorObj
	    },
	    on: {
	      "tab": _vm.handleTabInput,
	      "change": _vm.handleColorChange
	    }
	  }), _vm.isRenderRecommend ? _c('div', {
	    staticClass: "bk-color-picker-recommend-container"
	  }, [_c('RecommendColors', {
	    attrs: {
	      "color-obj": _vm.colorObj,
	      "recommend": _vm.recommend
	    },
	    on: {
	      "tab": _vm.handleTabRecommend,
	      "change": _vm.handleColorChange
	    }
	  })], 1) : _vm._e()], 1)])], 1)], 1);
	};

	var __vue_staticRenderFns__$6 = [function () {
	  var _vm = this;

	  var _h = _vm.$createElement;

	  var _c = _vm._self._c || _h;

	  return _c('div', {
	    staticClass: "bk-color-picker-icon"
	  }, [_c('span', {
	    staticClass: "bk-icon icon-angle-down"
	  })]);
	}];
	/* style */

	var __vue_inject_styles__$6 = undefined;
	/* scoped */

	var __vue_scope_id__$6 = undefined;
	/* module identifier */

	var __vue_module_identifier__$6 = undefined;
	/* functional template */

	var __vue_is_functional_template__$6 = false;
	/* style inject */

	/* style inject SSR */

	/* style inject shadow dom */

	var __vue_component__$6 = /*#__PURE__*/normalizeComponent_1({
	  render: __vue_render__$6,
	  staticRenderFns: __vue_staticRenderFns__$6
	}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

	var _defined = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};

	var _toObject = function (it) {
	  return Object(_defined(it));
	};

	var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return _cof(it) == 'String' ? it.split('') : Object(it);
	};

	var _toIobject = function (it) {
	  return _iobject(_defined(it));
	};

	var ceil = Math.ceil;
	var floor = Math.floor;
	var _toInteger = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

	var min = Math.min;
	var _toLength = function (it) {
	  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0;
	};

	var max = Math.max;
	var min$1 = Math.min;
	var _toAbsoluteIndex = function (index, length) {
	  index = _toInteger(index);
	  return index < 0 ? max(index + length, 0) : min$1(index, length);
	};

	var _arrayIncludes = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = _toIobject($this);
	    var length = _toLength(O.length);
	    var index = _toAbsoluteIndex(fromIndex, length);
	    var value;
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      if (value != value) return true;
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var _shared = createCommonjsModule(function (module) {
	var SHARED = '__core-js_shared__';
	var store = _global[SHARED] || (_global[SHARED] = {});
	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: _core.version,
	  mode:  'pure' ,
	  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var px = Math.random();
	var _uid = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

	var shared = _shared('keys');
	var _sharedKey = function (key) {
	  return shared[key] || (shared[key] = _uid(key));
	};

	var arrayIndexOf = _arrayIncludes(false);
	var IE_PROTO = _sharedKey('IE_PROTO');
	var _objectKeysInternal = function (object, names) {
	  var O = _toIobject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);
	  while (names.length > i) if (_has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	var _enumBugKeys = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

	var _objectKeys = Object.keys || function keys(O) {
	  return _objectKeysInternal(O, _enumBugKeys);
	};

	var _objectSap = function (KEY, exec) {
	  var fn = (_core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);
	};

	_objectSap('keys', function () {
	  return function keys(it) {
	    return _objectKeys(_toObject(it));
	  };
	});

	var keys = _core.Object.keys;

	var keys$1 = keys;

	function setInstaller (component, afterInstall) {
	  component.install = function (Vue) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var props = component.props || {};
	    keys$1(options).forEach(function (key) {
	      if (props.hasOwnProperty(key)) {
	        if (typeof props[key] === 'function' || props[key] instanceof Array) {
	          props[key] = {
	            type: props[key],
	            default: options[key]
	          };
	        } else {
	          props[key].default = options[key];
	        }
	      }
	    });
	    component.name = options.namespace ? component.name.replace('bk', options.namespace) : component.name;
	    Vue.component(component.name, component);
	    typeof afterInstall === 'function' && afterInstall(Vue, options);
	  };
	}

	setInstaller(__vue_component__$6);

	exports.default = __vue_component__$6;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
